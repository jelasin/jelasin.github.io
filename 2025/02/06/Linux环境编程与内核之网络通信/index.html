<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2025/02/06/linux环境编程与内核之网络通信/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="概述在互联网时代，网络通信编程已经是一个程序员必不可少的技能之一。几乎所有的产品都会涉及网络操作或访问。在Linux编程环境中，系统提供了socket套接字为程序员提供统一的网络编程接口。这里假设读者有一定的Linux网络编程基础，所以对于系统调用的解释都是点到为止，只针对不常见或容易忽视的问题进行详细说明。后面手写一个tcp&#x2F;ip协议栈，这里除了基本的API不做过多介绍了。 网路连接的">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux环境编程与内核之网络通信">
<meta property="og:url" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="概述在互联网时代，网络通信编程已经是一个程序员必不可少的技能之一。几乎所有的产品都会涉及网络操作或访问。在Linux编程环境中，系统提供了socket套接字为程序员提供统一的网络编程接口。这里假设读者有一定的Linux网络编程基础，所以对于系统调用的解释都是点到为止，只针对不常见或容易忽视的问题进行详细说明。后面手写一个tcp&#x2F;ip协议栈，这里除了基本的API不做过多介绍了。 网路连接的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/2645999549-5e99b7b074b37_fix732.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/3507527407-5e7b1e199cbbb_fix732.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/3987873264-5e7b1e34b2c51_fix732.webp">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/748605951-5e7b1e45d431b_fix732.webp">
<meta property="article:published_time" content="2025-02-06T06:49:47.000Z">
<meta property="article:modified_time" content="2025-07-08T08:31:59.612Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/2645999549-5e99b7b074b37_fix732.png">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            Linux环境编程与内核之网络通信 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":true,"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.4","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-xs">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">138</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Linux环境编程与内核之网络通信</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-02-06 14:49:47</span>
        <span class="mobile">2025-02-06 14:49:47</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-07-08 16:31:59</span>
            <span class="mobile">2025-07-08 16:31:59</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在互联网时代，网络通信编程已经是一个程序员必不可少的技能之一。几乎所有的产品都会涉及网络操作或访问。在Linux编程环境中，系统提供了socket套接字为程序员提供统一的网络编程接口。这里假设读者有一定的Linux网络编程基础，所以对于系统调用的解释都是点到为止，只针对不常见或容易忽视的问题进行详细说明。后面手写一个tcp&#x2F;ip协议栈，这里除了基本的API不做过多介绍了。</p>
<h1 id="网路连接的建立"><a href="#网路连接的建立" class="headerlink" title="网路连接的建立"></a>网路连接的建立</h1><h2 id="socket文件描述符"><a href="#socket文件描述符" class="headerlink" title="socket文件描述符"></a>socket文件描述符</h2><p>socket翻译成中文是插座、插槽的意思，而在网络编程中，其被翻译为“套接字”。Linux环境下，我们经常说“一切皆文件”。因此套接字也被视为一种文件描述符。首先，来看看如何使用socket系统调用创建一个套接字，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中的参数解释如下。</p>
<ul>
<li><strong>domain</strong>：用于指示协议族名字，如AF_INET为IPv4。</li>
<li><strong>type</strong>：用于指示类型，如基于流通信的SOCK_STREAM。</li>
<li><strong>protocol</strong>：用于指示对于这种socket的具体协议类型。一般情况下，使用前两个参数限定后，只会存在一种协议类型对应该情况。这时，可以将protocol设置为0。但是在某些情况下，会存在多个协议类型，这时就必须指定具体的协议类型。</li>
<li>成功创建socket后，会返回一个文件描述符。失败时，该接口返回-1。</li>
</ul>
<p>那么对于Linux内核来说，如何知道一个文件描述符是一个套接字，还是一个普通文件呢？其实这个问题也可以扩展到，内核如何知道一个文件描述符的具体类型，如何调用实际类型的操作函数呢？这仍然是VFS的魔力。</p>
<p>文件描述符fd与内核文件结构struct file之间的关系，后者是内核用于管理文件的真正结构，其中的成员变量<code>file-&gt;f_op</code>为VFS支持的所有文件操作。VFS层无须关心该文件file的实际类型，它会直接调用<code>file-&gt;f_op</code>中的操作函数（这样的处理，与面向对象语言中的多态是类似的）。</p>
<p>对于套接字来说，只要在创建套接字时，将<code>file-&gt;f_op</code>设置为正确的套接字操作函数即可。该操作是在<code>socket-&gt;sock_map_fd-&gt;sock_alloc_file</code>中完成的，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sock_alloc_file</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> file **f, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;    </span><br><span class="line">    …………    </span><br><span class="line">    <span class="comment">/* 申请一个struct file，并将socket_file_ops作为参数来传递。</span></span><br><span class="line"><span class="comment">    * 在alloc_file中，会将socket_file_ops赋给file-&gt;f_op。</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE, &amp;socket_file_ops);    </span><br><span class="line"> 	…………    </span><br><span class="line">    <span class="comment">/* 让sock-&gt;file指向file，完成sock和file的关联 */</span>    </span><br><span class="line">    sock-&gt;file = file;    </span><br><span class="line">    file-&gt;f_flags = O_RDWR | (flags &amp; O_NONBLOCK);    </span><br><span class="line">    file-&gt;f_pos = <span class="number">0</span>;    </span><br><span class="line">    file-&gt;private_data = sock;    </span><br><span class="line">    *f = file;    </span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>尽管Linux内核是使用C语言编写的，但是其应用了很多面向对象的设计思想。以这里的file为例，内核利用f_op（对象操作函数指针集合）指向具体对象的操作函数集合。这样一来，对于VFS来说，就只须关心struct file，而无须关心具体的对象类型了，它会在处理过程中，调用正确的处理函数。</p>
<h2 id="绑定IP地址"><a href="#绑定IP地址" class="headerlink" title="绑定IP地址"></a>绑定IP地址</h2><p>在成功创建套接字后，该套接字仅仅是一个文件描述符，并没有任何地址与之关联。使用该socket发送数据包时，由于该socket没有任何IP地址，内核会根据策略自动选择一个地址。但是，在某些情况下，我们需要手工指定socket使用哪个IP地址进行发送。这时，就需要使用bind系统调用了。</p>
<h3 id="bind的使用"><a href="#bind的使用" class="headerlink" title="bind的使用"></a>bind的使用</h3><p>bind系统调用的接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中的参数解释如下。</p>
<ul>
<li>sockfd：表示要绑定地址的套接字描述符。</li>
<li>addr：表示绑定到套接字的地址。</li>
<li>addrlen：表示绑定的地址长度。</li>
<li>返回值0表示成功，-1则表示错误。</li>
</ul>
<p>因为Linux的套接字是针对多种协议族的，而每个协议族都可以有不同的地址类型。所以Linux套接字关于地址的系统调用，统一使用了一个公共结构体，并要求调用者将实际地址参数进行强制类型转换，以此来避免编译警告。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span>    </span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;    </span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为每个协议族的地址类型各不相同，所以需要通过参数<code>addrlen</code>来告诉内核这个地址的实际大小。</p>
<blockquote>
<p>struct sockaddr数据类型会在socket涉及地址的所有接口中出现。这是因为套接字接口要支持所有的协议族，所以涉及地址的地方都使用了一个统一的地址结构struct sockaddr。</p>
</blockquote>
<p>下面是一个简单示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOOPBACK_ADDR 0x7F000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_PORT   1234</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sock) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to create socket\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = htonl(LOOPBACK_ADDR);</span><br><span class="line">    addr.sin_port = htons(LISTEN_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to bind\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != listen(sock, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to listen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err2:</span><br><span class="line">    close(sock);</span><br><span class="line">err1:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中，我们创建了一个TCP套接字，并将回环地址127.0.0.1和端口1234绑定到这个套接字上。运行这个程序，然后通过<code>netstat</code>检查监听端口：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[fgao@ubuntu ~]<span class="meta"># netstat -ant</span></span><br><span class="line">Active Internet <span class="title function_">connections</span> <span class="params">(servers and established)</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address  Foreign Address        State</span><br><span class="line">tcp        0      0    127.0.0.1:1234      0.0.0.0:*      LISTEN</span><br></pre></td></tr></table></figure></div>

<h3 id="bind-源码分析"><a href="#bind-源码分析" class="headerlink" title="bind 源码分析"></a>bind 源码分析</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bind, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, umyaddr, <span class="type">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接调用内核内部实现的 __sys_bind 函数</span></span><br><span class="line">    <span class="keyword">return</span> __sys_bind(fd, umyaddr, addrlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __sys_bind(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr __user *umyaddr, <span class="type">int</span> addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过文件描述符 fd 查找对应的 socket 结构</span></span><br><span class="line">    <span class="comment">// sockfd_lookup_light 是一个轻量级的查找函数</span></span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">        <span class="comment">// 将用户空间的地址 umyaddr 复制到内核空间的 address 变量中</span></span><br><span class="line">        err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line">        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">            <span class="comment">// 执行安全性检查，确保当前进程有权限执行 bind 操作</span></span><br><span class="line">            err = security_socket_bind(sock,</span><br><span class="line">                                       (<span class="keyword">struct</span> sockaddr *)&amp;address,</span><br><span class="line">                                       addrlen);</span><br><span class="line">            <span class="keyword">if</span> (!err)</span><br><span class="line">                <span class="comment">// 调用具体协议的 bind 实现</span></span><br><span class="line">                <span class="comment">// 通过 sock-&gt;ops-&gt;bind 函数指针调用协议相关的 bind 操作</span></span><br><span class="line">                err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">                                      (<span class="keyword">struct</span> sockaddr *)&amp;address, addrlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放对 socket 文件结构的引用</span></span><br><span class="line">        fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回操作的结果，成功返回 0，失败返回负的错误代码</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在bind的调用中，根据不同的协议调用不同的实现函数（Linux的内核代码中，大量使用了这种面向对象的设计思路）。对于AF_INET协议族来说，无论是面向连接的<code>SOCK_STREAM</code>类型，还是<code>SOCK_DGRAM</code>协议类型，其实现函数均是<code>inet_bind</code>。下面来看一下inet_bind的具体实现：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_bind</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk; <span class="comment">// 获取与 socket 关联的 sock 结构</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果套接字协议有自己的绑定函数，则直接调用它（例如 RAW 套接字）</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;</span><br><span class="line">        <span class="keyword">return</span> sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查地址长度是否小于 sockaddr_in 结构的大小</span></span><br><span class="line">    <span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL; <span class="comment">// 返回无效参数错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在进行任何检查之前运行 BPF 程序，以便如果程序以错误的方式更改上下文，</span></span><br><span class="line"><span class="comment">     * 它将被捕获。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = BPF_CGROUP_RUN_PROG_INET4_BIND(sk, uaddr);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err; <span class="comment">// 如果 BPF 程序返回错误，则直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内部的 __inet_bind 函数执行实际的绑定操作</span></span><br><span class="line">    <span class="keyword">return</span> __inet_bind(sk, uaddr, addr_len, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_bind); <span class="comment">// 导出符号以供其他内核模块使用</span></span><br><span class="line"><span class="type">int</span> __inet_bind(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len,</span><br><span class="line">		<span class="type">bool</span> force_bind_address_no_port, <span class="type">bool</span> with_lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)uaddr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> snum;</span><br><span class="line">	<span class="type">int</span> chk_addr_ret;</span><br><span class="line">	u32 tb_id = RT_TABLE_LOCAL;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr-&gt;sin_family != AF_INET) &#123;</span><br><span class="line">		<span class="comment">/* Compatibility games : accept AF_UNSPEC (mapped to AF_INET)</span></span><br><span class="line"><span class="comment">		 * only if s_addr is INADDR_ANY.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		err = -EAFNOSUPPORT;</span><br><span class="line">		<span class="keyword">if</span> (addr-&gt;sin_family != AF_UNSPEC ||</span><br><span class="line">		    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tb_id = l3mdev_fib_table_by_index(net, sk-&gt;sk_bound_dev_if) ? : tb_id;</span><br><span class="line">	chk_addr_ret = inet_addr_type_table(net, addr-&gt;sin_addr.s_addr, tb_id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Not specified by any standard per-se, however it breaks too</span></span><br><span class="line"><span class="comment">	 * many applications when removed.  It is unfortunate since</span></span><br><span class="line"><span class="comment">	 * allowing applications to make a non-local bind solves</span></span><br><span class="line"><span class="comment">	 * several problems with systems using dynamic addressing.</span></span><br><span class="line"><span class="comment">	 * (ie. your servers still start up even if your ISDN link</span></span><br><span class="line"><span class="comment">	 *  is temporarily down)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = -EADDRNOTAVAIL;</span><br><span class="line">	<span class="keyword">if</span> (!inet_can_nonlocal_bind(net, inet) &amp;&amp;</span><br><span class="line">	    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_LOCAL &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_MULTICAST &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_BROADCAST)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">	err = -EACCES;</span><br><span class="line">	<span class="keyword">if</span> (snum &amp;&amp; inet_port_requires_bind_service(net, snum) &amp;&amp;</span><br><span class="line">	    !ns_capable(net-&gt;user_ns, CAP_NET_BIND_SERVICE))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*      We keep a pair of addresses. rcv_saddr is the one</span></span><br><span class="line"><span class="comment">	 *      used by hash lookups, and saddr is used for transmit.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *      In the BSD API these are the same except where it</span></span><br><span class="line"><span class="comment">	 *      would be illegal to use them (multicast/broadcast) in</span></span><br><span class="line"><span class="comment">	 *      which case the sending device address is used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (with_lock)</span><br><span class="line">		lock_sock(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check these errors (active socket, double bind). */</span></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num)</span><br><span class="line">		<span class="keyword">goto</span> out_release_sock;</span><br><span class="line"></span><br><span class="line">	inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line">	<span class="keyword">if</span> (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)</span><br><span class="line">		inet-&gt;inet_saddr = <span class="number">0</span>;  <span class="comment">/* Use device */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we are allowed to bind here. */</span></span><br><span class="line">	<span class="keyword">if</span> (snum || !(inet-&gt;bind_address_no_port ||</span><br><span class="line">		      force_bind_address_no_port)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">			inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">			err = -EADDRINUSE;</span><br><span class="line">			<span class="keyword">goto</span> out_release_sock;</span><br><span class="line">		&#125;</span><br><span class="line">		err = BPF_CGROUP_RUN_PROG_INET4_POST_BIND(sk);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_release_sock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inet-&gt;inet_rcv_saddr)</span><br><span class="line">		sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;</span><br><span class="line">	<span class="keyword">if</span> (snum)</span><br><span class="line">		sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;</span><br><span class="line">	inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line">	inet-&gt;inet_daddr = <span class="number">0</span>;</span><br><span class="line">	inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">	sk_dst_reset(sk);</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">out_release_sock:</span><br><span class="line">	<span class="keyword">if</span> (with_lock)</span><br><span class="line">		release_sock(sk);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>无论是APUE还是man手册，在讲解bind的时候都有点问题，或有偏差，或不够详尽。从上面的源码我们知道，通过使用系统控制开关<code>sysctl_ip_nonlocal_bind</code>或套接字选项可以让套接字bind一个非本机地址。但APUE却说套接字只能绑定本机的有效地址——当然这也是由于APUE距现在的时间太久了，而man手册都没有提及非本机地址的事情。</p>
<h2 id="客户端连接过程"><a href="#客户端连接过程" class="headerlink" title="客户端连接过程"></a>客户端连接过程</h2><h3 id="connect-的使用"><a href="#connect-的使用" class="headerlink" title="connect 的使用"></a>connect 的使用</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中的参数解释如下：</p>
<ul>
<li><code>int sockfd</code>：套接字描述符。</li>
<li><code>const struct sockaddr *addr</code>：要连接的地址。</li>
<li><code>socklen_t addrlen</code>：要连接的地址长度。</li>
<li>返回值0表示成功，-1表示失败。</li>
</ul>
<p>connect的用途是使用指定的套接字去连接指定的地址。对于面向连接的协议（套接字类型为<code>SOCK_STREAM</code>），connect只能成功一次（当然要如此，因为真正的连接已经建立了）。如果重复调用connect，会返回-1表示失败，同时错误码为<code>EISCONN</code>。而对于非面向连接的协议（套接字类型为<code>SOCK_DGRAM</code>），则可以执行多次connect（因为这时的connect仅仅是设置了默认的目的地址）。</p>
<p>对于TCP套接字来说，<code>connect</code>实际上是要真正地进行三次握手，所以其默认是一个阻塞操作。那么是否可以写一个非阻塞的<code>TCP connect</code>代码呢？这是一个合格的网络开发工程师的基本功，具体的实现可以参看<code>UNPv1</code>的实现。更重要是要理解其原理，这样才能在需要的时候，信手拈来。</p>
<h3 id="connect-源码分析"><a href="#connect-源码分析" class="headerlink" title="connect 源码分析"></a>connect 源码分析</h3><p><code>connect</code>的源码入口位于<code>socket.c</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(connect, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, uservaddr,</span><br><span class="line">		<span class="type">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_connect(fd, uservaddr, addrlen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __sys_connect(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr __user *uservaddr, <span class="type">int</span> addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -EBADF; <span class="comment">// 初始化返回值为 -EBADF，表示文件描述符无效</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件描述符 fd 对应的文件结构</span></span><br><span class="line">    f = fdget(fd);</span><br><span class="line">    <span class="keyword">if</span> (f.file) &#123; <span class="comment">// 如果文件结构存在</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将用户空间的地址 uservaddr 复制到内核空间的 address 变量中</span></span><br><span class="line">        ret = move_addr_to_kernel(uservaddr, addrlen, &amp;address);</span><br><span class="line">        <span class="keyword">if</span> (!ret) <span class="comment">// 如果地址复制成功</span></span><br><span class="line">            <span class="comment">// 调用内部函数 __sys_connect_file 执行连接操作</span></span><br><span class="line">            ret = __sys_connect_file(f.file, &amp;address, addrlen, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 f.flags 不为 0，释放文件结构的引用</span></span><br><span class="line">        <span class="keyword">if</span> (f.flags)</span><br><span class="line">            fput(f.file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回操作的结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __sys_connect_file(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> sockaddr_storage *address,</span><br><span class="line">                       <span class="type">int</span> addrlen, <span class="type">int</span> file_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件结构中获取 socket 结构</span></span><br><span class="line">    sock = sock_from_file(file, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (!sock) <span class="comment">// 如果获取失败</span></span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">// 跳转到 out 标签，返回错误码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行安全性检查，确保连接操作被允许</span></span><br><span class="line">    err = security_socket_connect(sock, (<span class="keyword">struct</span> sockaddr *)address, addrlen);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="comment">// 如果安全检查失败</span></span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">// 跳转到 out 标签，返回错误码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 socket 操作的 connect 方法执行连接操作</span></span><br><span class="line">    err = sock-&gt;ops-&gt;connect(sock, (<span class="keyword">struct</span> sockaddr *)address, addrlen,</span><br><span class="line">                             sock-&gt;file-&gt;f_flags | file_flags);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err; <span class="comment">// 返回操作的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于AF_INET协议族来说，面向连接的协议类型是<code>SOCK_STREAM</code>，其连接函数为<code>inet_stream_connect</code>，而非面向连接的协议类型<code>SOCK_DGRAM</code>，其连接函数为<code>inet_dgram_connect</code>。这很合理，因为从connect的功能实现上看，两者的实现效果完全不同。让我们先从简单的<code>inet_dgram_connect</code>入手。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_dgram_connect</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr,</span></span><br><span class="line"><span class="params">		       <span class="type">int</span> addr_len, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(uaddr-&gt;sa_family))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (uaddr-&gt;sa_family == AF_UNSPEC)</span><br><span class="line">		<span class="keyword">return</span> sk-&gt;sk_prot-&gt;disconnect(sk, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) &#123;</span><br><span class="line">		err = sk-&gt;sk_prot-&gt;pre_connect(sk, uaddr, addr_len);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inet_sk(sk)-&gt;inet_num &amp;&amp; inet_autobind(sk))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	<span class="keyword">return</span> sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_dgram_connect);</span><br><span class="line"><span class="type">int</span> <span class="title function_">ip4_datagram_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	lock_sock(sk);</span><br><span class="line">	res = __ip4_datagram_connect(sk, uaddr, addr_len);</span><br><span class="line">	release_sock(sk);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ip4_datagram_connect);</span><br><span class="line"><span class="type">int</span> __ip4_datagram_connect(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">usin</span> =</span> (<span class="keyword">struct</span> sockaddr_in *) uaddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">    __be32 saddr;</span><br><span class="line">    <span class="type">int</span> oif;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查地址长度是否足够</span></span><br><span class="line">    <span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(*usin))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查地址族是否为 AF_INET</span></span><br><span class="line">    <span class="keyword">if</span> (usin-&gt;sin_family != AF_INET)</span><br><span class="line">        <span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置套接字的路由缓存</span></span><br><span class="line">    sk_dst_reset(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取绑定的设备接口索引和源地址</span></span><br><span class="line">    oif = sk-&gt;sk_bound_dev_if;</span><br><span class="line">    saddr = inet-&gt;inet_saddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理多播地址的情况</span></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_multicast(usin-&gt;sin_addr.s_addr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!oif || netif_index_is_l3_master(sock_net(sk), oif))</span><br><span class="line">            oif = inet-&gt;mc_index;</span><br><span class="line">        <span class="keyword">if</span> (!saddr)</span><br><span class="line">            saddr = inet-&gt;mc_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置流信息</span></span><br><span class="line">    fl4 = &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找路由</span></span><br><span class="line">    rt = ip_route_connect(fl4, usin-&gt;sin_addr.s_addr, saddr,</span><br><span class="line">                          RT_CONN_FLAGS(sk), oif,</span><br><span class="line">                          sk-&gt;sk_protocol,</span><br><span class="line">                          inet-&gt;inet_sport, usin-&gt;sin_port, sk);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(rt)) &#123;</span><br><span class="line">        err = PTR_ERR(rt);</span><br><span class="line">        <span class="keyword">if</span> (err == -ENETUNREACH)</span><br><span class="line">            IP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为广播地址且套接字不允许广播</span></span><br><span class="line">    <span class="keyword">if</span> ((rt-&gt;rt_flags &amp; RTCF_BROADCAST) &amp;&amp; !sock_flag(sk, SOCK_BROADCAST)) &#123;</span><br><span class="line">        ip_rt_put(rt);</span><br><span class="line">        err = -EACCES;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新源地址</span></span><br><span class="line">    <span class="keyword">if</span> (!inet-&gt;inet_saddr)</span><br><span class="line">        inet-&gt;inet_saddr = fl4-&gt;saddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新接收源地址</span></span><br><span class="line">    <span class="keyword">if</span> (!inet-&gt;inet_rcv_saddr) &#123;</span><br><span class="line">        inet-&gt;inet_rcv_saddr = fl4-&gt;saddr;</span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;rehash)</span><br><span class="line">            sk-&gt;sk_prot-&gt;rehash(sk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目标地址和端口</span></span><br><span class="line">    inet-&gt;inet_daddr = fl4-&gt;daddr;</span><br><span class="line">    inet-&gt;inet_dport = usin-&gt;sin_port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新重用端口状态</span></span><br><span class="line">    reuseport_has_conns(sk, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字状态为已连接</span></span><br><span class="line">    sk-&gt;sk_state = TCP_ESTABLISHED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置传输哈希</span></span><br><span class="line">    sk_set_txhash(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成 IP 标识符</span></span><br><span class="line">    inet-&gt;inet_id = prandom_u32();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字的路由缓存</span></span><br><span class="line">    sk_dst_set(sk, &amp;rt-&gt;dst);</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__ip4_datagram_connect);</span><br></pre></td></tr></table></figure></div>

<p>由于功能比较简单，所以UDP的connect实现源码也一目了然，可以看到，只是设置了目的IP、端口和路由信息。</p>
<hr>
<p>下面看一下TCP的connect实现，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_stream_connect</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> addr_len, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	lock_sock(sock-&gt;sk);</span><br><span class="line">	err = __inet_stream_connect(sock, uaddr, addr_len, flags, <span class="number">0</span>);</span><br><span class="line">	release_sock(sock-&gt;sk);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __inet_stream_connect(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr,</span><br><span class="line">                          <span class="type">int</span> addr_len, <span class="type">int</span> flags, <span class="type">int</span> is_sendmsg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">long</span> timeo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查地址参数的有效性</span></span><br><span class="line">    <span class="keyword">if</span> (uaddr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(uaddr-&gt;sa_family))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果地址族是 AF_UNSPEC，断开连接</span></span><br><span class="line">        <span class="keyword">if</span> (uaddr-&gt;sa_family == AF_UNSPEC) &#123;</span><br><span class="line">            err = sk-&gt;sk_prot-&gt;disconnect(sk, flags);</span><br><span class="line">            sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据套接字的当前状态进行处理</span></span><br><span class="line">    <span class="keyword">switch</span> (sock-&gt;state) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">case</span> SS_CONNECTED:</span><br><span class="line">        err = -EISCONN;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">case</span> SS_CONNECTING:</span><br><span class="line">        <span class="keyword">if</span> (inet_sk(sk)-&gt;defer_connect)</span><br><span class="line">            err = is_sendmsg ? -EINPROGRESS : -EISCONN;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -EALREADY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SS_UNCONNECTED:</span><br><span class="line">        err = -EISCONN;</span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果启用了 BPF 预连接钩子，调用预连接处理函数</span></span><br><span class="line">        <span class="keyword">if</span> (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) &#123;</span><br><span class="line">            err = sk-&gt;sk_prot-&gt;pre_connect(sk, uaddr, addr_len);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试连接</span></span><br><span class="line">        err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        sock-&gt;state = SS_CONNECTING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!err &amp;&amp; inet_sk(sk)-&gt;defer_connect)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        err = -EINPROGRESS;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取发送超时时间</span></span><br><span class="line">    timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果套接字处于 SYN_SENT 或 SYN_RECV 状态，等待连接完成</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">        <span class="type">int</span> writebias = (sk-&gt;sk_protocol == IPPROTO_TCP) &amp;&amp;</span><br><span class="line">                        tcp_sk(sk)-&gt;fastopen_req &amp;&amp;</span><br><span class="line">                        tcp_sk(sk)-&gt;fastopen_req-&gt;data ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timeo || !inet_wait_for_connect(sk, timeo, writebias))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        err = sock_intr_errno(timeo);</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查连接是否被关闭</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE)</span><br><span class="line">        <span class="keyword">goto</span> sock_error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字状态为已连接</span></span><br><span class="line">    sock-&gt;state = SS_CONNECTED;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">sock_error:</span><br><span class="line">    err = sock_error(sk) ? : -ECONNABORTED;</span><br><span class="line">    sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;disconnect(sk, flags))</span><br><span class="line">        sock-&gt;state = SS_DISCONNECTING;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接下来，就需要进入TCP协议自定义的connect函数<code>tcp_v4_connect</code>了，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">usin</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)uaddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">    __be16 orig_sport, orig_dport;</span><br><span class="line">    __be32 daddr, nexthop;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_timewait_death_row</span> *<span class="title">tcp_death_row</span> =</span> &amp;sock_net(sk)-&gt;ipv4.tcp_death_row;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查地址长度和地址族</span></span><br><span class="line">    <span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usin-&gt;sin_family != AF_INET)</span><br><span class="line">        <span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目的地址和下一跳地址</span></span><br><span class="line">    nexthop = daddr = usin-&gt;sin_addr.s_addr;</span><br><span class="line">    inet_opt = rcu_dereference_protected(inet-&gt;inet_opt, lockdep_sock_is_held(sk));</span><br><span class="line">    <span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!daddr)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        nexthop = inet_opt-&gt;opt.faddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始的源端口和目的端口</span></span><br><span class="line">    orig_sport = inet-&gt;inet_sport;</span><br><span class="line">    orig_dport = usin-&gt;sin_port;</span><br><span class="line">    fl4 = &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找路由</span></span><br><span class="line">    rt = ip_route_connect(fl4, nexthop, inet-&gt;inet_saddr, RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if, IPPROTO_TCP, orig_sport, orig_dport, sk);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(rt)) &#123;</span><br><span class="line">        err = PTR_ERR(rt);</span><br><span class="line">        <span class="keyword">if</span> (err == -ENETUNREACH)</span><br><span class="line">            IP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查路由标志</span></span><br><span class="line">    <span class="keyword">if</span> (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) &#123;</span><br><span class="line">        ip_rt_put(rt);</span><br><span class="line">        <span class="keyword">return</span> -ENETUNREACH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目的地址</span></span><br><span class="line">    <span class="keyword">if</span> (!inet_opt || !inet_opt-&gt;opt.srr)</span><br><span class="line">        daddr = fl4-&gt;daddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置源地址</span></span><br><span class="line">    <span class="keyword">if</span> (!inet-&gt;inet_saddr)</span><br><span class="line">        inet-&gt;inet_saddr = fl4-&gt;saddr;</span><br><span class="line">    sk_rcv_saddr_set(sk, inet-&gt;inet_saddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 TCP 时间戳选项</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;inet_daddr != daddr) &#123;</span><br><span class="line">        tp-&gt;rx_opt.ts_recent = <span class="number">0</span>;</span><br><span class="line">        tp-&gt;rx_opt.ts_recent_stamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (likely(!tp-&gt;repair))</span><br><span class="line">            WRITE_ONCE(tp-&gt;write_seq, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目的端口和地址</span></span><br><span class="line">    inet-&gt;inet_dport = usin-&gt;sin_port;</span><br><span class="line">    sk_daddr_set(sk, daddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置扩展头长度</span></span><br><span class="line">    inet_csk(sk)-&gt;icsk_ext_hdr_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (inet_opt)</span><br><span class="line">        inet_csk(sk)-&gt;icsk_ext_hdr_len = inet_opt-&gt;opt.optlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 MSS 限制</span></span><br><span class="line">    tp-&gt;rx_opt.mss_clamp = TCP_MSS_DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字状态为 SYN_SENT</span></span><br><span class="line">    tcp_set_state(sk, TCP_SYN_SENT);</span><br><span class="line">    err = inet_hash_connect(tcp_death_row, sk);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line">    sk_set_txhash(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新路由端口</span></span><br><span class="line">    rt = ip_route_newports(fl4, rt, orig_sport, orig_dport, inet-&gt;inet_sport, inet-&gt;inet_dport, sk);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(rt)) &#123;</span><br><span class="line">        err = PTR_ERR(rt);</span><br><span class="line">        rt = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字的 GSO 类型和能力</span></span><br><span class="line">    sk-&gt;sk_gso_type = SKB_GSO_TCPV4;</span><br><span class="line">    sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">    rt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 序列号和时间戳偏移</span></span><br><span class="line">    <span class="keyword">if</span> (likely(!tp-&gt;repair)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tp-&gt;write_seq)</span><br><span class="line">            WRITE_ONCE(tp-&gt;write_seq, secure_tcp_seq(inet-&gt;inet_saddr, inet-&gt;inet_daddr, inet-&gt;inet_sport, usin-&gt;sin_port));</span><br><span class="line">        tp-&gt;tsoffset = secure_tcp_ts_off(sock_net(sk), inet-&gt;inet_saddr, inet-&gt;inet_daddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 IP 标识符</span></span><br><span class="line">    inet-&gt;inet_id = prandom_u32();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 TCP 快速打开</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_fastopen_defer_connect(sk, &amp;err))</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 TCP 连接</span></span><br><span class="line">    err = tcp_connect(sk);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">failure:</span><br><span class="line">    <span class="comment">// 处理失败情况，重置套接字状态</span></span><br><span class="line">    tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">    ip_rt_put(rt);</span><br><span class="line">    sk-&gt;sk_route_caps = <span class="number">0</span>;</span><br><span class="line">    inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面来分析<code>tcp_connect</code>，看看内核是如何发送SYN包的，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 BPF 钩子函数，用于 TCP 连接的回调</span></span><br><span class="line">    tcp_call_bpf(sk, BPF_SOCK_OPS_TCP_CONNECT_CB, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建 IP 头部，如果失败则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (inet_csk(sk)-&gt;icsk_af_ops-&gt;rebuild_header(sk))</span><br><span class="line">        <span class="keyword">return</span> -EHOSTUNREACH; <span class="comment">// 路由失败或类似问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 TCP 连接参数</span></span><br><span class="line">    tcp_connect_init(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果处于 TCP 修复模式，直接完成连接</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tp-&gt;repair)) &#123;</span><br><span class="line">        tcp_finish_connect(sk, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个新的 sk_buff 用于发送 SYN 包</span></span><br><span class="line">    buff = sk_stream_alloc_skb(sk, <span class="number">0</span>, sk-&gt;sk_allocation, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!buff))</span><br><span class="line">        <span class="keyword">return</span> -ENOBUFS; <span class="comment">// 缓冲区不足</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化非数据包的 SKB，设置 SYN 标志</span></span><br><span class="line">    tcp_init_nondata_skb(buff, tp-&gt;write_seq++, TCPHDR_SYN);</span><br><span class="line">    tcp_mstamp_refresh(tp);</span><br><span class="line">    tp-&gt;retrans_stamp = tcp_time_stamp(tp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SKB 加入发送队列</span></span><br><span class="line">    tcp_connect_queue_skb(sk, buff);</span><br><span class="line">    tcp_ecn_send_syn(sk, buff);</span><br><span class="line">    tcp_rbtree_insert(&amp;sk-&gt;tcp_rtx_queue, buff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 SYN 包，如果启用了快速打开则包括数据</span></span><br><span class="line">    err = tp-&gt;fastopen_req ? tcp_send_syn_data(sk, buff) :</span><br><span class="line">          tcp_transmit_skb(sk, buff, <span class="number">1</span>, sk-&gt;sk_allocation);</span><br><span class="line">    <span class="keyword">if</span> (err == -ECONNREFUSED)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新发送序列号</span></span><br><span class="line">    WRITE_ONCE(tp-&gt;snd_nxt, tp-&gt;write_seq);</span><br><span class="line">    tp-&gt;pushed_seq = tp-&gt;write_seq;</span><br><span class="line">    buff = tcp_send_head(sk);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(buff)) &#123;</span><br><span class="line">        WRITE_ONCE(tp-&gt;snd_nxt, TCP_SKB_CB(buff)-&gt;seq);</span><br><span class="line">        tp-&gt;pushed_seq = TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加活动打开连接的统计计数</span></span><br><span class="line">    TCP_INC_STATS(sock_net(sk), TCP_MIB_ACTIVEOPENS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重传定时器以重复发送 SYN 直到收到响应</span></span><br><span class="line">    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,</span><br><span class="line">                              inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="服务端连接过程"><a href="#服务端连接过程" class="headerlink" title="服务端连接过程"></a>服务端连接过程</h2><h3 id="listen-的使用"><a href="#listen-的使用" class="headerlink" title="listen 的使用"></a>listen 的使用</h3><p>服务器端用listen来监听端口，其原型为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数int sockfd：成功创建的TCP套接字。</li>
<li>int backlog：定义TCP未处理连接的队列长度。该队列虽然已经完成了三次握手，但服务器端还没有执行accept的连接。</li>
<li>函数的返回值为0，表示成功；-1表示失败。</li>
</ul>
<h3 id="listen-源码分析"><a href="#listen-源码分析" class="headerlink" title="listen 源码分析"></a>listen 源码分析</h3><p>listen的源码入口位于<code>socket.c</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(listen, <span class="type">int</span>, fd, <span class="type">int</span>, backlog)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_listen(fd, backlog);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __sys_listen(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="type">int</span> err, fput_needed;</span><br><span class="line">	<span class="type">int</span> somaxconn;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (sock) &#123;</span><br><span class="line">		somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)backlog &gt; somaxconn)</span><br><span class="line">			backlog = somaxconn;</span><br><span class="line"></span><br><span class="line">		err = security_socket_listen(sock, backlog);</span><br><span class="line">		<span class="keyword">if</span> (!err)</span><br><span class="line">			err = sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line"></span><br><span class="line">		fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>AF_INET</code>协议族的listen实现函数为<code>inet_listen</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_listen</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> old_state;</span><br><span class="line">    <span class="type">int</span> err, tcp_fastopen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取套接字的锁，以确保对套接字状态的修改是线程安全的</span></span><br><span class="line">    lock_sock(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化错误码为无效参数</span></span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="comment">// 检查套接字状态是否为未连接，且类型是否为流式套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前套接字的状态</span></span><br><span class="line">    old_state = sk-&gt;sk_state;</span><br><span class="line">    <span class="comment">// 检查套接字状态是否为关闭或监听状态</span></span><br><span class="line">    <span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最大确认的积压队列长度</span></span><br><span class="line">    WRITE_ONCE(sk-&gt;sk_max_ack_backlog, backlog);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果套接字已经处于监听状态，只允许调整积压队列长度</span></span><br><span class="line">    <span class="keyword">if</span> (old_state != TCP_LISTEN) &#123;</span><br><span class="line">        <span class="comment">// 启用 TCP 快速打开（TFO），无需显式设置 TCP_FASTOPEN 套接字选项</span></span><br><span class="line">        tcp_fastopen = sock_net(sk)-&gt;ipv4.sysctl_tcp_fastopen;</span><br><span class="line">        <span class="keyword">if</span> ((tcp_fastopen &amp; TFO_SERVER_WO_SOCKOPT1) &amp;&amp;</span><br><span class="line">            (tcp_fastopen &amp; TFO_SERVER_ENABLE) &amp;&amp;</span><br><span class="line">            !inet_csk(sk)-&gt;icsk_accept_queue.fastopenq.max_qlen) &#123;</span><br><span class="line">            fastopen_queue_tune(sk, backlog);</span><br><span class="line">            tcp_fastopen_init_key_once(sock_net(sk));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动监听</span></span><br><span class="line">        err = inet_csk_listen_start(sk, backlog);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 BPF 钩子函数，用于 TCP 监听的回调</span></span><br><span class="line">        tcp_call_bpf(sk, BPF_SOCK_OPS_TCP_LISTEN_CB, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功设置监听状态</span></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="comment">// 释放套接字的锁</span></span><br><span class="line">    release_sock(sk);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接下来进入<code>inet_csk_listen_start</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_csk_listen_start</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">    <span class="type">int</span> err = -EADDRINUSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为接受队列分配资源</span></span><br><span class="line">    reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化确认积压队列长度和延迟确认</span></span><br><span class="line">    sk-&gt;sk_ack_backlog = <span class="number">0</span>;</span><br><span class="line">    inet_csk_delack_init(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里存在一个竞争窗口：我们宣布自己正在监听，</span></span><br><span class="line"><span class="comment">     * 但此转换尚未通过 get_port() 验证。</span></span><br><span class="line"><span class="comment">     * 这是可以的，因为只有在验证完成后，该套接字才会进入哈希表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    inet_sk_state_store(sk, TCP_LISTEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取端口号</span></span><br><span class="line">    <span class="keyword">if</span> (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;inet_num)) &#123;</span><br><span class="line">        <span class="comment">// 设置套接字的源端口</span></span><br><span class="line">        inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置套接字的路由缓存</span></span><br><span class="line">        sk_dst_reset(sk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将套接字插入到协议的哈希表中</span></span><br><span class="line">        err = sk-&gt;sk_prot-&gt;hash(sk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果成功插入哈希表，返回 0 表示成功</span></span><br><span class="line">        <span class="keyword">if</span> (likely(!err))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果失败，将套接字状态设置为关闭</span></span><br><span class="line">    inet_sk_set_state(sk, TCP_CLOSE);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>现在服务器端已经处于监听状态，可以接收客户端的连接请求了。同时，通过源码跟踪，也可以发现在第二个参数不超过系统限制的最大值的情况下，内核已直接使用其值作为已连接队列的长度了。</p>
<h3 id="accept-的使用"><a href="#accept-的使用" class="headerlink" title="accept 的使用"></a>accept 的使用</h3><p><code>accept</code>用于从指定套接字的连接队列中取出第一个连接，并返回一个新的套接字用于与客户端进行通信，示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">accept4</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中的参数解释如下：</p>
<ul>
<li><code>int sockfd</code>：处于监听状态的套接字。</li>
<li><code>struct sockaddr *addr</code>：用于保存对端的地址信息。</li>
<li><code>socklen_t *addrlen</code>：是一个输入输出值。调用者将其初始化为addr缓存的大小，accept返回时，会将其设置为addr的大小。</li>
<li><code>int flags</code>：是新引入的系统调用accept4的标志位；目前支持<code>SOCK_NONBLOCK</code>和<code>SOCK_CLOEXEC</code>。关于返回值，若执行成功，则返回一个非负的文件描述符；若失败则返回-1。</li>
</ul>
<blockquote>
<p>若不关心对端地址信息，则可以将addr和addrlen设置为NULL。</p>
</blockquote>
<h3 id="accept-源码分析"><a href="#accept-源码分析" class="headerlink" title="accept 源码分析"></a>accept 源码分析</h3><p>accept的源码入口位于文件<code>socket.c</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(accept, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, upeer_sockaddr,</span><br><span class="line">		<span class="type">int</span> __user *, upeer_addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">SYSCALL_DEFINE4(accept4, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, upeer_sockaddr,</span><br><span class="line">		<span class="type">int</span> __user *, upeer_addrlen, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __sys_accept4(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr __user *upeer_sockaddr,</span><br><span class="line">		  <span class="type">int</span> __user *upeer_addrlen, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = -EBADF;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = fdget(fd);</span><br><span class="line">	<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">		ret = __sys_accept4_file(f.file, <span class="number">0</span>, upeer_sockaddr,</span><br><span class="line">						upeer_addrlen, flags,</span><br><span class="line">						rlimit(RLIMIT_NOFILE));</span><br><span class="line">		<span class="keyword">if</span> (f.flags)</span><br><span class="line">			fput(f.file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __sys_accept4_file(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> file_flags,</span><br><span class="line">		       <span class="keyword">struct</span> sockaddr __user *upeer_sockaddr,</span><br><span class="line">		       <span class="type">int</span> __user *upeer_addrlen, <span class="type">int</span> flags,</span><br><span class="line">		       <span class="type">unsigned</span> <span class="type">long</span> nofile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>, *<span class="title">newsock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">    <span class="type">int</span> err, len, newfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 flags 是否只包含 SOCK_CLOEXEC 和 SOCK_NONBLOCK</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 SOCK_NONBLOCK 不等于 O_NONBLOCK 并且 flags 包含 SOCK_NONBLOCK，则替换为 O_NONBLOCK</span></span><br><span class="line">    <span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">        flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件结构中获取 socket</span></span><br><span class="line">    sock = sock_from_file(file, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (!sock)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的 socket 结构</span></span><br><span class="line">    err = -ENFILE;</span><br><span class="line">    newsock = sock_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!newsock)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制套接字类型和操作</span></span><br><span class="line">    newsock-&gt;type = sock-&gt;type;</span><br><span class="line">    newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 不需要在这里调用 try_module_get，因为监听套接字 (sock)</span></span><br><span class="line"><span class="comment">     * 已经持有协议模块 (sock-&gt;ops-&gt;owner)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __module_get(newsock-&gt;ops-&gt;owner);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个未使用的文件描述符</span></span><br><span class="line">    newfd = __get_unused_fd_flags(flags, nofile);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(newfd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        err = newfd;</span><br><span class="line">        sock_release(newsock);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新 socket 分配文件结构</span></span><br><span class="line">    newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(newfile)) &#123;</span><br><span class="line">        err = PTR_ERR(newfile);</span><br><span class="line">        put_unused_fd(newfd);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全检查</span></span><br><span class="line">    err = security_socket_accept(sock, newsock);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用协议的 accept 方法</span></span><br><span class="line">    err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags | file_flags, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户提供了对等地址缓冲区，则获取对等地址</span></span><br><span class="line">    <span class="keyword">if</span> (upeer_sockaddr) &#123;</span><br><span class="line">        len = newsock-&gt;ops-&gt;getname(newsock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -ECONNABORTED;</span><br><span class="line">            <span class="keyword">goto</span> out_fd;</span><br><span class="line">        &#125;</span><br><span class="line">        err = move_addr_to_user(&amp;address, len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件标志不会通过 accept() 继承，和其他操作系统不同。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装新的文件描述符</span></span><br><span class="line">    fd_install(newfd, newfile);</span><br><span class="line">    err = newfd;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">out_fd:</span><br><span class="line">    fput(newfile);</span><br><span class="line">    put_unused_fd(newfd);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于AF_INET协议族，accept的实现函数为<code>inet_accept</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_accept</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> socket *newsock, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">bool</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk1</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="type">int</span> err = -EINVAL;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span> =</span> sk1-&gt;sk_prot-&gt;accept(sk1, flags, &amp;err, kern);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sk2)</span><br><span class="line">		<span class="keyword">goto</span> do_err;</span><br><span class="line"></span><br><span class="line">	lock_sock(sk2);</span><br><span class="line"></span><br><span class="line">	sock_rps_record_flow(sk2);</span><br><span class="line">	WARN_ON(!((<span class="number">1</span> &lt;&lt; sk2-&gt;sk_state) &amp;</span><br><span class="line">		  (TCPF_ESTABLISHED | TCPF_SYN_RECV |</span><br><span class="line">		  TCPF_CLOSE_WAIT | TCPF_CLOSE)));</span><br><span class="line"></span><br><span class="line">	sock_graft(sk2, newsock);</span><br><span class="line"></span><br><span class="line">	newsock-&gt;state = SS_CONNECTED;</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	release_sock(sk2);</span><br><span class="line">do_err:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于TCP协议来说，其accept实现函数如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sock *<span class="title function_">inet_csk_accept</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> flags, <span class="type">int</span> *err, <span class="type">bool</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock_queue</span> *<span class="title">queue</span> =</span> &amp;icsk-&gt;icsk_accept_queue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">newsk</span>;</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    lock_sock(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保套接字处于监听状态，并且有挂起的连接请求 */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找已建立的连接 */</span></span><br><span class="line">    <span class="keyword">if</span> (reqsk_queue_empty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="type">long</span> timeo = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果是非阻塞套接字，则不等待 */</span></span><br><span class="line">        error = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span> (!timeo)</span><br><span class="line">            <span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">        error = inet_csk_wait_for_connect(sk, timeo);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从请求队列中移除一个请求</span></span><br><span class="line">    req = reqsk_queue_remove(<span class="built_in">queue</span>, sk);</span><br><span class="line">    newsk = req-&gt;sk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 TCP Fast Open 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_protocol == IPPROTO_TCP &amp;&amp;</span><br><span class="line">        tcp_rsk(req)-&gt;tfo_listener) &#123;</span><br><span class="line">        spin_lock_bh(&amp;<span class="built_in">queue</span>-&gt;fastopenq.lock);</span><br><span class="line">        <span class="keyword">if</span> (tcp_rsk(req)-&gt;tfo_listener) &#123;</span><br><span class="line">            <span class="comment">/* 我们仍在等待 3WHS 的最终 ACK，因此现在不能释放 req。</span></span><br><span class="line"><span class="comment">             * 相反，我们将 req-&gt;sk 设置为 NULL，以表示子套接字已被获取，</span></span><br><span class="line"><span class="comment">             * 因此当 3WHS 完成（或中止）时，reqsk_fastopen_remove() 将释放 req。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            req-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">            req = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_bh(&amp;<span class="built_in">queue</span>-&gt;fastopenq.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    <span class="keyword">if</span> (newsk &amp;&amp; mem_cgroup_sockets_enabled) &#123;</span><br><span class="line">        <span class="type">int</span> amt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 原子地获取内存使用情况，设置并收费 newsk-&gt;sk_memcg。 */</span></span><br><span class="line">        lock_sock(newsk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 套接字尚未被接受，因此无需查看 newsk-&gt;sk_wmem_queued。 */</span></span><br><span class="line">        amt = sk_mem_pages(newsk-&gt;sk_forward_alloc +</span><br><span class="line">                           <span class="type">atomic_read</span>(&amp;newsk-&gt;sk_rmem_alloc));</span><br><span class="line">        mem_cgroup_sk_alloc(newsk);</span><br><span class="line">        <span class="keyword">if</span> (newsk-&gt;sk_memcg &amp;&amp; amt)</span><br><span class="line">            mem_cgroup_charge_skmem(newsk-&gt;sk_memcg, amt);</span><br><span class="line"></span><br><span class="line">        release_sock(newsk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req)</span><br><span class="line">        reqsk_put(req);</span><br><span class="line">    <span class="keyword">return</span> newsk;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">    newsk = <span class="literal">NULL</span>;</span><br><span class="line">    req = <span class="literal">NULL</span>;</span><br><span class="line">    *err = error;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="TCP-三次握手的实现分析"><a href="#TCP-三次握手的实现分析" class="headerlink" title="TCP 三次握手的实现分析"></a>TCP 三次握手的实现分析</h2><p>前面从客户端和服务器端的系统调用的角度，来分析和学习TCP的连接过程。本节将从TCP三次握手的数据包交互过程，来研究TCP连接的建立。。</p>
<p><strong>TCP报文格式：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/2645999549-5e99b7b074b37_fix732.png"
                      alt="2645999549-5e99b7b074b37_fix732"
                ></p>
<p>TCP 首部包含以下内容，请留意其中的控制位，在三次握手和四次挥手过程中会频繁出现：</p>
<ul>
<li>**端口号 (Source Port and Destination Port)**：每个 TCP  报文段都包含源端和目的端的端口号，用于寻找发送端和接收端应用进程。这两个值加上 IP 首部中的源端 IP 地址和目的端 IP  地址就可以确定一个唯一的 TCP 连接。</li>
<li>**序号 (Sequence Number)**：这个字段的主要作用是用于将失序的数据重新排列。TCP 会隐式地对字节流中的每个字节进行编号，而 TCP 报文段的序号被设置为其数据部分的第一个字节的编号。序号是 32 bit 的无符号数，取值范围是0到 232 - 1。</li>
<li>**确认序号 (Acknowledgment  Number)**：接收方在接受到数据后，会回复确认报文，其中包含确认序号，作用就是告诉发送方自己接收到了哪些数据，下一次数据从哪里开始发，因此，确认序号应当是上次已成功收到数据字节序号加 1。只有 ACK 标志为 1 时确认序号字段才有效。</li>
<li>**首部长度 (Header  Length)**：首部中的选项部分的长度是可变的，因此首部的长度也是可变的，所以需要这个字段来明确表示首部的长度，这个字段占 4 bit，4  位的二进制数最大可以表示 15，而首部长度是以 4 个字节为一个单位的，因此首部最大长度是 15 * 4 &#x3D; 60 字节。</li>
<li>**保留字段 (Reserved)**：占 6 位，未来可能有具体用途，目前默认值为0.</li>
<li>**控制位 (Control Bits)**：在三次握手和四次挥手中会经常看到 SYN、ACK 和 FIN 的身影，一共有 6 个标志位，它们表示的意义如下：<ul>
<li>**URG (Urgent Bit)**：值为 1 时，紧急指针生效</li>
<li>**ACK (Acknowledgment Bit)**：值为 1 时，确认序号生效</li>
<li>**PSH (Push Bit)**：接收方应尽快将这个报文段交给应用层</li>
<li>**RST (Reset Bit)**：发送端遇到问题，想要重建连接</li>
<li>**SYN (Synchronize Bit)**：同步序号，用于发起一个连接</li>
<li>**FIN (Finish Bit)**：发送端要求关闭连接</li>
</ul>
</li>
<li>**窗口大小 (Window)**： TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个 16 bit 字段，单位是字节， 因而窗口大小最大为 65535 字节。</li>
<li>**检验和 (Checksum)**：功能类似于数字签名，用于验证数据完整性，也就是确保数据未被修改。检验和覆盖了整个 TCP 报文段，包括 TCP 首部和 TCP 数据，发送端根据特定算法对整个报文段计算出一个检验和，接收端会进行计算并验证。</li>
<li>**紧急指针 (Urgent Pointer)**：当 URG 控制位值为 1 时，此字段生效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</li>
<li>**选项 (Options)**：这一部分是可选字段，也就是非必须字段，最常见的可选字段是“最长报文大小 (MSS，Maximum Segment Size)”。</li>
<li>**有效数据部分 (Data)**：这部分也不是必须的，比如在建立和关闭 TCP 连接的阶段，双方交换的报文段就只包含 TCP 首部。</li>
</ul>
<p><strong>TCP三次握手</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/3507527407-5e7b1e199cbbb_fix732.png"
                      alt="3507527407-5e7b1e199cbbb_fix732"
                ></p>
<p><strong>三次握手</strong></p>
<ol>
<li><strong>第一次握手：</strong>客户端向服务器发送报文段1，其中的 SYN 标志位 (前文已经介绍过各种标志位的作用)的值为  1，表示这是一个用于请求发起连接的报文段，其中的序号字段 (Sequence Number，图中简写为seq)被设置为初始序号x  (Initial Sequence Number，ISN)，TCP 连接双方均可随机选择初始序号。发送完报文段1之后，客户端进入  SYN-SENT 状态，等待服务器的确认。</li>
<li><strong>第二次握手：</strong>服务器在收到客户端的连接请求后，向客户端发送报文段2作为应答，其中 ACK 标志位设置为  1，表示对客户端做出应答，其确认序号字段 (Acknowledgment Number，图中简写为小写 ack) 生效，该字段值为 x +  1，也就是从客户端收到的报文段的序号加一，代表服务器期望下次收到客户端的数据的序号。此外，报文段2的 SYN  标志位也设置为1，代表这同时也是一个用于发起连接的报文段，序号 seq 设置为服务器初始序号y。发送完报文段2后，服务器进入  SYN-RECEIVED 状态。</li>
<li><strong>第三次握手：</strong>客户端在收到报文段2后，向服务器发送报文段3，其 ACK 标志位为1，代表对服务器做出应答，确认序号字段 ack 为 y + 1，序号字段 seq 为 x + 1。此报文段发送完毕后，双方都进入 ESTABLISHED 状态，表示连接已建立。</li>
</ol>
<p><strong>同时打开</strong></p>
<p>这是 TCP 建立连接的特殊情况，有时会出现两台机器同时执行主动打开的情况，不过概率非常小，这种情况大家仅作了解即可。在这种情况下就无所谓发送方和接收方了，双放都可以称为客户端和服务器，同时打开的过程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/3987873264-5e7b1e34b2c51_fix732.webp"
                      alt="3987873264-5e7b1e34b2c51_fix732"
                ></p>
<p>如图所示，双方在同一时刻发送 SYN 报文段，并进入 SYN-SENT 状态，在收到 SYN 后，状态变为  SYN-RECEIVED，同时它们都再发送一个 SYN + ACK 的报文段，状态都变为  ESTABLISHED，连接成功建立。在此过程中双方一共交换了4个报文段，比三次握手多一个。</p>
<blockquote>
<p><strong>TCP 建立连接为什么要三次握手而不是两次？</strong></p>
<p>答：网上大多数资料对这个问题的回答只有简单的一句：防止已过期的连接请求报文突然又传送到服务器，因而产生错误，这既不够全面也不够具体。下面给出比较详细而全面的回答：</p>
<ol>
<li><p>防止已过期的连接请求报文突然又传送到服务器，因而产生错误</p>
<p>在双方两次握手即可建立连接的情况下，假设客户端发送 A  报文段请求建立连接，由于网络原因造成 A  暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段，客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B  顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED  状态，双方建立连接并传输数据，之后正常断开连接。此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED  状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED  状态，这将导致服务器长时间单方面等待，造成资源浪费。</p>
</li>
<li><p>三次握手才能让双方均确认自己和对方的发送和接收能力都正常</p>
<p>第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；</p>
<p>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p>
<p>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p>
<p>可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。</p>
</li>
<li><p>告知对方自己的初始序号值，并确认收到对方的初始序号值</p>
<p>TCP 实现了可靠的数据传输，原因之一就是 TCP  报文段中维护了序号字段和确认序号字段，也就是图中的 seq 和  ack，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</p>
</li>
</ol>
<p><strong>TCP 建立连接为什么要三次握手而不是四次？</strong></p>
<p>相比上个问题而言，这个问题就简单多了。因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p>
</blockquote>
<h2 id="TCP-四次挥手的实现分析"><a href="#TCP-四次挥手的实现分析" class="headerlink" title="TCP 四次挥手的实现分析"></a>TCP 四次挥手的实现分析</h2><p>建立一个连接需要三次握手，而终止一个连接要经过 4次握手。这由 TCP 的半关闭( half-close) 造成的。既然一个 TCP  连接是全双工 (即数据在两个方向上能同时传递)， 因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据发送任务后就能发送一个 FIN  来终止这个方向连接。当一端收到一个  FIN，它必须通知应用层另一端已经终止了数据传送。理论上客户端和服务器都可以发起主动关闭，但是更多的情况下是客户端主动发起。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/748605951-5e7b1e45d431b_fix732.webp"
                      alt="748605951-5e7b1e45d431b_fix732"
                ></p>
<p><strong>四次挥手详细过程如下：</strong></p>
<ol>
<li>客户端发送关闭连接的报文段，FIN 标志位1，请求关闭连接，并停止发送数据。序号字段 seq &#x3D; x (等于之前发送的所有数据的最后一个字节的序号加一)，然后客户端会进入 FIN-WAIT-1 状态，等待来自服务器的确认报文。</li>
<li>服务器收到 FIN 报文后，发回确认报文，ACK &#x3D; 1， ack &#x3D; x + 1，并带上自己的序号 seq &#x3D; y，然后服务器就进入  CLOSE-WAIT 状态。服务器还会通知上层的应用程序对方已经释放连接，此时 TCP  处于半关闭状态，也就是说客户端已经没有数据要发送了，但是服务器还可以发送数据，客户端也还能够接收。</li>
<li>客户端收到服务器的 ACK 报文段后随即进入 FIN-WAIT-2 状态，此时还能收到来自服务器的数据，直到收到 FIN 报文段。</li>
<li>服务器发送完所有数据后，会向客户端发送 FIN 报文段，各字段值如图所示，随后服务器进入 LAST-ACK 状态，等待来自客户端的确认报文段。</li>
<li>客户端收到来自服务器的 FIN 报文段后，向服务器发送 ACK 报文，随后进入 TIME-WAIT 状态，等待 2MSL(2 *  Maximum Segment Lifetime，两倍的报文段最大存活时间)  ，这是任何报文段在被丢弃前能在网络中存在的最长时间，常用值有30秒、1分钟和2分钟。如无特殊情况，客户端会进入 CLOSED 状态。</li>
<li>服务器在接收到客户端的 ACK 报文后会随即进入 CLOSED 状态，由于没有等待时间，一般而言，服务器比客户端更早进入 CLOSED 状态。</li>
</ol>
<blockquote>
<p><strong>为什么 TCP 关闭连接为什么要四次而不是三次？</strong></p>
<p>服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK  报文段，接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN  报文，表示数据已经发送完毕，请求关闭连接，然后客户端再做出应答，因此一共需要四次挥手。</p>
<p><strong>客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？</strong></p>
<p>按照常理，在网络正常的情况下，四个报文段发送完后，双方就可以关闭连接进入 CLOSED  状态了，但是网络并不总是可靠的，如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN  报文段，这显然不是我们想要的。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL  的时间，如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL  的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED  状态了。</p>
</blockquote>
<h1 id="数据报文的发送"><a href="#数据报文的发送" class="headerlink" title="数据报文的发送"></a>数据报文的发送</h1><h2 id="发送相关接口"><a href="#发送相关接口" class="headerlink" title="发送相关接口"></a>发送相关接口</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p>send只能用于处理已连接状态的套接字。而sendto可以在调用时，指定目的地址。这样的话，如果套接字已经是连接状态，那么目的地址dest_addr与地址长度就应该为NULL和0，不然就可能会返回错误。sendmsg则比较特殊，无论是要发送的数据还是目的地址，都保存在msg中。其中msg.msg_name和msg.msg_len用于指明目的地址，而msg.msg_iov则用于保存要发送的数据。这三个系统调用都支持设置指示标志位flags。</p>
<p>稍微现代些的系统调用，一般都会拥有或保留一个指示标志参数。通过标志位flags，可以从容地为系统调用增加新功能，并同时兼容老版本。<code>dup、dup2和dup3</code>则是这方面的一个反面典型。在不支持flag的情况下，不得不一再创建新的dup接口，直到dup3加入了对flag的支持为止。</p>
<p>由于socket同时还是文件描述符，所以为文件提供的写操作（如<code>write、writev</code>等），也可以被socket套接字直接调用，在此就不重复叙述了。</p>
<h2 id="数据包从用户空间到内核空间的流程"><a href="#数据包从用户空间到内核空间的流程" class="headerlink" title="数据包从用户空间到内核空间的流程"></a>数据包从用户空间到内核空间的流程</h2><p>send的内核实现代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(sendto, <span class="type">int</span>, fd, <span class="type">void</span> __user *, buff, <span class="type">size_t</span>, len,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>, flags, <span class="keyword">struct</span> sockaddr __user *, addr,</span><br><span class="line">		<span class="type">int</span>, addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_sendto(fd, buff, len, flags, addr, addr_len);</span><br><span class="line">&#125;</span><br><span class="line">SYSCALL_DEFINE4(send, <span class="type">int</span>, fd, <span class="type">void</span> __user *, buff, <span class="type">size_t</span>, len,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_sendto(fd, buff, len, flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __sys_sendto(<span class="type">int</span> fd, <span class="type">void</span> __user *buff, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		 <span class="keyword">struct</span> sockaddr __user *addr,  <span class="type">int</span> addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将用户空间的缓冲区导入到内核空间的 iovec 结构中</span></span><br><span class="line">	err = import_single_range(WRITE, buff, len, &amp;iov, &amp;msg.msg_iter);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(err))</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找文件描述符对应的 socket</span></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化消息头结构</span></span><br><span class="line">	msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">	msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果提供了地址，则将地址从用户空间移动到内核空间</span></span><br><span class="line">	<span class="keyword">if</span> (addr) &#123;</span><br><span class="line">		err = move_addr_to_kernel(addr, addr_len, &amp;address);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_put;</span><br><span class="line">		msg.msg_name = (<span class="keyword">struct</span> sockaddr *)&amp;address;</span><br><span class="line">		msg.msg_namelen = addr_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 socket 是非阻塞的，则设置 MSG_DONTWAIT 标志</span></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">		flags |= MSG_DONTWAIT;</span><br><span class="line">	msg.msg_flags = flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	err = sock_sendmsg(sock, &amp;msg);</span><br><span class="line"></span><br><span class="line">out_put:</span><br><span class="line">	<span class="comment">// 释放 socket 引用</span></span><br><span class="line">	fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里又调用到<code>sock_sendmsg</code>了，从名字上就能感觉到它可能也会被第三个接口sendmsg所调用。下面让我们来验证这个猜想。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(sendmsg, <span class="type">int</span>, fd, <span class="keyword">struct</span> user_msghdr __user *, msg, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_sendmsg(fd, msg, flags, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> __sys_sendmsg(<span class="type">int</span> fd, <span class="keyword">struct</span> user_msghdr __user *msg, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		   <span class="type">bool</span> forbid_cmsg_compat)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fput_needed, err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg_sys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (forbid_cmsg_compat &amp;&amp; (flags &amp; MSG_CMSG_COMPAT))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	err = ___sys_sendmsg(sock, msg, &amp;msg_sys, flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ____sys_sendmsg(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg_sys,</span><br><span class="line">			   <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> used_address *used_address,</span><br><span class="line">			   <span class="type">unsigned</span> <span class="type">int</span> allowed_msghdr_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ctl[<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cmsghdr) + <span class="number">20</span>]</span><br><span class="line">				__aligned(<span class="keyword">sizeof</span>(<span class="type">__kernel_size_t</span>));</span><br><span class="line">	<span class="comment">/* 20 is size of ipv6_pktinfo */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *ctl_buf = ctl;</span><br><span class="line">	<span class="type">int</span> ctl_len;</span><br><span class="line">	<span class="type">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">	err = -ENOBUFS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msg_sys-&gt;msg_controllen &gt; INT_MAX)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	flags |= (msg_sys-&gt;msg_flags &amp; allowed_msghdr_flags);</span><br><span class="line">	ctl_len = msg_sys-&gt;msg_controllen;</span><br><span class="line">	<span class="keyword">if</span> ((MSG_CMSG_COMPAT &amp; flags) &amp;&amp; ctl_len) &#123;</span><br><span class="line">		err =</span><br><span class="line">		    cmsghdr_from_user_compat_to_kern(msg_sys, sock-&gt;sk, ctl,</span><br><span class="line">						     <span class="keyword">sizeof</span>(ctl));</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		ctl_buf = msg_sys-&gt;msg_control;</span><br><span class="line">		ctl_len = msg_sys-&gt;msg_controllen;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctl_len) &#123;</span><br><span class="line">		BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cmsghdr) !=</span><br><span class="line">			     CMSG_ALIGN(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cmsghdr)));</span><br><span class="line">		<span class="keyword">if</span> (ctl_len &gt; <span class="keyword">sizeof</span>(ctl)) &#123;</span><br><span class="line">			ctl_buf = sock_kmalloc(sock-&gt;sk, ctl_len, GFP_KERNEL);</span><br><span class="line">			<span class="keyword">if</span> (ctl_buf == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		err = -EFAULT;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Careful! Before this, msg_sys-&gt;msg_control contains a user pointer.</span></span><br><span class="line"><span class="comment">		 * Afterwards, it will be a kernel pointer. Thus the compiler-assisted</span></span><br><span class="line"><span class="comment">		 * checking falls down on this.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(ctl_buf,</span><br><span class="line">				   (<span class="type">void</span> __user __force *)msg_sys-&gt;msg_control,</span><br><span class="line">				   ctl_len))</span><br><span class="line">			<span class="keyword">goto</span> out_freectl;</span><br><span class="line">		msg_sys-&gt;msg_control = ctl_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	msg_sys-&gt;msg_flags = flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">		msg_sys-&gt;msg_flags |= MSG_DONTWAIT;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If this is sendmmsg() and current destination address is same as</span></span><br><span class="line"><span class="comment">	 * previously succeeded address, omit asking LSM&#x27;s decision.</span></span><br><span class="line"><span class="comment">	 * used_address-&gt;name_len is initialized to UINT_MAX so that the first</span></span><br><span class="line"><span class="comment">	 * destination address never matches.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (used_address &amp;&amp; msg_sys-&gt;msg_name &amp;&amp;</span><br><span class="line">	    used_address-&gt;name_len == msg_sys-&gt;msg_namelen &amp;&amp;</span><br><span class="line">	    !<span class="built_in">memcmp</span>(&amp;used_address-&gt;name, msg_sys-&gt;msg_name,</span><br><span class="line">		    used_address-&gt;name_len)) &#123;</span><br><span class="line">		err = sock_sendmsg_nosec(sock, msg_sys);</span><br><span class="line">		<span class="keyword">goto</span> out_freectl;</span><br><span class="line">	&#125;</span><br><span class="line">	err = sock_sendmsg(sock, msg_sys);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If this is sendmmsg() and sending to current destination address was</span></span><br><span class="line"><span class="comment">	 * successful, remember it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (used_address &amp;&amp; err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		used_address-&gt;name_len = msg_sys-&gt;msg_namelen;</span><br><span class="line">		<span class="keyword">if</span> (msg_sys-&gt;msg_name)</span><br><span class="line">			<span class="built_in">memcpy</span>(&amp;used_address-&gt;name, msg_sys-&gt;msg_name,</span><br><span class="line">			       used_address-&gt;name_len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_freectl:</span><br><span class="line">	<span class="keyword">if</span> (ctl_buf != ctl)</span><br><span class="line">		sock_kfree_s(sock-&gt;sk, ctl_buf, ctl_len);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看完了<code>__sys_sendmsg</code>，我们可以确定，无论是哪个发送数据的系统调用，最终都会调用到<code>sock_sendmsg</code>。下面是<code>sock_sendmsg</code>的相关代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sock_sendmsg</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err = security_socket_sendmsg(sock, msg,</span><br><span class="line">					  msg_data_left(msg));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err ?: sock_sendmsg_nosec(sock, msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sock_sendmsg_nosec</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = INDIRECT_CALL_INET(sock-&gt;ops-&gt;sendmsg, inet6_sendmsg,</span><br><span class="line">				     inet_sendmsg, sock, msg,</span><br><span class="line">				     msg_data_left(msg));</span><br><span class="line">	BUG_ON(ret == -EIOCBQUEUED);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>到此，我们完成了数据包从用户空间到内核空间的流程跟踪。接下来的数据包发送过程，将根据不同的协议，走不同的流程。</p>
<h1 id="数据报文的接收"><a href="#数据报文的接收" class="headerlink" title="数据报文的接收"></a>数据报文的接收</h1><h2 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p>与send类似，recv一般也是面向连接的套接字。原因在于，对于非面向连接的套接字来说，若使用recv接收数据，通过该接口将不能获得发送端的地址，也就是说不知道这个数据是谁发过来的。所以，如果使用者不关心发送端信息，或者该信息可以从数据中获得，那么recv接口同样也可以用于非面向连接的套接字。再来看看recvfrom，它会通过额外的参数src_addr和addrlen，来获得发送方的地址，其中需要注意的是addrlen，它既是输入值又是输出值。最后是recvmsg，它与sendmsg一样，把接收到的数据和地址都保存在了msg中。其中msg.msg_name和msg.msg_len用于保存接收端地址，而msg.msg_iov用于保存接收到的数据。这三个系统调用与对应的发送接口一样，都支持设置标志位flags，都是比较现代的接口设计方法。</p>
<h2 id="数据包从内核空间到用户空间的流程"><a href="#数据包从内核空间到用户空间的流程" class="headerlink" title="数据包从内核空间到用户空间的流程"></a>数据包从内核空间到用户空间的流程</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(recv, <span class="type">int</span>, fd, <span class="type">void</span> __user *, ubuf, <span class="type">size_t</span>, size,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_recvfrom(fd, ubuf, size, flags, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">SYSCALL_DEFINE6(recvfrom, <span class="type">int</span>, fd, <span class="type">void</span> __user *, ubuf, <span class="type">size_t</span>, size,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>, flags, <span class="keyword">struct</span> sockaddr __user *, addr,</span><br><span class="line">		<span class="type">int</span> __user *, addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_recvfrom(fd, ubuf, size, flags, addr, addr_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __sys_recvfrom(<span class="type">int</span> fd, <span class="type">void</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		   <span class="keyword">struct</span> sockaddr __user *addr, <span class="type">int</span> __user *addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">	<span class="type">int</span> err, err2;</span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将用户空间的缓冲区导入到内核空间的 iovec 结构中</span></span><br><span class="line">	err = import_single_range(READ, ubuf, size, &amp;iov, &amp;msg.msg_iter);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(err))</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找文件描述符对应的 socket</span></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化消息头结构</span></span><br><span class="line">	msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果需要返回地址，则设置 msg_name 指向 address</span></span><br><span class="line">	msg.msg_name = addr ? (<span class="keyword">struct</span> sockaddr *)&amp;address : <span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">	msg.msg_iocb = <span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 socket 是非阻塞的，则设置 MSG_DONTWAIT 标志</span></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">		flags |= MSG_DONTWAIT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接收消息</span></span><br><span class="line">	err = sock_recvmsg(sock, &amp;msg, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果接收成功并且需要返回地址</span></span><br><span class="line">	<span class="keyword">if</span> (err &gt;= <span class="number">0</span> &amp;&amp; addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// 将内核空间的地址移动到用户空间</span></span><br><span class="line">		err2 = move_addr_to_user(&amp;address, msg.msg_namelen, addr, addr_len);</span><br><span class="line">		<span class="keyword">if</span> (err2 &lt; <span class="number">0</span>)</span><br><span class="line">			err = err2; <span class="comment">// 如果移动失败，返回错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放 socket 引用</span></span><br><span class="line">	fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sock_recvmsg</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err ?: sock_recvmsg_nosec(sock, msg, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sock_recvmsg_nosec</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg,</span></span><br><span class="line"><span class="params">				     <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> INDIRECT_CALL_INET(sock-&gt;ops-&gt;recvmsg, inet6_recvmsg,</span><br><span class="line">				  inet_recvmsg, sock, msg, msg_data_left(msg),</span><br><span class="line">				  flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>recvmsg</code> 函数最后也会进入<code>sock_recvmsg_nosec</code>，后面的接收流程就要依赖于具体的协议实现了。。</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="连接到建立"><a href="#连接到建立" class="headerlink" title="连接到建立"></a>连接到建立</h2><p>在 Linux 网络编程中，<code>bind</code>、<code>connect</code>、<code>listen</code> 和 <code>accept</code> 是用于网络套接字编程的关键系统调用。它们在服务器和客户端通信中扮演着重要的角色。以下是这些函数的详细用法：</p>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a><code>bind</code> 函数</h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p><code>bind</code> 函数将套接字与特定的IP地址和端口号绑定在一起。</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符，通过 <code>socket()</code> 创建。</li>
<li><code>addr</code>：指向特定协议地址的指针，通常是 <code>struct sockaddr_in</code>、<code>struct sockaddr_in6</code> 或 <code>struct sockaddr_un</code>。</li>
<li><code>addrlen</code>：地址的长度，以字节为单位。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回 0。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(PORT);         <span class="comment">// 指定端口</span></span><br><span class="line">server_addr.sin_addr.s_addr = INADDR_ANY;   <span class="comment">// 服务器上所有可用接口</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure></div>

<h3 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a><code>connect</code> 函数</h3><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p><code>connect</code> 函数用于客户端向服务器发起连接。</p>
<h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符。</li>
<li><code>addr</code>：指向服务器地址的指针。</li>
<li><code>addrlen</code>：地址的长度。</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回 0。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(PORT);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure></div>

<h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a><code>listen</code> 函数</h3><h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><p><code>listen</code> 函数用于将绑定到特定端口的套接字转换为一个被动套接字，以便接受来自客户端的连接请求。</p>
<h4 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符。</li>
<li><code>backlog</code>：等待连接队列的最大长度。</li>
</ul>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回 0。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">listen(sockfd, <span class="number">5</span>);  <span class="comment">// 最大连接数为 5</span></span><br></pre></td></tr></table></figure></div>

<h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a><code>accept</code> 函数</h3><h4 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h4><p><code>accept</code> 函数从连接请求队列中提取下一个连接请求，并为该连接返回一个新的套接字。</p>
<h4 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：监听套接字的文件描述符。</li>
<li><code>addr</code>：用于返回发起连接请求的实体的地址。</li>
<li><code>addrlen</code>：指向地址长度的指针。</li>
</ul>
<h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回一个新的套接字文件描述符（用于与客户端通信）。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"><span class="type">int</span> new_sockfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);</span><br></pre></td></tr></table></figure></div>

<p>使用这些函数，您可以创建一个基本的 TCP 服务器和客户端模型。服务器负责监听和接受客户端连接，而客户端则主动连接到服务器。</p>
<p><code>accept4</code> 是 Linux 特定的系统调用，类似于 <code>accept</code> 函数，但它具有更多的灵活性，因为它允许在接受连接时指定额外的套接字标志。这种功能可以帮助在创建新套接字时避免竞争条件（race condition）或减少系统调用。<code>accept4</code> 是 GNU C Library (glibc) 的一部分，在一些 Unix-like 操作系统上可用。</p>
<h3 id="accept4-函数"><a href="#accept4-函数" class="headerlink" title="accept4 函数"></a><code>accept4</code> 函数</h3><h4 id="用途-4"><a href="#用途-4" class="headerlink" title="用途"></a>用途</h4><p><code>accept4</code> 函数用于从连接请求队列中提取下一个连接请求，并返回一个新的套接字，同时可以指定标志来设置新套接字的特性，比如非阻塞方式或关闭执行标志。</p>
<h4 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept4</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：监听套接字的文件描述符。</li>
<li><code>addr</code>：用于存储发起连接请求的客户端地址（可以为 NULL）。</li>
<li><code>addrlen</code>：指向地址长度的指针，表示 <code>addr</code> 的空间大小，也用于返回实际地址的长度（可以为 NULL）。</li>
<li><code>flags</code>：用于指定新套接字的属性标志，可以是以下标志的组合：<ul>
<li><code>O_NONBLOCK</code>：将套接字设置为非阻塞模式。</li>
<li><code>SOCK_CLOEXEC</code>：设置关闭执行标志（close-on-exec），这对于多线程或 fork&#x2F;exec 模型很有用。</li>
</ul>
</li>
</ul>
<h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回一个新的套接字文件描述符（用于与客户端的通信）。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  <span class="comment">// for O_NONBLOCK</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 accept4 接受连接，并指定非阻塞模式标志</span></span><br><span class="line">    <span class="type">int</span> new_sockfd = accept4(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len, O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (new_sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept4 failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里可以使用 new_sockfd 进行数据通信</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    close(new_sockfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>accept4</code> 提供的特性主要用于优化和简化套接字的使用过程，但在使用时需要检查平台是否支持此函数。</li>
<li>如果你在一个不支持 <code>accept4</code> 的平台工作，可以通过 <code>accept</code> 和再调用 <code>fcntl</code> 来实现类似的功能。</li>
<li>尽管 <code>accept4</code> 对应用程序性能和可靠性有帮助，要确保理解每个标志的影响，合理地组合使用。</li>
</ul>
<h2 id="报文的发送"><a href="#报文的发送" class="headerlink" title="报文的发送"></a>报文的发送</h2><p>在 Linux 网络编程中，<code>send</code>、<code>sendto</code> 和 <code>sendmsg</code> 是用于发送数据的函数。虽然它们具有相似的功能，但每个函数针对不同的场景进行了优化和设计。</p>
<h3 id="send-函数"><a href="#send-函数" class="headerlink" title="send 函数"></a><code>send</code> 函数</h3><h4 id="用途-5"><a href="#用途-5" class="headerlink" title="用途"></a>用途</h4><p><code>send</code> 函数用于通过连接的 TCP 套接字发送数据。</p>
<h4 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符，必须是已连接的套接字。</li>
<li><code>buf</code>：指向待发送数据缓冲区的指针。</li>
<li><code>len</code>：要发送的数据长度。</li>
<li><code>flags</code>：指定传输选项，通常为 0，也可以是以下一个或多个标志的组合：<ul>
<li><code>MSG_DONTWAIT</code>：非阻塞操作。</li>
<li><code>MSG_NOSIGNAL</code>：避免在对等端崩溃的情况下发送 SIGPIPE 信号。</li>
</ul>
</li>
</ul>
<h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回实际发送的字节数。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *message = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">int</span> bytes_sent = send(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="sendto-函数"><a href="#sendto-函数" class="headerlink" title="sendto 函数"></a><code>sendto</code> 函数</h3><h4 id="用途-6"><a href="#用途-6" class="headerlink" title="用途"></a>用途</h4><p><code>sendto</code> 函数用于通过未连接的套接字（如 UDP）发送数据，并允许指定目标地址。</p>
<h4 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符，可以是已连接或未连接的套接字。</li>
<li><code>buf</code>：指向待发送数据缓冲区的指针。</li>
<li><code>len</code>：要发送的数据长度。</li>
<li><code>flags</code>：传输选项，与 <code>send</code> 的类似。</li>
<li><code>dest_addr</code>：指向目标地址的指针。</li>
<li><code>addrlen</code>：目标地址的长度。</li>
</ul>
<h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回实际发送的字节数。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_addr</span>;</span></span><br><span class="line">dest_addr.sin_family = AF_INET;</span><br><span class="line">dest_addr.sin_port = htons(PORT);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;dest_addr.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *message = <span class="string">&quot;Hello, UDP World!&quot;</span>;</span><br><span class="line"><span class="type">int</span> bytes_sent = sendto(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;dest_addr, <span class="keyword">sizeof</span>(dest_addr));</span><br></pre></td></tr></table></figure></div>

<h3 id="sendmsg-函数"><a href="#sendmsg-函数" class="headerlink" title="sendmsg 函数"></a><code>sendmsg</code> 函数</h3><h4 id="用途-7"><a href="#用途-7" class="headerlink" title="用途"></a>用途</h4><p><code>sendmsg</code> 函数是一种高级接口，用于发送带辅助数据的消息，也可以用于原始套接字或发送带有控制信息的数据包，可以用于已连接和未连接的套接字，已连接套接字不需要目标地址。</p>
<h4 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符。</li>
<li><code>msg</code>：指向 <code>msghdr</code> 结构的指针，该结构包含要发送的数据和可选的地址和控制信息。</li>
<li><code>flags</code>：传输选项，与 <code>send</code> 的类似。</li>
</ul>
<h4 id="msghdr-结构"><a href="#msghdr-结构" class="headerlink" title="msghdr 结构"></a><code>msghdr</code> 结构</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>         *msg_name;       <span class="comment">// 目标地址</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">// I/O 向量数组</span></span><br><span class="line">    <span class="type">size_t</span>        msg_iovlen;     <span class="comment">// I/O 向量中的元素数</span></span><br><span class="line">    <span class="type">void</span>         *msg_control;    <span class="comment">// 整体附属数据的开始指针</span></span><br><span class="line">    <span class="type">size_t</span>        msg_controllen; <span class="comment">// 附属数据的大小</span></span><br><span class="line">    <span class="type">int</span>           msg_flags;      <span class="comment">// 消息标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回实际发送的字节数。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line"><span class="type">char</span> *message = <span class="string">&quot;Hello, Advanced World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置消息中的I/O向量</span></span><br><span class="line">iov[<span class="number">0</span>].iov_base = message;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(message);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置msghdr结构</span></span><br><span class="line">msg.msg_name = <span class="literal">NULL</span>;  <span class="comment">// 不指定目标地址</span></span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">msg.msg_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="type">int</span> bytes_sent = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p>这三个函数分别用于在不同的场景中发送数据：<code>send</code> 用于简单的已连接套接字，<code>sendto</code> 用于未连接的套接字，<code>sendmsg</code> 则用于更复杂的消息结构和控制信息。选择合适的函数取决于您的应用程序需求。</p>
<h2 id="报文的接收"><a href="#报文的接收" class="headerlink" title="报文的接收"></a>报文的接收</h2><p>在 Linux 网络编程中，<code>recv</code>、<code>recvfrom</code> 和 <code>recvmsg</code> 是用于接收数据的函数。每个函数都有其特定的用途，根据不同的网络通信需求和场景进行设计。</p>
<h3 id="recv-函数"><a href="#recv-函数" class="headerlink" title="recv 函数"></a><code>recv</code> 函数</h3><h4 id="用途-8"><a href="#用途-8" class="headerlink" title="用途"></a>用途</h4><p><code>recv</code> 函数用于从已连接的套接字接收数据，通常用于 TCP 连接。</p>
<h4 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符，必须是已连接的。</li>
<li><code>buf</code>：指向存储接收数据的缓冲区的指针。</li>
<li><code>len</code>：要接收的最大字节数（缓冲区大小）。</li>
<li><code>flags</code>：指定接收选项，通常为 0，但可以是以下一个或多个标志的组合：<ul>
<li><code>MSG_DONTWAIT</code>：非阻塞操作。</li>
<li><code>MSG_PEEK</code>：查看数据而不将其从队列中移除。</li>
<li><code>MSG_WAITALL</code>：等待完整请求数据到达。</li>
</ul>
</li>
</ul>
<h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回实际接收到的字节数。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> bytes_received = recv(sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="recvfrom-函数"><a href="#recvfrom-函数" class="headerlink" title="recvfrom 函数"></a><code>recvfrom</code> 函数</h3><h4 id="用途-9"><a href="#用途-9" class="headerlink" title="用途"></a>用途</h4><p><code>recvfrom</code> 函数用于从未连接的套接字（如 UDP）接收数据，并可以获取数据来源的地址。</p>
<h4 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符，可以是已连接或未连接的。</li>
<li><code>buf</code>：指向存储接收数据的缓冲区的指针。</li>
<li><code>len</code>：要接收的最大字节数。</li>
<li><code>flags</code>：接收选项，与 <code>recv</code> 的类似。</li>
<li><code>src_addr</code>：指向用于存储源地址的 <code>sockaddr</code> 结构。</li>
<li><code>addrlen</code>：指向 <code>src_addr</code> 的长度，调用后返回实际地址长度。</li>
</ul>
<h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回实际接收到的字节数。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">src_addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(src_addr);</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> bytes_received = recvfrom(sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;src_addr, &amp;addrlen);</span><br></pre></td></tr></table></figure></div>

<h3 id="recvmsg-函数"><a href="#recvmsg-函数" class="headerlink" title="recvmsg 函数"></a><code>recvmsg</code> 函数</h3><h4 id="用途-10"><a href="#用途-10" class="headerlink" title="用途"></a>用途</h4><p><code>recvmsg</code> 提供了一个高级接口，用于接收包含辅助数据的消息，适用于需要处理控制信息或者更复杂协议的场景。</p>
<h4 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>sockfd</code>：套接字文件描述符。</li>
<li><code>msg</code>：指向 <code>msghdr</code> 结构的指针，包含接收的数据和可选控制信息。</li>
<li><code>flags</code>：接收选项，与 <code>recv</code> 的类似。</li>
</ul>
<h4 id="msghdr-结构-1"><a href="#msghdr-结构-1" class="headerlink" title="msghdr 结构"></a><code>msghdr</code> 结构</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>         *msg_name;       <span class="comment">// 存储源地址</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">// I/O 向量数组</span></span><br><span class="line">    <span class="type">size_t</span>        msg_iovlen;     <span class="comment">// 向量的元素数</span></span><br><span class="line">    <span class="type">void</span>         *msg_control;    <span class="comment">// 用于存储辅助数据</span></span><br><span class="line">    <span class="type">size_t</span>        msg_controllen; <span class="comment">// 辅助数据的大小</span></span><br><span class="line">    <span class="type">int</span>           msg_flags;      <span class="comment">// 消息标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回实际接收到的字节数。</li>
<li>失败：返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置接收的数据缓冲区</span></span><br><span class="line">iov[<span class="number">0</span>].iov_base = buffer;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 msghdr 结构</span></span><br><span class="line">msg.msg_name = <span class="literal">NULL</span>;        <span class="comment">// 如果不需要来源地址</span></span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">msg.msg_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 recvmsg</span></span><br><span class="line"><span class="type">int</span> bytes_received = recvmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h2><h3 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h3><h4 id="inet-aton-inet-ntoa-IPv4专用"><a href="#inet-aton-inet-ntoa-IPv4专用" class="headerlink" title="inet_aton &amp; inet_ntoa (IPv4专用)"></a><code>inet_aton</code> &amp; <code>inet_ntoa</code> (IPv4专用)</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>局限</strong>：</p>
<ul>
<li>仅支持IPv4</li>
<li>非线程安全（<code>inet_ntoa</code>使用静态缓冲区）</li>
<li>无错误码返回</li>
</ul>
<p><strong>替代方案</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代协议无关版本</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>示例对比</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式 (不推荐)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">inet_aton(<span class="string">&quot;192.168.1.1&quot;</span>, &amp;addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, inet_ntoa(addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代方式 (线程安全)</span></span><br><span class="line"><span class="type">char</span> str[INET6_ADDRSTRLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">addr6</span>;</span></span><br><span class="line">inet_pton(AF_INET6, <span class="string">&quot;2001:db8::1&quot;</span>, &amp;addr6);</span><br><span class="line">inet_ntop(AF_INET6, &amp;addr6, str, <span class="keyword">sizeof</span>(str));</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h3><h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;  <span class="comment">// 主机到网络(short)</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;   <span class="comment">// 主机到网络(long)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;   <span class="comment">// 网络到主机(short)</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;    <span class="comment">// 网络到主机(long)</span></span><br></pre></td></tr></table></figure></div>

<p><strong>现代扩展</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 64位支持 (Linux 3.10+)</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htobe64</span><span class="params">(<span class="type">uint64_t</span> host_64bits)</span>;  </span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">be64toh</span><span class="params">(<span class="type">uint64_t</span> big_endian_64bits)</span>; <span class="comment">// 大端序转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数转换 (IEEE 754兼容)</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">htonf</span><span class="params">(<span class="type">float</span> host_float)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">htond</span><span class="params">(<span class="type">double</span> host_double)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>最佳实践</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体序列化模板</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Packet</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;    <span class="comment">// = htonl(0xA1B2C3D4)</span></span><br><span class="line">    <span class="type">uint16_t</span> version;  <span class="comment">// = htons(1)</span></span><br><span class="line">    <span class="type">float</span> timestamp;   <span class="comment">// = htonf(get_time())</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="主机与服务查询"><a href="#主机与服务查询" class="headerlink" title="主机与服务查询"></a>主机与服务查询</h3><h4 id="gethostbyname-getservbyname-传统方案"><a href="#gethostbyname-getservbyname-传统方案" class="headerlink" title="gethostbyname &amp; getservbyname (传统方案)"></a><code>gethostbyname</code> &amp; <code>getservbyname</code> (传统方案)</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>缺陷</strong>：</p>
<ul>
<li>同步阻塞操作</li>
<li>无IPv6支持</li>
<li>非线程安全</li>
</ul>
<h4 id="现代替代方案-getaddrinfo"><a href="#现代替代方案-getaddrinfo" class="headerlink" title="现代替代方案 getaddrinfo"></a>现代替代方案 <code>getaddrinfo</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> addrinfo **res)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>高级用法</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步DNS查询 (使用c-ares库)</span></span><br><span class="line">ares_getaddrinfo(channel, <span class="string">&quot;example.com&quot;</span>, <span class="literal">NULL</span>, &amp;hints, callback, arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务发现扩展 (mDNS/DNSSD)</span></span><br><span class="line">avahi_service_resolver_new(...); <span class="comment">// 通过Avahi库实现</span></span><br></pre></td></tr></table></figure></div>

<p><strong>配置示例</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span> =</span> &#123;</span><br><span class="line">    .ai_family = AF_UNSPEC,     <span class="comment">// IPv4/IPv6双栈</span></span><br><span class="line">    .ai_socktype = SOCK_STREAM,</span><br><span class="line">    .ai_flags = AI_V4MAPPED | AI_ADDRCONFIG | AI_CANONNAME</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="接口控制函数"><a href="#接口控制函数" class="headerlink" title="接口控制函数"></a>接口控制函数</h3><h4 id="ioctl-传统控制"><a href="#ioctl-传统控制" class="headerlink" title="ioctl (传统控制)"></a><code>ioctl</code> (传统控制)</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>常见操作</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取接口地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">ioctl(sockfd, SIOCGIFADDR, &amp;ifr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure></div>

<h4 id="现代替代方案-netlink"><a href="#现代替代方案-netlink" class="headerlink" title="现代替代方案 netlink"></a>现代替代方案 <code>netlink</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建netlink套接字</span></span><br><span class="line"><span class="type">int</span> nl_sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取网络接口列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">send(nl_sock, &amp;req, <span class="keyword">sizeof</span>(req), <span class="number">0</span>);</span><br><span class="line">recv(nl_sock, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="高级诊断工具"><a href="#高级诊断工具" class="headerlink" title="高级诊断工具"></a>高级诊断工具</h3><h4 id="getsockopt-setsockopt"><a href="#getsockopt-setsockopt" class="headerlink" title="getsockopt &#x2F; setsockopt"></a><code>getsockopt</code> &#x2F; <code>setsockopt</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">              <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>关键选项</strong>：</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Option</th>
<th>用途</th>
<th>现代扩展</th>
</tr>
</thead>
<tbody><tr>
<td>SOL_SOCKET</td>
<td>SO_TIMESTAMPNS</td>
<td>纳秒级时间戳</td>
<td>SO_TXTIME (时间敏感网络)</td>
</tr>
<tr>
<td>IPPROTO_TCP</td>
<td>TCP_CONGESTION</td>
<td>设置拥塞控制算法</td>
<td>bpf_tcp_ca (eBPF扩展)</td>
</tr>
<tr>
<td>SOL_TLS</td>
<td>TLS_TX</td>
<td>内核TLS卸载</td>
<td>KTLS_FORCE_TX (强制加密)</td>
</tr>
<tr>
<td>IPPROTO_IPV6</td>
<td>IPV6_V6ONLY</td>
<td>禁用IPv4映射</td>
<td>IPV6_BINDV6ONLY</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取TCP诊断信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_info</span> <span class="title">info</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(info);</span><br><span class="line">getsockopt(sockfd, IPPROTO_TCP, TCP_INFO, &amp;info, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置BBR拥塞控制</span></span><br><span class="line"><span class="type">char</span> ca_name[TCP_CA_NAME_MAX] = <span class="string">&quot;bbr&quot;</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_CONGESTION, ca_name, <span class="keyword">sizeof</span>(ca_name));</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="现代辅助函数"><a href="#现代辅助函数" class="headerlink" title="现代辅助函数"></a>现代辅助函数</h3><h4 id="内存安全操作"><a href="#内存安全操作" class="headerlink" title="内存安全操作"></a>内存安全操作</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全字符串复制 (替代strncpy)</span></span><br><span class="line">strlcpy(ifr.ifr_name, <span class="string">&quot;eth0&quot;</span>, <span class="keyword">sizeof</span>(ifr.ifr_name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边界检查地址转换</span></span><br><span class="line"><span class="keyword">if</span> (inet_pton(AF_INET, ip_str, &amp;addr) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="eBPF辅助函数"><a href="#eBPF辅助函数" class="headerlink" title="eBPF辅助函数"></a>eBPF辅助函数</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 套接字过滤 (Linux 4.10+)</span></span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(prog_fd));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流量统计 (XDP)</span></span><br><span class="line">bpf_map_lookup_elem(&amp;stats_map, &amp;key, &amp;value);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="跨平台兼容方案"><a href="#跨平台兼容方案" class="headerlink" title="跨平台兼容方案"></a>跨平台兼容方案</h3><h4 id="可移植地址处理"><a href="#可移植地址处理" class="headerlink" title="可移植地址处理"></a>可移植地址处理</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型安全访问</span></span><br><span class="line"><span class="keyword">if</span> (addr.ss_family == AF_INET) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)&amp;addr;</span><br><span class="line">    <span class="comment">// IPv4处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (addr.ss_family == AF_INET6) &#123;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in6 *s6 = (<span class="keyword">struct</span> sockaddr_in6 *)&amp;addr;</span><br><span class="line">    <span class="comment">// IPv6处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="CMake检测模块"><a href="#CMake检测模块" class="headerlink" title="CMake检测模块"></a>CMake检测模块</h4><div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测现代网络特性</span></span><br><span class="line"><span class="keyword">include</span>(CheckSymbolExists)</span><br><span class="line">check_symbol_exists(accept4 <span class="string">&quot;sys/socket.h&quot;</span> HAVE_ACCEPT4)</span><br><span class="line">check_symbol_exists(TCP_FASTOPEN <span class="string">&quot;netinet/tcp.h&quot;</span> HAVE_TCP_FASTOPEN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件编译</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(myapp PRIVATE</span><br><span class="line">    $&lt;$&lt;BOOL:<span class="variable">$&#123;HAVE_ACCEPT4&#125;</span>&gt;:USE_ACCEPT4&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="工具函数使用指南"><a href="#工具函数使用指南" class="headerlink" title="工具函数使用指南"></a>工具函数使用指南</h2><h3 id="迁移路线图"><a href="#迁移路线图" class="headerlink" title="迁移路线图"></a>迁移路线图</h3><table>
<thead>
<tr>
<th>传统函数</th>
<th>问题</th>
<th>现代替代</th>
</tr>
</thead>
<tbody><tr>
<td><code>inet_aton</code></td>
<td>仅IPv4, 无错误处理</td>
<td><code>inet_pton</code></td>
</tr>
<tr>
<td><code>gethostbyname</code></td>
<td>阻塞, 非线程安全</td>
<td><code>getaddrinfo</code></td>
</tr>
<tr>
<td><code>ioctl</code></td>
<td>接口不一致</td>
<td><code>netlink</code> 或 <code>libmnl</code></td>
</tr>
<tr>
<td><code>getservbyname</code></td>
<td>无协议无关设计</td>
<td><code>getaddrinfo</code></td>
</tr>
</tbody></table>
<h3 id="错误处理模板"><a href="#错误处理模板" class="headerlink" title="错误处理模板"></a>错误处理模板</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inet_pton(AF_INET6, ip_str, &amp;addr6) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EAFNOSUPPORT) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;IPv6 not supported\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;Invalid address format&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="性能关键路径优化"><a href="#性能关键路径优化" class="headerlink" title="性能关键路径优化"></a>性能关键路径优化</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速地址转换 (无错误检查)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">fast_pton</span><span class="params">(<span class="type">uint32_t</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> a,b,c,d;</span><br><span class="line">    <span class="built_in">sscanf</span>(src, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    *dst = (a&lt;&lt;<span class="number">24</span>) | (b&lt;&lt;<span class="number">16</span>) | (c&lt;&lt;<span class="number">8</span>) | d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 零拷贝套接字选项</span></span><br><span class="line"><span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_ZEROCOPY, &amp;val, <span class="keyword">sizeof</span>(val));</span><br></pre></td></tr></table></figure></div>

<hr>
<p>本扩展新增：</p>
<ol>
<li>完整的传统工具函数与现代替代方案对照表</li>
<li>网络命名空间感知的现代函数（如netlink）</li>
<li>eBPF辅助函数的实际集成示例</li>
<li>跨平台兼容性解决方案</li>
<li>CMake构建系统检测模块</li>
<li>性能关键路径优化技巧</li>
<li>详细的错误代码处理模板</li>
</ol>
<p>所有推荐方案均支持IPv6双栈环境，符合现代网络安全和性能要求，适用于云原生、IoT边缘计算及高性能网络中间件开发场景。</p>
<h2 id="现代扩展"><a href="#现代扩展" class="headerlink" title="现代扩展"></a>现代扩展</h2><h3 id="套接字创建与基础配置"><a href="#套接字创建与基础配置" class="headerlink" title="套接字创建与基础配置"></a>套接字创建与基础配置</h3><h4 id="socket函数原型"><a href="#socket函数原型" class="headerlink" title="socket函数原型"></a>socket函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数详解</strong></p>
<p><strong>1. domain（协议域&#x2F;地址族）</strong></p>
<p>指定套接字使用的协议族：</p>
<ul>
<li><strong>AF_INET</strong>: IPv4协议族</li>
<li><strong>AF_INET6</strong>: IPv6协议族</li>
<li><strong>AF_UNIX&#x2F;AF_LOCAL</strong>: 本地通信（Unix域套接字）</li>
<li><strong>AF_NETLINK</strong>: 内核与用户空间通信</li>
</ul>
<p><strong>2. type（套接字类型）</strong></p>
<p>指定套接字的通信类型：</p>
<ul>
<li><strong>SOCK_STREAM</strong>: 流式套接字（TCP）<ul>
<li>提供可靠、有序、双向的字节流</li>
<li>面向连接</li>
<li>保证数据完整性</li>
</ul>
</li>
<li><strong>SOCK_DGRAM</strong>: 数据报套接字（UDP）<ul>
<li>无连接的数据报服务</li>
<li>不保证可靠性和顺序</li>
<li>效率较高</li>
</ul>
</li>
<li><strong>SOCK_RAW</strong>: 原始套接字<ul>
<li>直接访问底层协议</li>
<li>需要root权限</li>
</ul>
</li>
</ul>
<p><strong>3. protocol（协议）</strong></p>
<p>指定具体的传输协议：</p>
<ul>
<li><strong>0</strong>: 自动选择（推荐）</li>
<li><strong>IPPROTO_TCP</strong>: TCP协议</li>
<li><strong>IPPROTO_UDP</strong>: UDP协议</li>
<li><strong>IPPROTO_ICMP</strong>: ICMP协议</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><strong>成功</strong>: 返回非负整数的文件描述符</li>
<li><strong>失败</strong>: 返回-1，并设置errno</li>
</ul>
<h4 id="socket-创建通信端点"><a href="#socket-创建通信端点" class="headerlink" title="socket() - 创建通信端点"></a><code>socket()</code> - 创建通信端点</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>现代扩展</strong>：</p>
<ol>
<li>支持新协议类型：<ul>
<li><code>SOCK_NONBLOCK</code>：创建非阻塞套接字（Linux 2.6.27+）</li>
<li><code>SOCK_CLOEXEC</code>：执行时关闭（close-on-exec）</li>
</ul>
</li>
<li>协议选择：<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建QUIC套接字（Linux 5.10+）</span></span><br><span class="line"><span class="type">int</span> quic_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_QUIC);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>最佳实践</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐创建方式（原子性设置标志）</span></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET6, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p>关于Linux C中socket函数的现代扩展，我来详细介绍一下近年来的重要发展和新特性。</p>
<h4 id="现代socket扩展特性"><a href="#现代socket扩展特性" class="headerlink" title="现代socket扩展特性"></a>现代socket扩展特性</h4><p><strong>1. socket()函数的现代标志位</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代socket创建支持额外标志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type参数可以与以下标志位进行OR操作</span></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>现代标志位:</strong></p>
<ul>
<li><strong>SOCK_CLOEXEC</strong>: 在exec()时自动关闭套接字，避免文件描述符泄漏</li>
<li><strong>SOCK_NONBLOCK</strong>: 创建非阻塞套接字，无需额外调用fcntl()</li>
</ul>
<p><strong>2. 新的协议族支持</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代Linux支持更多协议族</span></span><br><span class="line"><span class="type">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv6支持</span></span><br><span class="line">sockfd = socket(AF_INET6, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Netlink套接字（内核通信）</span></span><br><span class="line">sockfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蓝牙支持</span></span><br><span class="line">sockfd = socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAN总线支持</span></span><br><span class="line">sockfd = socket(AF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包套接字（原始以太网帧）</span></span><br><span class="line">sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br></pre></td></tr></table></figure></div>

<p><strong>3. 高性能I&#x2F;O模型</strong></p>
<p><strong>epoll（Linux特有）</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代用法示例</span></span><br><span class="line"><span class="type">int</span> epfd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"></span><br><span class="line">ev.events = EPOLLIN | EPOLLET;  <span class="comment">// 边缘触发</span></span><br><span class="line">ev.data.fd = sockfd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br></pre></td></tr></table></figure></div>

<p><strong>io_uring（最新异步I&#x2F;O）</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化io_uring</span></span><br><span class="line">io_uring_queue_init(<span class="number">256</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备socket操作</span></span><br><span class="line">sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">io_uring_prep_socket(sqe, AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交并等待完成</span></span><br><span class="line">io_uring_submit(&amp;ring);</span><br><span class="line">io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br></pre></td></tr></table></figure></div>

<p><strong>4. 现代套接字选项</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP_NODELAY - 禁用Nagle算法</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line"><span class="comment">// SO_REUSEPORT - 端口复用（负载均衡）</span></span><br><span class="line"><span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP_FASTOPEN - TCP快速打开</span></span><br><span class="line"><span class="type">int</span> qlen = <span class="number">5</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN, &amp;qlen, <span class="keyword">sizeof</span>(qlen));</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP_USER_TIMEOUT - 用户超时控制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> timeout = <span class="number">30000</span>;  <span class="comment">// 30秒</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_USER_TIMEOUT, &amp;timeout, <span class="keyword">sizeof</span>(timeout));</span><br><span class="line"></span><br><span class="line"><span class="comment">// SO_BUSY_POLL - 忙等待轮询</span></span><br><span class="line"><span class="type">int</span> busy_poll = <span class="number">50</span>;  <span class="comment">// 微秒</span></span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_BUSY_POLL, &amp;busy_poll, <span class="keyword">sizeof</span>(busy_poll));</span><br></pre></td></tr></table></figure></div>

<p><strong>5. 现代网络命名空间支持</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在特定网络命名空间中创建socket</span></span><br><span class="line"><span class="type">int</span> netns_fd = open(<span class="string">&quot;/proc/self/ns/net&quot;</span>, O_RDONLY);</span><br><span class="line">setns(netns_fd, CLONE_NEWNET);</span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>6. 多队列网络接口支持</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SO_REUSEPORT配合多进程/多线程实现负载均衡</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_server_socket</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">  </span><br><span class="line">    bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    listen(sockfd, <span class="number">128</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 多个进程可以绑定同一端口，内核自动负载均衡</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>7. 现代TLS&#x2F;SSL集成</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代SSL/TLS套接字封装</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    SSL *ssl;</span><br><span class="line">    SSL_CTX *ctx;</span><br><span class="line">&#125; <span class="type">secure_socket_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">secure_socket_t</span>* <span class="title function_">create_secure_socket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">secure_socket_t</span> *ssock = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">secure_socket_t</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建基础socket</span></span><br><span class="line">    ssock-&gt;sockfd = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化SSL上下文</span></span><br><span class="line">    SSL_library_init();</span><br><span class="line">    ssock-&gt;ctx = SSL_CTX_new(TLS_client_method());</span><br><span class="line">    ssock-&gt;ssl = SSL_new(ssock-&gt;ctx);</span><br><span class="line">    SSL_set_fd(ssock-&gt;ssl, ssock-&gt;sockfd);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> ssock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>8. 现代错误处理和调试</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代错误处理</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_with_retry</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">int</span> retry_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_retries = <span class="number">3</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (retry_count &lt; max_retries) &#123;</span><br><span class="line">        sockfd = socket(domain, type | SOCK_CLOEXEC, protocol);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (sockfd != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sockfd;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 详细错误分析</span></span><br><span class="line">        <span class="keyword">switch</span> (errno) &#123;</span><br><span class="line">            <span class="keyword">case</span> EMFILE:</span><br><span class="line">            <span class="keyword">case</span> ENFILE:</span><br><span class="line">                <span class="comment">// 文件描述符耗尽，等待后重试</span></span><br><span class="line">                usleep(<span class="number">100000</span>);  <span class="comment">// 100ms</span></span><br><span class="line">                retry_count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EPROTONOSUPPORT:</span><br><span class="line">            <span class="keyword">case</span> EAFNOSUPPORT:</span><br><span class="line">                <span class="comment">// 协议不支持，立即返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>9. 现代网络性能优化</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 零拷贝技术</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendfile - 内核空间直接传输</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// splice - 管道零拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out, <span class="type">loff_t</span> *off_out, </span></span><br><span class="line"><span class="params">               <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MSG_ZEROCOPY - 零拷贝发送</span></span><br><span class="line">send(sockfd, buffer, size, MSG_ZEROCOPY);</span><br></pre></td></tr></table></figure></div>

<p><strong>10. 现代监控和调试工具集成</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sockios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字统计信息获取</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_info</span> <span class="title">info</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> info_len = <span class="keyword">sizeof</span>(info);</span><br><span class="line">getsockopt(sockfd, IPPROTO_TCP, TCP_INFO, &amp;info, &amp;info_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RTT: %u us\n&quot;</span>, info.tcpi_rtt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RTT variance: %u us\n&quot;</span>, info.tcpi_rttvar);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Send MSS: %u\n&quot;</span>, info.tcpi_snd_mss);</span><br></pre></td></tr></table></figure></div>

<h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><h3 id="高性能Web服务器框架"><a href="#高性能Web服务器框架" class="headerlink" title="高性能Web服务器框架"></a>高性能Web服务器框架</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_BACKLOG 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_modern_server</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建支持现代特性的服务器socket</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置现代socket选项</span></span><br><span class="line">    <span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// TCP优化</span></span><br><span class="line">    <span class="type">int</span> nodelay = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;nodelay, <span class="keyword">sizeof</span>(nodelay));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 快速打开</span></span><br><span class="line">    <span class="type">int</span> fastopen = <span class="number">5</span>;</span><br><span class="line">    setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN, &amp;fastopen, <span class="keyword">sizeof</span>(fastopen));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 绑定和监听</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">  </span><br><span class="line">    bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    listen(sockfd, LISTEN_BACKLOG);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这些现代扩展极</p>
<hr>
<h3 id="高级地址管理"><a href="#高级地址管理" class="headerlink" title="高级地址管理"></a>高级地址管理</h3><h4 id="getaddrinfo-协议无关地址解析"><a href="#getaddrinfo-协议无关地址解析" class="headerlink" title="getaddrinfo() - 协议无关地址解析"></a><code>getaddrinfo()</code> - 协议无关地址解析</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> addrinfo **res)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>现代特性</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持DNS-over-HTTPS（glibc 2.34+）</span></span><br><span class="line">setenv(<span class="string">&quot;RES_OPTIONS&quot;</span>, <span class="string">&quot;use-vc trust-ad&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步解析（使用c-ares库）</span></span><br><span class="line">ares_gethostbyname(channel, <span class="string">&quot;example.com&quot;</span>, AF_INET, callback, arg);</span><br></pre></td></tr></table></figure></div>

<p><strong>配置示例</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span> =</span> &#123;</span><br><span class="line">    .ai_family = AF_UNSPEC,</span><br><span class="line">    .ai_socktype = SOCK_STREAM,</span><br><span class="line">    .ai_flags = AI_V4MAPPED | AI_ADDRCONFIG</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="高性能I-O多路复用"><a href="#高性能I-O多路复用" class="headerlink" title="高性能I&#x2F;O多路复用"></a>高性能I&#x2F;O多路复用</h3><h4 id="epoll-API-可扩展事件通知"><a href="#epoll-API-可扩展事件通知" class="headerlink" title="epoll API - 可扩展事件通知"></a><code>epoll</code> API - 可扩展事件通知</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>现代扩展</strong>：</p>
<ol>
<li><strong>边缘触发优化</strong>：<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>多线程优化</strong>：<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用EPOLLEXCLUSIVE避免惊群（Linux 4.5+）</span></span><br><span class="line">event.events |= EPOLLEXCLUSIVE;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="io-uring-下一代异步I-O"><a href="#io-uring-下一代异步I-O" class="headerlink" title="io_uring - 下一代异步I&#x2F;O"></a><code>io_uring</code> - 下一代异步I&#x2F;O</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 零拷贝网络I/O示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line">io_uring_prep_send(sqe, sockfd, buf, len, flags);</span><br><span class="line">io_uring_sqe_set_flags(sqe, IOSQE_ASYNC);</span><br></pre></td></tr></table></figure></div>

<p><strong>性能对比</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>select&#x2F;poll</th>
<th>epoll</th>
<th>io_uring</th>
</tr>
</thead>
<tbody><tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>内存拷贝</td>
<td>全量复制</td>
<td>部分复制</td>
<td>零拷贝</td>
</tr>
<tr>
<td>系统调用</td>
<td>同步</td>
<td>同步</td>
<td>异步提交</td>
</tr>
<tr>
<td>支持操作</td>
<td>基础I&#x2F;O</td>
<td>基础I&#x2F;O</td>
<td>全异步操作</td>
</tr>
</tbody></table>
<hr>
<h3 id="零拷贝数据传输"><a href="#零拷贝数据传输" class="headerlink" title="零拷贝数据传输"></a>零拷贝数据传输</h3><h4 id="splice-内核级管道传输"><a href="#splice-内核级管道传输" class="headerlink" title="splice() - 内核级管道传输"></a><code>splice()</code> - 内核级管道传输</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> fd_out, <span class="type">loff_t</span> *off_out,</span></span><br><span class="line"><span class="params">               <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>现代用例</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络代理数据中转（零拷贝）</span></span><br><span class="line"><span class="keyword">while</span> ((ret = splice(net_in, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">4096</span>, SPLICE_F_MOVE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, net_out, <span class="literal">NULL</span>, ret, SPLICE_F_MOVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="AF-XDP-超高性能数据面"><a href="#AF-XDP-超高性能数据面" class="headerlink" title="AF_XDP - 超高性能数据面"></a><code>AF_XDP</code> - 超高性能数据面</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eBPF/XDP快速路径（Linux 4.18+）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xsk_socket</span> *<span class="title">xsk</span>;</span></span><br><span class="line">xsk_socket__create(&amp;xsk, ifname, queue_id, umem, &amp;rx, &amp;tx, &amp;config);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="协议栈扩展与优化"><a href="#协议栈扩展与优化" class="headerlink" title="协议栈扩展与优化"></a>协议栈扩展与优化</h3><h4 id="TCP-Fast-Open-TFO"><a href="#TCP-Fast-Open-TFO" class="headerlink" title="TCP Fast Open (TFO)"></a>TCP Fast Open (TFO)</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端启用TFO</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT, &amp;(<span class="type">int</span>)&#123;<span class="number">1</span>&#125;, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端设置TFO密钥</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN, &amp;(<span class="type">int</span>)&#123;<span class="number">1024</span>&#125;, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></div>

<h4 id="eBPF-套接字扩展"><a href="#eBPF-套接字扩展" class="headerlink" title="eBPF 套接字扩展"></a>eBPF 套接字扩展</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 附加eBPF程序到套接字（Linux 4.10+）</span></span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(prog_fd));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 典型应用场景：</span></span><br><span class="line"><span class="comment">// 1. 自定义拥塞控制 (bpf_tcp_ca)</span></span><br><span class="line"><span class="comment">// 2. 数据包过滤和监控</span></span><br><span class="line"><span class="comment">// 3. 低延迟传输优化</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="安全增强函数"><a href="#安全增强函数" class="headerlink" title="安全增强函数"></a>安全增强函数</h3><h4 id="TLS-1-3-套接字扩展"><a href="#TLS-1-3-套接字扩展" class="headerlink" title="TLS 1.3 套接字扩展"></a><code>TLS 1.3</code> 套接字扩展</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用OpenSSL实现KTLS（内核TLS，Linux 4.13+）</span></span><br><span class="line">setsockopt(sockfd, SOL_TCP, TCP_ULP, <span class="string">&quot;tls&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;tls&quot;</span>));</span><br><span class="line">setsockopt(sockfd, SOL_TLS, TLS_TX, &amp;crypto_info, <span class="keyword">sizeof</span>(crypto_info));</span><br></pre></td></tr></table></figure></div>

<h4 id="量子安全加密"><a href="#量子安全加密" class="headerlink" title="量子安全加密"></a>量子安全加密</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后量子加密支持（OpenSSL 3.0+）</span></span><br><span class="line">SSL_CTX_set_ciphersuites(ctx, <span class="string">&quot;TLS_AES_256_GCM_SHA384:KYBER-512-R3&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="诊断与调试工具"><a href="#诊断与调试工具" class="headerlink" title="诊断与调试工具"></a>诊断与调试工具</h3><h4 id="getsockopt-扩展"><a href="#getsockopt-扩展" class="headerlink" title="getsockopt 扩展"></a><code>getsockopt</code> 扩展</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取TCP诊断信息（Linux 4.17+）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_info</span> <span class="title">info</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(info);</span><br><span class="line">getsockopt(sockfd, IPPROTO_TCP, TCP_INFO, &amp;info, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键指标：</span></span><br><span class="line"><span class="comment">// tcpi_rtt - RTT微秒数</span></span><br><span class="line"><span class="comment">// tcpi_bytes_acked - 已确认字节数</span></span><br><span class="line"><span class="comment">// tcpi_snd_cwnd - 拥塞窗口大小</span></span><br></pre></td></tr></table></figure></div>

<h4 id="BPF-PERF-OUTPUT-跟踪"><a href="#BPF-PERF-OUTPUT-跟踪" class="headerlink" title="BPF_PERF_OUTPUT 跟踪"></a><code>BPF_PERF_OUTPUT</code> 跟踪</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eBPF实时流量监控</span></span><br><span class="line">bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;data, <span class="keyword">sizeof</span>(data));</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="现代网络编程最佳实践"><a href="#现代网络编程最佳实践" class="headerlink" title="现代网络编程最佳实践"></a>现代网络编程最佳实践</h2><ol>
<li><p><strong>协议无关设计</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">addr</span>;</span> <span class="comment">// 同时支持IPv4/IPv6</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>零拷贝架构</strong>：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[网卡DMA] --&gt;|XDP| B[eBPF程序]</span><br><span class="line">B --&gt;|AF_XDP| C[用户空间]</span><br><span class="line">C --&gt;|io_uring| D[存储/网络]</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>安全基线配置</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代安全加固</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_SYNCNT, &amp;(<span class="type">int</span>)&#123;<span class="number">3</span>&#125;, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// SYN重试</span></span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE, <span class="string">&quot;eth0&quot;</span>, <span class="number">5</span>); <span class="comment">// 接口绑定</span></span><br><span class="line"><span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_TCP, TCP_FASTOPEN, &amp;val, <span class="keyword">sizeof</span>(val)); <span class="comment">// TFO</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>云原生支持</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kubernetes环境优化</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_REPAIR, &amp;(<span class="type">int</span>)&#123;<span class="number">1</span>&#125;, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 连接迁移</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>
<p>这份总结新增了：</p>
<ol>
<li>现代Linux内核特性（io_uring, AF_XDP, eBPF）</li>
<li>云原生和量子安全扩展</li>
<li>零拷贝架构实现细节</li>
<li>性能优化配置参数</li>
<li>可视化架构图（Mermaid语法）</li>
<li>安全加固最佳实践</li>
</ol>
<p>所有代码示例均基于Linux 5.10+内核和glibc 2.35+环境，适用于现代分布式系统和云基础设施开发。</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Linux环境编程与内核之网络通信</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2025-02-06 14:49:47</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-07-08 16:31:59
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2025/02/06/Linux环境编程与内核之网络通信/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/02/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8F%92%E6%A1%A9%E4%B8%8E%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">二进制插桩与污点分析</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Linux环境编程与内核之进程间通信</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Linux环境编程与内核之网络通信</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E8%B7%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-text">网路连接的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#socket%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">socket文件描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9AIP%E5%9C%B0%E5%9D%80"><span class="nav-text">绑定IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bind%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">bind的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">bind 源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">客户端连接过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#connect-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">connect 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connect-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">connect 源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">服务端连接过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#listen-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">listen 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listen-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">listen 源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">accept 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">accept 源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="nav-text">TCP 三次握手的实现分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="nav-text">TCP 四次挥手的实现分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E7%9A%84%E5%8F%91%E9%80%81"><span class="nav-text">数据报文的发送</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3"><span class="nav-text">发送相关接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BB%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%88%B0%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-text">数据包从用户空间到内核空间的流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E7%9A%84%E6%8E%A5%E6%94%B6"><span class="nav-text">数据报文的接收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">系统调用接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BB%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%88%B0%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-text">数据包从内核空间到用户空间的流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%BB%BA%E7%AB%8B"><span class="nav-text">连接到建立</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bind-%E5%87%BD%E6%95%B0"><span class="nav-text">bind 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connect-%E5%87%BD%E6%95%B0"><span class="nav-text">connect 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listen-%E5%87%BD%E6%95%B0"><span class="nav-text">listen 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept-%E5%87%BD%E6%95%B0"><span class="nav-text">accept 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept4-%E5%87%BD%E6%95%B0"><span class="nav-text">accept4 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E7%9A%84%E5%8F%91%E9%80%81"><span class="nav-text">报文的发送</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#send-%E5%87%BD%E6%95%B0"><span class="nav-text">send 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendto-%E5%87%BD%E6%95%B0"><span class="nav-text">sendto 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendmsg-%E5%87%BD%E6%95%B0"><span class="nav-text">sendmsg 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E7%9A%84%E6%8E%A5%E6%94%B6"><span class="nav-text">报文的接收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#recv-%E5%87%BD%E6%95%B0"><span class="nav-text">recv 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recvfrom-%E5%87%BD%E6%95%B0"><span class="nav-text">recvfrom 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recvmsg-%E5%87%BD%E6%95%B0"><span class="nav-text">recvmsg 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Utils"><span class="nav-text">Utils</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-text">地址转换函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-text">字节序转换函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E6%9F%A5%E8%AF%A2"><span class="nav-text">主机与服务查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="nav-text">接口控制函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7"><span class="nav-text">高级诊断工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-text">现代辅助函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%96%B9%E6%A1%88"><span class="nav-text">跨平台兼容方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="nav-text">工具函数使用指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%81%E7%A7%BB%E8%B7%AF%E7%BA%BF%E5%9B%BE"><span class="nav-text">迁移路线图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF"><span class="nav-text">错误处理模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96"><span class="nav-text">性能关键路径优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E6%89%A9%E5%B1%95"><span class="nav-text">现代扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="nav-text">套接字创建与基础配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">实际应用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BDWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6"><span class="nav-text">高性能Web服务器框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86"><span class="nav-text">高级地址管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BDI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">高性能I&#x2F;O多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-text">零拷贝数据传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%89%A9%E5%B1%95%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-text">协议栈扩展与优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%87%BD%E6%95%B0"><span class="nav-text">安全增强函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-text">诊断与调试工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">现代网络编程最佳实践</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        138 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.4</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>