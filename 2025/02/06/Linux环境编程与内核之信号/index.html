<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2025/02/06/linux环境编程与内核之信号/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="信号概念信号是一种软件中断，用来处理异步事件。内核递送这些异步事件到某个进程，告诉进程某个特殊事件发生了。这些异步事件，可能来自硬件，比如访问了非法的内存地址，或者除以0了；可能来自用户的输入，比如shell终端上用户在键盘上敲击了Ctrl+C；还可能来自另一个进程，甚至有些来自进程自身。信号的本质是一种进程间的通信，一个进程向另一个进程发送信号，内核至少传递了信号值这个字段。实际上，通信的内容不">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux环境编程与内核之信号">
<meta property="og:url" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="信号概念信号是一种软件中断，用来处理异步事件。内核递送这些异步事件到某个进程，告诉进程某个特殊事件发生了。这些异步事件，可能来自硬件，比如访问了非法的内存地址，或者除以0了；可能来自用户的输入，比如shell终端上用户在键盘上敲击了Ctrl+C；还可能来自另一个进程，甚至有些来自进程自身。信号的本质是一种进程间的通信，一个进程向另一个进程发送信号，内核至少传递了信号值这个字段。实际上，通信的内容不">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_191.jpg">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_195.jpg">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_196.jpg">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_197.jpg">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_198.jpg">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_199.jpg">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_200.jpg">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_202.jpg">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250212170614283.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250212170648929.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250212170733502.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213142446681.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213144648616.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213150039270.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213151657770.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213152122134.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213152532415.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213152708485.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214104854283.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214111245372.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214112042190.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214113829908.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214114137018.png">
<meta property="og:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214114215988.png">
<meta property="article:published_time" content="2025-02-06T06:48:59.000Z">
<meta property="article:modified_time" content="2025-03-17T05:15:16.956Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_191.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            Linux环境编程与内核之信号 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">123</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Linux环境编程与内核之信号</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-02-06 14:48:59</span>
        <span class="mobile">2025-02-06 14:48:59</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-03-17 13:15:16</span>
            <span class="mobile">2025-03-17 13:15:16</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h1><p>信号是一种软件中断，用来处理异步事件。内核递送这些异步事件到某个进程，告诉进程某个特殊事件发生了。这些异步事件，可能来自硬件，比如访问了非法的内存地址，或者除以0了；可能来自用户的输入，比如shell终端上用户在键盘上敲击了Ctrl+C；还可能来自另一个进程，甚至有些来自进程自身。信号的本质是一种进程间的通信，一个进程向另一个进程发送信号，内核至少传递了信号值这个字段。实际上，通信的内容不止是信号值。信号机制是Unix家族里一个古老的通信机制。传统的信号机制有一些弊端，更为严重的是，信号处理函数的执行流和正常的执行流同时存在，给编程带来了很多的麻烦和困扰，一不小心就可能掉入陷阱。</p>
<h1 id="信号的完整生命周期"><a href="#信号的完整生命周期" class="headerlink" title="信号的完整生命周期"></a>信号的完整生命周期</h1><p>前文提到过，信号的本质是一种进程间的通信。进程之间约定好：如果发生了某件事情T（trigger），就向目标进程（destination process）发送某特定信号X，而目标进程看到X，就意识到T事件发生了，目标进程就会执行相应的动作A（action）。</p>
<p>接下来以配置文件改变为例，来描述整个过程。很多应用都有配置文件，如果配置文件发生改变，需要通知进程重新加载配置。一般而言，程序会默认采用SIGHUP信号来通知目标进程重新加载配置文件。目标进程首先约定，只要收到SIGHUP，就执行重新加载配置文件的动作。这个行为称为信号的安装（installation），或者信号处理函数的注册。安装好了之后，因为信号是异步事件，不知道何时会发生，所以目标进程依然正常地干自己的事情。某年某月的某一天，管理员突然改变了配置文件，想通知这个目标进程，于是就向目标进程发送了信号。他可能在终端执行了kill-SIGHUP命令，也可能调用了C的API，不管怎样，信号产生了。这时候，Linux内核收到了产生的信号，然后就在目标进程的进程描述符里记录了一笔：收到信号SIGHUP一枚。Linux内核会在适当的时机，将信号递送（deliver）给进程。在内核收到信号，但是还没有递送给目标进程的这一段时间里，信号处于挂起状态，被称为挂起（pending）信号，也称为未决信号。内核将信号递送给进程，进程就会暂停当前的控制流，转而去执行信号处理函数。这就是一个信号的完整生命周期。</p>
<p>一个典型的信号会按照上面所述的流程来处理，但是实际情况要复杂得多，还有很多场景需要考虑，比如：</p>
<ul>
<li>目标进程正在执行关键代码，不能被信号中断，需要阻塞某些信号，那么在这期间，信号就不允许被递送到进程，直到目标进程解除阻塞。</li>
<li>内核发现同一个信号已经存在，那么它该如何处理这种重复的信号，排队还是丢弃？</li>
<li>内核递送信号的时候，发现已有多个不同的信号被挂起，那它应该优先递送哪个信号？</li>
<li>对于多线程的进程，如果向该进程发送信号，应该由哪个线程来负责响应？</li>
</ul>
<h1 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h1><p>作为进程间通信的一种手段，进程之间可以互相发送信号，然而发给进程的信号，通常源于内核，包括：</p>
<ul>
<li>硬件异常。</li>
<li>终端相关的信号。</li>
<li>软件事件相关的信号。</li>
</ul>
<h2 id="硬件异常"><a href="#硬件异常" class="headerlink" title="硬件异常"></a>硬件异常</h2><p>硬件检测到了错误并通知内核，由内核发送相应的信号给相关进程。和硬件异常相关的信号见表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_191.jpg"
                      alt="epub_831302_191"
                ></p>
<p>常见的能触发<code>SIGBUS</code>信号的场景有：</p>
<ul>
<li>变量地址未对齐：很多架构访问数据时有对齐的要求。比如int型变量占用4个字节，因此架构要求int变量的地址必须为4字节对齐，否则就会触发SIGBUS信号。</li>
<li>mmap映射文件：使用mmap将文件映射入内存，如果文件大小被其他进程截短，那么在访问文件大小以外的内存时，会触发SIGBUS信号。</li>
</ul>
<p>虽然<code>SIGFPE</code>的后缀FPE是浮点异常（Float Point Exception）的含义，但是该异常并不限于浮点运算，常见的算术运算错误也会引发<code>SIGFPE</code>信号。最常见的就是“整数除以0”的例子。<code>SIGILL</code>的含义是非法指令（illegal instruction）。一般表示进程执行了错误的机器指令。</p>
<p><code>SIGSEGV</code>是所有C程序员的噩梦。没经历几个刻骨铭心的段错误，很难成长为合格的C程序员。由于C语言可以直接操作指针，就像时常行走在河边的顽童很难避免湿鞋一样，程序员很难避免段错误，没有经验的程序员更是如此。常见的情况有：</p>
<ul>
<li>访问未初始化的指针或NULL指针指向的地址。</li>
<li>进程企图在用户态访问内核部分的地址。</li>
<li>进程尝试去修改只读的内存地址。</li>
</ul>
<p>这四种硬件异常，一般是由程序自身引发的，不是由其他进程发送的信号引发的，并且这些异常都比较致命，以至于进程无法继续下去。所以这些信号产生之后，会立刻递送给进程。默认情况下，这四种信号都会使进程终止，并且产生core dump文件以供调试。对于这些信号，进程既不能忽略，也不能阻塞。</p>
<h2 id="终端相关的信号"><a href="#终端相关的信号" class="headerlink" title="终端相关的信号"></a>终端相关的信号</h2><p>对于Linux程序员而言，终端操作是免不了的。终端有很多的设置，可以通过执行如下指令来查看：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="built_in">stty</span> -a</span><br><span class="line">speed 38400 baud; rows 33; columns 211; line = 0;</span><br><span class="line">intr = ^C; quit = ^\; erase = ^?; <span class="built_in">kill</span> = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;</span><br><span class="line">-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts</span><br><span class="line">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel iutf8</span><br><span class="line">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class="line">isig icanon iexten <span class="built_in">echo</span> echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc</span><br></pre></td></tr></table></figure></div>

<p>很重要的是，终端定义了如下几种信号生成字符：</p>
<ul>
<li>Ctrl+C：产生<code>SIGINT</code>信号。</li>
<li>Ctrl+\：产生<code>SIGQUIT</code>信号。</li>
<li>Ctrl+Z：产生<code>SIGTSTP</code>信号。</li>
</ul>
<p>键入这些信号生成字符，相当于向前台进程组发送了对应的信号。</p>
<p>另一个和终端关系比较密切的信号是<code>SIGHUP</code>信号。很多程序员都遇到过这种问题：使用ssh登录到远程的Linux服务器，执行比较耗时的操作（如编译项目代码），却因为网络不稳定，或者需要关机回家，ssh连接被断开，最终导致操作中途被放弃而失败。之所以会如此，是因为一个控制进程在失去其终端之后，内核会负责向其发送一个SIGHUP信号。在登录会话中，shell通常是终端的控制进程，控制进程收到SIGHUP信号后，会引发如下的连锁反应。shell收到SIGHUP后会终止，但是在终止之前，会向由shell创建的前台进程组和后台进程组发送SIGHUP信号，为了防止处于停止状态的任务接收不到SIGHUP信号，通常会在SIGHUP信号之后，发送SIGCONT信号，唤醒处于停止状态的任务。前台进程组和后台进程组的进程收到SIGHUP信号，默认的行为是终止进程，这也是前面提到的耗时任务会中途失败的原因。注意，单纯地将命令放入后台执行（通过&amp;符号，如下所示），并不能摆脱被SIGHUP信号追杀的命运。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &amp;</span><br></pre></td></tr></table></figure></div>

<p>那么如何让进程在后台稳定地执行而不受终端连接断开的影响呢？可以采用如下方法。</p>
<p><strong>1.nohup</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure></div>

<p>标准输入会重定向到<code>/dev/null</code>，标准输出和标准错误会重定向到<code>nohup.out</code>，如果无权限写入当前目录下的nohup.out，则会写入home目录下的nohup.out。nohup仅仅是使启动的进程不再响应SIGHUP信号。</p>
<p><strong>2.setsid</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsid command</span><br></pre></td></tr></table></figure></div>

<p>这种方式和nohup的原理不太一样。nohup仅仅是使启动的进程不再响应SIGHUP信号，但是setsid则完全不属于shell所在的会话了，并且其父进程也已经不是shell而是init进程了。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ <span class="built_in">nohup</span> <span class="built_in">sleep</span> 200 &amp;</span><br><span class="line">[1] 11686</span><br><span class="line"><span class="built_in">nohup</span>: 忽略输入并把输出追加到<span class="string">&quot;nohup.out&quot;</span></span><br><span class="line">manu@manu-hacks:~$ ps -o cmd,pid,ppid,pgid,sid,etime</span><br><span class="line">CMD                           PID  PPID  PGID   SID     ELAPSED</span><br><span class="line">-bash                       11365 11364 11365 11365       03:59</span><br><span class="line"><span class="built_in">sleep</span> 200                   11686 11365 11686 11365       00:30</span><br><span class="line">ps -o cmd,pid,ppid,pgid,sid 11750 11365 11750 11365       00:00</span><br><span class="line">manu@manu-hacks:~$ setsid <span class="built_in">sleep</span> 300 &amp;</span><br><span class="line">[1] 11910</span><br><span class="line">[1]+  已完成               setsid <span class="built_in">sleep</span> 300</span><br><span class="line">manu@manu-hacks:~$ ps -p 11912 -o cmd,pid,ppid,pgid,sid,etime</span><br><span class="line">CMD                           PID  PPID  PGID   SID     ELAPSED</span><br><span class="line"><span class="built_in">sleep</span> 300                   11912     1 11912 11912       00:48</span><br></pre></td></tr></table></figure></div>

<p><strong>3.disown</strong></p>
<p>启动命令时，忘记了使用nohup或setsid，可还有办法亡羊补牢？答案是使用作业控制里面的disown，方法如下：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ <span class="built_in">sleep</span> 1004 &amp;</span><br><span class="line">[1] 13861</span><br><span class="line">manu@manu-hacks:~$ <span class="built_in">jobs</span> -l</span><br><span class="line">[1]+ 13861 运行中               <span class="built_in">sleep</span> 1004 &amp;</span><br><span class="line">manu@manu-hacks:~$ <span class="built_in">disown</span> %1</span><br><span class="line">manu@manu-hacks:~$ <span class="built_in">jobs</span> –l</span><br><span class="line">manu@manu-hacks:~$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 使用disown之后，shell退出时，就不会向这些进程发送SIGHUP信号了。在另一个终端上，仍然可以看到sleep 1004在运行：</span></span><br><span class="line">manu@manu-hacks:~$ ps -ef|grep <span class="built_in">sleep</span></span><br><span class="line">manu     13861     1  0 12:42 ?        00:00:00 <span class="built_in">sleep</span> 1004</span><br></pre></td></tr></table></figure></div>

<p>当然，还有其他的方法可以做到这点，如screen等。</p>
<h2 id="软件事件相关的信号"><a href="#软件事件相关的信号" class="headerlink" title="软件事件相关的信号"></a>软件事件相关的信号</h2><p>软件事件触发信号产生的情况也比较多：</p>
<ul>
<li>子进程退出，内核可能会向父进程发送SIGCHLD信号。</li>
<li>父进程退出，内核可能会给子进程发送信号。</li>
<li>定时器到期，给进程发送信号。</li>
</ul>
<p>与子进程退出向父进程发送信号相反，有时候，进程希望父进程退出时向自己发送信号，从而可以得知父进程的退出事件。Linux也提供了这种机制。每一个进程的进程描述符<code>task_struct</code>中都存在如下成员变量：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pdeath_signal;  <span class="comment">/*  The signal sent when the parent dies  */</span></span><br></pre></td></tr></table></figure></div>

<p>如果父进程退出，子进程希望收到通知，那么子进程可以通过执行如下代码来做到：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_PDEATHSIG, sig);</span><br></pre></td></tr></table></figure></div>

<p>父进程退出时，会遍历其子进程，发现有子进程很关心自己的退出，就会向该子进程发送子进程希望收到的信号。很多定时器相关的函数，背后都牵扯到信号，具体见表:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_195.jpg"
                      alt="epub_831302_195"
                ></p>
<h1 id="信号的默认处理函数"><a href="#信号的默认处理函数" class="headerlink" title="信号的默认处理函数"></a>信号的默认处理函数</h1><p>从上一节可以看出，信号产生的源头有很多。那么内核将信号递送给进程后，进程会执行什么操作呢？很多信号尤其是传统的信号，都会有默认的信号处理方式。如果我们不改变信号的处理函数，那么收到信号之后，就会执行默认的操作。信号的默认操作有以下几种：</p>
<ul>
<li>**显式地忽略信号(ignore)**：即内核将会丢弃该信号，信号不会对目标进程产生任何影响。</li>
<li>**终止进程(terminate)**：很多信号的默认处理是终止进程，即将进程杀死。</li>
<li>**生成核心转储文件并终止进程(core)**：进程被杀死，并且产生核心转储文件。核心转储文件记录了进程死亡现场的信息。用户可以使用核心转储文件来调试，分析进程死亡的原因。</li>
<li>**停止进程(stop)**：停止进程不同于终止进程，终止进程是进程已经死亡，但是停止进程仅仅是使进程暂停，将进程的状态设置成<code>TASK_STOPPED</code>，一旦收到恢复执行的信号，进程还可以继续执行。</li>
<li>**恢复进程的执行(continue)**：和停止进程相对应，某些信号可以使进程恢复执行。</li>
</ul>
<p>事实上，根据信号的默认操作，可以将传统信号分成5派，具体见表:</p>
<p><strong>ignore</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_196.jpg"
                      alt="epub_831302_196"
                ></p>
<p><strong>terminate</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_197.jpg"
                      alt="epub_831302_197"
                ></p>
<p><strong>core</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_198.jpg"
                      alt="epub_831302_198"
                ></p>
<p><strong>stop</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_199.jpg"
                      alt="epub_831302_199"
                ></p>
<p><strong>continue</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_200.jpg"
                      alt="epub_831302_200"
                ></p>
<p>信号的这些默认行为是非常有用的。比如停止行为和恢复执行。系统可能有一些备份的工作，这些工作优先级并不高，但是却消耗了大量的I&#x2F;O资源，甚至是CPU资源（比如需要先压缩再备份）。这样的工作一般是在夜深人静，业务稀少的时候进行的。在业务比较繁忙的情况下，如果备份工作还在进行，则可能会影响到业务。这时候停止和恢复就非常有用了。在业务繁忙之前，可以通过SIGSTOP信号将备份进程暂停，在几乎没有什么业务的时候，通过SIGCONT信号使备份进程恢复执行。</p>
<p>很多信号产生核心转储文件也是非常有意义的。一般而言，程序出错才会导致SIGSEGV、SIGBUS、SIGFPE、SIGILL及SIGABRT等信号的产生。生成的核心转储文件保留了进程死亡的现场，提供了大量的信息供程序员调试、分析错误产生的原因。核心转储文件的作用有点类似于航空中的黑盒子，可以帮助程序员还原事故现场，找到程序漏洞。</p>
<p>很多情况下，默认的信号处理函数，可能并不能满足实际的需要，这时需要修改信号的信号处理函数。信号发生时，不执行默认的信号处理函数，改而执行用户自定义的信号处理函数。为信号指定新的信号处理函数的动作，被称为信号的安装。glibc提供了signal函数和sigaction函数来完成信号的安装。signal出现得比较早，接口也比较简单，sigaction则提供了精确的控制。</p>
<h1 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h1><p>在Linux的shell终端，执行kill -l，可以看到所有的信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kill -l       </span><br><span class="line">HUP INT QUIT ILL TRAP IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS</span><br><span class="line"> </span><br><span class="line"> <span class="number">1</span>) SIGHUP      <span class="number">2</span>) SIGINT         <span class="number">3</span>) SIGQUIT        <span class="number">4</span>) SIGILL          <span class="number">5</span>) SIGTRAP</span><br><span class="line"> <span class="number">6</span>) SIGABRT     <span class="number">7</span>) SIGBUS         <span class="number">8</span>) SIGFPE         <span class="number">9</span>) SIGKILL        <span class="number">10</span>) SIGUSR1</span><br><span class="line"><span class="number">11</span>) SIGSEGV    <span class="number">12</span>) SIGUSR2       <span class="number">13</span>) SIGPIPE       <span class="number">14</span>) SIGALRM        <span class="number">15</span>) SIGTERM</span><br><span class="line"><span class="number">16</span>) SIGSTKFLT  <span class="number">17</span>) SIGCHLD       <span class="number">18</span>) SIGCONT       <span class="number">19</span>) SIGSTOP        <span class="number">20</span>) SIGTSTP</span><br><span class="line"><span class="number">21</span>) SIGTTIN    <span class="number">22</span>) SIGTTOU       <span class="number">23</span>) SIGURG        <span class="number">24</span>) SIGXCPU        <span class="number">25</span>) SIGXFSZ</span><br><span class="line"><span class="number">26</span>) SIGVTALRM  <span class="number">27</span>) SIGPROF       <span class="number">28</span>) SIGWINCH      <span class="number">29</span>) SIGIO          <span class="number">30</span>) SIGPWR</span><br><span class="line"><span class="number">31</span>) SIGSYS      <span class="number">34</span>) SIGRTMIN     <span class="number">35</span>) SIGRTMIN+<span class="number">1</span>   <span class="number">36</span>) SIGRTMIN+<span class="number">2</span>  <span class="number">37</span>) SIGRTMIN+<span class="number">3</span></span><br><span class="line"><span class="number">38</span>) SIGRTMIN+<span class="number">4</span>  <span class="number">39</span>) SIGRTMIN+<span class="number">5</span>   <span class="number">40</span>) SIGRTMIN+<span class="number">6</span>   <span class="number">41</span>) SIGRTMIN+<span class="number">7</span>  <span class="number">42</span>) SIGRTMIN+<span class="number">8</span></span><br><span class="line"><span class="number">43</span>) SIGRTMIN+<span class="number">9</span>  <span class="number">44</span>) SIGRTMIN+<span class="number">10</span>  <span class="number">45</span>) SIGRTMIN+<span class="number">11</span>  <span class="number">46</span>) SIGRTMIN+<span class="number">12</span> <span class="number">47</span>) SIGRTMIN+<span class="number">13</span></span><br><span class="line"><span class="number">48</span>) SIGRTMIN+<span class="number">14</span> <span class="number">49</span>) SIGRTMIN+<span class="number">15</span>  <span class="number">50</span>) SIGRTMAX<span class="number">-14</span>  <span class="number">51</span>) SIGRTMAX<span class="number">-13</span> <span class="number">52</span>) SIGRTMAX<span class="number">-12</span></span><br><span class="line"><span class="number">53</span>) SIGRTMAX<span class="number">-11</span> <span class="number">54</span>) SIGRTMAX<span class="number">-10</span>  <span class="number">55</span>) SIGRTMAX<span class="number">-9</span>   <span class="number">56</span>) SIGRTMAX<span class="number">-8</span>  <span class="number">57</span>) SIGRTMAX<span class="number">-7</span></span><br><span class="line"><span class="number">58</span>) SIGRTMAX<span class="number">-6</span>  <span class="number">59</span>) SIGRTMAX<span class="number">-5</span>   <span class="number">60</span>) SIGRTMAX<span class="number">-4</span>   <span class="number">61</span>) SIGRTMAX<span class="number">-3</span>  <span class="number">62</span>) SIGRTMAX<span class="number">-2</span></span><br><span class="line"><span class="number">63</span>) SIGRTMAX<span class="number">-1</span>  <span class="number">64</span>) SIGRTMAX</span><br></pre></td></tr></table></figure></div>

<p>这些信号可以分成两类：</p>
<ul>
<li>可靠信号。</li>
<li>不可靠信号。</li>
</ul>
<p>信号值在[1，31]之间的所有信号，都被称为不可靠信号；在[SIGRTMIN，SIGRTMAX]之间的信号，被称为可靠信号。不可靠信号是从传统的Unix继承而来的。早期Unix系统信号的机制并不完备，在实践过程中暴露了很多弊端，因此把这些早期出现的信号值在[1，31]之间的信号称之为不可靠信号。所谓不可靠，指的是发送的信号，内核不一定能递送给目标进程，信号可能会丢失。随着时间的流逝，人们意识到原有的信号机制存在弊端。但是[1，31]之间的信号存在已久，在很多应用中被广泛使用，出于兼容性的考虑，不能改变这些信号的行为模式，所以只能新增信号。新增的信号就是我们今天看到的在[SIGRTMIN，SIGRTMAX]范围内的信号，它们被称为可靠信号。</p>
<p>所谓不可靠，指的是发送的信号，内核不一定能递送给目标进程，信号可能会丢失。信号的可靠与否，完全取决于信号的值，而与采用哪种方式安装或发送无关。根本差异在于收到信号后，内核有不同的处理方式。</p>
<p>对于不可靠信号，内核用位图来记录该信号是否处于挂起状态。如果收到某不可靠信号，内核发现已经存在该信号处于未决状态，就会简单地丢弃该信号。因此发送不可靠信号，信号可能会丢失，即内核递送给目标进程的次数，可能小于信号发送的次数。对于可靠信号，内核内部有队列来维护，如果收到可靠信号，内核会将信号挂到相应的队列中，因此不会丢失。严格说来，内核也设有上限，挂起信号的个数也不能无限制地增大，因此只能说，在一定范围之内，可靠信号不会被丢弃。</p>
<h1 id="传统信号特点"><a href="#传统信号特点" class="headerlink" title="传统信号特点"></a>传统信号特点</h1><p>传统的signal机制，分为System V风格和BSD风格的signal。glibc提供了signal函数来注册用户定义的信号处理函数，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure></div>

<p>除此以外，Linux还提供了如下两个接口供我们“考古”，下面来探查一下signal机制的演化：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">sysv_signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">bsd_signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span><br></pre></td></tr></table></figure></div>

<p>从接口上看，存在4种signal函数，见表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/epub_831302_202.jpg"
                      alt="epub_831302_202"
                ></p>
<p>接下来用实验的方法，测试各种不同的信号机制表现出来的行为模式，帮助大家体会传统信号的特点和弊端，以及学习Linux下glibc提供的signal函数的行为特性：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG <span class="string">&quot;OMG , I catch the signal SIGINT\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_END <span class="string">&quot;OK,finished process signal SIGINT\n&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_heavy_work</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">100000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">             k = rand()%<span class="number">1234589</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    write(<span class="number">2</span>,MSG,<span class="built_in">strlen</span>(MSG));</span><br><span class="line">    do_heavy_work();</span><br><span class="line">    write(<span class="number">2</span>,MSG_END,<span class="built_in">strlen</span>(MSG_END));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined SYSCALL_SIGNAL_API</span></span><br><span class="line">    <span class="keyword">if</span>(syscall(SYS_signalfd ,SIGINT,signal_handler) == <span class="number">-1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined SYSV_SIGNAL_API</span></span><br><span class="line">    <span class="keyword">if</span>(sysv_signal(SIGINT,signal_handler) == SIG_ERR)</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined BSD_SIGNAL_API</span></span><br><span class="line">    <span class="keyword">if</span>(bsd_signal(SIGINT,signal_handler) == SIG_ERR)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span>(signal(SIGINT,signal_handler) == SIG_ERR)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;signal failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a string:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fgets(input,<span class="keyword">sizeof</span>(input),<span class="built_in">stdin</span>)== <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fgets failed(%s)\n&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;you entered:%s&quot;</span>,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>分别采用了Linux操作系统提供的signal系统调用、System V风格的sysv_signal、BSD风格的bsd_signal，还有glibc提供的标准API signal函数。下面来分别体会它们之间的不同之处。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o systemcall_signal -DSYSCALL_SIGNAL_API    signal_comp.c</span><br><span class="line">gcc -o sysv_signal    -DSYSV_SIGNAL_API          signal_comp.c</span><br><span class="line">gcc -o bsd_signal     -DBSD_SIGNAL_API           signal_comp.c</span><br><span class="line">gcc -o glibc_signal                              signal_comp.c</span><br></pre></td></tr></table></figure></div>

<h2 id="信号的ONESHOT特性"><a href="#信号的ONESHOT特性" class="headerlink" title="信号的ONESHOT特性"></a>信号的ONESHOT特性</h2><p>传统的System V风格的signal，其注册的信号处理函数是一次性的，信号递送给目标进程之后，信号处理函数会变成默认值SIG_DFL。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~/code/c/self/signal$ ./sysv_signal</span><br><span class="line">input a <span class="built_in">string</span>:</span><br><span class="line">hello</span><br><span class="line">you entered:hello</span><br><span class="line">manu@manu-hacks:~/code/c/self/signal$ ./sysv_signal</span><br><span class="line">input a <span class="built_in">string</span>:</span><br><span class="line">hello^COMG , I catch the signal SIGINT</span><br><span class="line">^C</span><br><span class="line">manu@manu-hacks:~/code/c/self/signal$</span><br></pre></td></tr></table></figure></div>

<p>可以看到第一次实验的时候，输入一个字符串，敲击回车，正常显示了输入的字符串。第二次输入结束之前，按Ctrl+C键，系统会向进程发送SIGINT信号，进程收到信号后，执行了信号处理函数（打印出了OMG，I catch the signal SIGINT），再次向进程发送SIGINT信号，进程就退出了。可见，在System V风格的信号处理机制中，安装的信号处理函数是一次性的，内核把信号递送出去后，信号处理函数恢复成默认值SIG_DFL。因为SIGINT信号的默认处理是终止进程，所以进程就退出了。</p>
<hr>
<p>Linux系统调用也是如此，信号处理函数同样是一次性的：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:signal$ ./systemcall_signal</span><br><span class="line">input a string:</span><br><span class="line">hello</span><br><span class="line">you entered:hello</span><br><span class="line">manu@manu-hacks:signal$ ./systemcall_signal</span><br><span class="line">input a string:</span><br><span class="line">hello^COMG , I catch the signal SIGINT</span><br><span class="line">^C</span><br><span class="line">manu@manu-hacks:signal$</span><br></pre></td></tr></table></figure></div>

<p>对于这种风格，内核中有个很形象的宏来描述这种行为模式，即SA_ONESHOT。</p>
<p>对于信号而言，是用标志位来控制信号的ONESHOT行为模式的，这个标志位是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*架构相关，对于x86平台*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SA_RESETHAND    0x80000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SA_ONESHOT SA_RESETHAND</span></span><br></pre></td></tr></table></figure></div>

<p>当内核递送信号给进程时，如果发现同时满足以下两个条件，则会将信号处理函数恢复成默认函数：</p>
<ul>
<li>信号处理函数不是默认值。</li>
<li>信号处理函数的标志位中，SA_ONESHOT标志置位。</li>
</ul>
<p>这部分控制逻辑，出现于内核的<code>get_signal_to_deliver</code>函数中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_signal_to_deliver</span><span class="params">(<span class="type">siginfo_t</span> *info, <span class="keyword">struct</span> k_sigaction *return_ka,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> pt_regs *regs, <span class="type">void</span> *cookie)</span></span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;</span><br><span class="line">            <span class="comment">/* Run the handler.  */</span></span><br><span class="line">            *return_ka = *ka;</span><br><span class="line">            <span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">                ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* will return non-zero &quot;signr&quot; value */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用<code>strace</code>来追踪<code>sysv_signal</code>的执行，可以看到有如下的系统调用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rt_sigaction(SIGINT, &#123;sa_handler=<span class="number">0x5e6638ebb336</span>, sa_mask=[], sa_flags=SA_RESTORER|SA_INTERRUPT|SA_NODEFER|SA_RESETHAND|<span class="number">0xffffffff00000000</span>, sa_restorer=<span class="number">0x7b41cf642520</span>&#125;, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=<span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<p>BSD风格的signal和glibc的signal函数已经不存在ONESHOT的问题了，代码如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:signal$ ./bsd_signal</span><br><span class="line">input a <span class="built_in">string</span>:</span><br><span class="line">hello^COMG , I catch the signal SIGINT</span><br><span class="line">^COK,finished process signal SIGINT</span><br><span class="line">OMG , I catch the signal SIGINT</span><br><span class="line">OK,finished process signal SIGINT</span><br><span class="line">^COMG , I catch the signal SIGINT</span><br><span class="line">OK,finished process signal SIGINT</span><br><span class="line">manu@manu-hacks:signal$ ./glibc_signal</span><br><span class="line">input a <span class="built_in">string</span>:</span><br><span class="line">hello^COMG , I catch the signal SIGINT</span><br><span class="line">^COK,finished process signal SIGINT</span><br><span class="line">OMG , I catch the signal SIGINT</span><br><span class="line">^COK,finished process signal SIGINT</span><br><span class="line">OMG , I catch the signal SIGINT</span><br><span class="line">OK,finished process signal SIGINT</span><br></pre></td></tr></table></figure></div>

<p>通过strace追踪<code>bsd_signal</code>和<code>glibc_signal</code>执行的系统调用，可以看到，两者调用<code>rt_sigaction</code>系统调用时都没有设置<code>SA_ONESHOT</code>的标志位。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc</span></span><br><span class="line">rt_sigaction(SIGINT, &#123;sa_handler=<span class="number">0x646fb30d8336</span>, sa_mask=[INT], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=<span class="number">0x7cdd23442520</span>&#125;, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=<span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">//bsd</span></span><br><span class="line">rt_sigaction(SIGINT, &#123;sa_handler=<span class="number">0x65235ece9336</span>, sa_mask=[INT], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=<span class="number">0x77efcee42520</span>&#125;, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=<span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h2 id="信号执行时屏蔽自身的特性"><a href="#信号执行时屏蔽自身的特性" class="headerlink" title="信号执行时屏蔽自身的特性"></a>信号执行时屏蔽自身的特性</h2><p>在执行信号处理函数期间，很有可能会收到其他的信号，当然也有可能再次收到正在处理的信号。如果在处理A信号期间再次收到A信号，会发生什么呢？对于传统的System V信号机制，在信号处理期间，不会屏蔽对应的信号，而这就会引起信号处理函数的重入。这算是传统的System V信号机制的另一个弊端了。BSD信号处理机制修正了这个缺陷。当然了，BSD信号处理机制只是屏蔽了当前信号，并没有屏蔽当前信号以外的其他信号。</p>
<p>来比较下System V和BSD signal机制的区别。System V风格的系统调用：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//sysv风格</span><br><span class="line">rt_sigaction(SIGINT, &#123;0x8048756, [], SA_INTERRUPT|SA_NODEFER|SA_RESETHAND&#125;, &#123;SIG_DFL, [], 0&#125;, 8) = 0</span><br><span class="line">//bsd风格</span><br><span class="line">rt_sigaction(SIGINT, &#123;0x8048736, [INT], SA_RESTART&#125;, &#123;SIG_DFL, [], 0&#125;, 8) = 0</span><br></pre></td></tr></table></figure></div>

<p>BSD风格的信号处理机制，在安装信号的时候，会将自身这个信号添加到信号处理函数的屏蔽集合中。如果在执行A信号的信号处理函数期间，再次收到A信号，那么当前的A信号处理流程则不会被新来A信号打断。简单地说，就是不会嵌套了。System V风格的信号，在其信号处理期间没有屏蔽任何信号，换句话说，执行信号处理函数期间，处理流程可以被任意信号中断，包括正在处理的信号。从前面的实验可以看出，BSD风格的信号处理函数“OMG，I catch the signal SIGINT”，以及“OK，finished process signal SIGINT”总是成对出现的，不可能连续出现两个“OMG，I catch the signal SIGINT”，原因就是SIGINT信号在信号处理函数执行期间被暂时屏蔽了。内核是如何做到这一点的？完整的信号递送流程大致如此：内核首先调用<code>get_signal_to_deliver</code>，在挂起的信号集合中选择一个信号，递送给进程，选择完毕后，调用<code>handler_signal</code>函数。<code>handler_signal</code>函数的作用是为执行信号处理函数做准备。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler_signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *info, <span class="keyword">struct</span> k_sigaction *ka,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> pt_regs *regs, <span class="type">int</span> stepping)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> blocked;</span><br><span class="line">    ...</span><br><span class="line">    clear_restore_sigmask();</span><br><span class="line">    sigorsets(&amp;blocked, &amp;current-&gt;blocked, &amp;ka-&gt;sa.sa_mask);</span><br><span class="line">    <span class="keyword">if</span> (!(ka-&gt;sa.sa_flags &amp; SA_NODEFER))</span><br><span class="line">        sigaddset(&amp;blocked, sig);</span><br><span class="line">    set_current_blocked(&amp;blocked);</span><br><span class="line">    tracehook_signal_handler(sig, info, ka, regs, stepping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从上面代码中不难看出，如果信号没有设置SA_NODEFER标志位，正在处理的信号就必须在信号处理程序执行期间被阻塞。System V风格的signal机制为何会出现不屏蔽自身信号的情况？原因就是sysv_signal函数，在调用rt_sigaction系统调用时加上了SA_NODEFER标志位，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rt_sigaction(SIGINT, &#123;<span class="number">0x8048756</span>, [], SA_INTERRUPT|SA_NODEFER|SA_RESETHAND&#125;, &#123;SIG_DFL, [], <span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h2 id="信号中断系统调用的重启特性"><a href="#信号中断系统调用的重启特性" class="headerlink" title="信号中断系统调用的重启特性"></a>信号中断系统调用的重启特性</h2><p>系统调用在执行期间，很可能会收到信号，此时进程可能不得不从系统调用中返回，去执行信号处理函数。对于执行时间比较久的系统调用（如wait、read等）被信号中断的可能性会大大增加。系统调用被中断后，一般会返回失败，并置错误码为EINTR。如果程序员希望处理完信号之后，被中断的系统调用能够重启，则需要通过判断errno的值来解决，即如果发现错误码是EINTR，就重新调用系统调用。来看下面的例子：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~/code/c/self/signal$ ./sysv_signal</span><br><span class="line">input a <span class="built_in">string</span>:</span><br><span class="line">^COMG , I catch the signal SIGINT</span><br><span class="line">OK,finished process signal SIGINT</span><br><span class="line">fgets <span class="title function_">failed</span><span class="params">(Interrupted system call)</span></span><br></pre></td></tr></table></figure></div>

<p>通过strace可以看到，fgets调用了read系统调用，而read系统调用因为等待用户输入而陷入长时间的阻塞。在阻塞过程中，收到了一个SIGINT信号，导致read系统调用被中断，返回了错误码EINTR。</p>
<p>Linux世界中的很多系统调用都会遭遇这种情景，尤其是read、wait这种可能比较耗时的系统调用。《Unix系统编程：通信、并发和线程》一书中存在很多类似的例子：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">r_wait</span><span class="params">(<span class="type">int</span> *stat_loc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">while</span>(((retval = wait(stat_loc)) ==<span class="number">-1</span> &amp;&amp; (errno == EINTR))&#123;</span><br><span class="line">        ;&#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种封装就是用来应对系统调用被信号中断的场景的。当系统调用被信号中断时，程序并不认为这是一种无法处理的错误，相反，程序完全可以通过重新调用系统调用，来完成其想做的事情。在System V信号机制下，系统调用如果被信号中断，则会返回-1，并置errno为EINTR，而不会主动重启被信号中断的系统调用。细细想来，如果所有的系统调用都要判断返回值是否为EINTR，是的话，则重启系统调用，那么程序员就太累了。</p>
<p>BSD风格的signal机制提供了另外一种思路，即如果系统调用被信号中断，内核会在信号处理函数结束之后，自动重启系统调用，无须程序员再次调用系统调用。Linux操作系统提供了一个标志位SA_RESTART来告诉内核，被信号中断后是否要重启系统调用。如果该标志位为1，则表示如果系统调用被信号中断，那么内核会自动重启系统调用。BSD风格的signal函数和glibc的函数，毫无意外地都带有该标志位：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rt_sigaction(SIGINT, &#123;<span class="number">0x8048736</span>, [INT], SA_RESTART&#125;, &#123;SIG_DFL, [], <span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">//由于BSD风格的signal存在这个标志SA_RESTART，因此fgets不会像System V的signal一样，返回错误码：</span></span><br><span class="line">manu@manu-hacks:~/code/c/self/signal$ ./bsd_signal</span><br><span class="line">input a <span class="built_in">string</span>:</span><br><span class="line">hello^COMG , I catch the signal SIGINT</span><br><span class="line">OK,finished process signal SIGINT</span><br><span class="line">^COMG , I catch the signal SIGINT</span><br><span class="line">OK,finished process signal SIGINT</span><br></pre></td></tr></table></figure></div>

<p>非常不幸的是，并不是所有的系统调用对信号中断都表现出同样的行为。某些系统调用哪怕设置了SA_RESTART的标志位，也绝不会自动重启。那么问题就来了，在Linux下，如果信号处理函数设置了SA_RESTART，哪些阻塞型的系统调用遭到信号中断后，可以自动重启，哪些系统调用又是死活也无法自动重启的呢？</p>
<p>下表列出了设置SA_RESTART标志位后，可以自动重启的阻塞型系统调用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250212170614283.png"
                      alt="image-20250212170614283"
                ></p>
<p>下表是设置了SA_RESTART标志位，也不会重启的系统调用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250212170648929.png"
                      alt="image-20250212170648929"
                ></p>
<p>通过man 7 signal就可以获得这些信息。</p>
<hr>
<p>通过测试得知4种信号函数的不同表现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250212170733502.png"
                      alt="image-20250212170733502"
                ></p>
<p>手册明确表示bsd_signal没有ONESHOT特性，信号处理函数不会reset成默认值，无须重复安装信号处理函数；信号处理函数期间，自身信号会被屏蔽；系统调用被中断，会重启系统调用。这三个特性都是可以保证的，但是glibc下signal函数就不一定了，这要取决于操作系统，取决于glibc的版本。这是signal函数被人诟病的一个重要原因。简言之，就是其历史负担太重。通过前面的讨论可以发现，Linux系统会通过一些标志位和屏蔽信号集来完成对某些特性的控制。</p>
<ul>
<li>SA_ONESHOT（或SA_RESERTHAND）：将信号处理函数恢复成默认值。</li>
<li>SA_NODEFER（或SA_NOMASK）：显式地告诉内核，不要将当前处理信号值添加进阻塞信号集。</li>
<li>SA_RESTART：将中断的系统调用重启，而不是返回错误码EINTR。</li>
</ul>
<h1 id="信号的可靠性"><a href="#信号的可靠性" class="headerlink" title="信号的可靠性"></a>信号的可靠性</h1><p>传统的信号存在信号丢失的问题，因此被称为不可靠信号。为了对传统的不可靠信号有更直观的认识，下面来做一个简单的实验，让事实来说话。我们可以疯狂地向某个进程发送信号，然后通过比较信号发送的次数和信号处理函数执行的次数来验证是否存在信号丢失的问题。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sig_cnt[NSIG];</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> get_SIGINT = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(signo == SIGINT)</span><br><span class="line">        get_SIGINT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sig_cnt[signo]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">sigset_t</span> blockall_mask ;</span><br><span class="line">    <span class="type">sigset_t</span> empty_mask ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:PID is %d\n&quot;</span>,argv[<span class="number">0</span>],getpid());</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; NSIG; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == SIGKILL || i == SIGSTOP ||</span><br><span class="line">           i== <span class="number">32</span> || i== <span class="number">33</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(signal(i,&amp;handler) == SIG_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;signal for signo(%d) failed (%s)\n&quot;</span>,</span><br><span class="line">                    i,strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sleep_time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        sigfillset(&amp;blockall_mask);</span><br><span class="line">        <span class="keyword">if</span>(sigprocmask(SIG_SETMASK,&amp;blockall_mask,<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;setprocmask to block all signal failed(%s)\n&quot;</span>,</span><br><span class="line">              strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I will sleep %d second\n&quot;</span>,sleep_time);</span><br><span class="line">        sleep(sleep_time);</span><br><span class="line">        sigemptyset(&amp;empty_mask);</span><br><span class="line">        <span class="keyword">if</span>(sigprocmask(SIG_SETMASK,&amp;empty_mask,<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;setprocmask to release all signal failed(%s)\n&quot;</span>,        strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!get_SIGINT)</span><br><span class="line">        <span class="keyword">continue</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-10s%-10s\n&quot;</span>,<span class="string">&quot;signo&quot;</span>,<span class="string">&quot;times&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; NSIG ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sig_cnt[i] != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-10d%-10d\n&quot;</span>,i,sig_cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果执行时不带参数，那么进程会原地循环，直到收到SIGINT信号为止。在这期间，信号处理函数每执行一次，都会将收到信号的次数加1，进程结束前，会将各种信号收到的次数打印出来。如果执行时带一个参数，那么这个参数的含义是屏蔽信号的时间N，首先将能够阻塞的信号全部阻塞，在信号阻塞期间，虽然会有进程向signal_receiver进程发送信号，但是内核并不会立即将收到的信号递送给进程。在沉睡N秒之后，解除阻塞，内核开始向signal_receiver进程递送信号。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;USAGE:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;--------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;signal_sender  pid  signo  times\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span> ;</span><br><span class="line">    <span class="type">int</span> signo = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid = atol(argv[<span class="number">1</span>]);</span><br><span class="line">    signo = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    times = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span>(pid &lt;= <span class="number">0</span> || times &lt; <span class="number">0</span> || signo &lt;<span class="number">1</span> ||</span><br><span class="line">       signo &gt;=<span class="number">64</span> ||signo == <span class="number">32</span> || signo ==<span class="number">33</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d,signo = %d,times = %d\n&quot;</span>,pid,signo,times);</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; times ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(pid,signo) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;send signo(%d) to pid(%d) failed,reason(%s)\n&quot;</span>,</span><br><span class="line">                    signo,pid,strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>程序比较简单，接受三个参数：目标进程号、信号值和发送次数。有了这个工具，我们可以向目标进程signal_receiver连续发送任意次数的信号X。</p>
<p>首先，signal_receiver不带参数执行（即signal_receiver进程不会让信号阻塞一段时间），向signal_receiver连续发送信号，看看目标进程signal_receiver一共收到多少次信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">终端<span class="number">1</span>：</span><br><span class="line">manu@manu-hacks:signal$ ./signal_receiver</span><br><span class="line">./signal_receiver:PID is <span class="number">9937</span></span><br></pre></td></tr></table></figure></div>

<p>向9937进程发送信号SIGUSR2 10000次，然后发送SIGINT信号1次来结束signal_receiver进程，下面查看signal_receiver进程一共收到多少次信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">终端<span class="number">2</span></span><br><span class="line">manu@manu-hacks:signal$ ./signal_sender  <span class="number">9937</span> <span class="number">12</span> <span class="number">10000</span></span><br><span class="line">pid = <span class="number">9937</span>,signo = <span class="number">12</span>,times = <span class="number">10000</span></span><br><span class="line">done</span><br><span class="line">manu@manu-hacks:signal$ ./signal_sender  <span class="number">9937</span> <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">pid = <span class="number">9937</span>,signo = <span class="number">2</span>,times = <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">终端<span class="number">1</span></span><br><span class="line">signo     times</span><br><span class="line">------------------------</span><br><span class="line"><span class="number">12</span>        <span class="number">2488</span></span><br><span class="line"></span><br><span class="line">signo     times</span><br><span class="line">------------------------</span><br><span class="line"><span class="number">12</span>        <span class="number">2352</span></span><br><span class="line">signo     times</span><br><span class="line">------------------------</span><br><span class="line"><span class="number">12</span>        <span class="number">2403</span></span><br></pre></td></tr></table></figure></div>

<p>可以看到我们发送12号信号10000次，可是signal_receiver只收到2488次，这个2488也不是固定的，如果多执行几次，你会看到每次收到的信号次数均不相同。</p>
<p>可以看到收到信号的次数是不一定的，但是都不等于发送信号的次数。再进一步，让信号接收进程屏蔽信号一段时间，在这段时间内，发送信号，查询信号处理函数被触发的次数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">终端<span class="number">1</span></span><br><span class="line">manu@manu-hacks:signal$ ./signal_receiver <span class="number">30</span></span><br><span class="line">./signal_receiver:PID is <span class="number">27639</span></span><br><span class="line">I will sleep <span class="number">30</span> second终端<span class="number">2</span></span><br><span class="line">manu@manu-hacks:signal$ ./signal_sender <span class="number">27639</span> <span class="number">10</span> <span class="number">10000</span></span><br><span class="line">pid = <span class="number">27639</span>,signo = <span class="number">10</span>,times = <span class="number">10000</span></span><br><span class="line">done</span><br><span class="line">manu@manu-hacks:signal$ ./signal_sender <span class="number">27639</span> <span class="number">36</span> <span class="number">10000</span></span><br><span class="line">pid = <span class="number">27639</span>,signo = <span class="number">36</span>,times = <span class="number">10000</span></span><br><span class="line">done终端<span class="number">1</span></span><br><span class="line">signo     times</span><br><span class="line">------------------------</span><br><span class="line"><span class="number">10</span>        <span class="number">1</span></span><br><span class="line"><span class="number">36</span>        <span class="number">10000</span></span><br></pre></td></tr></table></figure></div>

<p>从上面的例子可以看出，如果进程将信号屏蔽一段时间，在此期间向目标进程发送SIGUSR2信号10000次，在解除屏蔽之后，信号处理函数只触发了一次。那么可靠信号的表现又如何呢？实验中发送实时信号36共计10000次，解除屏蔽后信号处理函数共触发了10000次，没有丢失信号，所有信号都被递送给进程去处理了。</p>
<p>从上面的实验可以看出可靠信号和不可靠信号存在着不小的差异。不可靠信号，不能可靠地被传递给进程处理，内核可能会丢弃部分信号。会不会丢弃，以及丢弃多少，取决于信号到来和信号递送给进程的时序。而可靠信号，基本不会丢失信号。</p>
<p>之所以存在这种差异，是因为重复的信号到来时，内核采取了不同的处理方式。从内核收到发给某进程的信号，到内核将信号递送给该进程，中间有个时间窗口。在这个时间窗口内，内核会负责记录收到的信号信息，这些信号被称为挂起信号或未决信号。但是对于可靠信号和不可靠信号，内核采取了不同的记录方式。内核中负责记录挂起信号的数据结构为sigpending结构体，定义代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        <span class="type">sigset_t</span> signal;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NSIG           64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NSIG_BPW      64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NSIG_WORDS   (_NSIG / _NSIG_BPW)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> sig[_NSIG_WORDS];</span><br><span class="line">&#125; <span class="type">sigset_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>在sigpending结构体中，sigset_t类型的成员变量signal本质上是一个位图，用一个比特来记录是否存在与该位置对应的信号处于未决的状态。根据位图可以有效地判断某信号是否已经存在未决信号。因为共有64种不同的信号，因此对于64位的操作系统，一个无符号的长整型就足以描述所有信号的挂起情况了。在sigpending结构体中，第一个成员变量是个链表头。内核定义了结构体sigqueue，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        <span class="type">int</span> flags;</span><br><span class="line">        <span class="type">siginfo_t</span> info;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>该结构体中info成员变量详细记录了信号的信息。如果内核收到发给某进程的信号，则会分配一个sigqueue结构体，并将该结构体挂入sigpending中第一个成员变量list为表头的链表之中。综上所述，内核的进程描述符提供了两套机制来记录挂起信号：位图和队列。可能有读者会问，存在两套机制，尤其是存在队列，不应该丢失信号啊！正常来讲，来一个信号，只须将信号的相关信息挂入队列之中，就可以确保信号不丢。的确如此，但是实际上，可靠信号和不可靠信号的处理方式不同，不可靠信号并没有充分的队列来确保信号不丢。内核收到不可靠信号时，会检查位图中对应位置是否已经是1，如果不是1，则表示尚无该信号处于挂起状态，然后会分配sigqueue结构体，并将信号挂入链表之中，同时将位图对应位置置1。但是如果位图显示已经存在该不可靠信号，那么内核会直接丢弃本次收到的信号。换句话说，内核的sigpending链表之中，最多只会存在一个不可靠信号的sigqueue结构体。</p>
<p>内核收到可靠信号时，不论是否已经存在该信号处于挂起状态，都会为该信号分配一个sigqueue结构体，并将sigqueue结构体挂入sigpending的链表之中，以确保不会丢失信号。那么可靠信号是不是可以无限制地挂入队列呢？也不是。实际上内核也做了限制，一个进程默认挂起信号的个数是有限的，超过限制，可靠信号也会变得没那么可靠了，也会丢失信号。让我们看看内核代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *</span></span><br><span class="line"><span class="class">__<span class="title">sigqueue_alloc</span>(<span class="title">int</span> <span class="title">sig</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>, <span class="title">gfp_t</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">override_rlimit</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">    ……</span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    user = get_uid(__task_cred(t)-&gt;user);</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;user-&gt;sigpending);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">if</span> (override_rlimit ||</span><br><span class="line">        <span class="type">atomic_read</span>(&amp;user-&gt;sigpending) &lt;=</span><br><span class="line">            task_rlimit(t, RLIMIT_SIGPENDING)) &#123; <span class="comment">// 限制</span></span><br><span class="line">        q = kmem_cache_alloc(sigqueue_cachep, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print_dropped_signal(sig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(q == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="type">atomic_dec</span>(&amp;user-&gt;sigpending);</span><br><span class="line">        free_uid(user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        INIT_LIST_HEAD(&amp;q-&gt;<span class="built_in">list</span>);</span><br><span class="line">        q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        q-&gt;user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实时信号也不能被无限制地挂起。该限制属于资源限制的范畴，该限制项（RLIMIT_SIGPENDING）限制了目标进程所属的真实用户ID信号队列中挂起信号的总数。可以通过如下命令来查看系统的限制：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ ulimit –a</span><br><span class="line">...</span><br><span class="line">pending <span class="title function_">signals</span>            <span class="params">(-i)</span> 15144</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">终端<span class="number">1</span></span><br><span class="line">manu@manu-hacks:signal$ ./signal_receiver  <span class="number">30</span></span><br><span class="line">./signal_receiver:PID is <span class="number">14699</span></span><br><span class="line">I will sleep <span class="number">30</span> second终端<span class="number">2</span></span><br><span class="line">manu@manu-hacks:signal$ ./signal_sender <span class="number">14699</span> <span class="number">36</span> <span class="number">20000</span></span><br><span class="line">pid = <span class="number">14699</span>,signo = <span class="number">36</span>,times = <span class="number">20000</span></span><br><span class="line">done</span><br><span class="line">manu@manu-hacks:signal$ ./signal_sender <span class="number">14699</span>  <span class="number">2</span> <span class="number">1</span></span><br><span class="line">pid = <span class="number">14699</span>,signo = <span class="number">2</span>,times = <span class="number">1</span></span><br><span class="line">done</span><br><span class="line">manu@manu-hacks:signal$终端<span class="number">1</span></span><br><span class="line">signo     times</span><br><span class="line">------------------------</span><br><span class="line"><span class="number">36</span>        <span class="number">15144</span></span><br></pre></td></tr></table></figure></div>

<p>向目标进程发送了实时信号36共计20000次，但目标进程只收到了15144次，超出限制的部分都被丢弃掉了。这个挂起信号的上限值是可以修改的，可以用<code>ulimit -i unlimited</code>这个命令将进程挂起信号的最大值设为无穷大，从而确保内核不会主动丢弃实时信号。</p>
<h1 id="信号的安装"><a href="#信号的安装" class="headerlink" title="信号的安装"></a>信号的安装</h1><p>前面讲了传统信号的很多弊端，讲了signal的兼容性问题，有问题就会有解决方案。对此，Linux提供了新的信号安装方法：sigaction函数。和signal函数相比，这个函数的优点在于语义明确，可以提供更精确的控制。先来看一下sigaction函数的定义：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">       <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">       <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">       <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">       <span class="type">int</span>       sa_flags;</span><br><span class="line">       <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>上面给出的sigaction结构体的定义并非严格意义上的定义，即结构体必须要有上述的成员变量，但成员变量的具体顺序取决于实现。顾名思义，<code>sa_mask</code>就是信号处理函数执行期间的屏蔽信号集。前文介绍<code>bsd_signal</code>的时候曾提到，为SIGINT安装处理函数时，内核会自动将SIGINT添加入屏蔽信号集，在SIGINT信号处理函数执行期间，SIGINT信号不会被递送给进程。但是，也仅仅是SIGINT，如果执行SIGINT信号处理函数期间，需要屏蔽SIGHUP、SIGUSR1等其他信号，那<code>bsd_signal</code>函数就爱莫能助了。这个屏蔽其他信号的需求对sigaction函数而言，根本就不是问题，只需如下代码即可做到：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>；</span></span><br><span class="line"><span class="class"><span class="title">sa</span>.<span class="title">sa_mask</span> =</span> SIGHUP|SIGUSR1|SIGINT;</span><br></pre></td></tr></table></figure></div>

<p>需要特别指出的是，并不是所有的信号都能被屏蔽。对于SIGKILL和SIGSTOP，不可以为它们安装信号处理函数，也不能屏蔽掉这些信号。原因是，系统总要控制某些进程，如果进程可以自行设计所有信号的处理函数，那么操作系统可能无法控制这些进程。换言之，操作系统是终极boss，需要杀死某些进程的时候，要能够做到，SIGKILL和SIGSTOP不能被屏蔽，就是为了防止出现进程无法无天而操作系统徒叹奈何的困境。</p>
<p>若通过sigaction强行给SIGKILL或SIGSTOP注册信号处理函数，则会返回-1，并置errno为EINVAL。在sigaction函数接口中，比较有意思的是<code>sa_flags</code>。sigaction函数之所以可以提供更精确的控制，大部分都是该参数的功劳。下面简要介绍一下sa_flags的含义，其中很多标志位并不是新面孔，前面已经讨论过了。</p>
<p>（1）<code>SA_NOCLDSTOP</code>这个标志位只用于SIGCHLD信号。父进程可以监测子进程的三种事件：</p>
<ul>
<li>子进程终止（即子进程死亡）</li>
<li>子进程停止（即子进程暂停）</li>
<li>子进程恢复（即子进程从暂停中恢复执行）</li>
</ul>
<p>其中SA_NOCLDSTOP标志位是用来控制第二种和第三种事件的。即一旦父进程为SIGCHLD信号设置了这个标志位，那么子进程停止和子进程恢复这两件事情，就无须向父进程发送SIGCHLD信号了。</p>
<p>（2）<code>SA_NOCLDWAIT</code>这个标志只用于SIGCHLD信号。</p>
<p>它可控制上面提到的子进程终止时的行为。如果父进程为SIGCHLD设置了SA_NOCLDWAIT标志位，那么子进程退出时，就不会进入僵尸状态，而是直接自行了断。但是子进程还会不会向父进程发送SIGCHLD信号呢？这取决于具体的实现。对于Linux而言，仍然会发送SIGCHLD信号。这点和上面的SA_NOCLDSTOP略有不同。</p>
<p>（3）<code>SA_ONESHOT</code>和<code>SA_RESETHAND</code>这两个标志位的本质是一样的，表示信号处理函数是一次性的，信号递送出去之后，信号处理函数便恢复成默认值SIG_DFL。</p>
<p>（4）<code>SA_NODEFER</code>和<code>SA_NOMASK</code>这两个标志位的作用是一样的，在信号处理函数执行期间，不阻塞当前信号。</p>
<p>（5）<code>SA_RESTART</code>这个标志位表示，如果系统调用被信号中断，则不返回错误，而是自动重启系统调用。</p>
<p>（6）SA_SIGINFO这个标志位表示信号发送者会提供额外的信息。</p>
<p>这种情况下，信号处理函数应该为三参数的函数，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure></div>

<p>此处重点讲述一下带SA_SIGINFO标志位的信号安装方式。本章引言中提到过，signal的本质是一种进程间的通信。一个进程向另外一个进程发送信号，能够传递的信息，不仅仅是signo，它还可以发送更多的信息，而接收进程也能获取到发送进程的PID、UID及发送的额外信息。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> signo,<span class="type">siginfo_t</span> *info,<span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nget signal:%d\n&quot;</span>,signo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;signal number is %d\n&quot;</span>,info-&gt;si_signo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>,info-&gt;si_pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sigval = %d\n&quot;</span>,info-&gt;si_value.sival_int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">new_action</span>;</span></span><br><span class="line">    sigemptyset(&amp;new_action.sa_mask);</span><br><span class="line">    new_action.sa_sigaction = sig_handler;</span><br><span class="line">    new_action.sa_flags |= SA_SIGINFO|SA_RESTART;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(<span class="number">36</span>,&amp;new_action,<span class="literal">NULL</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set signal process mode\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        pause();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个例子比较简单，为36号信号注册了信号处理函数。因为sa_flags带上了SA_SIGINFO标志位，所以必须使用三参数的信号处理函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> signo,<span class="type">siginfo_t</span> *info,<span class="type">void</span> *context)</span></span><br></pre></td></tr></table></figure></div>

<p>本例中的信号处理函数中，info-&gt;si_pid记录着信号发送者的PID，info-&gt;si_value.sival_int是信号发送进程时额外发送的int值。发送进程和接收进程约定好，发送者使用sigqueue发送信号，同时带上int型的额外信息，接收进程就能获得发送进程的PID及int型的额外信息。</p>
<h1 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h1><h2 id="kill、tkill和tgkill"><a href="#kill、tkill和tgkill" class="headerlink" title="kill、tkill和tgkill"></a>kill、tkill和tgkill</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div>

<p>注意，不能望文生义，将kill函数的作用理解为杀死进程。kill函数的作用是发送信号。kill函数不仅可以向特定进程发送信号，也可以向特定进程组发送信号。第一个参数pid的值，决定了kill函数的不同含义，具体来讲，可以分成以下几种情况。</p>
<ul>
<li>pid＞0：发送信号给进程ID等于pid的进程。</li>
<li>pid＝0：发送信号给调用进程所在的同一个进程组的每一个进程。</li>
<li>pid＝-1：有权限向调用进程发送信号的所有进程发出信号，init进程和进程自身除外。</li>
<li>pid＜-1：向进程组-pid发送信号。</li>
</ul>
<p>当函数成功时，返回0，失败时，返回-1，并置errno。常见的出错情况见表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213142446681.png"
                      alt="image-20250213142446681"
                ></p>
<p>有一种情况很有意思，即调用kill函数时，第二个参数signo的值为0。众所周知，没有一个信号的值是为0的，这种情况下，kill函数其实并不是真的向目标进程或进程组发送信号，而是用来检测目标进程或进程组是否存在。如果kill函数返回-1且errno为ESRCH，则可以断定我们关注的进程或进程组并不存在。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(kill(<span class="number">3423</span>,SIGUSR1) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">/*error handler*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Linux提供了<code>tkill</code>和<code>tgkill</code>两个系统调用来向某个线程发送信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tkill</span><span class="params">(<span class="type">int</span> tid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tgkill</span><span class="params">(<span class="type">int</span> tgid, <span class="type">int</span> tid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这两个都是内核提供的系统调用，glibc并没有提供对这两个系统调用的封装，所以如果想使用这两个函数，需要采用syscall的方式，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = syscall(SYS_tkill,tid,sig)</span><br><span class="line">ret = syscall(SYS_tgkill,tgid,tid,sig)</span><br></pre></td></tr></table></figure></div>

<p>为什么有了tkill，还要引入tgkill？实际上，tkill是一个过时的接口，并不推荐使用它来向线程发送信号。相比之下，tgkill接口更加安全。tgkill系统调用的第一个参数tgid，为线程组中主线程的线程ID，或者称为进程号。这个参数表面看起来是多余的，其实它能起到保护的作用，防止向错误的线程发送信号。进程ID或线程ID这种资源是由内核负责管理的，进程（或线程）有自己的生命周期，比如向线程ID为1234的线程发送信号时，很可能线程1234早就退出了，而线程ID 1234恰好被内核分配给了另一个不相干的进程。这种情况下，如果直接调用tkill，就会将信号发送到不相干的进程上。为了防止出现这种情况，于是内核引入了tgkill系统调用，含义是向线程组ID是tgid、线程ID为tid的线程发送信号。这样，出现误杀的可能就几乎不存在了。</p>
<p>这两个函数都是Linux特有的，存在可移植性的问题。</p>
<h2 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h2><p>Linux提供了向进程自身发送信号的接口：raise函数，其定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这个接口对于单线程的程序而言，就相当于执行如下语句：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill(getpid(),sig)</span><br></pre></td></tr></table></figure></div>

<p>这个接口对于多线程的程序而言，就相当于执行如下语句：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_kill(pthread_self(),sig)</span><br></pre></td></tr></table></figure></div>

<p>执行成功的时候，返回0，否则返回非零的值，并置errno。如果sig的值是无效的，raise函数就将errno置为EINVAL。值得注意的是，信号处理函数执行完毕之后，raise才能返回。</p>
<h2 id="sigqueue函数"><a href="#sigqueue函数" class="headerlink" title="sigqueue函数"></a>sigqueue函数</h2><p>在信号发送的方式当中，<code>sigqueue</code>算是后起之秀，传统的信号多用<code>signal/kill</code>这两个函数搭配，完成信号处理函数的安装和信号的发送。后来因为signal函数的表达力有限，控制不够精准，所以引入了<code>sigaction</code>函数来负责信号的安装，与其对应的是，引入了<code>sigqueue</code>函数来完成实时信号的发送。当然了，<code>sigqueue</code>函数也能发送非实时信号。sigqueue函数的接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br></pre></td></tr></table></figure></div>

<p>sigqueue函数拥有和kill函数类似的语义，也可以发送空信号（信号0）来检查进程是否存在。和kill函数不同的地方在于，它不能通过将pid指定为负值而向整个进程组发送信号。比较有意思的是函数的第三个入参，它指定了信号的伴随数据（或者称为有效载荷，payload），该参数的数据类型是联合体，定义代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span></span><br><span class="line">      <span class="type">int</span>   sival_int;</span><br><span class="line">      <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过指定sigqueue函数的第三个参数，可以传递一个int值或指针给目标进程。考虑到不同的进程有各自独立的地址空间，传递指针到另一个进程几乎没有任何意义。因此sigqueue函数很少传递指针（sival_ptr），大多是传递整型（sival_int）。</p>
<blockquote>
<p>尽管跨进程使用sigval中的指针sival_ptr没有任何意义，但sival_ptr字段并非百无一用。该字段可用于使用sigval联合体的其他函数中，如POSIX计时器的timer_create函数和POSIX消息队列中的mq_notify函数。</p>
</blockquote>
<p>sigval联合体的存在，扩展了信号的通信能力。一些简单的消息传递完全可以使用sigqueue函数来进行。比如，通信双方事先定义某些事件为不同的int值，通过sigval联合体，将事件发送给目标进程。目标进程根据联合体中的int值来区分不同的事件，做出不同的响应。但是这种方法传递的消息内容受到了限制，不容易扩展，所以不宜作为常规的通信手段。</p>
<p>下面的例子会使用sigqueue函数向目标进程发送信号，其中目标进程、信号值和发送次数都可指定，发送信号的同时，也发送了伴随数据。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;sigqueue_send sig pid [times]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">mysigval</span> ;</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sig = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        times = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    mysigval.sival_int = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">if</span>(sig &lt; <span class="number">0</span> || sig &gt;<span class="number">64</span> ||times &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i&lt; times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigqueue(pid,sig,mysigval) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;sigqueue failed (%s)\n&quot;</span>,  strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一般来说，sigqueue函数的黄金搭档是sigaction函数。在使用sigaction函数时，只要给成员变量sa_flags置上SA_SIGINFO的标志位，就可以使用三参数的信号处理函数来处理实时信号。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>；</span></span><br><span class="line"><span class="class"><span class="title">act</span>.<span class="title">sa_flags</span>  |=</span> SA_SIGINFO;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>   <span class="title function_">handle</span><span class="params">(<span class="type">int</span>, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *ucontext)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">siginfo_t</span> &#123;</span><br><span class="line">          <span class="type">int</span>      si_signo;</span><br><span class="line">          <span class="type">int</span>      si_errno;</span><br><span class="line">          <span class="type">int</span>      si_code;</span><br><span class="line">          <span class="type">int</span>      si_trapno;</span><br><span class="line">          <span class="type">pid_t</span>    si_pid;</span><br><span class="line">          <span class="type">uid_t</span>    si_uid;</span><br><span class="line">          <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">si_value</span>;</span></span><br><span class="line">          <span class="type">void</span>    *si_addr</span><br><span class="line">          ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p><code>siginfo_t</code>结构体包含很多信息，目标进程可以通过该数据结构获取到如下的信息：</p>
<ul>
<li>si_signo：信号的值。</li>
<li>si_code：信号来源，可以通过这个值来判断信号的来源，具体见表</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213144648616.png"
                      alt="image-20250213144648616"
                ></p>
<p>除此之外，一些特殊的信号会产生一些独特的si_code，来表示信号产生的根源或来源。例如，如果无效地址对齐引发SIGBUS信号，si_code就会被置为BUS_ADRALN等。想进一步了解详情，可以查看glibc的<code>bits/siginfo.h</code>头文件。</p>
<ul>
<li>si_value：sigqueue函数发送信号时所带的伴随数据。</li>
<li>si_pid：信号发送进程的进程ID。</li>
<li>si_uid：信号发送进程的真实用户ID。</li>
<li>si_addr：仅针对硬件产生的信号SIGBUS、SIGFPE、SIGILL和SIGSEGV设置该字段，该字段表示无效的内存地址（SIGBUS和SIGSEGV）或导致信号产生的程序的指令地址（SIGFPE和SIGILL）。</li>
</ul>
<p>三参数信号处理函数的第三个参数是void*类型的，其实它是一个ucontext_t类型的变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> uc_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="type">stack_t</span> uc_stack;</span><br><span class="line">    <span class="type">mcontext_t</span> uc_mcontext;</span><br><span class="line">    <span class="type">__sigset_t</span> uc_sigmask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span> __<span class="title">fpregs_mem</span>;</span></span><br><span class="line">&#125; <span class="type">ucontext_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>这个结构体提供了进程上下文的信息，用于描述进程执行信号处理函数之前进程所处的状态。通常情况下信号处理函数很少会用到这个变量，但是该变量也有很精妙的应用，如下面的例子。对于C程序员而言，基本每个人都会遇到段错误。一般情况下，段错误出现的原因是程序访问了非法的内存地址。当段错误发生时，操作系统会发送一个SIGSEGV信号给进程，导致进程产生核心转储文件并且退出。如何才能让进程先捕捉SIGSEGV信号，打印出有用的方便定位问题的信息，然后再优雅地退出呢？可以通过给SIGSEGV注册信号处理函数来实现，代码如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_GNU</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USE_GNU</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sig_ucontext</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>     uc_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span>   *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="type">stack_t</span>           uc_stack;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span> <span class="title">uc_mcontext</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span>          uc_sigmask;</span><br><span class="line">&#125; <span class="type">sig_ucontext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">crit_err_hdlr</span><span class="params">(<span class="type">int</span> sig_num, <span class="type">siginfo_t</span> * info, <span class="type">void</span> * ucontext)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *             <span class="built_in">array</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="type">void</span> *             caller_address;</span><br><span class="line">    <span class="type">char</span> **            messages;</span><br><span class="line">    <span class="type">int</span>                size, i;</span><br><span class="line">    <span class="type">sig_ucontext_t</span> *   uc;</span><br><span class="line">    uc = (<span class="type">sig_ucontext_t</span> *)ucontext;</span><br><span class="line">    caller_address = (<span class="type">void</span> *) uc-&gt;uc_mcontext.rip;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;signal %d (%s), address is %p from %p\n&quot;</span>,</span><br><span class="line">            sig_num, strsignal(sig_num), info-&gt;si_addr,</span><br><span class="line">            (<span class="type">void</span> *)caller_address);</span><br><span class="line">    size = backtrace(<span class="built_in">array</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = caller_address;</span><br><span class="line">    messages = backtrace_symbols(<span class="built_in">array</span>, size);</span><br><span class="line">    <span class="comment">/* 跳过第一个栈帧 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; size &amp;&amp; messages != <span class="literal">NULL</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[bt]: (%d) %s\n&quot;</span>, i, messages[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(messages);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">crash</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    crash();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo4();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigact</span>;</span></span><br><span class="line">    sigact.sa_sigaction = crit_err_hdlr;</span><br><span class="line">    sigact.sa_flags = SA_RESTART | SA_SIGINFO;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGSEGV, &amp;sigact, (<span class="keyword">struct</span> sigaction *)<span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error setting signal handler for %d (%s)\n&quot;</span>, SIGSEGV, strsignal(SIGSEGV));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    foo1();</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的函数利用了第三个参数里面的ucontext-&gt;uc_mcontext.rip字段，获取到了收到信号前的EIP寄存器的值，根据该值，可以将堆栈信息打印出来，输出如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~/code/me/aple/chapter_05$ ./print_bt</span><br><span class="line">signal <span class="number">11</span> (Segmentation fault), address <span class="title function_">is</span> <span class="params">(nil)</span> from 0x40089d</span><br><span class="line">[bt]: <span class="params">(<span class="number">1</span>)</span> ./<span class="title function_">print_bt</span><span class="params">()</span> [0x40089d]</span><br><span class="line">[bt]: <span class="params">(<span class="number">2</span>)</span> ./<span class="title function_">print_bt</span><span class="params">()</span> [0x40089d]</span><br><span class="line">[bt]: <span class="params">(<span class="number">3</span>)</span> ./<span class="title function_">print_bt</span><span class="params">()</span> [0x4008b5]</span><br><span class="line">[bt]: <span class="params">(<span class="number">4</span>)</span> ./<span class="title function_">print_bt</span><span class="params">()</span> [0x4008ca]</span><br><span class="line">[bt]: <span class="params">(<span class="number">5</span>)</span> ./<span class="title function_">print_bt</span><span class="params">()</span> [0x4008df]</span><br><span class="line">[bt]: <span class="params">(<span class="number">6</span>)</span> ./<span class="title function_">print_bt</span><span class="params">()</span> [0x4008f4]</span><br><span class="line">[bt]: <span class="params">(<span class="number">7</span>)</span> ./<span class="title function_">print_bt</span><span class="params">()</span> [0x400984]</span><br><span class="line">[bt]: <span class="params">(<span class="number">8</span>)</span> /lib/x86_64-linux-gnu/libc.so.6<span class="params">(__libc_start_main+<span class="number">0xf5</span>)</span> [0x7f6a8fa88ec5]</span><br><span class="line">[bt]: <span class="params">(<span class="number">9</span>)</span> ./<span class="title function_">print_bt</span><span class="params">()</span> [0x400679]</span><br></pre></td></tr></table></figure></div>

<h1 id="信号与线程"><a href="#信号与线程" class="headerlink" title="信号与线程"></a>信号与线程</h1><p>提到线程与信号的关系，必须先介绍下POSIX标准，POSIX标准对多线程情况下的信号机制提出了一些要求：</p>
<ul>
<li>信号处理函数必须在多线程进程的所有线程之间共享，但是每个线程要有自己的挂起信号集合和阻塞信号掩码。</li>
<li>POSIX函数kill&#x2F;sigqueue必须面向进程，而不是进程下的某个特定的线程。</li>
<li>每个发给多线程应用的信号仅递送给一个线程，这个线程是由内核从不会阻塞该信号的线程中随意选出来的。</li>
<li>如果发送一个致命信号到多线程，那么内核将杀死该应用的所有线程，而不仅仅是接收信号的那个线程。</li>
</ul>
<h2 id="线程之间共享信号处理函数"><a href="#线程之间共享信号处理函数" class="headerlink" title="线程之间共享信号处理函数"></a>线程之间共享信号处理函数</h2><p>对于进程下的多个线程来说，信号处理函数是共享的。在Linux内核实现中，同一个线程组里的所有线程都共享一个<code>struct sighand</code>结构体。该结构体中存在一个action数组，数组共64项，每一个成员都是k_sigaction结构体类型，一个k_sigaction结构体对应一个信号的信号处理函数。相关数据结构定义如下（这与架构相关，这里给出的是x86_64位下的定义）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">       <span class="type">__sighandler_t</span> sa_handler;</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span> sa_flags;</span><br><span class="line">       <span class="type">__sigrestore_t</span> sa_restorer;</span><br><span class="line">       <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span>  <span class="title">action</span>[_<span class="title">NSIG</span>];</span></span><br><span class="line">    <span class="type">spinlock_t</span>      siglock;</span><br><span class="line">    <span class="type">wait_queue_head_t</span>   signalfd_wqh;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">task_struct</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span>...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>多线程的进程中，信号处理函数相关的数据结构如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213150039270.png"
                      alt="image-20250213150039270"
                ></p>
<p>内核中<code>k_sigaction</code>结构体的定义和glibc中sigaction函数中用到的<code>struct sigaction</code>结构体的定义几乎是一样的。通过sigaction函数安装信号处理函数，最终会影响到进程描述符中的sighand指针指向的sighand_struct结构体对应位置上的action成员变量。在创建线程时，最终会执行内核的do_fork函数，由do_fork函数走进copy_sighand来实现线程组内信号处理函数的共享。创建线程时，<code>CLONE_SIGHAND</code>标志位是置位的。创建线程组的主线程时，内核会分配sighand_struct结构体；创建线程组内的其他线程时，并不会另起炉灶，而是共享主线程的sighand_struct结构体，只须增加引用计数而已。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_sighand</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_SIGHAND) &#123;</span><br><span class="line">        <span class="comment">//如果发现是线程，则直接将引用计数++，无须分配sighand_struct结构</span></span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;current-&gt;sighand-&gt;count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);</span><br><span class="line">    rcu_assign_pointer(tsk-&gt;sighand, sig);</span><br><span class="line">    <span class="keyword">if</span> (!sig)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;sig-&gt;count, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(sig-&gt;action, current-&gt;sighand-&gt;action, <span class="keyword">sizeof</span>(sig-&gt;action));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="线程有独立的阻塞信号掩码"><a href="#线程有独立的阻塞信号掩码" class="headerlink" title="线程有独立的阻塞信号掩码"></a>线程有独立的阻塞信号掩码</h2><p>每个线程都拥有独立的阻塞信号掩码。在介绍这条性质之前，首先需要介绍什么是阻塞信号掩码。就像我们开重要会议时要关闭手机一样，进程在执行某些重要操作时，不希望内核递送某些信号，阻塞信号掩码就是用来实现该功能的。如果进程将某信号添加进了阻塞信号掩码，纵然内核收到了该信号，甚至该信号在挂起队列中已经存在了相当长的时间，内核也不会将信号递送给进程，直到进程解除对该信号的阻塞为止。开会时关闭手机是一种比较极端的例子。更合理的做法是暂时屏蔽部分人的电话。对于某些重要的电话，比如儿子老师的电话、父母的电话或老板的电话，是不希望被屏蔽的。信号也是如此。进程在执行某些操作的时候，可能只需要屏蔽一部分信号，而不是所有信号。为了实现掩码的功能，Linux提供了一种新的数据结构：信号集。多个信号组成的集合被称为信号集，其数据类型为sigset_t。在Linux的实现中，sigset_t的类型是位掩码，每一个比特代表一个信号。Linux提供了两个函数来初始化信号集，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>sigemptyset函数用来初始化一个空的未包含任何信号的信号集，而sigfillset函数则会初始化一个包含所有信号的信号集。</p>
<p>必须要调用这两个初始化函数中的一个来初始化信号集，对于声明了sigset_t类型的变量，不能一厢情愿地假设它是空集合，也不能调用memset函数，或者用赋值为0的方式来初始化。</p>
<p>初始化信号之后，Linux提供了sigaddset函数向信号集中添加一个信号，同时还提供了sigdelset函数在信号集中移除一个信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></div>

<p>为了判断某一个信号是否属于信号集，Linux提供了sigismember函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果signum属于信号集，则返回1，否则返回0。出错的时候，返回-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></div>

<p>有了信号集，就可以使用信号集来设置进程的阻塞信号掩码了。Linux提供了<code>sigprocmask</code>函数来做这件事情：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>sigprocmask</code>根据how的值，提供了三种用于改变进程的阻塞信号掩码的方式，见表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213151657770.png"
                      alt="image-20250213151657770"
                ></p>
<p>我们知道SIGKILL信号和SIGSTOP信号不能阻塞，可是如果调用sigprocmask函数时，将SIGKILL信号和SIGSTOP信号添加进阻塞信号集中，会怎么样？答案是不怎么样。sigprocmask函数不会报错，但是也不会将SIGKILL和SIGSTOP真的添加进阻塞信号集中。对应的rt_sigprocmask系统调用会执行如下语句，剔除掉集合中的SIGKILL和SIGSTOP：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sigdelsetmask(&amp;new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));</span><br></pre></td></tr></table></figure></div>

<p>对于多线程的进程而言，每一个线程都有自己的阻塞信号集：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>&#123;</span></span><br><span class="line">    <span class="type">sigset_t</span> blocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>sigprocmask函数改变的是调用线程的阻塞信号掩码，而不是整个进程。sigprocmask出现得比较早，它出现在线程尚未引入Linux的时代。在单线程的时代，进程的阻塞信号掩码和线程的阻塞掩码是一回事，但是引入多线程之后，sigprocmask的语义就变成了设置调用线程的阻塞信号掩码。为了更显式地设置线程的阻塞信号掩码，线程库提供了pthread_sigmask函数来设置线程的阻塞信号掩码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure></div>

<p>事实上pthread_sigmask函数和sigprocmask函数的行为是一样的。</p>
<h2 id="私有挂起信号和共享挂起信号"><a href="#私有挂起信号和共享挂起信号" class="headerlink" title="私有挂起信号和共享挂起信号"></a>私有挂起信号和共享挂起信号</h2><p>POSIX标准中有如下要求：对于多线程的进程，kill和sigqueue发送的信号必须面对所有的线程，而不是某个线程，内核是如何做到的呢？而系统调用tkill和tgkill发送的信号，又必须递送给进程下某个特定的线程。内核又是如何做到的呢？</p>
<p>前面简单提到过内核维护有挂起队列，尚未递送进程的信号可以挂入挂起队列中。有意思的是，内核的进程描述符task_struct之中，维护了两套sigpending，代码如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span>      ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> &#123;</span>...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>       <span class="title">shared_pending</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213152122134.png"
                      alt="image-20250213152122134"
                ></p>
<p>内核就是靠这两个挂起队列实现了POSIX标准的要求。在Linux实现中，线程作为独立的调度实体也有自己的进程描述符。Linux下既可以向进程发送信号，也可以向进程中的特定线程发送信号。因此进程描述符中需要有两套sigpending结构。其中task_struct结构体中的pending，记录的是发送给线程的未决信号；而通过signal指针指向signal_struct结构体的shared_pending，记录的是发送给进程的未决信号。每个线程都有自己的私有挂起队列（pending），但是进程里的所有线程都会共享一个公有的挂起队列（shared_pending）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213152532415.png"
                      alt="image-20250213152532415"
                ></p>
<p>上图描述的是通过kill、sigqueue、tkill和tgkill发送信号后，内核的相关处理流程。从图中可以看出，向进程发送信号也好，向线程发送信号也罢，最终都殊途同归，在do_send_sig_info函数处会师。尽管会师在一处，却还是存在不同。不同的地方在于，到底将信号放入哪个挂起队列。在<code>__send_signal</code>函数中，通过group入参的值来判断需要将信号放入哪个挂起队列（如果需要进队列的话）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __send_signal(<span class="type">int</span> sig, <span class="keyword">struct</span> siginfo *info, <span class="keyword">struct</span> task_struct *t,</span><br><span class="line">           <span class="type">int</span> group, <span class="type">int</span> from_ancestor_ns)</span><br><span class="line">&#123;</span><br><span class="line">    ...pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果用户调用的是kill或sigqueue，那么group就是1；如果用户调用的是tkill或tgkill，那么group参数就是0。内核就是以此来区分该信号是发给进程的还是发给某个特定线程的，如表所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250213152708485.png"
                      alt="image-20250213152708485"
                ></p>
<p>上述情景并不难理解。多线程的进程就像是一个班级，进程下的每一个线程就像是班级的成员。kill和sigqueue函数发送的信号是给进程的，就像是优秀班集体的荣誉是颁发给整个班级的；tkill和tgkill发送的信号是给特定线程的，就像是三好学生的荣誉是颁发给学生个人的。另一个需要解决的问题是，多线程情况下发送给进程的信号，到底由哪个线程来负责处理？这个问题就和高二（五）班荣获优秀班集体，由谁负责上台领奖一样。内核是不是一定会将信号递送给进程的主线程？答案是不一定。尽管如此，Linux还是采取了尽力而为的策略，尽量地尊重函数调用者的意愿，如果进程的主线程方便的话，则优先选择主线程来处理信号；如果主线程确实不方便，那就有可能由线程组里的其他线程来负责处理信号。</p>
<p>户在调用<code>kill/sigqueue</code>函数之后，内核最终会走到<code>__send_signal</code>函数。在该函数的最后，由<code>complete_signal</code>函数负责寻找合适的线程来处理该信号。因为主线程的线程ID等于进程ID，所以该函数会优先查询进程的主线程是否方便处理信号。如果主线程不方便，则会遍历线程组中的其他线程。如果找到了方便处理信号的线程，就调用<code>signal_wake_up</code>函数，唤醒该线程去处理信号。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal_wake_up(t, sig == SIGKILL);</span><br></pre></td></tr></table></figure></div>

<p>如果线程组内全都不方便处理信号，complete函数也就当即返回了。如何判断方便不方便？内核通过<code>wants_signal</code>函数来判断某个调度实体是否方便处理某信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">wants_signal</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigismember(&amp;p-&gt;blocked, sig))<span class="comment">/*位于阻塞信号集，不方便*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;flags &amp; PF_EXITING)<span class="comment">/*正在退出，不方便*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGKILL)<span class="comment">/*SIGKILL信号，必须处理*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (task_is_stopped_or_traced(p))<span class="comment">/*被调试或被暂停，不方便*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> task_curr(p) || !signal_pending(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>glibc提供了一个API来获取当前线程的阻塞挂起信号，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>该函数很容易产生误解，很多人认为该接口返回的是线程的挂起信号，即还没有来得及处理的信号，这种理解其实是错误的。严格来讲，返回的信号集中的信号必须同时满足以下两个条件：</p>
<ul>
<li>处于挂起状态。</li>
<li>信号属于线程的阻塞信号集。</li>
</ul>
<p>看下内核的<code>do_sigpending</code>函数的内容就不难理解sigpending函数的含义了：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">sigorsets(&amp;pending, &amp;current-&gt;pending.signal,</span><br><span class="line">     &amp;current-&gt;signal-&gt;shared_pending.signal);</span><br><span class="line">spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">sigandsets(&amp;pending, &amp;current-&gt;blocked, &amp;pending);</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (!copy_to_user(<span class="built_in">set</span>, &amp;pending, sigsetsize))</span><br><span class="line">    error = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>因此，返回的挂起阻塞信号集合的计算方式是：</p>
<p>(1）进程共享的挂起信号和线程私有的挂起信号取并集，得到集合1。</p>
<p>(2）对集合1和线程的阻塞信号集取交集，以获得最终的结果。</p>
<p>从此处可以看出，sigprocmask函数会影响到sigpendig函数的输出结果。</p>
<h2 id="致命信号下进程组全体退出"><a href="#致命信号下进程组全体退出" class="headerlink" title="致命信号下进程组全体退出"></a>致命信号下进程组全体退出</h2><p>关于进程的退出，前面已经有所提及，Linux为了应对多线程，提供了exit_group系统调用，确保多个线程一起退出。对于线程收到致命信号的这种情况，操作是类似的。可以通过给每个调度实体的pending上挂上一个SIGKILL信号以确保每个线程都会退出。此处就不再赘述了。</p>
<h1 id="等待信号"><a href="#等待信号" class="headerlink" title="等待信号"></a>等待信号</h1><p>有时候，需要等待某种信号的发生。POSIX中的pause、sigsuspend和sigwait函数提供了三种方法，可以将进程暂时挂起，等待信号来临。</p>
<h2 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h2><p>pause函数将调用线程挂起，使进程进入可中断的睡眠状态，直到传递了一个信号为止。这个信号的动作或者是执行用户定义的信号处理函数，或者是终止进程。如果是执行用户自定义的信号处理函数，那么pause会在信号处理函数执行完毕后返回；如果是终止进程，pause函数就不返回了。如果内核发出的信号被忽略，那么进程就不会被唤醒。pause函数的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>比较有意思的是，pause函数如果可以返回，那它总是返回-1，并且errno为EINTR。</p>
<p>如果希望pause函数等待某个特定的信号，就必须确定哪个信号会让pause返回。事实上，pause并不能主动区分使pause返回的信号是不是正在等待的信号，我们必须间接地完成这个任务。常用的方法是，在期待的特定信号的信号处理函数中，将某变量的值设置为1，待pause返回后，通过查看该变量的值是否为1来判定等待的特定信号是否被捕获，方法如下面的代码所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> sig_received_flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sig_received_flag == <span class="number">0</span>)</span><br><span class="line">    pause();</span><br></pre></td></tr></table></figure></div>

<p>看起来很美好，可是上面的逻辑是有漏洞的。检查sig_received_flag&#x3D;&#x3D;0和调用pause之间存在一个时间窗口，如果在该时间窗口内收到信号，并且信号处理函数将sig_received_flag置1，那么主控制流根本就不知道这件事情，进程就会依然阻塞。也就是说，等待的信号已经到来，但是进程错过了。在收到下一个信号之前，pause函数不会返回，进程也就没有机会发现其实在等待的信号早就已经收到了。因为检查和pause之间存在时间窗口，所以就有了错失信号的情况。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214104854283.png"
                      alt="image-20250214104854283"
                ></p>
<p>下面通过另一个例子来描述一下pause的困境。程序执行过程中，关键部分不期望被信号打断，于是临时阻塞信号，关键部分完成之后，就解除信号的阻塞，然后暂停执行直到有信号到达为止：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*关键代码结束*/</span></span><br><span class="line">sigprocmask(SIG_SETMASK,&amp;orig_mask,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*此处信号可能已经递送给进程了，导致pause无法返回*/</span></span><br><span class="line">pause();</span><br></pre></td></tr></table></figure></div>

<p>可以看到解除对特定信号的阻塞之后，调用pause之前，信号已经被递送给进程，这个信号已经错失了，pause无法等到这个信号，直到下一个信号递送给进程为止，pause函数都无法返回。这就违背了代码的本意：解除对信号的阻塞并且等待该信号的第一次出现。要避免这种情况，必须将解除信号阻塞和挂起进程等待信号这两个动作封装成一个原子操作。这就是引入sigsuspend系统调用的原因。</p>
<h2 id="sigsuspend函数"><a href="#sigsuspend函数" class="headerlink" title="sigsuspend函数"></a>sigsuspend函数</h2><p>在pause之前传递信号是Linux早期遇到的一个困境，并没有好办法来解决这个问题。从本质上讲，必须将解除对信号的阻塞和挂起进程以等待信号的形式封装成一个原子操作，才能解决该问题，而sigsuspend函数就是为了解决这个难题而生的。sigsuspend函数的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果信号终止了进程，那么sigsuspend函数不会返回。如果内核将信号递送给进程，并执行了信号处理函数，那么sigsuspend函数返回-1，并置errno为EINTR。如果mask指针指向的地址不是合法地址，那么sigsuspend函数返回-1，并置errno为EFAULT。sigsuspend函数用mask指向的掩码来设置进程的阻塞掩码，并将进程挂起，直到进程捕捉到信号为止。一旦从信号处理函数中返回，sigsuspend函数就会把进程的阻塞掩码恢复为调用之前的老的阻塞掩码值。</p>
<p>简单地说，sigsuspend相当于以不可中断的方式执行下面的操作：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK,&amp;mask,&amp;old_mask);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK,&amp;old_mask,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div>

<p>有了sigsuspend函数，就可以完成pause()完成不了的任务了</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> sig_received_flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">sigset_t</span> mask_all, mask_most, mask_old;</span><br><span class="line"><span class="type">int</span> signum = SIGUSR1;</span><br><span class="line">sigfillset(&amp;mask_all);</span><br><span class="line">sigfillset(&amp;mask_most);</span><br><span class="line">sigdelset(&amp;mask_most,signum);</span><br><span class="line">sigprocmask(SIG_SETMASK,&amp;mask_all,&amp;mask_old);</span><br><span class="line"><span class="comment">/*不要忘记先判断，因为在sigprocmask阻塞所有信号之前，SIGUSR1可能已经被递送*/</span></span><br><span class="line"><span class="keyword">if</span>(sig_received_flag == <span class="number">0</span>)</span><br><span class="line">    sigsuspend(&amp;mask_most);</span><br><span class="line">sigprocmask(SIG_SETMASK,&amp;mask_old,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div>

<p>假定等待特定信号SIGUSR1，首先要将所有的信号屏蔽掉，如果屏蔽信号之前，已经收到了SIGUSR1，那么<code>sig_received_flag</code>会被设置为1，此时就不需要再调用sigsuspend了，我们已经等到了要等的信号SIGUSR1。如果没收到，则调用sigsuspend，将阻塞掩码设为<code>mask_most</code>，即将所有信号都屏蔽，只有SIGUSR1未被屏蔽。sigsuspend返回时，我们就可以确定，收到了信号SIGUSR1。此时，阻塞掩码也已经恢复成调用sigsuspend之前的<code>mask_all</code>了，然后显式地将阻塞掩码恢复成默认的阻塞掩码<code>mask_old</code>。</p>
<p>等一等，类似于上一节的代码，在判断之后、pause之前，有信号递送，会导致信号错失，那么在上面的代码中，判断sig_received_flag&#x3D;&#x3D;1之后，调用sigsuspend函数之前，是否会有SIGUSR1被递送给进程，再次导致错失信号一次？答案是否定的，因为我们已经通过setprocmask函数阻塞了所有的信号，因此SIGUSR1没有机会被递送给进程。上面的代码虽然完成了等待某特定信号的任务，但是它也有副作用，就是在等待特定信号期间，所有的其他信号都不能递送，原因是sigsuspend的mask阻塞了SIGUSR1以外的所有信号，导致其他信号无法正常递送。下面的代码对这种情况做了改进：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> sig_received_flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">sigset_t</span> mask_blocked, mask_old, mask_unblocked;</span><br><span class="line"><span class="type">int</span> signum = SIGUSR1;</span><br><span class="line">sigprocmask(SIGSETMASK,<span class="literal">NULL</span>,&amp;mask_blocked);</span><br><span class="line">sigprocmask(SIGSETMASK,<span class="literal">NULL</span>,&amp;mask_unblocked);</span><br><span class="line">sigaddset(&amp;mask_blocked,signum);</span><br><span class="line">sigdelset(&amp;mask_unblocked,signum);</span><br><span class="line"><span class="comment">/*将SIGUSR1添加到阻塞掩码中，确保下面判断sig_received_flag和sigsuspend之间不会收到SIGUSR1信号，从而导致SIGUSR1错失*/</span></span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;mask_blocked,&amp;mask_old);</span><br><span class="line"><span class="comment">/*sigsuspend返回，可能是由其他信号引起的，*因此需要再次判断sig_received_flag是否置1*/</span></span><br><span class="line"><span class="keyword">while</span>(sig_received_flag == <span class="number">0</span>)</span><br><span class="line">     sigsuspend(&amp;mask_unblocked);</span><br><span class="line"><span class="comment">/*将信号恢复成默认值*/</span></span><br><span class="line">sigprocmask(SIG_SETMASK,&amp;mask_old,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div>

<p>上面的例子不仅做到了等待特定信号SIGUSR1，而且期间如果有其他信号，也不会影响其他信号的递送。至此等待特定信号的任务算是圆满地解决了。</p>
<h2 id="sigwait函数和sigwaitinfo函数"><a href="#sigwait函数和sigwaitinfo函数" class="headerlink" title="sigwait函数和sigwaitinfo函数"></a>sigwait函数和sigwaitinfo函数</h2><p>sigsuspend函数可以实现等待特定信号的任务，但是上面的示例过于繁复，不够直接。sigwait系列函数就可以比较优雅地等待某个特定信号的到来。sigwait系列函数提供了一种同步接收信号的机制，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> *sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwaitinfo</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">siginfo_t</span> *info)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigtimedwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">siginfo_t</span> *info, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这三个函数虽然接口上有差异，但是总体来说做的事情是一样的。信号集set里面的信号是进程关心的信号。当调用sigwait系列函数中的任何一个时，内核会查看进程的信号挂起队列（包括私有挂起队列和线程组共享的挂起队列），检查set中是否有信号处于挂起状态。如果有，那么sigwait相关的函数会立刻返回，并将信号从相应的挂起队列中移除；如果没有，进程就会陷入阻塞，进入可中断的睡眠状态，直到进程醒来，再次检查挂起队列。</p>
<p>上面是这三个函数的共同之处，不过它们在接口设计上有些许差异。</p>
<ul>
<li>sigwait函数成功返回时，返回值是0，并将导致函数返回的信号记录在sig指向的地址中。如果sigwait调用失败，则返回值不是-1，而是直接将errno返回。</li>
<li>sigwaitinfo函数是升级加强版的sigwait，通过它可以获取到信号相关的更多信息。当第二个siginfo_t结构体类型的指针info不是NULL时，内核会将信号相关的信息填入该指针指向的地址，从而获得导致函数返回的信号的详细信息。和sigwait函数不同，如果sigwaitinfo函数成功返回，那么返回值则是导致函数返回的信号的值（signo），而不是0；如果sigwaitinfo函数失败，则会返回-1，并置errno。</li>
<li>sigtimedwait函数和sigwaitinfo函数几乎是一样的，除了前者约定了一个timeout时间之外。如果到了timeout时间，还未等到set中的信号，sigtimedwait就不再继续等待了，而是返回-1，并置errno为EAGAIN。</li>
</ul>
<p>sigwait系列函数的本质是同步等待信号的到达，所以不需要编写信号处理函数。需要提示的是，纵然某信号遭到了阻塞，sigwaitinfo依然可以获取等待信号。看到这里，不知道读者有没有意识到，引入了sigwait系列函数之后，其实也引入了竞争。正常的信号处理流程，会从信号挂起队列中摘取信号递送给进程，而sigwait函数也会从信号挂起队列中摘取信号，返回给调用进程，两者成了抢生意的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214111245372.png"
                      alt="image-20250214111245372"
                ></p>
<p>所以在调用sigwait系列函数之前，首先需要将set中的信号阻塞，并将set中信号的独家经营权拿到手，否则，如果调用sigwaitinfo之前或两次sigwaitinfo之间有信号到达，很有可能会被正常地递送给进程，进而执行注册的信号处理函数（如果有的话）或执行默认操作SIG_DFL。sigwait系列函数的典型使用方式如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sigusr1 = <span class="number">0</span>;</span><br><span class="line">sigemptyset(&amp;mask_sigusr1);</span><br><span class="line">sigaddset(&amp;mask_sigusr1,SIGUSR1);</span><br><span class="line">sigprocmask(SIG_SETMASK,&amp;mask_sigusr1,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sig = sigwaitinfo(&amp;mask_sigusr1,&amp;si);</span><br><span class="line">    <span class="keyword">if</span>(sig != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigusr1_count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面这个例子是统计收到SIGUSR1的次数。在调用sigwaitinfo之前，需要先调用sigprocmask将等待的信号屏蔽。sigtimedwait函数的用法和sigwaitinfo函数类似，只不过timeout参数指定了最大的等待时长。如果调用超时却没有等到任何信号，那么sigtimedwait就返回-1，并且设errno为EAGAIN。最后，SIGKILL和SIGSTOP不能等待，尝试等待SIGKILL和SIGSTOP会被忽略。原因和无法更改SIGKILL和SIGSTOP信号的信号处理函数一样。</p>
<h1 id="通过文件描述符获取信号"><a href="#通过文件描述符获取信号" class="headerlink" title="通过文件描述符获取信号"></a>通过文件描述符获取信号</h1><p>从内核2.6.22版本开始，Linux提供了另外一种机制来接收信号：通过文件描述符来获取信号即signalfd机制。这个机制和sigwaitinfo非常地类似，都属于同步等待信号的范畴，都需要首先调用sigprocmask将关注的信号屏蔽，以防止被信号处理函数劫走。不同之处在于，文件描述符方法提供了文件系统的接口，可以通过select、poll和epoll来监控这些文件描述符。signalfd接口的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">signalfd</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">sigset_t</span> *mask, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中，mask参数是信号集，表示关注信号的集合。这些信号的集合应该在调用signalfd函数之前，先调用sigprocmask函数阻塞这些信号，以防止被信号处理函数劫走。首次创建时fd参数应该为-1，该函数会创建一个文件描述符，用于读取mask中到来的信号。如果fd不是-1，则表示是修改操作，一般是修改mask的值，此时fd是之前调用signalfd时返回的值。第三个参数flags用来控制行为，目前支持的标志位如下。</p>
<ul>
<li>SFD_CLOEXEC：和普通文件的O_CLOEXEC一样，调用exec函数时，文件描述符会被关闭。</li>
<li>SFD_NONBLOCK：控制将来的读取操作，如果执行read操作时，并没有信号到来，则立刻返回失败，并设置errno为EAGAIN。</li>
</ul>
<p>创建文件描述符后，可以使用read函数来读取到来的信号。提供的缓冲区大小一般要足以放下一个signalfd_siginfo结构体，该结构体一般包括如下成员变量：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span> &#123;</span></span><br><span class="line">   <span class="type">uint32_t</span> ssi_signo;</span><br><span class="line">   <span class="type">int32_t</span>  ssi_errno;</span><br><span class="line">   <span class="type">int32_t</span>  ssi_code;</span><br><span class="line">   <span class="type">uint32_t</span> ssi_pid;</span><br><span class="line">   <span class="type">uint32_t</span> ssi_uid;</span><br><span class="line">   <span class="type">int32_t</span>  ssi_fd;</span><br><span class="line">   <span class="type">uint32_t</span> ssi_tid;</span><br><span class="line">   <span class="type">uint32_t</span> ssi_band;</span><br><span class="line">   <span class="type">uint32_t</span> ssi_overrun;</span><br><span class="line">   <span class="type">uint32_t</span> ssi_trapno;</span><br><span class="line">   <span class="type">int32_t</span>  ssi_status;</span><br><span class="line">   <span class="type">int32_t</span>  ssi_int;</span><br><span class="line">   <span class="type">uint64_t</span> ssi_ptr;</span><br><span class="line">   <span class="type">uint64_t</span> ssi_utime;</span><br><span class="line">   <span class="type">uint64_t</span> ssi_stime;</span><br><span class="line">   <span class="type">uint64_t</span> ssi_addr;</span><br><span class="line">   <span class="type">uint8_t</span>  pad[X];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这个结构体和前面提到的<code>siginfo_t</code>结构体几乎可以一一对应。含义和<code>siginfo_t</code>中的成员也一样，在此就不再赘述了。使用signalfd来接收信号的方法如下（此处忽略了一些异常处理）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK,&amp;mask,<span class="literal">NULL</span>);</span><br><span class="line">sfd = signalfd(<span class="number">-1</span>,&amp;mask,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    n = read(sfd,&amp;fd_siginfo,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_siginfo));</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_siginfo))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*error handle*/</span>&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">/*process the signal*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>比较推荐的做法是用文件描述符signalfd和sigwaitinfo两种方法来处理信号，使用传统信号处理函数会因为异步带来很多问题，大量的函数因不是异步信号安全的，而无法用于信号处理函数。本节介绍的signalfd方法更加值得推荐，因为方法简单，且可以和select、poll和epoll函数配合使用，非常灵活。</p>
<h1 id="信号传递顺序"><a href="#信号传递顺序" class="headerlink" title="信号传递顺序"></a>信号传递顺序</h1><p>有一个非常有意思的话题，当有多个处于挂起状态的信号时，信号递送的顺序又是如何的呢？信号实质上是一种软中断，中断有优先级，信号也有优先级。如果一个进程有多个未决信号，那么对于同一个未决的实时信号，内核将按照发送的顺序来递送信号。如果存在多个未决的实时信号，那么值（或者说编号）越小的越优先被递送。如果既存在不可靠信号，又存在可靠信号（实时信号），虽然POSIX对这一情况没有明确规定，但Linux系统和大多数遵循POSIX标准的操作系统一样，即将优先递送不可靠信号。虽然是优先递送不可靠信号，但在不可靠信号中，不同信号的优先级又是如何的呢？内核如何实现这些这些优先级的顺序呢？内核选择信号递送给进程的流程如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214112042190.png"
                      alt="image-20250214112042190"
                ></p>
<p>下面来分析相关的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dequeue_signal</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="type">sigset_t</span> *mask, <span class="type">siginfo_t</span> *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> signr;</span><br><span class="line">    <span class="comment">/* We only dequeue private signals from ourselves, we don&#x27;t let</span></span><br><span class="line"><span class="comment">     * signalfd steal them</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*线程私有的挂起信号队列优先*/</span></span><br><span class="line">    signr = __dequeue_signal(&amp;tsk-&gt;pending, mask, info);</span><br><span class="line">    <span class="keyword">if</span> (!signr) &#123;</span><br><span class="line">        signr = __dequeue_signal(&amp;tsk-&gt;signal-&gt;shared_pending,</span><br><span class="line">                  mask, info);</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>前文讲过，线程的挂起信号队列有两个：线程私有的挂起队列（pending）和整个线程组共享的挂起队列（signal-&gt;shared_pending）。如上面的代码所示，选择信号的顺序是优先从私有的挂起队列中选择，如果没有找到，则从线程组共享的挂起队列中选择信号递送给线程。当然选择的时候需要考虑线程的阻塞掩码，属于阻塞掩码集中的信号不会被选出。在挂起信号队列（无论是共享挂起队列还是私有挂起队列）中，选择信号的工作交给了next_signal函数，其逻辑如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">next_signal</span><span class="params">(<span class="keyword">struct</span> sigpending *pending, <span class="type">sigset_t</span> *mask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i, *s, *m, x;</span><br><span class="line">    <span class="type">int</span> sig = <span class="number">0</span>;</span><br><span class="line">    s = pending-&gt;signal.sig;</span><br><span class="line">    m = mask-&gt;sig;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Handle the first word specially: it contains the</span></span><br><span class="line"><span class="comment">     * synchronous signals that need to be dequeued first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    x = *s &amp;~ *m;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        <span class="comment">/*优先选择同步信号，所谓同步信号集合就是SIGSEGV、SIGBUS等六种信号*/</span></span><br><span class="line">        <span class="keyword">if</span> (x &amp; SYNCHRONOUS_MASK)</span><br><span class="line">            x &amp;= SYNCHRONOUS_MASK;</span><br><span class="line">        <span class="comment">/*小信号值优先递送的算法*/</span></span><br><span class="line">        sig = ffz(~x) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> sig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (_NSIG_WORDS) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; _NSIG_WORDS; ++i) &#123;</span><br><span class="line">            x = *++s &amp;~ *++m;</span><br><span class="line">            <span class="keyword">if</span> (!x)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sig = ffz(~x) + i*_NSIG_BPW + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        x = s[<span class="number">1</span>] &amp;~ m[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sig = ffz(~x) + _NSIG_BPW + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">/* Nothing to do */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sig;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYNCHRONOUS_MASK \</span></span><br><span class="line"><span class="meta">    (sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \</span></span><br><span class="line"><span class="meta">     sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))</span></span><br></pre></td></tr></table></figure></div>

<p>由于不同平台long的长度不同，所以算法略有不同，但是思想是一样的，如下。</p>
<p>（1）出现在阻塞掩码集中的信号不能被选出。</p>
<p>（2）优先选择同步信号，所谓同步信号指的是以下6种信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;SIGSEGV,SIGBUS,SIGILL,SIGTRAP,SIGFPE,SIGSYS&#125;，</span><br></pre></td></tr></table></figure></div>

<p>这6种信号都是与硬件相关的信号。</p>
<p>（3）如果没有上面6种信号，非实时信号优先；如果存在多种非实时信号，小信号值的信号优先。</p>
<p>（4）如果没有非实时信号，那么实时信号按照信号值递送，小信号值的信号优先递送。</p>
<h1 id="异步信号安全"><a href="#异步信号安全" class="headerlink" title="异步信号安全"></a>异步信号安全</h1><p>设计信号处理函数是一件很头疼的事情，原因就藏在下图中。当内核递送信号给进程时，进程正在执行的指令序列就会被中断，转而执行信号处理函数。待信号处理函数执行完毕返回（如果可以返回的话），则继续执行被中断的正常指令序列。此时，问题就来了，同一个进程中出现了两条执行流，而两条执行流正是信号机制众多问题的根源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214113829908.png"
                      alt="image-20250214113829908"
                ></p>
<p>在信号处理函数中有很多函数都不可以使用，原因就是它们并不是异步信号安全的，强行使用这些不安全的函数隐患重重，还可能带来很诡异的bug。引入多线程后，很多库函数为了保证线程安全，不得不使用锁来保护临界区。比如malloc就是一种典型的场景。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214114137018.png"
                      alt="image-20250214114137018"
                ></p>
<p>加锁保护临界区的方法，虽然不可重入，却是实现线程安全的一种选择。但是这种方法无法保证异步信号安全见表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/image-20250214114215988.png"
                      alt="image-20250214114215988"
                ></p>
<p>还是以malloc为例，如果主程序执行流调用malloc已经持有了锁，但是尚未完成临界区的操作，这时候被信号中断，转而执行信号处理函数，如果信号处理函数中再次调用malloc加锁，就会发生死锁。从上面的讨论可以看出，异步信号安全是一个很苛刻的条件。事实上只有非常有限的函数才能保证异步信号安全。</p>
<p>一般说来，不安全的函数大抵上可以分为以下几种情况：</p>
<ul>
<li>使用了静态变量，典型的是strtok、localtime等函数。</li>
<li>使用了malloc或free函数。</li>
<li>标准I&#x2F;O函数，如printf。</li>
</ul>
<p>读者可以通过<code>man 7 signal</code>的<code>Async-signal-safe functions</code>小节查看异步信号安全的函数列表，在此就不罗列了。本书中有很多地方在信号处理函数中调用了printf函数，其实这是不对的，在真正的工程代码中，是不允许非异步信号安全的函数出现在信号处理函数中的。在正常程序流里面工作得很正常的函数，在异步信号的条件下，会出现很诡异的bug。这种bug的触发，经常依赖信号到达的时间、进程调度等不可控制的时序条件，很难重现。因此编写信号处理函数就像将船驶入暗礁丛生的海域，不可不小心。既然陷阱重重，那该如何使用信号机制呢？</p>
<h2 id="轻量级信号处理函数"><a href="#轻量级信号处理函数" class="headerlink" title="轻量级信号处理函数"></a>轻量级信号处理函数</h2><p>这是一种比较常见的做法，就是信号处理函数非常短，基本就是设置标志位，然后由主程序执行流根据标志位来获知信号已经到达。这种做法可用伪代码的形式表示，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> get_SIGINT = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*信号处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(sig)&#123;    <span class="keyword">case</span> SIGINT:         get_SIGINT = <span class="number">1</span>         <span class="keyword">break</span>;    ...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*主程序流是一个循环*/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(get_SIGINT==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*在主程序流中处理SIGINT*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    job = get_next_job();</span><br><span class="line">    do_single_job(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是一种常见的设计，信号处理函数非常简单，非常轻量，仅仅是设置了一个标志位。程序的主流程会周期性地检查标志，以此来判断是否收到某信号。若收到信号，则执行相应的操作，通常也会将标志重新清零。一般来讲定义标志的时候，会将标志的类型定义成：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> flag;</span><br></pre></td></tr></table></figure></div>

<p><code>sig_atomic_t</code>是C语言标志定义的一种数据类型，该数据类型可以保证读写操作的原子性。而volatile关键字则是告诉编译器，flag的值是易变的，每次使用它的时候，都要到flag的内存地址去取。之所以这么做，是因为编译器会做优化，编译器如果发现两次取flag值之间，并没有代码修改过flag，就有可能将上一次的flag值拿来用。而由于主程序和信号处理不在一个控制流之中，因此编译器几乎总是会做这种优化，这就违背了设计的本意。因此使用volatile来保证主程序流能够看到信号处理函数对flag的修改。</p>
<h2 id="化异步为同步"><a href="#化异步为同步" class="headerlink" title="化异步为同步"></a>化异步为同步</h2><p>由于信号处理函数的存在，进程会同时存在两条执行流，这带来了很多问题，因此操作系统也想了一些办法，就是前面提到的sigwait和signalfd机制。sigwait的设计本意是同步地等待信号。在执行流中，执行sigwait函数会陷入阻塞，直到等待的信号降临。一般来讲，sigwait用在多线程的程序中，而等待信号降临的使命，一般落在主线程身上。具体做法如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sigfillset(&amp;set_all);</span><br><span class="line">sigprocmask(SIG_SETMASK,&amp;set_all,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    ret = sigwait(&amp;set_all,&amp;signo)；</span><br><span class="line">     <span class="comment">/*处理收到的signo*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>sigwait虽然化异步为同步，但是也废掉了一条执行流。signalfd机制则提供了另外一种思路：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">signalfd</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">sigset_t</span> *mask, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p>具体步骤如下：</p>
<p>（1）将关心的信号放入集合。</p>
<p>（2）调用sigprocmask函数，阻塞关心的信号。</p>
<p>（3）调用signalfd函数，返回一个文件描述符。有了文件描述符，就可以使用select&#x2F;poll&#x2F;epoll等I&#x2F;O多路复用函数来监控它。</p>
<p>这样，当信号来临时，就可以通过read接口来获取到信号的相关信息：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signalfd_info</span> <span class="title">signalfd_info</span>;</span></span><br><span class="line">read(signal_fd,&amp;signalfd_info,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_info));</span><br></pre></td></tr></table></figure></div>

<p>在引入<code>signalfd</code>机制以前，有一种很有意思的化异步为同步的方式被广泛使用。这种技术被称为“<code>self-pipe trick</code>”。简单地讲，就是打开一个无名管道，在信号处理函数中向管道写入一个字节（write函数是异步信号安全的），而主程序从无名管道中读取一个字节。通过这种方式也做到了在主程序流中处理信号的目的。</p>
<p>《Linux高性能服务器编程》一书中，在“统一事件源”一节中详细介绍了这个技术。不过使用的不是无名管道，而是socketpair函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> pipefd[<span class="number">2</span>]</span><br><span class="line"><span class="comment">/*信号处理函数中，向socketpair中写入1个字节，即信号值*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno ;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    send(pipefd[<span class="number">1</span>],(<span class="type">char</span>*)&amp;msg,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    errno = save_errno ;</span><br><span class="line">&#125;</span><br><span class="line">ret = socketpair(PF_UNIX,SOCK_STREAM,<span class="number">0</span>,pipefd);</span><br><span class="line"><span class="comment">/*当I/O多路复用函数，侦测到pipefd[0]，有内容到来时，则使用recv读取*/</span></span><br><span class="line"><span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(pipefd[<span class="number">0</span>],signals,<span class="keyword">sizeof</span>(signals),<span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p>将<code>socketpair</code>的一端置于<code>select/poll/epoll</code>等函数的监控下，当信号到达的时候，信号处理函数会往<code>socketpair</code>的另一端写入1个字节，即信号的值。此时，主程序的<code>select/poll/epoll</code>函数就能侦测到此事，对<code>socketpair</code>执行<code>recv</code>操作，获取到信号处理函数写入的信号值，进行相应的处理。</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p>在 Linux 和其他类 UNIX 系统中，硬件异常信号用于通知进程发生了特定的硬件异常。这些信号通常由内核在检测到某些错误条件时发送给进程。以下是常见的硬件异常信号及其解析：</p>
<h2 id="显式地忽略信号-ignore"><a href="#显式地忽略信号-ignore" class="headerlink" title="显式地忽略信号(ignore)"></a>显式地忽略信号(ignore)</h2><p>内核将会丢弃该信号，信号不会对目标进程产生任何影响。</p>
<h3 id="忽略信号"><a href="#忽略信号" class="headerlink" title="忽略信号"></a>忽略信号</h3><p>忽略信号意味着进程在接收到信号时不执行默认动作或自定义处理程序。可以通过使用 <code>signal</code> 或 <code>sigaction</code> 系统调用将信号的处理程序设置为 <code>SIG_IGN</code> 来忽略信号。例如：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">signal(SIGINT, SIG_IGN);  <span class="comment">// 忽略 SIGINT 信号</span></span><br></pre></td></tr></table></figure></div>

<h3 id="SIGHUP-Hangup"><a href="#SIGHUP-Hangup" class="headerlink" title="SIGHUP (Hangup)"></a>SIGHUP (Hangup)</h3><ul>
<li><strong>信号编号</strong>: 通常为 1。</li>
<li><strong>描述</strong>: 挂起信号。最初用于通知终端断开连接。对于守护进程，通常表示需要重新读取配置文件或重新启动。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
<li><strong>忽略用途</strong>: 如果不希望进程在终端断开连接时被终止，可以选择忽略 SIGHUP。对于守护进程，通常会捕获此信号来实现配置重读，而不是忽略。</li>
</ul>
<h3 id="SIGURG-Urgent-Condition"><a href="#SIGURG-Urgent-Condition" class="headerlink" title="SIGURG (Urgent Condition)"></a>SIGURG (Urgent Condition)</h3><ul>
<li><strong>信号编号</strong>: 通常为 23。</li>
<li><strong>描述</strong>: 紧急条件信号。用于通知进程在套接字上有紧急数据可读（如带外数据）。</li>
<li><strong>默认处理</strong>: 忽略。</li>
<li><strong>忽略用途</strong>: 默认情况下，SIGURG 已经被忽略。如果应用程序不处理带外数据，可以继续忽略此信号。</li>
</ul>
<h3 id="SIGWINCH-Window-Change"><a href="#SIGWINCH-Window-Change" class="headerlink" title="SIGWINCH (Window Change)"></a>SIGWINCH (Window Change)</h3><ul>
<li><strong>信号编号</strong>: 通常为 28。</li>
<li><strong>描述</strong>: 窗口大小改变信号。当终端窗口的大小发生变化时，系统会向前台进程组发送此信号。</li>
<li><strong>默认处理</strong>: 忽略。</li>
<li><strong>忽略用途</strong>: 如果应用程序不关心终端窗口大小的变化，可以忽略此信号。然而，许多终端应用程序会捕获此信号来调整显示内容。</li>
</ul>
<h2 id="终止进程-terminate"><a href="#终止进程-terminate" class="headerlink" title="终止进程(terminate)"></a>终止进程(terminate)</h2><p>在 Linux 系统中，许多信号的默认行为是终止进程。这些信号通常用于通知进程发生了特定事件，进程可以选择捕获这些信号以执行自定义的处理逻辑，或者允许它们按照默认行为终止进程。以下是一些默认会终止进程的信号解析：</p>
<h3 id="SIGHUP-Hangup-1"><a href="#SIGHUP-Hangup-1" class="headerlink" title="SIGHUP (Hangup)"></a><strong>SIGHUP (Hangup)</strong></h3><ul>
<li><strong>信号编号</strong>: 1</li>
<li><strong>描述</strong>: 通知终端断开连接。对于守护进程，通常表示需要重新加载配置。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGINT-Interrupt"><a href="#SIGINT-Interrupt" class="headerlink" title="SIGINT (Interrupt)"></a><strong>SIGINT (Interrupt)</strong></h3><ul>
<li><strong>信号编号</strong>: 2</li>
<li><strong>描述</strong>: 由用户通过终端生成的中断信号（通常是 Ctrl+C）。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGKILL-Kill"><a href="#SIGKILL-Kill" class="headerlink" title="SIGKILL (Kill)"></a><strong>SIGKILL (Kill)</strong></h3><ul>
<li><strong>信号编号</strong>: 9</li>
<li><strong>描述</strong>: 强制终止进程，无法被捕获、阻塞或忽略。</li>
<li><strong>默认处理</strong>: 立即终止进程。</li>
</ul>
<h3 id="SIGUSR1-User-defined-Signal-1"><a href="#SIGUSR1-User-defined-Signal-1" class="headerlink" title="SIGUSR1 (User-defined Signal 1)"></a><strong>SIGUSR1 (User-defined Signal 1)</strong></h3><ul>
<li><strong>信号编号</strong>: 10</li>
<li><strong>描述</strong>: 用户自定义信号，通常用于应用程序内部的自定义事件。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGUSR2-User-defined-Signal-2"><a href="#SIGUSR2-User-defined-Signal-2" class="headerlink" title="SIGUSR2 (User-defined Signal 2)"></a><strong>SIGUSR2 (User-defined Signal 2)</strong></h3><ul>
<li><strong>信号编号</strong>: 12</li>
<li><strong>描述</strong>: 用户自定义信号，类似于 SIGUSR1。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGPIPE-Broken-Pipe"><a href="#SIGPIPE-Broken-Pipe" class="headerlink" title="SIGPIPE (Broken Pipe)"></a><strong>SIGPIPE (Broken Pipe)</strong></h3><ul>
<li><strong>信号编号</strong>: 13</li>
<li><strong>描述</strong>: 当进程向一个没有读端的管道写入数据时触发。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGALRM-Alarm-Clock"><a href="#SIGALRM-Alarm-Clock" class="headerlink" title="SIGALRM (Alarm Clock)"></a><strong>SIGALRM (Alarm Clock)</strong></h3><ul>
<li><strong>信号编号</strong>: 14</li>
<li><strong>描述</strong>: 由 <code>alarm</code> 系统调用设置的计时器到期时产生。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGTERM-Termination"><a href="#SIGTERM-Termination" class="headerlink" title="SIGTERM (Termination)"></a><strong>SIGTERM (Termination)</strong></h3><ul>
<li><strong>信号编号</strong>: 15</li>
<li><strong>描述</strong>: 请求进程终止，通常用于正常的进程关闭。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGSTKFLT-Stack-Fault"><a href="#SIGSTKFLT-Stack-Fault" class="headerlink" title="SIGSTKFLT (Stack Fault)"></a><strong>SIGSTKFLT (Stack Fault)</strong></h3><ul>
<li><strong>信号编号</strong>: 16</li>
<li><strong>描述</strong>: 与协处理器相关的堆栈错误（在现代 Linux 系统中很少使用）。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGVTALRM-Virtual-Alarm-Clock"><a href="#SIGVTALRM-Virtual-Alarm-Clock" class="headerlink" title="SIGVTALRM (Virtual Alarm Clock)"></a><strong>SIGVTALRM (Virtual Alarm Clock)</strong></h3><ul>
<li><strong>信号编号</strong>: 26</li>
<li><strong>描述</strong>: 虚拟计时器到期。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGPROF-Profiling-Timer-Expired"><a href="#SIGPROF-Profiling-Timer-Expired" class="headerlink" title="SIGPROF (Profiling Timer Expired)"></a><strong>SIGPROF (Profiling Timer Expired)</strong></h3><ul>
<li><strong>信号编号</strong>: 27</li>
<li><strong>描述</strong>: 分析计时器到期。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGIO-I-O-Now-Possible"><a href="#SIGIO-I-O-Now-Possible" class="headerlink" title="SIGIO (I&#x2F;O Now Possible)"></a><strong>SIGIO (I&#x2F;O Now Possible)</strong></h3><ul>
<li><strong>信号编号</strong>: 29</li>
<li><strong>描述</strong>: 通知进程可以执行非阻塞 I&#x2F;O 操作。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="SIGPWR-Power-Failure"><a href="#SIGPWR-Power-Failure" class="headerlink" title="SIGPWR (Power Failure)"></a><strong>SIGPWR (Power Failure)</strong></h3><ul>
<li><strong>信号编号</strong>: 30</li>
<li><strong>描述</strong>: 电源故障警告（通常不常用）。</li>
<li><strong>默认处理</strong>: 终止进程。</li>
</ul>
<h3 id="信号处理建议"><a href="#信号处理建议" class="headerlink" title="信号处理建议"></a>信号处理建议</h3><ul>
<li><strong>捕获和处理信号</strong>: 可以通过 <code>signal</code> 或 <code>sigaction</code> 函数捕获信号并定义自定义处理程序，以便在信号发生时执行特定操作，而不是终止进程。</li>
<li><strong>忽略信号</strong>: 某些信号可以被忽略（如 SIGHUP、SIGINT），但不建议忽略所有信号，尤其是 SIGKILL 和 SIGTERM，因为它们用于进程的正常关闭。</li>
<li><strong>调试和日志记录</strong>: 在信号处理程序中添加日志记录，以帮助调试和分析信号触发的原因和上下文。</li>
</ul>
<p>通过合理地处理这些信号，可以提高程序的健壮性和稳定性，确保在各种情况下都能正常运行或安全终止。</p>
<h2 id="生成核心转储文件并终止进程-core"><a href="#生成核心转储文件并终止进程-core" class="headerlink" title="生成核心转储文件并终止进程(core)"></a>生成核心转储文件并终止进程(core)</h2><p>在 Linux 中，当某些信号导致进程终止时，系统会生成一个核心转储文件（core dump），该文件包含进程的内存映像和调试信息。这对于调试和分析进程崩溃的原因非常有用。以下是一些默认情况下会生成核心转储文件并终止进程的信号：</p>
<h3 id="SIGQUIT-Quit"><a href="#SIGQUIT-Quit" class="headerlink" title="SIGQUIT (Quit)"></a><strong>SIGQUIT (Quit)</strong></h3><ul>
<li><strong>信号编号</strong>: 3</li>
<li><strong>描述</strong>: 由用户发出的退出信号（通常是 Ctrl+\），用于请求进程退出并生成核心转储。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGILL-Illegal-Instruction"><a href="#SIGILL-Illegal-Instruction" class="headerlink" title="SIGILL (Illegal Instruction)"></a><strong>SIGILL (Illegal Instruction)</strong></h3><ul>
<li><strong>信号编号</strong>: 4</li>
<li><strong>描述</strong>: 非法指令信号，通常由于执行了非法或未定义的 CPU 指令。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGTRAP-Trace-Breakpoint-Trap"><a href="#SIGTRAP-Trace-Breakpoint-Trap" class="headerlink" title="SIGTRAP (Trace&#x2F;Breakpoint Trap)"></a><strong>SIGTRAP (Trace&#x2F;Breakpoint Trap)</strong></h3><ul>
<li><strong>信号编号</strong>: 5</li>
<li><strong>描述</strong>: 断点陷阱，通常用于调试器中。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGABRT-Abort"><a href="#SIGABRT-Abort" class="headerlink" title="SIGABRT (Abort)"></a><strong>SIGABRT (Abort)</strong></h3><ul>
<li><strong>信号编号</strong>: 6</li>
<li><strong>描述</strong>: 由调用 <code>abort()</code> 函数触发，表示进程异常终止。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGBUS-Bus-Error"><a href="#SIGBUS-Bus-Error" class="headerlink" title="SIGBUS (Bus Error)"></a><strong>SIGBUS (Bus Error)</strong></h3><ul>
<li><strong>信号编号</strong>: 7</li>
<li><strong>描述</strong>: 总线错误，通常由于内存访问对齐错误。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGFPE-Floating-Point-Exception"><a href="#SIGFPE-Floating-Point-Exception" class="headerlink" title="SIGFPE (Floating Point Exception)"></a><strong>SIGFPE (Floating Point Exception)</strong></h3><ul>
<li><strong>信号编号</strong>: 8</li>
<li><strong>描述</strong>: 浮点异常，例如除以零或浮点溢出。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGSEGV-Segmentation-Fault"><a href="#SIGSEGV-Segmentation-Fault" class="headerlink" title="SIGSEGV (Segmentation Fault)"></a><strong>SIGSEGV (Segmentation Fault)</strong></h3><ul>
<li><strong>信号编号</strong>: 11</li>
<li><strong>描述</strong>: 段错误，通常由于非法内存访问。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGXCPU-CPU-Time-Limit-Exceeded"><a href="#SIGXCPU-CPU-Time-Limit-Exceeded" class="headerlink" title="SIGXCPU (CPU Time Limit Exceeded)"></a><strong>SIGXCPU (CPU Time Limit Exceeded)</strong></h3><ul>
<li><strong>信号编号</strong>: 24</li>
<li><strong>描述</strong>: 超过 CPU 时间限制。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGXFSZ-File-Size-Limit-Exceeded"><a href="#SIGXFSZ-File-Size-Limit-Exceeded" class="headerlink" title="SIGXFSZ (File Size Limit Exceeded)"></a><strong>SIGXFSZ (File Size Limit Exceeded)</strong></h3><ul>
<li><strong>信号编号</strong>: 25</li>
<li><strong>描述</strong>: 超过文件大小限制。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="SIGSYS-Bad-System-Call"><a href="#SIGSYS-Bad-System-Call" class="headerlink" title="SIGSYS (Bad System Call)"></a><strong>SIGSYS (Bad System Call)</strong></h3><ul>
<li><strong>信号编号</strong>: 31</li>
<li><strong>描述</strong>: 错误的系统调用。</li>
<li><strong>默认处理</strong>: 生成核心转储文件并终止进程。</li>
</ul>
<h3 id="核心转储文件的使用"><a href="#核心转储文件的使用" class="headerlink" title="核心转储文件的使用"></a>核心转储文件的使用</h3><ul>
<li><p><strong>启用核心转储</strong>: 默认情况下，核心转储可能被限制或禁用。可以使用 <code>ulimit -c</code> 命令来查看或设置核心转储文件的大小限制。例如，<code>ulimit -c unlimited</code> 可以允许生成不受限制大小的核心转储文件。</p>
</li>
<li><p><strong>分析核心转储</strong>: 核心转储文件通常用于调试崩溃问题。可以使用调试器（如 <code>gdb</code>）加载核心文件以查看崩溃时的调用栈和内存状态。例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb /path/to/executable core</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>存储位置和命名</strong>: 核心转储文件的存储位置和命名可以通过 <code>/proc/sys/kernel/core_pattern</code> 配置。可以自定义以便更好地管理和分析。</p>
</li>
</ul>
<p>通过了解和处理这些信号，开发人员可以更有效地诊断和解决程序中的问题，从而提高软件的稳定性和可靠性。</p>
<h2 id="停止进程-stop"><a href="#停止进程-stop" class="headerlink" title="停止进程(stop)"></a>停止进程(stop)</h2><p>在 Linux 中，有一些信号用于停止（暂停）进程的执行。这些信号不会终止进程，而是将其暂停，直到收到继续执行的信号（如 SIGCONT）。以下是与停止进程相关的信号：</p>
<h3 id="SIGSTOP-Stop"><a href="#SIGSTOP-Stop" class="headerlink" title="SIGSTOP (Stop)"></a><strong>SIGSTOP (Stop)</strong></h3><ul>
<li><strong>信号编号</strong>: 19</li>
<li><strong>描述</strong>: 无条件停止进程的执行。这个信号不能被捕获、阻塞或忽略。</li>
<li><strong>默认处理</strong>: 暂停进程。</li>
</ul>
<h3 id="SIGTSTP-Terminal-Stop"><a href="#SIGTSTP-Terminal-Stop" class="headerlink" title="SIGTSTP (Terminal Stop)"></a><strong>SIGTSTP (Terminal Stop)</strong></h3><ul>
<li><strong>信号编号</strong>: 20</li>
<li><strong>描述</strong>: 由用户通过终端生成的停止信号（通常是 Ctrl+Z）。与 SIGSTOP 不同，这个信号可以被捕获或忽略。</li>
<li><strong>默认处理</strong>: 暂停进程。</li>
</ul>
<h3 id="SIGTTIN-Terminal-Input-for-Background-Process"><a href="#SIGTTIN-Terminal-Input-for-Background-Process" class="headerlink" title="SIGTTIN (Terminal Input for Background Process)"></a><strong>SIGTTIN (Terminal Input for Background Process)</strong></h3><ul>
<li><strong>信号编号</strong>: 21</li>
<li><strong>描述</strong>: 当后台进程尝试从终端读取输入时触发。通常用于防止后台进程干扰前台任务。</li>
<li><strong>默认处理</strong>: 暂停进程。</li>
</ul>
<h3 id="SIGTTOU-Terminal-Output-for-Background-Process"><a href="#SIGTTOU-Terminal-Output-for-Background-Process" class="headerlink" title="SIGTTOU (Terminal Output for Background Process)"></a><strong>SIGTTOU (Terminal Output for Background Process)</strong></h3><ul>
<li><strong>信号编号</strong>: 22</li>
<li><strong>描述</strong>: 当后台进程尝试向终端写入输出时触发。</li>
<li><strong>默认处理</strong>: 暂停进程。</li>
</ul>
<h3 id="使用和管理"><a href="#使用和管理" class="headerlink" title="使用和管理"></a>使用和管理</h3><ul>
<li><p><strong>恢复进程</strong>: 一个被停止的进程可以通过发送 SIGCONT 信号来恢复执行。可以使用命令 <code>kill -CONT &lt;pid&gt;</code> 来实现。</p>
</li>
<li><p><strong>信号处理</strong>: 虽然 SIGSTOP 不能被处理，但其他信号（如 SIGTSTP、SIGTTIN、SIGTTOU）可以被捕获和处理。开发人员可以实现自定义的信号处理程序，以便在这些信号触发时执行特定操作。</p>
</li>
<li><p><strong>前后台任务管理</strong>: 这些信号在任务控制中非常有用，允许用户在前台和后台之间切换任务。例如，使用 <code>fg</code> 命令可以将后台任务恢复到前台执行。</p>
</li>
</ul>
<p>通过对这些信号的理解和管理，用户可以更有效地控制进程的执行流，特别是在需要暂停和恢复进程的场景中。</p>
<h2 id="恢复进程的执行-continue"><a href="#恢复进程的执行-continue" class="headerlink" title="恢复进程的执行(continue)"></a>恢复进程的执行(continue)</h2><p>在 Linux 中，<code>SIGCONT</code> 信号用于恢复一个被暂停的进程的执行。这个信号是任务控制的重要组成部分，允许用户在进程被暂停后继续其执行。</p>
<h3 id="SIGCONT-Continue"><a href="#SIGCONT-Continue" class="headerlink" title="SIGCONT (Continue)"></a>SIGCONT (Continue)</h3><ul>
<li><strong>信号编号</strong>: 18</li>
<li><strong>描述</strong>: 用于恢复一个被 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code> 或 <code>SIGTTOU</code> 信号暂停的进程。</li>
<li><strong>默认处理</strong>: 恢复进程的执行。如果进程之前处于暂停状态，那么它将继续运行。</li>
<li><strong>捕获与处理</strong>: <code>SIGCONT</code> 可以被进程捕获和处理，这意味着进程可以在接收到 <code>SIGCONT</code> 时执行特定的操作。不过，默认行为是继续执行，不需要额外处理。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p><strong>恢复暂停的进程</strong>: 当一个进程被暂停（例如，通过 <code>SIGSTOP</code> 或用户按下 Ctrl+Z 发送 <code>SIGTSTP</code>），可以通过发送 <code>SIGCONT</code> 来恢复它。可以使用命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -CONT &lt;pid&gt;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>&lt;pid&gt;</code> 是进程的 ID。</p>
</li>
<li><p><strong>任务控制</strong>: 在命令行中，用户可以使用 <code>bg</code> 命令将暂停的任务放到后台继续执行，或使用 <code>fg</code> 命令将其恢复到前台。这些命令隐式地使用 <code>SIGCONT</code> 信号。</p>
</li>
<li><p><strong>信号处理</strong>: 虽然 <code>SIGCONT</code> 的默认行为是继续执行，但进程可以设置一个信号处理程序来在接收到 <code>SIGCONT</code> 时执行一些恢复操作，如重新初始化某些资源或状态。</p>
</li>
</ol>
<p><strong>示例</strong></p>
<p>假设你有一个正在运行的进程，你可以通过以下步骤暂停并恢复它：</p>
<ol>
<li><strong>暂停进程</strong>: 使用 <code>kill -STOP &lt;pid&gt;</code> 或在终端中按下 <code>Ctrl+Z</code>。</li>
<li><strong>恢复进程</strong>: 使用 <code>kill -CONT &lt;pid&gt;</code> 或在终端中使用 <code>bg</code> 或 <code>fg</code>。</li>
</ol>
<p>通过理解 <code>SIGCONT</code> 及其相关信号，用户可以更有效地管理进程的生命周期，特别是在需要暂停和恢复进程的场景中。</p>
<h2 id="信号安装"><a href="#信号安装" class="headerlink" title="信号安装"></a>信号安装</h2><p>在 Linux 和其他类 Unix 系统中，信号处理是一个重要的机制，用于进程间通信和异常处理。以下是一些常用的信号安装函数及其详细说明：</p>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a><code>signal()</code></h3><ul>
<li><p><strong>描述</strong>: 最基本的信号处理安装函数，用于设置一个信号处理器。</p>
</li>
<li><p><strong>原型</strong>: </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>简单易用，但行为可能因系统实现而异。</li>
<li>在某些系统上，信号处理器在信号到达后会被重置为默认值，这意味着需要在处理器中重新安装。</li>
<li>不支持信号的阻塞和排队。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, handler);  <span class="comment">// 设置 SIGINT 的处理器</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<hr>
<h3 id="sysv-signal"><a href="#sysv-signal" class="headerlink" title="sysv_signal()"></a><code>sysv_signal()</code></h3><ul>
<li><p><strong>描述</strong>: 提供 System V 风格的信号处理。</p>
</li>
<li><p><strong>原型</strong>: </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*sysv_signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>自动重置: 默认情况下，当信号被捕获后，信号处理程序会被自动重置为默认行为。这意味着每次捕获信号后，需要重新设置信号处理程序。</li>
<li>信号阻塞: 在信号处理程序执行期间，当前信号通常不会被阻塞，这可能导致信号处理程序重入。</li>
<li>可移植性: sysv_signal 是 System V 的特性，在现代系统中通常不推荐使用，因为它的行为可能不一致。</li>
</ul>
</li>
<li><p><strong>示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sysv_signal(SIGINT, handler);  <span class="comment">// 设置 SIGINT 的处理器</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="bsd-signal"><a href="#bsd-signal" class="headerlink" title="bsd_signal()"></a><code>bsd_signal()</code></h3><ul>
<li><p><strong>描述</strong>: 提供 BSD 风格的信号处理。</p>
</li>
<li><p><strong>原型</strong>: </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*bsd_signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>自动重置</strong>: 默认情况下，当信号被捕获后，信号处理程序不会自动重置为默认行为。这意味着信号处理程序在信号被捕获后仍然有效。</li>
<li><strong>信号阻塞</strong>: 在信号处理程序执行期间，当前信号会被阻塞。这可以防止信号处理程序重入。</li>
<li><strong>可移植性</strong>: 由于 <code>bsd_signal</code> 是 BSD 系统的特性，因此在非 BSD 系统上可能不可用或表现不一致。</li>
</ul>
</li>
<li><p><strong>示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bsd_signal(SIGINT, handler);  <span class="comment">// 设置 SIGINT 的处理器</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<hr>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a><code>sigaction()</code></h3><ul>
<li><strong>描述</strong>: 提供更强大和灵活的信号处理机制，是现代 Unix 系统中推荐的信号处理方式。</li>
<li><strong>原型</strong>: <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>特点</strong>:<ul>
<li>支持信号的阻塞和排队，允许更复杂的信号处理。</li>
<li><code>struct sigaction</code> 结构体包含信号处理器、信号掩码和标志位，提供更精细的控制。</li>
<li>信号处理器不会被自动重置。</li>
<li>可以设置额外的标志，如 <code>SA_RESTART</code>，用于自动重启被信号中断的系统调用。</li>
</ul>
</li>
</ul>
<h4 id="struct-sigaction-结构体"><a href="#struct-sigaction-结构体" class="headerlink" title="struct sigaction 结构体"></a><code>struct sigaction</code> 结构体</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);    <span class="comment">// 信号处理器或 SIG_IGN, SIG_DFL</span></span><br><span class="line">    <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;               <span class="comment">// 在处理信号时要阻塞的信号集</span></span><br><span class="line">    <span class="type">int</span>      sa_flags;              <span class="comment">// 选项标志</span></span><br><span class="line">    <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);  <span class="comment">// 已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>sa_handler</code>：指定信号处理函数，或使用 <code>SIG_IGN</code> 忽略信号，或 <code>SIG_DFL</code> 使用默认处理。</li>
<li><code>sa_sigaction</code>：用于处理带有附加信息的信号（需要设置 <code>SA_SIGINFO</code> 标志）。</li>
<li><code>sa_mask</code>：在处理该信号时要阻塞的其他信号。</li>
<li><code>sa_flags</code>：控制信号处理行为的标志，如 <code>SA_RESTART</code>、<code>SA_SIGINFO</code> 等。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;  <span class="comment">// 使用默认标志</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);  <span class="comment">// 初始化信号集为空</span></span><br><span class="line"></span><br><span class="line">    sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);  <span class="comment">// 安装 SIGINT 的处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h3 id="SYSCALL"><a href="#SYSCALL" class="headerlink" title="SYSCALL"></a><code>SYSCALL</code></h3><p>在 Linux 中，信号处理通常通过用户空间的库函数（如 <code>signal</code> 或 <code>sigaction</code>）来完成。然而，底层实现是通过系统调用（syscall）来实现的。在 Linux 内核中，信号处理可以通过以下系统调用来实现：</p>
<h4 id="rt-sigaction"><a href="#rt-sigaction" class="headerlink" title="rt_sigaction"></a><code>rt_sigaction</code></h4><ul>
<li><p><strong>描述</strong>: <code>rt_sigaction</code> 是现代 Linux 系统中用于安装信号处理器的系统调用，支持实时信号。</p>
</li>
<li><p><strong>原型</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rt_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact, <span class="type">size_t</span> sigsetsize)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>signum</code>: 信号编号。</li>
<li><code>act</code>: 指向 <code>struct sigaction</code>，用于指定新的信号行为。</li>
<li><code>oldact</code>: 指向 <code>struct sigaction</code>，用于保存旧的信号行为。</li>
<li><code>sigsetsize</code>: <code>sigset_t</code> 的大小，通常使用 <code>sizeof(sigset_t)</code>。</li>
</ul>
</li>
<li><p><strong>使用示例</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line"></span><br><span class="line">    syscall(SYS_rt_sigaction, SIGINT, &amp;sa, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sigset_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="sigprocmask-rt-sigprocmask"><a href="#sigprocmask-rt-sigprocmask" class="headerlink" title="sigprocmask &#x2F; rt_sigprocmask"></a><code>sigprocmask</code> &#x2F; <code>rt_sigprocmask</code></h4><ul>
<li><p><strong>描述</strong>: 用于修改进程的信号屏蔽字。</p>
</li>
<li><p><strong>原型</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rt_sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset, <span class="type">size_t</span> sigsetsize)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>how</code>: 指定如何修改信号掩码，可以是 <code>SIG_BLOCK</code>, <code>SIG_UNBLOCK</code>, <code>SIG_SETMASK</code>。</li>
<li><code>set</code>: 指向新的信号掩码。</li>
<li><code>oldset</code>: 指向旧的信号掩码。</li>
<li><code>sigsetsize</code>: <code>sigset_t</code> 的大小。</li>
</ul>
</li>
<li><p><strong>使用示例</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞 SIGINT</span></span><br><span class="line">    syscall(SYS_rt_sigprocmask, SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sigset_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is blocked. Press Ctrl+C now will not stop the program.\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除阻塞 SIGINT</span></span><br><span class="line">    syscall(SYS_rt_sigprocmask, SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sigset_t</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is unblocked.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>使用系统调用需要通过 <code>syscall</code> 函数来实现，<code>SYS_rt_sigaction</code> 和 <code>SYS_rt_sigprocmask</code> 是系统调用号。</li>
<li>这些系统调用提供了更底层的接口，通常不直接在应用程序中使用，而是通过标准库函数间接使用。</li>
<li><code>rt_sigaction</code> 和 <code>rt_sigprocmask</code> 是现代 Linux 系统中推荐使用的接口，支持实时信号和更大的信号集。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>signal()</code> 是最简单的信号处理方式，但在不同系统上可能有不同的行为。</li>
<li><code>sysv_signal()</code> 和 <code>bsd_signal()</code> 提供 System V 和 BSD 风格的信号处理，适合需要特定兼容性的应用。</li>
<li><code>sigaction()</code> 是最灵活和强大的信号处理方式，推荐在现代 Unix 系统中使用。它提供了对信号处理的更精细控制，并且在信号处理后不会自动重置处理器。</li>
</ul>
<h2 id="信号发送"><a href="#信号发送" class="headerlink" title="信号发送"></a>信号发送</h2><p>在 Linux 和其他类 UNIX 系统中，信号发送函数用于向进程或线程发送信号。以下是 <code>kill</code>, <code>tkill</code>, <code>tgkill</code>, <code>raise</code>, 和 <code>sigqueue</code> 等函数的解析：</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a><code>kill</code></h3><ul>
<li><strong>功能</strong>: 向指定的进程或进程组发送信号。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>pid</code>: 接收信号的进程 ID 或者进程组 ID。<ul>
<li><blockquote>
<p>0: 发送信号给指定进程。</p>
</blockquote>
</li>
<li>&#x3D;0: 发送信号给调用进程所在的进程组中的所有进程。</li>
<li>&lt;0: 发送信号给进程组 ID 为 <code>-pid</code> 的所有进程。</li>
</ul>
</li>
<li><code>sig</code>: 要发送的信号编号。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill(<span class="number">1234</span>, SIGTERM);  <span class="comment">// 向进程 ID 为 1234 的进程发送 SIGTERM 信号</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="tkill"><a href="#tkill" class="headerlink" title="tkill"></a><code>tkill</code></h3><ul>
<li><strong>功能</strong>: 向指定线程发送信号。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tkill</span><span class="params">(<span class="type">pid_t</span> tid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>tid</code>: 接收信号的线程 ID。</li>
<li><code>sig</code>: 要发送的信号编号。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkill(<span class="number">5678</span>, SIGUSR1);  <span class="comment">// 向线程 ID 为 5678 的线程发送 SIGUSR1 信号</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="tgkill"><a href="#tgkill" class="headerlink" title="tgkill"></a><code>tgkill</code></h3><ul>
<li><strong>功能</strong>: 向指定线程发送信号，同时指定进程 ID，避免信号发送到错误的进程。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tgkill</span><span class="params">(<span class="type">pid_t</span> tgid, <span class="type">pid_t</span> tid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>tgid</code>: 线程所在的进程 ID。</li>
<li><code>tid</code>: 接收信号的线程 ID。</li>
<li><code>sig</code>: 要发送的信号编号。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgkill(<span class="number">1234</span>, <span class="number">5678</span>, SIGUSR2);  <span class="comment">// 向进程 ID 为 1234 中线程 ID 为 5678 的线程发送 SIGUSR2 信号</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a><code>raise</code></h3><ul>
<li><strong>功能</strong>: 向调用进程发送信号。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>sig</code>: 要发送的信号编号。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回非零值。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise(SIGINT);  <span class="comment">// 向调用进程自身发送 SIGINT 信号</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigqueue"><a href="#sigqueue" class="headerlink" title="sigqueue"></a><code>sigqueue</code></h3><ul>
<li><p><strong>功能</strong>: 向指定进程发送信号，并携带一个用户定义的值。</p>
</li>
<li><p><strong>原型</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pid</code>: 接收信号的进程 ID。</li>
<li><code>sig</code>: 要发送的信号编号。</li>
<li><code>value</code>: 联合类型 <code>sigval</code>，可以包含一个整数或指针，用于传递附加信息。</li>
</ul>
<p><code>union sigval</code> 是一个用于信号处理的联合体，特别是在使用 <code>sigqueue</code> 函数时，用于传递附加信息。它允许用户在发送信号时附带一个整数或指针值，这在发送实时信号时尤其有用。</p>
<blockquote>
<p><strong><code>union sigval</code> 定义</strong></p>
<p><code>union sigval</code> 的定义通常如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   sival_int;   <span class="comment">// 整数值</span></span><br><span class="line">    <span class="type">void</span> *sival_ptr;   <span class="comment">// 指针值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>成员解析</strong></p>
<ul>
<li><strong><code>sival_int</code></strong>:<ul>
<li>类型为 <code>int</code>。</li>
<li>用于传递一个整数值。</li>
<li>在某些应用中，可以用作标识符、状态码或其他需要传递的整数信息。</li>
</ul>
</li>
<li><strong><code>sival_ptr</code></strong>:<ul>
<li>类型为 <code>void *</code>。</li>
<li>用于传递一个指针值。</li>
<li>可以指向任意类型的数据结构，允许传递复杂的数据。</li>
<li>需要注意的是，传递指针时，接收方必须在同一地址空间中（例如，同一进程内的线程之间），否则指针将无效。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><p><strong>用法示例</strong></p>
</li>
</ul>
<p>在使用 <code>sigqueue</code> 函数时，可以选择使用 <code>sival_int</code> 或 <code>sival_ptr</code> 来传递附加信息：</p>
  <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (si-&gt;si_code == SI_QUEUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d with value: %d\n&quot;</span>, sig, si-&gt;si_value.sival_int);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sa.sa_sigaction = signal_handler;</span><br><span class="line">    sigaction(SIGRTMIN, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">value</span>;</span></span><br><span class="line">    value.sival_int = <span class="number">42</span>;  <span class="comment">// 传递整数值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();  <span class="comment">// 获取当前进程的 PID</span></span><br><span class="line">    sigqueue(pid, SIGRTMIN, value);  <span class="comment">// 发送信号并传递附加值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><code>union sigval</code> 主要用于实时信号（如 <code>SIGRTMIN</code> 和 <code>SIGRTMAX</code>）的附加数据传递。</li>
<li>当使用 <code>sival_ptr</code> 时，确保指针指向的内存在信号处理期间是有效的，并且发送和接收方在同一地址空间中。</li>
<li><code>siginfo_t</code> 结构体的 <code>si_value</code> 成员用于接收 <code>union sigval</code> 传递的值，通常在信号处理程序中使用。</li>
</ul>
<p>  通过 <code>union sigval</code>，用户可以在发送信号时传递额外的信息，增强了信号处理的灵活性和功能性。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>kill</code> 是最常用的信号发送函数，用于发送信号给进程或进程组。</li>
<li><code>tkill</code> 和 <code>tgkill</code> 是 Linux 特有的，用于发送信号到特定线程，<code>tgkill</code> 提供了更精确的控制。</li>
<li><code>raise</code> 用于向自身进程发送信号。</li>
<li><code>sigqueue</code> 可以发送带有附加数据的信号，通常用于实时信号。</li>
</ul>
<h2 id="信号同步"><a href="#信号同步" class="headerlink" title="信号同步"></a>信号同步</h2><p>在 Linux 和其他类 UNIX 系统中，信号等待函数用于挂起进程或线程的执行，直到接收到信号。以下是 <code>pause</code>, <code>sigsuspend</code>, <code>sigwait</code>, <code>sigwaitinfo</code>, 和 <code>sigtimedwait</code> 等函数的用法解析：</p>
<h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a><code>pause</code></h3><ul>
<li><strong>功能</strong>: 挂起调用进程，直到捕获到一个信号。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>返回值</strong>:<ul>
<li><code>pause</code> 总是返回 <code>-1</code>，并将 <code>errno</code> 设置为 <code>EINTR</code>，因为它唯一的退出方式是通过信号处理程序。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal %d received\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, handler); <span class="comment">// 设置信号处理程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for signal...\n&quot;</span>);</span><br><span class="line">    pause(); <span class="comment">// 等待信号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigsuspend"><a href="#sigsuspend" class="headerlink" title="sigsuspend"></a><code>sigsuspend</code></h3><ul>
<li><p><strong>功能</strong>: 暂时替换进程的信号掩码，并挂起进程直到捕获到信号。</p>
</li>
<li><p><strong>原型</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>mask</code>: 新的信号掩码，指定哪些信号应该被阻塞。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>总是返回 <code>-1</code>，并将 <code>errno</code> 设置为 <code>EINTR</code>。</li>
</ul>
</li>
<li><p><strong>用法示例</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal %d received\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for signal...\n&quot;</span>);</span><br><span class="line">    sigsuspend(&amp;mask); <span class="comment">// 临时替换信号掩码并等待信号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigwait"><a href="#sigwait" class="headerlink" title="sigwait"></a><code>sigwait</code></h3><ul>
<li><strong>功能</strong>: 阻塞直到指定信号集中的一个信号被捕获，并将信号编号返回。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> *sig)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 信号集，包含要等待的信号。</li>
<li><code>sig</code>: 用于存储接收到的信号编号。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回错误码。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>); <span class="comment">// 阻塞 SIGINT</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for SIGINT...\n&quot;</span>);</span><br><span class="line">    sigwait(&amp;mask, &amp;sig); <span class="comment">// 等待 SIGINT</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal %d received\n&quot;</span>, sig);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigwaitinfo"><a href="#sigwaitinfo" class="headerlink" title="sigwaitinfo"></a><code>sigwaitinfo</code></h3><ul>
<li><strong>功能</strong>: 类似于 <code>sigwait</code>，但还提供信号的附加信息。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwaitinfo</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">siginfo_t</span> *info)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 信号集，包含要等待的信号。</li>
<li><code>info</code>: 用于存储信号的附加信息。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回接收到的信号编号。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="type">siginfo_t</span> info;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>); <span class="comment">// 阻塞 SIGINT</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for SIGINT...\n&quot;</span>);</span><br><span class="line">    sigwaitinfo(&amp;mask, &amp;info); <span class="comment">// 等待 SIGINT</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal %d received\n&quot;</span>, info.si_signo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigtimedwait"><a href="#sigtimedwait" class="headerlink" title="sigtimedwait"></a><code>sigtimedwait</code></h3><ul>
<li><strong>功能</strong>: 类似于 <code>sigwaitinfo</code>，但允许指定超时时间。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigtimedwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">siginfo_t</span> *info, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 信号集，包含要等待的信号。</li>
<li><code>info</code>: 用于存储信号的附加信息。</li>
<li><code>timeout</code>: 超时时间，使用 <code>timespec</code> 结构体指定。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回接收到的信号编号。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="type">siginfo_t</span> info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>); <span class="comment">// 阻塞 SIGINT</span></span><br><span class="line"></span><br><span class="line">    timeout.tv_sec = <span class="number">5</span>;  <span class="comment">// 设置超时时间为 5 秒</span></span><br><span class="line">    timeout.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for SIGINT with timeout...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sigtimedwait(&amp;mask, &amp;info, &amp;timeout) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigtimedwait&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Signal %d received\n&quot;</span>, info.si_signo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>pause</code> 和 <code>sigsuspend</code> 用于挂起进程直到捕获到信号。</li>
<li><code>sigwait</code>, <code>sigwaitinfo</code>, 和 <code>sigtimedwait</code> 用于在阻塞状态下等待信号，并可以选择获取信号的附加信息。</li>
<li><code>sigwaitinfo</code> 和 <code>sigtimedwait</code> 提供了更丰富的信号信息，而 <code>sigtimedwait</code> 还允许设置超时时间。</li>
</ul>
<h2 id="其他常用API"><a href="#其他常用API" class="headerlink" title="其他常用API"></a>其他常用API</h2><p><code>signalfd</code> 是 Linux 提供的一个用于信号处理的系统调用，它允许应用程序通过文件描述符来接收信号。这种方法可以将信号处理整合到基于文件描述符的事件循环中，比如 <code>select</code>、<code>poll</code> 或 <code>epoll</code>，从而简化了信号处理逻辑。</p>
<h3 id="signalfd"><a href="#signalfd" class="headerlink" title="signalfd"></a><code>signalfd</code></h3><ul>
<li><p><strong>头文件</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>原型</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">signalfd</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">sigset_t</span> *mask, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>fd</code>: 如果为 <code>-1</code>，则创建一个新的 signalfd 文件描述符；如果是一个有效的文件描述符，则修改该文件描述符的信号掩码。</li>
<li><code>mask</code>: 指向一个 <code>sigset_t</code>，指定要监控的信号集。</li>
<li><code>flags</code>: 控制文件描述符的行为，可以是以下标志的组合：<ul>
<li><code>SFD_CLOEXEC</code>: 在执行 <code>exec</code> 系列函数时关闭文件描述符。</li>
<li><code>SFD_NONBLOCK</code>: 以非阻塞模式打开文件描述符。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回一个新的文件描述符。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li><strong>创建信号集</strong>: 使用 <code>sigemptyset</code>、<code>sigaddset</code> 等函数初始化和设置信号集。</li>
<li><strong>阻塞信号</strong>: 使用 <code>sigprocmask</code> 阻塞要通过 <code>signalfd</code> 接收的信号，防止它们被默认处理。</li>
<li><strong>创建 signalfd</strong>: 使用 <code>signalfd</code> 创建一个文件描述符，用于接收信号。</li>
<li><strong>读取信号</strong>: 使用 <code>read</code> 从 signalfd 读取信号信息。</li>
</ol>
<h4 id="signalfd-siginfo-结构体"><a href="#signalfd-siginfo-结构体" class="headerlink" title="signalfd_siginfo 结构体"></a><code>signalfd_siginfo</code> 结构体</h4><p>从 <code>signalfd</code> 读取的数据是一个或多个 <code>signalfd_siginfo</code> 结构体：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_signo;   <span class="comment">// 信号编号</span></span><br><span class="line">    <span class="type">int32_t</span>  ssi_errno;   <span class="comment">// 错误码</span></span><br><span class="line">    <span class="type">int32_t</span>  ssi_code;    <span class="comment">// 信号来源</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_pid;     <span class="comment">// 发送信号的进程 ID</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_uid;     <span class="comment">// 发送信号的用户 ID</span></span><br><span class="line">    <span class="type">int32_t</span>  ssi_fd;      <span class="comment">// 文件描述符（仅适用于某些信号）</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_tid;     <span class="comment">// 线程 ID</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_band;    <span class="comment">// 事件带</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_overrun; <span class="comment">// 定时器超限次数</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_trapno;  <span class="comment">// 陷阱编号</span></span><br><span class="line">    <span class="type">int32_t</span>  ssi_status;  <span class="comment">// 状态</span></span><br><span class="line">    <span class="type">int32_t</span>  ssi_int;     <span class="comment">// 整数值</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_ptr;     <span class="comment">// 指针值</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_utime;   <span class="comment">// 用户时间</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_stime;   <span class="comment">// 系统时间</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_addr;    <span class="comment">// 内存地址</span></span><br><span class="line">    <span class="type">uint8_t</span>  __pad[<span class="number">48</span>];   <span class="comment">// 填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>用法示例</strong></p>
<p>以下是一个简单的示例，展示如何使用 <code>signalfd</code> 来捕获 <code>SIGINT</code> 信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="type">int</span> sfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span> <span class="title">fdsi</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号集并添加 SIGINT</span></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞 SIGINT 信号</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 signalfd</span></span><br><span class="line">    sfd = signalfd(<span class="number">-1</span>, &amp;mask, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;signalfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for SIGINT (Ctrl+C)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        s = read(sfd, &amp;fdsi, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_siginfo));</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_siginfo)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fdsi.ssi_signo == SIGINT) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received SIGINT\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong></p>
<ul>
<li><code>signalfd</code> 提供了一种通过文件描述符接收信号的机制，使得信号处理可以与其他文件描述符事件统一管理。</li>
<li>使用 <code>signalfd</code> 时，需要先阻塞信号，以确保它们不会被默认处理。</li>
<li>通过 <code>read</code> 函数从 signalfd 读取信号信息，可以获取信号的详细信息。</li>
</ul>
<h3 id="sigemptyset"><a href="#sigemptyset" class="headerlink" title="sigemptyset()"></a><code>sigemptyset()</code></h3><p><code>sigemptyset</code> 是一个用于信号集操作的函数，常用于信号处理程序中。它的主要作用是初始化一个信号集，并将其清空，即将所有信号从集合中移除。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>set</code>: 指向 <code>sigset_t</code> 类型的指针，用于存储信号集。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code> 以指示错误类型。</li>
</ul>
<p><strong>用法</strong></p>
<p><code>sigemptyset</code> 通常用于初始化一个信号集，以便在后续的信号操作中使用。初始化后的信号集不包含任何信号。常见的用法是在设置信号处理程序时，清空信号集，然后根据需要添加或删除特定信号。</p>
<p><strong>示例</strong></p>
<p>下面是一个简单的示例，展示如何使用 <code>sigemptyset</code> 来初始化信号集，并结合 <code>sigaddset</code> 添加信号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号集并清空</span></span><br><span class="line">    <span class="keyword">if</span> (sigemptyset(&amp;<span class="built_in">set</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to initialize signal set&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 SIGINT 信号到信号集中</span></span><br><span class="line">    <span class="keyword">if</span> (sigaddset(&amp;<span class="built_in">set</span>, SIGINT) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to add SIGINT to signal set&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 SIGINT 是否在信号集中</span></span><br><span class="line">    <span class="keyword">if</span> (sigismember(&amp;<span class="built_in">set</span>, SIGINT)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is in the signal set.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is not in the signal set.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>说明</strong></p>
<ol>
<li><strong>初始化</strong>: 使用 <code>sigemptyset</code> 清空信号集 <code>set</code>，确保它不包含任何信号。</li>
<li><strong>添加信号</strong>: 使用 <code>sigaddset</code> 将 <code>SIGINT</code> 信号添加到信号集中。</li>
<li><strong>检查信号</strong>: 使用 <code>sigismember</code> 检查 <code>SIGINT</code> 是否在信号集中。</li>
</ol>
<p><strong>注意事项</strong></p>
<ul>
<li>在对信号集进行任何操作之前，应该先使用 <code>sigemptyset</code> 或 <code>sigfillset</code> 初始化信号集。</li>
<li><code>sigemptyset</code> 是信号集操作的一部分，通常与其他信号集函数（如 <code>sigaddset</code>, <code>sigdelset</code>, <code>sigismember</code>）一起使用，以实现复杂的信号处理逻辑。</li>
</ul>
<p>在 Linux 和其他类 UNIX 系统中，信号集操作函数用于管理和操作信号集。以下是 <code>sigfillset</code>, <code>sigaddset</code>, <code>sigdelset</code>, 和 <code>sigismember</code> 的用法解析：</p>
<h3 id="sigfillset"><a href="#sigfillset" class="headerlink" title="sigfillset"></a><code>sigfillset</code></h3><ul>
<li><strong>功能</strong>: 初始化一个信号集，并将所有可用信号添加到集合中。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 指向 <code>sigset_t</code> 类型的指针，用于存储信号集。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">if</span> (sigfillset(&amp;<span class="built_in">set</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to fill signal set&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigaddset"><a href="#sigaddset" class="headerlink" title="sigaddset"></a><code>sigaddset</code></h3><ul>
<li><strong>功能</strong>: 向信号集中添加一个特定的信号。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 指向 <code>sigset_t</code> 类型的指针，用于存储信号集。</li>
<li><code>signum</code>: 要添加的信号编号。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);  <span class="comment">// 初始化并清空信号集</span></span><br><span class="line"><span class="keyword">if</span> (sigaddset(&amp;<span class="built_in">set</span>, SIGINT) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to add SIGINT to signal set&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigdelset"><a href="#sigdelset" class="headerlink" title="sigdelset"></a><code>sigdelset</code></h3><ul>
<li><strong>功能</strong>: 从信号集中删除一个特定的信号。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 指向 <code>sigset_t</code> 类型的指针，用于存储信号集。</li>
<li><code>signum</code>: 要删除的信号编号。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">sigfillset(&amp;<span class="built_in">set</span>);  <span class="comment">// 初始化并填充信号集</span></span><br><span class="line"><span class="keyword">if</span> (sigdelset(&amp;<span class="built_in">set</span>, SIGINT) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to delete SIGINT from signal set&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigismember"><a href="#sigismember" class="headerlink" title="sigismember"></a><code>sigismember</code></h3><ul>
<li><strong>功能</strong>: 检查特定信号是否在信号集中。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 指向 <code>sigset_t</code> 类型的指针，用于存储信号集。</li>
<li><code>signum</code>: 要检查的信号编号。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>如果信号在集合中，返回 <code>1</code>。</li>
<li>如果信号不在集合中，返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGINT);  <span class="comment">// 添加 SIGINT 到信号集</span></span><br><span class="line"><span class="keyword">if</span> (sigismember(&amp;<span class="built_in">set</span>, SIGINT)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is in the signal set.\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is not in the signal set.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>在 Linux 和其他类 UNIX 系统中，信号相关的 API 提供了一套机制来管理和处理信号。以下是一些常用的信号相关 API，包括 <code>sigprocmask</code> 和 <code>sigpending</code> 等函数的解析：</p>
<h3 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask"></a><code>sigprocmask</code></h3><ul>
<li><strong>功能</strong>: 用于检查或更改进程的信号掩码。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>how</code>: 指定如何修改信号掩码，可取值为 <code>SIG_BLOCK</code>, <code>SIG_UNBLOCK</code>, 或 <code>SIG_SETMASK</code>。<ul>
<li><code>SIG_BLOCK</code>: 将 <code>set</code> 中的信号添加到当前信号掩码中。</li>
<li><code>SIG_UNBLOCK</code>: 从当前信号掩码中移除 <code>set</code> 中的信号。</li>
<li><code>SIG_SETMASK</code>: 将当前信号掩码设置为 <code>set</code>。</li>
</ul>
</li>
<li><code>set</code>: 指向一个信号集，指定要修改的信号。</li>
<li><code>oldset</code>: 如果不为 <code>NULL</code>，存储之前的信号掩码。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> newmask, oldmask;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGINT); <span class="comment">// 添加 SIGINT 到信号集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞 SIGINT，并保存旧的信号掩码</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is blocked\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复旧的信号掩码</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is unblocked\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a><code>sigpending</code></h3><ul>
<li><strong>功能</strong>: 检查当前进程中未决的信号。</li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 用于存储未决信号集。</li>
</ul>
</li>
<li><strong>返回值</strong>:<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><strong>用法示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> pendingset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取未决信号集</span></span><br><span class="line">    <span class="keyword">if</span> (sigpending(&amp;pendingset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigpending&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigismember(&amp;pendingset, SIGINT)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is pending\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is not pending\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Linux环境编程与内核之信号</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2025-02-06 14:48:59</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-03-17 13:15:16
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2025/02/06/Linux环境编程与内核之信号/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Linux环境编程与内核之线程</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">操作系统</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Linux环境编程与内核之信号</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%A6%82%E5%BF%B5"><span class="nav-text">信号概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">信号的完整生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-text">信号的产生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8"><span class="nav-text">硬件异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-text">终端相关的信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-text">软件事件相关的信号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">信号的默认处理函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">信号的分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E4%BF%A1%E5%8F%B7%E7%89%B9%E7%82%B9"><span class="nav-text">传统信号特点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84ONESHOT%E7%89%B9%E6%80%A7"><span class="nav-text">信号的ONESHOT特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%97%B6%E5%B1%8F%E8%94%BD%E8%87%AA%E8%BA%AB%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">信号执行时屏蔽自身的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E9%87%8D%E5%90%AF%E7%89%B9%E6%80%A7"><span class="nav-text">信号中断系统调用的重启特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-text">信号的可靠性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-text">信号的安装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%91%E9%80%81"><span class="nav-text">信号的发送</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kill%E3%80%81tkill%E5%92%8Ctgkill"><span class="nav-text">kill、tkill和tgkill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#raise%E5%87%BD%E6%95%B0"><span class="nav-text">raise函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sigqueue%E5%87%BD%E6%95%B0"><span class="nav-text">sigqueue函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">信号与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">线程之间共享信号处理函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E7%8B%AC%E7%AB%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="nav-text">线程有独立的阻塞信号掩码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E6%8C%82%E8%B5%B7%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%85%B1%E4%BA%AB%E6%8C%82%E8%B5%B7%E4%BF%A1%E5%8F%B7"><span class="nav-text">私有挂起信号和共享挂起信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%B4%E5%91%BD%E4%BF%A1%E5%8F%B7%E4%B8%8B%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%85%A8%E4%BD%93%E9%80%80%E5%87%BA"><span class="nav-text">致命信号下进程组全体退出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%BF%A1%E5%8F%B7"><span class="nav-text">等待信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pause%E5%87%BD%E6%95%B0"><span class="nav-text">pause函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sigsuspend%E5%87%BD%E6%95%B0"><span class="nav-text">sigsuspend函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sigwait%E5%87%BD%E6%95%B0%E5%92%8Csigwaitinfo%E5%87%BD%E6%95%B0"><span class="nav-text">sigwait函数和sigwaitinfo函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%8E%B7%E5%8F%96%E4%BF%A1%E5%8F%B7"><span class="nav-text">通过文件描述符获取信号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%BC%A0%E9%80%92%E9%A1%BA%E5%BA%8F"><span class="nav-text">信号传递顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8"><span class="nav-text">异步信号安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">轻量级信号处理函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%96%E5%BC%82%E6%AD%A5%E4%B8%BA%E5%90%8C%E6%AD%A5"><span class="nav-text">化异步为同步</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%9C%B0%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7-ignore"><span class="nav-text">显式地忽略信号(ignore)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7"><span class="nav-text">忽略信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGHUP-Hangup"><span class="nav-text">SIGHUP (Hangup)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGURG-Urgent-Condition"><span class="nav-text">SIGURG (Urgent Condition)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGWINCH-Window-Change"><span class="nav-text">SIGWINCH (Window Change)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B-terminate"><span class="nav-text">终止进程(terminate)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGHUP-Hangup-1"><span class="nav-text">SIGHUP (Hangup)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGINT-Interrupt"><span class="nav-text">SIGINT (Interrupt)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGKILL-Kill"><span class="nav-text">SIGKILL (Kill)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGUSR1-User-defined-Signal-1"><span class="nav-text">SIGUSR1 (User-defined Signal 1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGUSR2-User-defined-Signal-2"><span class="nav-text">SIGUSR2 (User-defined Signal 2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGPIPE-Broken-Pipe"><span class="nav-text">SIGPIPE (Broken Pipe)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGALRM-Alarm-Clock"><span class="nav-text">SIGALRM (Alarm Clock)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGTERM-Termination"><span class="nav-text">SIGTERM (Termination)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGSTKFLT-Stack-Fault"><span class="nav-text">SIGSTKFLT (Stack Fault)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGVTALRM-Virtual-Alarm-Clock"><span class="nav-text">SIGVTALRM (Virtual Alarm Clock)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGPROF-Profiling-Timer-Expired"><span class="nav-text">SIGPROF (Profiling Timer Expired)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGIO-I-O-Now-Possible"><span class="nav-text">SIGIO (I&#x2F;O Now Possible)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGPWR-Power-Failure"><span class="nav-text">SIGPWR (Power Failure)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%BB%BA%E8%AE%AE"><span class="nav-text">信号处理建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E5%B9%B6%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B-core"><span class="nav-text">生成核心转储文件并终止进程(core)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGQUIT-Quit"><span class="nav-text">SIGQUIT (Quit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGILL-Illegal-Instruction"><span class="nav-text">SIGILL (Illegal Instruction)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGTRAP-Trace-Breakpoint-Trap"><span class="nav-text">SIGTRAP (Trace&#x2F;Breakpoint Trap)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGABRT-Abort"><span class="nav-text">SIGABRT (Abort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGBUS-Bus-Error"><span class="nav-text">SIGBUS (Bus Error)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGFPE-Floating-Point-Exception"><span class="nav-text">SIGFPE (Floating Point Exception)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGSEGV-Segmentation-Fault"><span class="nav-text">SIGSEGV (Segmentation Fault)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGXCPU-CPU-Time-Limit-Exceeded"><span class="nav-text">SIGXCPU (CPU Time Limit Exceeded)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGXFSZ-File-Size-Limit-Exceeded"><span class="nav-text">SIGXFSZ (File Size Limit Exceeded)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGSYS-Bad-System-Call"><span class="nav-text">SIGSYS (Bad System Call)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">核心转储文件的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E8%BF%9B%E7%A8%8B-stop"><span class="nav-text">停止进程(stop)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGSTOP-Stop"><span class="nav-text">SIGSTOP (Stop)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGTSTP-Terminal-Stop"><span class="nav-text">SIGTSTP (Terminal Stop)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGTTIN-Terminal-Input-for-Background-Process"><span class="nav-text">SIGTTIN (Terminal Input for Background Process)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGTTOU-Terminal-Output-for-Background-Process"><span class="nav-text">SIGTTOU (Terminal Output for Background Process)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%A1%E7%90%86"><span class="nav-text">使用和管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C-continue"><span class="nav-text">恢复进程的执行(continue)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGCONT-Continue"><span class="nav-text">SIGCONT (Continue)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%AE%89%E8%A3%85"><span class="nav-text">信号安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#signal"><span class="nav-text">signal()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sysv-signal"><span class="nav-text">sysv_signal()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bsd-signal"><span class="nav-text">bsd_signal()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigaction"><span class="nav-text">sigaction()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SYSCALL"><span class="nav-text">SYSCALL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%8F%91%E9%80%81"><span class="nav-text">信号发送</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kill"><span class="nav-text">kill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tkill"><span class="nav-text">tkill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tgkill"><span class="nav-text">tgkill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#raise"><span class="nav-text">raise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigqueue"><span class="nav-text">sigqueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%90%8C%E6%AD%A5"><span class="nav-text">信号同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pause"><span class="nav-text">pause</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigsuspend"><span class="nav-text">sigsuspend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigwait"><span class="nav-text">sigwait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigwaitinfo"><span class="nav-text">sigwaitinfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigtimedwait"><span class="nav-text">sigtimedwait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8API"><span class="nav-text">其他常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#signalfd"><span class="nav-text">signalfd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigemptyset"><span class="nav-text">sigemptyset()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigfillset"><span class="nav-text">sigfillset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigaddset"><span class="nav-text">sigaddset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigdelset"><span class="nav-text">sigdelset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigismember"><span class="nav-text">sigismember</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigprocmask"><span class="nav-text">sigprocmask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigpending"><span class="nav-text">sigpending</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        123 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>