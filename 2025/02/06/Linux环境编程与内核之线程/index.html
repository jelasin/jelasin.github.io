<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2025/02/06/linux环境编程与内核之线程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="会当身由己，婉转入江湖">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux环境编程与内核之线程">
<meta property="og:url" content="https://jelasin.github.io/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="会当身由己，婉转入江湖">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/images/touxiang.jpg">
<meta property="article:published_time" content="2025-02-06T06:49:11.000Z">
<meta property="article:modified_time" content="2025-08-06T10:44:18.633Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/images/touxiang.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            Linux环境编程与内核之线程 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":true,"image":"/images/touxiang.jpg","description":"会当身由己，婉转入江湖"},"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"kanxue":"https://bbs.kanxue.com/homepage-958172.htm","Github":"https://github.com/jelasin","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":false}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-xs">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    ABOUT
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    KANXUE
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/jelasin">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                ABOUT
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">KANXUE</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/jelasin">GITHUB</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">39</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">125</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Linux环境编程与内核之线程</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-02-06 14:49:11</span>
        <span class="mobile">2025-02-06 14:49:11</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-08-06 18:44:18</span>
            <span class="mobile">2025-08-06 18:44:18</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><p>在Linux下，程序或可执行文件是一个静态的实体，它只是一组指令的集合，没有执行的含义。进程是一个动态的实体，有自己的生命周期。线程是操作系统进程调度器可以调度的最小执行单元。进程和线程的关系如图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250217101916574.png"
                      alt="image-20250217101916574"
                ></p>
<p>一个进程可能包含多个线程，传统意义上的进程，不过是多线程的一种特例，即该进程只包含一个线程。为什么要有多线程？举个生活中的例子，这就好比去银行办理业务。到达银行后，首先找到领导的机器领取一个号码，然后坐下来安心等待。这时候你一定希望，办理业务的窗口越多越好。如果把整个营业大厅当成一个进程的话，那么每一个窗口就是一个工作线程。这种场景在Linux中屡见不鲜。编程的思想和生活中解决问题的想法总是类似的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250217102103826.png"
                      alt="image-20250217102103826"
                ></p>
<p>有人说不必非要使用线程，多个进程也能做到这点。的确如此。<code>Unix/Linux</code>原本的设计是没有线程的，类Unix系统包括Linux从设计上更倾向于使用进程，反倒是<code>Windows</code>因为创建进程的开销巨大，而更加钟爱线程。那么线程是不是一种设计上的冗余呢？其实不是这样的。进程之间，彼此的地址空间是独立的，但线程会共享内存地址空间。同一个进程的多个线程共享一份全局内存区域，包括初始化数据段、未初始化数据段和动态分配的堆内存段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250217102432338.png"
                      alt="image-20250217102432338"
                ></p>
<p>这种共享给线程带来了很多的优势：</p>
<ul>
<li>创建线程花费的时间要少于创建进程花费的时间。</li>
<li>终止线程花费的时间要少于终止进程花费的时间。</li>
<li>线程之间上下文切换的开销，要小于进程之间的上下文切换。</li>
<li>线程之间数据的共享比进程之间的共享要简单。</li>
</ul>
<p>线程间的上下文切换，指的是同一个进程里不同线程之间发生的上下文切换。由于线程原本属于同一个进程，它们会共享地址空间，大量资源共享，切换的代价小于进程之间的切换是自然而然的事情。线程之间通信的代价低于进程之间通信的代价。线程共享地址空间的设计，让多个线程之间的通信变得非常简单。进程之间的通信代价则要高很多。进程之间不得不采用一些进程间通信的手段（如管道、共享内存及信号量等）来协作。前面是从操作系统的角度来分析线程优势的，从用户或应用的视角来分析，多线程的程序也有很多的优势。</p>
<p><strong>发挥多核优势，充分利用CPU资源</strong></p>
<p>CPU是一种资源，如果一方面CPU资源大量闲置，处于IDLE的状态，另一方面很多任务得不到及时的处理，处于排队等待的状态，这就表明资源没有得到有效的利用，本质上是一种浪费。如果存在多个相同的任务，彼此之间并行不悖，互不依赖（或者依赖性很小），那么启动多个线程并发处理，是一个不错的选择。虽然对每个任务而言，处理的时间并没有缩短，但是在相同时间内，处理了更多的任务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250217103346943.png"
                      alt="image-20250217103346943"
                ></p>
<p><strong>更自然的编程模型</strong></p>
<p>有很多程序，天生就适合用多线程。将工作切分成多个模块，并为每个模块分配一个或多个执行单元，更符合人类解决问题的思路。以文本编辑程序为例，用户的输入需要及时响应，必须要有线程来监控鼠标和键盘；如果用户删除了第一页的某一行，后面很多页的格式都会受到影响，这时就需要有文本格式化线程在后台执行格式处理；很多文本编辑软件都有自动保存的功能，第三个线程会周期性地将文件内容写入磁盘；很多文本编辑软件都有检测拼写错误的功能，或许我们需要第四个线程……</p>
<p>上述的分工是很自然的事情，想象一下如果将所有工作都放在一个单线程的进程里面，那么该进程是不是就不得不处理庞杂而又繁芜的事情？程序结构也就会变得异常复杂。没有银弹。多线程带来优势的同时，也存在一些弊端。</p>
<p>（1）多线程的进程，因地址空间的共享让该进程变得更加脆弱</p>
<p>多个线程之中，只要有一个线程不够健壮存在bug（如访问了非法地址引发的段错误），就会导致进程内的所有线程一起完蛋。进程的地址空间互相独立，彼此隔离得更加彻底。多个进程之间互相协同，一个进程存在bug导致异常退出，不会影响到其他进程。</p>
<p>（2）线程模型作为一种并发的编程模型，效率并没有想象的那么高，会出现复杂度高、易出错、难以测试和定位的问题目前存在的并发编程，基本可以分成两类：</p>
<ul>
<li>共享状态式</li>
<li>消息传递式线程模型采用的是第一种。</li>
</ul>
<blockquote>
<p>从现在开始，停止幻想，欢迎来到真实的世界。一个程序员碰到了一个问题，他决定用多线程来解决。现在两个他问题了有。</p>
<p>​	——关于线程的冷笑话</p>
</blockquote>
<p>在真实的场景中，多线程编程是很复杂的。前面所说的多个任务并行不悖，互不依赖，在大多数情况下只是一种美好的幻想。首先，多个线程之间，存在负载均衡的问题，现实中很难将全部任务等分给每个线程。想象一下，如果存在10个线程，一个线程承担了90%的任务，9个线程承担了10%的任务，整体的效率立刻就降了下来。</p>
<p>有人说，怎么会有这么愚蠢的设计呢。试想如下场景：你需要用支持10个并发线程的服务器去计算<code>1~10^10</code>以内的所有素数，要怎么设计？首先进入脑海的第一反应是不是将<code>1~10^10</code>这个范围平均分成10份，每一份有109个数，10个线程分别查找范围内的素数？这就是糟糕的设计，尽管每个线程负责的范围是相同的，但是每个线程的负载并不均匀，因为判断一个较大的数是不是素数，通常要比判断较小的数所花费的时间更长。当然这个例子有比较妥善的解决方案，但是在很多情况下，很难将负载均匀地分配给各个线程。</p>
<p>其次，多个线程的任务之间还可能存在顺序依赖的关系，一个线程未能完成某些操作之前，其他线程不能或不应该运行。</p>
<p>多个线程之间需要同步。多个线程生活在进程地址空间这同一个屋檐下，若存在多个线程操作共享资源，则需要同步，否则可能会出现结果错误、数据结构遭到破坏甚至是程序崩溃等后果。因此多线程编程中存在临界区的概念，临界区的代码只允许一个线程执行，线程提供了锁机制来保护临界区。当其他线程来到临界区却无法申请到锁时，就可能陷入阻塞，不再处于可执行状态，线程可能不得不让出CPU资源。如果设计不合理，临界区非常多，线程之间的竞争异常激烈，频繁地上下文切换也会导致性能急剧恶化。</p>
<p>上面两种情况的存在，决定了多线程并非总是处于并发的状态，加速也并非线性的。4个工作线程未必能带来4倍的效率，加速比取决于可以串行执行的部分在全部工作中所占的比例。有人曾经这样打比方：多进程属于立体交通系统，虽然造价高，上坡下坡比较耗油，但是堵车少；多线程属于平面交通系统，造价低，但是红绿灯太多，老堵车。</p>
<p>多线程模型的复杂度更是不容小觑。很多人诟病多线程模型，就在于它不符合人的心智模型。俗语道，一心不可两用，人很难同时控制多条走走停停，彼此又有交互和同步的控制流。由于进程调度的无序性，严格来说多线程程序的每次执行其实并不一样，很难穷举所有的时序组合，所以我们永远无法宣称多线程的程序经过了充分的测试。在某些特殊时序的条件下，bug可能会出现，这种bug难以复现，而且难以排查。所以编程时，需要谨慎地设计，以确保程序能够在所有的时序条件下正常运行。对于多线程编程，还存在四大陷阱，一不小心就可能落入陷阱之中。这四个陷阱分别是：</p>
<ul>
<li>死锁（Dead Lock）</li>
<li>饿死（Starvation）</li>
<li>活锁（Live Lock）</li>
<li>竞态条件（Race Condition）</li>
</ul>
<p>客观地说，多线程编程的难度要更大一些，需要程序员更加小心，更加谨慎。当你需要使用多线程的时候，一定要花费足够的时间小心地规划每个线程的分工，尽可能地减少线程之间的依赖。良好的设计，合理的分工是多线程编程至关重要的环节。若初期随意地设计线程的分工，那么在最后，你很有可能不得不花费大量的时间来优化性能，定位bug，甚至不得不推倒重来。</p>
<h1 id="进程ID和线程ID"><a href="#进程ID和线程ID" class="headerlink" title="进程ID和线程ID"></a>进程ID和线程ID</h1><p>在Linux中，目前的线程实现是Native POSIX Thread Library，简称NPTL。在这种实现下，线程又被称为轻量级进程（Light Weighted Process），每一个用户态的线程，在内核之中都对应一个调度实体，也拥有自己的进程描述符（<code>task_struct</code>结构体）。</p>
<p>没有线程之前，一个进程对应内核里的一个进程描述符，对应一个进程ID。但是引入了线程的概念之后，情况就发生了变化，一个用户进程下管辖N个用户态线程，每个线程作为一个独立的调度实体在内核态都有自己的进程描述符，进程和内核的进程描述符一下子就变成了1∶N的关系，POSIX标准又要求进程内的所有线程调用getpid函数时返回相同的进程ID。如何解决上述问题呢？</p>
<p>内核引入了线程组（Thread Group）的概念。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span>...</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">pid_t</span> tgid</span><br><span class="line">      ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>多线程的进程，又被称为线程组，线程组内的每一个线程在内核之中都存在一个进程描述符（task_struct）与之对应。进程描述符结构体中的pid，表面上看对应的是进程ID，其实不然，它对应的是线程ID；进程描述符中的tgid，含义是Thread Group ID，该值对应的是用户层面的进程ID。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250217105301113.png"
                      alt="image-20250217105301113"
                ></p>
<p>本节介绍的线程ID，不同于后面会讲到的pthread_t类型的线程ID，和进程ID一样，线程ID是pid_t类型的变量，而且是用来唯一标识线程的一个整型变量。那么如何查看一个线程的ID呢？</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ ps –eLf</span><br><span class="line">...</span><br><span class="line">UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD</span><br><span class="line">syslog     <span class="number">837</span>     <span class="number">1</span>   <span class="number">837</span>  <span class="number">0</span>    <span class="number">4</span> <span class="number">22</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> rsyslogd</span><br><span class="line">syslog     <span class="number">837</span>     <span class="number">1</span>   <span class="number">838</span>  <span class="number">0</span>    <span class="number">4</span> <span class="number">22</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> rsyslogd</span><br><span class="line">syslog     <span class="number">837</span>     <span class="number">1</span>   <span class="number">839</span>  <span class="number">0</span>    <span class="number">4</span> <span class="number">22</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> rsyslogd</span><br><span class="line">syslog     <span class="number">837</span>     <span class="number">1</span>   <span class="number">840</span>  <span class="number">0</span>    <span class="number">4</span> <span class="number">22</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> rsyslogd</span><br><span class="line">...</span><br><span class="line"><span class="comment">// ps命令中的-L选项，会显示出线程的如下信息。</span></span><br><span class="line"><span class="comment">// LWP：线程ID，即gettid（​）系统调用的返回值。</span></span><br><span class="line"><span class="comment">// NLWP：线程组内线程的个数。</span></span><br></pre></td></tr></table></figure></div>

<p>所以从上面可以看出rsyslogd进程是多线程的，进程ID为837，进程内有4个线程，线程ID分别为837、838、839和840</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250217105554968.png"
                      alt="image-20250217105554968"
                ></p>
<p>已知某进程的进程ID，该如何查看该进程内线程的个数及其线程ID呢？其实可以通过<code>/proc/PID/task/</code>目录下的子目录来查看，如下。因为procfs在task下会给进程的每个线程建立一个子目录，目录名为线程ID。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ ll /proc/<span class="number">837</span>/task/总用量 <span class="number">0</span></span><br><span class="line">dr-xr-xr-x <span class="number">6</span> syslog syslog <span class="number">0</span>  <span class="number">4</span>月 <span class="number">16</span> <span class="number">22</span>:<span class="number">32</span> ./</span><br><span class="line">dr-xr-xr-x <span class="number">9</span> syslog syslog <span class="number">0</span>  <span class="number">4</span>月 <span class="number">16</span> <span class="number">22</span>:<span class="number">20</span> ../</span><br><span class="line">dr-xr-xr-x <span class="number">6</span> syslog syslog <span class="number">0</span>  <span class="number">4</span>月 <span class="number">16</span> <span class="number">22</span>:<span class="number">32</span> <span class="number">837</span>/</span><br><span class="line">dr-xr-xr-x <span class="number">6</span> syslog syslog <span class="number">0</span>  <span class="number">4</span>月 <span class="number">16</span> <span class="number">22</span>:<span class="number">32</span> <span class="number">838</span>/</span><br><span class="line">dr-xr-xr-x <span class="number">6</span> syslog syslog <span class="number">0</span>  <span class="number">4</span>月 <span class="number">16</span> <span class="number">22</span>:<span class="number">32</span> <span class="number">839</span>/</span><br><span class="line">dr-xr-xr-x <span class="number">6</span> syslog syslog <span class="number">0</span>  <span class="number">4</span>月 <span class="number">16</span> <span class="number">22</span>:<span class="number">32</span> <span class="number">840</span>/</span><br></pre></td></tr></table></figure></div>

<p>对于线程，Linux提供了gettid系统调用来返回其线程ID，可惜的是glibc并没有将该系统调用封装起来，再开放出接口来供程序员使用。如果确实需要获取线程ID，可以采用如下方法：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> TID = syscall(SYS_gettid);</span><br></pre></td></tr></table></figure></div>

<p>从上面的示例来看，rsyslogd是个多线程的进程，进程ID为837，下面有一个线程的ID也是837，这不是巧合。线程组内的第一个线程，在用户态被称为主线程（main thread），在内核中被称为Group Leader。内核在创建第一个线程时，会将线程组ID的值设置成第一个线程的线程ID，group_leader指针则指向自身，即主线程的进程描述符，如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线程组ID等于主线程的ID，group_leader指向自身*/</span></span><br><span class="line">p-&gt;tgid = p-&gt;pid;</span><br><span class="line">p-&gt;group_leader = p;</span><br><span class="line">INIT_LIST_HEAD(&amp;p-&gt;thread_group);</span><br></pre></td></tr></table></figure></div>

<p>所以可以看到，线程组内存在一个线程ID等于进程ID，而该线程即为线程组的主线程。至于线程组其他线程的ID则由内核负责分配，其线程组ID总是和主线程的线程组ID一致，无论是主线程直接创建的线程，还是创建出来的线程再次创建的线程，都是这样。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">         p-&gt;tgid = current-&gt;tgid;</span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">     p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">     list_add_tail_rcu(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过<code>group_leader</code>指针，每个线程都能找到主线程。主线程存在一个链表头，后面创建的每一个线程都会链入到该双向链表中。利用上述的结构，每个线程都可以轻松地找到其线程组的主线程（通过<code>group_leader</code>指针），另一方面，通过线程组的主线程，也可以轻松地遍历其所有的组内线程（通过链表）。需要强调的一点是，线程和进程不一样，进程有父进程的概念，但在线程组里面，所有的线程都是对等的关系。</p>
<ul>
<li>并不是只有主线程才能创建线程，被创建出来的线程同样可以创建线程。</li>
<li>不存在类似于fork函数那样的父子关系，大家都归属于同一个线程组，进程ID都相等，<code>group_leader</code>都指向主线程，而且各有各的线程ID。</li>
<li>并非只有主线程才能调用<code>pthread_join</code>连接其他线程，同一线程组内的任意线程都可以对某线程执行<code>pthread_join</code>函数。</li>
<li>并非只有主线程才能调用<code>pthread_detach</code>函数，其实任意线程都可以对同一线程组内的线程执行分离操作。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250217110329941.png"
                      alt="image-20250217110329941"
                ></p>
<h1 id="pthread-库接口介绍"><a href="#pthread-库接口介绍" class="headerlink" title="pthread 库接口介绍"></a>pthread 库接口介绍</h1><p>后面详细介绍这些函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250217110840510.png"
                      alt="image-20250217110840510"
                ></p>
<h1 id="线程的创建和标识"><a href="#线程的创建和标识" class="headerlink" title="线程的创建和标识"></a>线程的创建和标识</h1><p>首先要介绍的接口是创建线程的接口，即pthread_create函数。程序开始启动的时候，产生的进程只有一个线程，我们称之为主线程或初始线程。对于单线程的进程而言，只存在主线程一个线程。如果想在主线程之外，再创建一个或多个线程，就需要用到这个接口了。</p>
<h2 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数是pthread_t类型的指针，线程创建成功的话，会将分配的线程ID填入该指针指向的地址。线程的后续操作将使用该值作为线程的唯一标识。</span></span><br><span class="line"><span class="comment">第二个参数是pthread_attr_t类型，通过该参数可以定制线程的属性，比如可以指定新建线程栈的大小、调度策略等。如果创建线程无特殊的要求，该值也可以是NULL，表示采用默认属性。</span></span><br><span class="line"><span class="comment">第三个参数是线程需要执行的函数。创建线程，是为了让线程执行一定的任务。线程创建成功之后，该线程就会执行start_routine函数，该函数之于线程，就如同main函数之于主线程。</span></span><br><span class="line"><span class="comment">第四个参数是新建线程执行的start_routine函数的入参。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *<span class="keyword">restrict</span> thread,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *<span class="keyword">restrict</span> arg)</span>;</span><br></pre></td></tr></table></figure></div>

<p>新建线程如果想要正常工作，则可能需要入参，那么主线程在调用<code>pthread_create</code>的时候，就可以将入参的指针放入第四个参数以传递给新建线程。如果线程的执行函数<code>start_routine</code>需要很多入参，传递一个指针就能提供足够的信息吗？答案是能。线程创建者（一般是主线程）和线程约定一个结构体，创建者便把信息填入该结构体，再将结构体的指针传递给子进程，子进程只要解析该结构体，就能取出需要的信息。如果成功，则<code>pthread_create</code>返回0；如果不成功，则<code>pthread_create</code>返回一个非0的错误码。常见的错误码如表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250219111906392.png"
                      alt="image-20250219111906392"
                ></p>
<p><code>pthread_create</code>函数的返回情况有些特殊，通常情况下，函数调用失败，则返回-1，并且设置errno。pthread_create函数则不同，它会将errno作为返回值，而不是一个负值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">thread_worker</span><span class="params">(<span class="type">void</span> *)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“I am thread worker”);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">pthread_t</span> tid ;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,&amp;thread_worker,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)<span class="comment">/* 注意此处，不能用ret &lt; 0 作为出错判断*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*ret is the errno*/</span></span><br><span class="line">    <span class="comment">/*error handler*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="线程ID及进程地址空间布局"><a href="#线程ID及进程地址空间布局" class="headerlink" title="线程ID及进程地址空间布局"></a>线程ID及进程地址空间布局</h2><p>pthread_create函数，会产生一个线程ID，存放在第一个参数指向的地址中。该线程ID前面提到的线程ID不同。前面提到的线程ID，属于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一标识该线程。而pthread_create函数产生并记录在第一个参数指向地址的线程ID中，属于NPTL线程库的范畴，线程库的后续操作，就是根据该线程ID来操作线程的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程库NPTL提供了pthread_self函数，可以获取到线程自身的ID：</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 在同一个线程组内，线程库提供了接口，可以判断两个线程ID是否对应着同一个线程,</span></span><br><span class="line"><span class="comment">// 返回值是0的时候，表示两个线程是同一个线程，非零值则表示不是同一个线程。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>pthread_t</code>到底是个什么样的数据结构呢？因为POSIX标准并没有限制<code>pthread_t</code>的数据类型，所以该类型取决于具体实现。对于Linux目前使用的NPTL实现而言，pthread_t类型的线程ID，本质就是一个进程地址空间上的一个地址。是时候看一下进程地址空间的布局了。在x86_64平台上，用户地址空间为128TB，对于地址空间的布局，系统有如下控制选项：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/vm/legacy_va_layout</span><br><span class="line">0</span><br></pre></td></tr></table></figure></div>

<p>该选项影响地址空间的布局，主要是影响mmap区域的基地址位置，以及mmap是向上还是向下增长。如果该值为1，那么mmap的基地址mmap_base变小（约在128T的三分之一处），mmap区域从低地址向高地址扩展。如果该值为0，那么mmap区域的基地址在栈的下面（约在128T空间处），mmap区域从高地址向低地址扩展。默认值为0，布局如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250219112606377.png"
                      alt="image-20250219112606377"
                ></p>
<p>可以通过procfs或pmap命令来查看进程的地址空间的情况：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pmap PID</span><br><span class="line">cat /proc/PID/maps</span><br></pre></td></tr></table></figure></div>

<p>在接近128TB的巨大地址空间里面，代码段、已初始化数据段、未初始化数据段，以及主线程的栈，所占用的空间非常小，都是KB、MB这个数量级的，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ pmap <span class="number">3706</span></span><br><span class="line"><span class="number">3706</span>:   ./process_map</span><br><span class="line"><span class="number">0000000000400000</span>      <span class="number">4</span>K r-x-- process_map</span><br><span class="line"><span class="number">0000000000601000</span>      <span class="number">4</span>K r---- process_map</span><br><span class="line"><span class="number">0000000000602000</span>      <span class="number">4</span>K rw--- process_map…</span><br><span class="line"><span class="number">00007f</span>fdd5f68000   <span class="number">5128</span>K rw---   [ <span class="built_in">stack</span> ]  <span class="comment">/*栈在128T位置附近*/</span></span><br></pre></td></tr></table></figure></div>

<p>由于主线程的栈大小并不是固定的，要在运行时才能确定大小（上限大概在8MB左右），因此，在栈中不能存在巨大的局部变量，另外编写递归函数时一定要小心，递归不能太深，否则很可能耗尽栈空间。</p>
<p>进程地址空间之中，最大的两块地址空间是内存映射区域和堆。堆的起始地址特别低，向上扩展，mmap区域的起始地址特别高，向下扩展。用户调用pthread_create函数时，glibc首先要为线程分配线程栈，而线程栈的位置就落在mmap区域。glibc会调用mmap函数为线程分配栈空间。pthread_create函数分配的pthread_t类型的线程ID，不过是分配出来的空间里的一个地址，更确切地说是一个结构体的指针，如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250219112811414.png"
                      alt="image-20250219112811414"
                ></p>
<p>创建两个线程，将其pthread_self（）的返回值打印出来，输出如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address of tid in thread<span class="number">-1</span> = <span class="number">0x7f011ca12700</span></span><br><span class="line">address of tid in thread<span class="number">-2</span> = <span class="number">0x7f011c211700</span></span><br></pre></td></tr></table></figure></div>

<p>线程ID是进程地址空间内的一个地址，要在同一个线程组内进行线程之间的比较才有意义。不同线程组内的两个线程，哪怕两者的pthread_t值是一样的，也不是同一个线程，这是显而易见的。很有意思的一点是，pthread_t类型的线程ID很有可能会被复用。在满足下列条件时，线程ID就有可能会被复用：</p>
<ul>
<li><p>线程退出。</p>
</li>
<li><p>线程组的其他线程对该线程执行了pthread_join，或者线程退出前将分离状态设置为已分离。</p>
</li>
<li><p>再次调用pthread_create创建线程。</p>
</li>
</ul>
<p>对于pthread_t类型的线程ID，虽然在同一时刻不会存在两个线程的ID值相同，但是如果线程退出了，重新创建的线程很可能复用了同一个pthread_t类型的ID。从这个角度看，如果要设计调试日志，用pthread_t类型的线程ID来标识进程就不太合适了。用pid_t类型的线程ID则是一个比较不错的选择。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> TID = syscall(SYS_gettid);</span><br></pre></td></tr></table></figure></div>

<p>采用pid_t类型的线程ID来唯一标识进程有以下优势：</p>
<ul>
<li>返回类型是pid_t类型，进程之间不会存在重复的线程ID，而且不同线程之间也不会重复，在任意时刻都是全局唯一的值。</li>
<li>procfs中记录了线程的相关信息，可以方便地查看&#x2F;proc&#x2F;pid&#x2F;task&#x2F;tid来获取线程对应的信息。</li>
<li>ps命令提供了查看线程信息的-L选项，可以通过输出中的LWP和NLWP，来查看同一个线程组的线程个数及线程ID的信息。</li>
</ul>
<p>另外一个比较有意思的功能是我们可以给线程起一个有意义的名字，命名以后，既可以从procfs中获取到线程的名字，也可以从ps命令中得到线程的名字，这样就可以更好地辨识不同的线程。Linux提供了prctl系统调用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">prctl</span><span class="params">(<span class="type">int</span>  option,  <span class="type">unsigned</span>  <span class="type">long</span> arg2,</span></span><br><span class="line"><span class="params">           <span class="type">unsigned</span> <span class="type">long</span> arg3 , <span class="type">unsigned</span> <span class="type">long</span> arg4,</span></span><br><span class="line"><span class="params">           <span class="type">unsigned</span> <span class="type">long</span> arg5)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_setnamev</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* namefmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">17</span>];</span><br><span class="line">    vsnprintf(name, <span class="keyword">sizeof</span>(name), namefmt, args);</span><br><span class="line">    prctl(PR_SET_NAME, name, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_setname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* namefmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, namefmt);</span><br><span class="line">    thread_setnamev(namefmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line">thread_setname(<span class="string">&quot;BEAN-%d&quot;</span>,num);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这个系统调用和ioctl非常类似，通过option来控制系统调用的行为。当需要给线程设定名字的时候，只需要将option设为<code>PR_SET_NAME</code>，同时将线程的名字作为arg2传递给prctl系统调用即可，这样就能给线程命名了。</p>
<h2 id="线程创建的默认属性"><a href="#线程创建的默认属性" class="headerlink" title="线程创建的默认属性"></a>线程创建的默认属性</h2><p>线程创建的第二个参数是pthread_attr_t类型的指针，pthread_attr_init函数会将线程的属性重置成默认值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span>    attr;</span><br><span class="line">pthread_attr_init(&amp;attr);</span><br></pre></td></tr></table></figure></div>

<p>在创建线程时，传递重置过的属性，或者传递NULL，都可以创建一个具有默认属性的线程，见表:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250219113259111.png"
                      alt="image-20250219113259111"
                ></p>
<p>默认情况下，线程栈的大小为8MB：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ ulimit -s</span><br><span class="line"><span class="number">8192</span></span><br></pre></td></tr></table></figure></div>

<p>调用<code>pthread_attr_getstack</code>函数可以返回线程栈的基地址和栈的大小。出于可移植性的考虑不建议指定线程栈的基地址。但是有时候会有修改线程栈的大小的需要。一个线程需要分配8MB左右的栈空间，就决定了不可能无限地创建线程，在进程地址空间受限的32位系统里尤为如此。在32位系统下，3GB的用户地址空间决定了能创建线程的个数不会太多。如果确实需要很多的线程，可以调用接口来调整线程栈的大小：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr,<span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr,<span class="type">size_t</span> *stacksize)</span>;</span><br></pre></td></tr></table></figure></div>

<h1 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h1><p>有生就有灭，线程执行完任务，也需要终止。下面的三种方法中，线程会终止，但是进程不会终止（如果线程不是进程组里的最后一个线程的话）：</p>
<ul>
<li>创建线程时的start_routine函数执行了return，并且返回指定值。</li>
<li>线程调用pthread_exit。</li>
<li>其他线程调用了pthread_cancel函数取消了该线程。</li>
</ul>
<p>如果线程组中的任何一个线程调用了exit函数，或者主线程在main函数中执行了return语句，那么整个线程组内的所有线程都会终止。</p>
<p>值得注意的是，pthread_exit和线程启动函数（start_routine）执行return是有区别的。在start_routine中调用的任何层级的函数执行pthread_exit（）都会引发线程退出，而return，只能是在start_routine函数内执行才能导致线程退出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果foo函数执行了pthread_exit函数，则线程会立刻退出，后面的bar就会没有机会执行了。</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">start_routine</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    foo();</span><br><span class="line">    bar();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value_ptr是一个指针，存放线程的“临终遗言”。</span></span><br><span class="line"><span class="comment">线程组内的其他线程可以通过调用pthread_join函数接收这个地址，从而获取到退出线程的临终遗言。</span></span><br><span class="line"><span class="comment">如果线程退出时没有什么遗言，则可以直接传递NULL指针.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *value_ptr)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这里有一个问题，就是不能将遗言存放到线程的局部变量里，因为如果用户写的线程函数退出了，线程函数栈上的局部变量可能就不复存在了，线程的临终遗言也就无法被接收者读到。那我们应该如何正确地传递返回值呢？</p>
<ul>
<li>如果是int型的变量，则可以使用<code>pthread_exit((int*)ret)</code>。</li>
<li>使用全局变量返回。</li>
<li>将返回值填入到用malloc在堆上分配的空间里。</li>
<li>使用字符串常量，如pthread_exit（“hello，world”）。</li>
</ul>
<p>第一种是tricky的做法，我们将返回值ret进行强制类型转换，接收方再把返回值强制转换成int。但是不推荐使用这种方法。这种方法虽然是奏效的，但是太tricky，而且C标准没有承诺将int型转成指针后，再从指针转成int型时，数据一直保持不变。</p>
<p>第二种方法使用全局变量，其他线程调用pthread_join时也可见这个变量。</p>
<p>第三种方法是用malloc，在堆上分配空间，然后将返回值填入其中。因为堆上的空间不会随着线程的退出而释放，所以pthread_join可以取出返回值。切莫忘记释放该空间，否则会引起内存泄漏。</p>
<p>第四种方法之所以可行，是因为字符串常量有静态存储的生存期限。</p>
<p>传递线程的返回值，除了pthread_exit函数可以做到，线程的启动函数（start_routine函数）return也可以做到，两者的数据类型要保持一致，都是<code>void*</code>类型。这也解释了为什么线程的启动函数start_routine的返回值总是<code>void*</code>类型，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">start_routine</span><span class="params">(<span class="type">void</span> *param)</span></span><br></pre></td></tr></table></figure></div>

<p>线程退出有一种比较有意思的场景，即线程组的其他线程仍在执行的情况下，主线程却调用pthread_exit函数退出了。这会发生什么事情？首先要说明的是这不是常规的做法，但是如果真的这样做了，<strong>那么主线程将进入僵尸状态</strong>，而其他线程则不受影响，会继续执行。</p>
<p>当主线程调用 <code>pthread_exit(NULL)</code> 时，它会导致主线程自行终止，但不会终止整个进程。具体行为如下：</p>
<ol>
<li><p><strong>主线程终止</strong>: <code>pthread_exit(NULL)</code> 使得调用线程（在这里是主线程）正常退出。</p>
</li>
<li><p><strong>进程继续运行</strong>: 如果在 <code>pthread_exit(NULL)</code> 被调用时，进程中还有其他线程在运行，那么这些线程会继续执行，进程不会因为主线程的退出而终止。</p>
</li>
<li><p><strong>不会执行 <code>return 0;</code></strong>: 在 <code>pthread_exit(NULL)</code> 被调用后，主线程的控制流不会继续执行，因此 <code>pthread_exit(NULL)</code> 之后的任何代码，包括 <code>return 0;</code>，都不会被执行。</p>
</li>
<li><p><strong>进程终止条件</strong>: 进程会在所有线程都终止后才会终止。因此，如果主线程调用了 <code>pthread_exit(NULL)</code>，而其他线程仍在运行，进程会继续存在，直到所有线程都结束。</p>
</li>
</ol>
<p>如果主线程希望在退出时终止整个进程，通常会使用 <code>exit()</code> 或 <code>return</code> 语句（在 <code>main</code> 函数中）。<code>exit()</code> 会终止进程并停止所有线程的运行，而 <code>return</code> 语句在 <code>main</code> 函数中也会导致进程终止。</p>
<h1 id="线程的连接与分离"><a href="#线程的连接与分离" class="headerlink" title="线程的连接与分离"></a>线程的连接与分离</h1><h2 id="线程的连接"><a href="#线程的连接" class="headerlink" title="线程的连接"></a>线程的连接</h2><p>线程库提供了<code>pthread_join</code>函数，用来等待某线程的退出并接收它的返回值。这种操作被称为连接（joining）。相关函数的接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 该函数第一个参数为要等待的线程的线程ID，第二个参数用来接收返回值。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure></div>

<p>根据等待的线程是否退出，可得到如下两种情况：</p>
<ul>
<li>等待的线程尚未退出，那么pthread_join的调用线程就会陷入阻塞。</li>
<li>等待的线程已经退出，那么pthread_join函数会将线程的退出值<code>（void*类型）</code>存放到<code>retval</code>指针指向的位置。</li>
</ul>
<p>线程的连接（join）操作有点类似于进程等待子进程退出的等待（wait）操作，但细细想来，还是有不同之处：第一点不同之处是进程之间的等待只能是父进程等待子进程，而线程则不然。线程组内的成员是对等的关系，只要是在一个线程组内，就可以对另外一个线程执行连接（join）操作。如图所示，线程F一样可以连接线程A。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250221115130266.png"
                      alt="image-20250221115130266"
                ></p>
<p>第二点不同之处是进程可以等待任一子进程的退出，但是线程的连接操作没有类似的接口，即不能连接线程组内的任一线程，必须明确指明要连接的线程的线程ID。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wait(&amp;status);</span><br><span class="line">waitpid(<span class="number">-1</span>,&amp;status,optioins)</span><br></pre></td></tr></table></figure></div>

<p>pthread_join不能连接线程组内任意线程的做法，并不是NPTL线程库设计上的瑕疵，而是有意为之的。如果听任线程连接线程组内的任意线程，那么所谓的任意线程就会包括其他库函数私自创建的线程，当库函数尝试连接（join）私自创建的线程时，发现已经被连接过了，就会返回EINVAL错误。如果库函数需要根据返回值来确定接下来的流程，这就会引发严重的问题。正确的做法是，连接已知线程ID的那些线程，就像pthread_join函数那样。</p>
<p>下面来分析出错的情况，当调用失败时，和pthread_create函数一样，errno作为返回值返回。错误码的情况见表:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250221115318059.png"
                      alt="image-20250221115318059"
                ></p>
<hr>
<p>pthread_join函数之所以能够判断是否死锁和连接操作是否被其他线程捷足先登，是因为目标线程的控制结构体struct pthread中，存在如下成员变量，记录了该线程的连接者。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">joinid</span>；</span></span><br></pre></td></tr></table></figure></div>

<p>该指针存在三种可能，如下。</p>
<ul>
<li>NULL：线程是可连接的，但是尚没有其他线程调用pthread_join来连接它。</li>
<li>指向线程自身的struct pthread：表示该线程属于自我了断型，执行过分离操作，或者创建线程时，设置的分离属性为PTHREAD_CREATE_DETACHED，一旦退出，则自动释放所有资源，无需其他线程来连接。</li>
<li>指向线程组内其他线程的struct pthread：表示joinid对应的线程会负责连接。</li>
</ul>
<p>因为有了该成员变量来记录线程的连接者，所以可以判断如下场景，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250221115511405.png"
                      alt="image-20250221115511405"
                ></p>
<p>不过两者还是略有区别的，第一种场景，线程A连接线程A，pthread_join函数一定会返回EDEADLK。但是第二种场景，大部分情况下会返回EDEADLK，不过也有例外。不管怎样，不建议两个线程互相连接。如果两个线程几乎同时对处于可连接状态的线程执行连接操作会怎么样？答案是只有一个线程能够成功，另一个则返回EINVAL。NTPL提供了原子性的保证：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(atomic_compare_and_exchange_bool_acq（&amp;pd-&gt;joined,self,<span class="literal">NULL</span>）</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果是NULL，则设置成调用线程的线程ID，CAS操作（Compare And Swap）是原子操作，不可分割，决定了只有一个线程能成功。</li>
<li>如果joinid不是NULL，表示该线程已经被别的线程连接了，或者正处于已分离的状态，在这两种情况下，都会返回EINVAL。</li>
</ul>
<h2 id="连接退出的线程"><a href="#连接退出的线程" class="headerlink" title="连接退出的线程"></a>连接退出的线程</h2><p>不连接已经退出的线程会怎么样？如果不连接已经退出的线程，会导致资源无法释放。所谓资源指的又是什么呢？下面通过一个测试来让事实说话。测试模拟下面两种情况：</p>
<ul>
<li>主线程并不执行连接操作，待确定创建的第一个线程退出后，再创建第二个线程。</li>
<li>主线程执行连接操作，等到第一个线程退出后，再创建第二个线程。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250221133932044.png"
                      alt="image-20250221133932044"
                ></p>
<p>面是代码部分，为了简化程序和便于理解，使用sleep操作来确保创建的第一个线程退出后，再来创建第二个线程。须知sleep并不是同步原语，在真正的项目代码中，用sleep函数来同步线程是不可原谅的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_THREAD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERRBUF_LEN 4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_work</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> TID = syscall(SYS_gettid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread-%d IN \n&quot;</span>,TID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread-%d pthread_self return %p \n&quot;</span>,TID,(<span class="type">void</span>*)pthread_self());</span><br><span class="line">    sleep(<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread-%d EXIT \n&quot;</span>,TID);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc ,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[NR_THREAD];</span><br><span class="line">    <span class="type">pthread_t</span> tid_2[NR_THREAD];</span><br><span class="line">    <span class="type">char</span> errbuf[ERRBUF_LEN];</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; NR_THREAD ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid[i],<span class="literal">NULL</span>,thread_work,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;create thread failed ,return %d (%s)\n&quot;</span>,</span><br><span class="line">                    ret, strerror_r (ret,errbuf,<span class="keyword">sizeof</span>(errbuf)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_JOIN</span></span><br><span class="line">    sleep(<span class="number">100</span>);<span class="comment">/*sleep是为了确保线程退出之后，再来重新创建线程*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;join thread Begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; NR_THREAD; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; NR_THREAD ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid_2[i],<span class="literal">NULL</span>,thread_work,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;create thread failed ,return %d (%s)\n&quot;</span>,</span><br><span class="line">                    ret, strerror_r (ret,errbuf,<span class="keyword">sizeof</span>(errbuf)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据编译选项<code>NO_JOIN</code>，将程序编译成以下两种情况：</p>
<ul>
<li>编译加上<code>–DNO_JOIN</code>：主线不执行<code>pthread_join</code>，主线程通过sleep足够的时间，来确保第一个线程退出以后，再创建第二个线程。</li>
<li>不加<code>NO_JOIN</code>编译选项：主线程负责连接线程，第一个线程退出以后，再来创建第二个线程。</li>
</ul>
<p>下面按照编译选项，分别编出<code>pthread_no_join</code>和<code>pthread_has_join</code>两个程序：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o pthread_no_join pthread_join_cmp.c -DNO_JOIN   –lpthread</span><br><span class="line">gcc -o pthread_has_join pthread_join_cmp.c            -lpthread</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先说说pthread_no_join的情况，当创建了第一个线程时：</span></span><br><span class="line">manu@manu-hacks:~/code/me/thread$ ./pthread_no_join</span><br><span class="line">thread<span class="number">-12876</span> IN</span><br><span class="line">thread<span class="number">-12876</span> pthread_self <span class="keyword">return</span> <span class="number">0x7fe0c842b700</span></span><br><span class="line"><span class="comment">// 从输出可以看到，创建了第一个线程，其线程ID为12876，通过pmap和procfs可以看到系统为该线程分配了8MB的地址空间：</span></span><br><span class="line">manu@manu-hacks:~$ pmap <span class="number">12875</span></span><br><span class="line"><span class="number">00007f</span>e0c7c2b000      <span class="number">4</span>K -----   [ anon ]</span><br><span class="line"><span class="number">00007f</span>e0c7c2c000   <span class="number">8192</span>K rw---   [ anon ]</span><br><span class="line">manu@manu-hacks:~$ cat /proc/<span class="number">12875</span>/maps</span><br><span class="line"><span class="number">7f</span>e0c7c2b000<span class="number">-7f</span>e0c7c2c000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">07f</span>e0c7c2c000<span class="number">-7f</span>e0c842c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                    [<span class="built_in">stack</span>:<span class="number">12876</span>]</span><br><span class="line"><span class="comment">// 当线程12876退出，创建新的线程时：</span></span><br><span class="line">thread<span class="number">-12876</span> EXIT</span><br><span class="line">thread<span class="number">-13391</span> IN</span><br><span class="line">thread<span class="number">-13391</span> pthread_self <span class="keyword">return</span> <span class="number">0x7fe0c7c2a700</span></span><br><span class="line"><span class="comment">// 此时查看进程的地址空间：</span></span><br><span class="line"><span class="number">00007f</span>e0c742a000      <span class="number">4</span>K -----   [ anon ]</span><br><span class="line"><span class="number">00007f</span>e0c742b000   <span class="number">8192</span>K rw---   [ anon ]</span><br><span class="line"><span class="number">00007f</span>e0c7c2b000      <span class="number">4</span>K -----   [ anon ]</span><br><span class="line"><span class="number">00007f</span>e0c7c2c000   <span class="number">8192</span>K rw---   [ anon ]</span><br><span class="line"><span class="number">7f</span>e0c742a000<span class="number">-7f</span>e0c742b000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>e0c742b000<span class="number">-7f</span>e0c7c2b000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                     [<span class="built_in">stack</span>:<span class="number">13391</span>]</span><br><span class="line"><span class="number">7f</span>e0c7c2b000<span class="number">-7f</span>e0c7c2c000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">07f</span>e0c7c2c000<span class="number">-7f</span>e0c842c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<p>从上面的输出可以看出两点：</p>
<p>1）已经退出的线程，其空间没有被释放，仍然在进程的地址空间之内。</p>
<p>2）新创建的线程，没有复用刚才退出的线程的地址空间。</p>
<p>如果仅仅是情况1的话，尚可以理解，但是1和2同时发生，既不释放，也不复用，这就不能忍了，因为这已经属于内存泄漏了。试想如下场景：<code>FTP Server</code>采用<code>thread per connection</code>的模型，每接受一个连接就创建一个线程为之服务，服务结束后，连接断开，线程退出。但线程退出了，线程栈消耗的空间仍不能释放，不能复用，久而久之，内存耗尽，再也不能创建线程，也无法再提供FTP服务。</p>
<h2 id="线程的分离"><a href="#线程的分离" class="headerlink" title="线程的分离"></a>线程的分离</h2><p>默认情况下，新创建的线程处于可连接（Joinable）的状态，可连接状态的线程退出后，需要对其执行连接操作，否则线程资源无法释放，从而造成资源泄漏。如果其他线程并不关心线程的返回值，那么连接操作就会变成一种负担：你不需要它，但是你不去执行连接操作又会造成资源泄漏。这时候你需要的东西只是：线程退出时，系统自动将线程相关的资源释放掉，无须等待连接。NPTL提供了pthread_detach函数来将线程设置成已分离（detached）的状态，如果线程处于已分离的状态，那么线程退出时，系统将负责回收线程的资源，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure></div>

<p>可以是线程组内其他线程对目标线程进行分离，也可以是线程自己执行pthread_detach函数，将自身设置成已分离的状态，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self())</span><br></pre></td></tr></table></figure></div>

<p>线程的状态之中，可连接状态和已分离状态是冲突的，一个线程不能既是可连接的，又是已分离的。因此，如果线程处于已分离的状态，其他线程尝试连接线程时，会返回EINVAL错误。pthread_detach出错的情况见表所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250221134726670.png"
                      alt="image-20250221134726670"
                ></p>
<p>需要强调的是，不要误解已分离状态的内涵。所谓已分离，并不是指线程失去控制，不归线程组管理，而是指线程退出后，系统会自动释放线程资源。若线程组内的任意线程执行了exit函数，即使是已分离的线程，也仍然会受到影响，一并退出。将线程设置成已分离状态，并非只有pthread_detach一种方法。另一种方法是在创建线程时，将线程的属性设定为已分离：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr,<span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr,<span class="type">int</span> *detachstate)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中<code>detachstate</code>的可能值如表所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250221134806949.png"
                      alt="image-20250221134806949"
                ></p>
<p>有了这个，如果确实不关心线程的返回值，可以在创建线程之初，就指定其分离属性为<code>PTHREAD_CREATE_DETACHED</code>。</p>
<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><p>大部分情况下，线程使用的数据都是局部变量，变量的地址在线程栈空间内，这种情况下，变量归属于单个线程，其他线程无法获取到这种变量。如果所有的变量都是如此，将会省去无数的麻烦。但实际的情况是，很多变量都是多个线程共享的，这样的变量称为共享变量（shared variable）。可以通过数据的共享，完成多个线程之间的交互。但是多个线程并发地操作共享变量，会带来一些问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250225135504554.png"
                      alt="image-20250225135504554"
                ></p>
<p>如果存在4个线程，不加任何同步措施，共同操作一个全局变量global_cnt，假设每个线程执行1000万次自加操作，那么会发生什么事情呢？4个线程结束的时候，global_cnt等于几？结果并不是期待的4000万，而是11115156，一个很奇怪的数字。而且每次执行，最后的结果都不相同。为什么无法获得正确的结果？</p>
<p><code>++</code>操作，并不是一个原子操作（atomic operation），而是对应了如下三条汇编指令。</p>
<ul>
<li>Load：将共享变量global_cnt从内存加载进寄存器，简称L。</li>
<li>Update：更新寄存器里面的global_cnt值，执行加1操作，简称U。</li>
<li>Store：将新的值，从寄存器写回到共享变量global_cnt的内存地址，简称为S。将上述情况用伪代码表示，就是如下情况：</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L操作：<span class="keyword">register</span> = global_cnt</span><br><span class="line">U操作：<span class="keyword">register</span> = <span class="keyword">register</span> + <span class="number">1</span></span><br><span class="line">S操作：global_cnt = <span class="keyword">register</span></span><br></pre></td></tr></table></figure></div>

<p>两个线程为例，如果两个线程的执行如图所示，就会引发结果不一致：执行了两次++操作，最终的结果却只加了1。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250225135757167.png"
                      alt="image-20250225135757167"
                ></p>
<p>上面的例子表明，应该避免多个线程同时操作共享变量，对于共享变量的访问，包括读取和写入，都必须被限制为每次只有一个线程来执行。用更详细的语言来描述下，解决方案需要能够做到以下三点。</p>
<p>1）代码必须要有互斥的行为：当一个线程正在临界区中执行时，不允许其他线程进入该临界区中。</p>
<p>2）如果多个线程同时要求执行临界区的代码，并且当前临界区并没有线程在执行，那么只能允许一个线程进入该临界区。</p>
<p>3）如果线程不在临界区中执行，那么该线程不能阻止其他线程进入临界区。上面说了这么多，本质其实就是一句话，我们需要一把锁</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250225135845478.png"
                      alt="image-20250225135845478"
                ></p>
<p>锁是一个很普遍的需求，当然用户可以自行实现锁来保护临界区。但是实现一个正确并且高效的锁非常困难。纵然抛下高效不谈，让用户从零开始实现一个正确的锁也并不容易。正是因为这种需求具有普遍性，所以Linux提供了互斥量。</p>
<h2 id="互斥量的接口"><a href="#互斥量的接口" class="headerlink" title="互斥量的接口"></a>互斥量的接口</h2><p><strong>互斥量的初始化</strong></p>
<p>互斥量采用的是英文mutual exclusive（互相排斥之意）的缩写，即mutex。正确地使用互斥量来保护共享数据，首先要定义和初始化互斥量。POSIX提供了两种初始化互斥量的方法。第一种方法是将<code>PTHREAD_MUTEX_INITIALIZER</code>赋值给定义的互斥量，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure></div>

<p>如果互斥量是动态分配的，或者需要设定互斥量的属性，那么上面静态初始化的方法就不适用了，NPTL提供了另外的函数<code>pthread_mutex_init（）</code>对互斥量进行动态的初始化：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure></div>

<p>第二个pthread_mutexattr_t指针的入参，是用来设定互斥量的属性的。大部分情况下，并不需要设置互斥量的属性，传递NULL即可，表示使用互斥量的默认属性。调用pthread_mutex_init（）之后，互斥量处于没有加锁的状态。</p>
<p><strong>互斥量的销毁</strong></p>
<p>在确定不再需要互斥量的时候，就要销毁它。在销毁之前，有三点需要注意：</p>
<ul>
<li>使用<code>PTHREAD_MUTEX_INITIALIZER</code>初始化的互斥量无须销毁。</li>
<li>不要销毁一个已加锁的互斥量，或者是真正配合条件变量使用的互斥量。</li>
<li>已经销毁的互斥量，要确保后面不会有线程再尝试加锁。销毁互斥量的接口如下：</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<p>当互斥量处于已加锁的状态，或者正在和条件变量配合使用，调用pthread_mutex_destroy函数会返回<code>EBUSY</code>错误码。</p>
<p><strong>互斥量的加锁和解锁</strong></p>
<p>POSIX提供了如下接口：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<p>在调用pthread_lock（）的时候，可能会遭遇以下几种情况：</p>
<ul>
<li>互斥量处于未锁定的状态，该函数会将互斥量锁定，同时返回成功。</li>
<li>发起函数调用时，其他线程已锁定互斥量，或者存在其他线程同时申请互斥量，但没有竞争到互斥量，那么pthread_lock（）调用会陷入阻塞，等待互斥量解锁。</li>
</ul>
<p>在等待的过程中，如果互斥量持有线程解锁互斥量，可能会发生如下事件：</p>
<ul>
<li>函数调用线程是唯一等待者，获得互斥量，成功返回。</li>
<li>函数调用线程不是唯一等待者，但成功获得互斥量，返回。</li>
<li>函数调用线程不是唯一等待者，没能获得互斥量，继续阻塞，等待下一轮。</li>
<li>如果在调用pthread_lock（）线程时，之前已经调用过pthread_lock（）且已经持有了互斥量，则根据互斥锁的类型，存在以下三种可能。</li>
<li><ul>
<li>PTHREAD_MUTEX_NORMAL：这是默认类型的互斥锁，这种情况下会发生死锁，调用线程永久阻塞，线程组的其他线程也无法申请到该互斥量。</li>
<li>PTHREAD_MUTEX_ERRORCHECK：第二次调用pthread_mutex_lock函数时返回EDEADLK。</li>
<li>PTHREAD_MUTEX_RECURSIVE：这种类型的互斥锁内部维护有引用计数，允许锁的持有者再次调用加锁操作。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">global_cnt++;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure></div>

<p>有了互斥量，重新运行上面的的程序，将会得到正确的结果。</p>
<h2 id="临界区的大小"><a href="#临界区的大小" class="headerlink" title="临界区的大小"></a>临界区的大小</h2><p>现在，我们已经意识到需要用锁来保护共享变量。不过还有另一个需要注意的事项，即合理地设定临界区的范围。第一临界区的范围不能太小，如果太小，可能起不到保护的目的。考虑如下场景，如果哈希表中不存在某元素，那么向哈希表中插入某元素，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!htable_contain(hashtable,elem.key))</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    htable_insert(hashtable,&amp;elem);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>表面上看，共享变量hashtable得到了保护，在插入时有锁保护，但是结果却不是我们想要的。上面的程序不希望哈希表中有重复的元素，但是其临界区太小，多线程条件下可能达不到预设的效果。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250225183627142.png"
                      alt="image-20250225183627142"
                ></p>
<h2 id="互斥量的性能"><a href="#互斥量的性能" class="headerlink" title="互斥量的性能"></a>互斥量的性能</h2><p>还是以前面的例子为例进行说明，4个线程分别对全局变量累加1000万次，使用互斥量版本的程序和不使用互斥量的版本相比，会消耗更多的时间</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250225184435675.png"
                      alt="image-20250225184435675"
                ></p>
<p>互斥量版本需要消耗更长的时间，其原因有以下三点：</p>
<p>1）对互斥量的加锁和解锁操作，本身有一定的开销。</p>
<p>2）临界区的代码不能并发执行。</p>
<p>3）进入临界区的次数过于频繁，线程之间对临界区的争夺太过激烈，若线程竞争互斥量失败，就会陷入阻塞，让出CPU，所以执行上下文切换的次数要远远多于不使用互斥量的版本。</p>
<p>Linux下，互斥量的实现采用了futex（fast user space mutex）机制。传统的同步手段，进入临界区之前会申请锁，而此时不得不执行系统调用，查看是否存在竞争；当离开临界区释放锁的时候，需要再次执行系统调用，查看是否需要唤醒正在等待锁的进程。但是在竞争并不激烈的情况下，加锁和解锁的过程中可能会出现以下两种情况：</p>
<ul>
<li>申请锁时，执行系统调用，从用户模式进入内核模式，却发现并无竞争。</li>
<li>释放锁时，执行系统调用，从用户模式进入内核模式，尝试唤醒正在等待锁的进程，却发现并没有进程正在等待锁的释放。</li>
</ul>
<p>考虑到系统调用的开销，这两种情况耗资靡费，却劳而无功。futex机制的出现有效地解决了这两个问题。futex的全称是fast userspace mutex，中文名为快速用户空间互斥体，它是一种用户态和内核态协同工作的同步机制。glibc使用内核提供的futex系统调用实现了互斥量。glibc的互斥量实现，含有大量的汇编代码，不易读懂，下面用伪代码来描述下互斥量的加锁和解锁操作：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(mutex* lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c；</span><br><span class="line">    <span class="keyword">if</span>(c = cmpxchg(lock,<span class="number">0</span>,<span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 如果原始值是0，则表示处于没加锁的状态，将lock改成1，直接返回</span></span><br><span class="line">    <span class="comment">// 如果原始值不是0，则表示互斥量已被加锁，需要继续执行</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 此处有以下可能性：1) c==2 表示已被加锁，并且有其他正在等待的线程,应立即调用futex_wait2) 原子地检查lock是否为1，如果是，则将lock改成2，然后调用futex_wait</span></span><br><span class="line"><span class="comment">  如果不是，则表示其他线程释放了锁，将lock改成了0，需要执行while语句争夺锁</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">2</span> || cmpxchg(lock, <span class="number">1</span>, <span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">//如果执行futex_wait时，lock已经被改写，不等于2，则当即返回</span></span><br><span class="line">            futex_wait(lock, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> （(c = cmpxchg(lock, <span class="number">0</span>, <span class="number">2</span>))！= <span class="number">0</span>）;</span><br><span class="line">    <span class="comment">//表示有线程unlock，但是不知道解锁后是1还是2，保险起见，写成2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(mutex* lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//atomic_dec的作用是减1并返回原始值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_dec</span>(lock) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 原始值是2，有线程等待互斥量，才会进入</span></span><br><span class="line">        <span class="comment">// 如果原始值是1，则表示没有线程等待，没必要futex_wake</span></span><br><span class="line">        lock = <span class="number">0</span>;</span><br><span class="line">        futex_wake(lock, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的cmpxchg和atomic_dec都是原子操作。</p>
<ul>
<li>cmpxchg（lock，a，b）：表示如果lock的值等于a，那么将lock改为b，并将原始值返回，否则直接将原始值返回。</li>
<li>atomic_dec（lock）：表示将lock的值减去1，并且返回原始值。glibc的互斥量中维护了一个值lock，该值有以下三种情况。</li>
<li><ul>
<li>0：表示互斥量并未上锁。</li>
<li>1：表示互斥量已经上锁，但是并没有线程正在等待该锁。</li>
<li>2：表示互斥量已经上锁，并且有线程正在等待该锁。</li>
</ul>
</li>
</ul>
<p>加锁时，如果发现该值是0，那么直接将该值改为1，无须执行任何系统调用，因为并没有线程持有该锁，无须等待；解锁时，如果发现该值是1，直接将该值改成0，无须执行任何系统调用，因为并没有线程正在等待该锁，无须唤醒。当然，在这两种情况下，比较和修改操作（Compare And Swap）必须是原子操作，否则会出现问题。如果无竞争，可以看出，互斥量的加锁和解锁非常轻量级。</p>
<p>内核提供了futex_wait和futex_wake两个操作（futex系统调用支持的两个命令）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">futex_wait</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">futex_wake</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<p>futex_wait是用来协助加锁操作的。线程调用pthread_mutex_lock，如果发现锁的值不是0，就会调用futex_wait，告知内核，线程须要等待在uaddr对应的锁上，请将线程挂起。内核会建立与uaddr地址对应的等待队列。为什么需要内核维护等待队列？因为一旦互斥量的持有者线程释放了互斥量，就需要及时通知那些等待在该互斥量上的线程。如果没有等待队列，内核将无法通知到那些正陷入阻塞的线程。如果整个系统有很多这种互斥量，是不是需要为每个uaddr地址建立一个等待队列呢？事实上不需要。理论上讲，futex只需要在内核之中维护一个队列就够了，当线程释放互斥量时，可能会调用futex_wake，此时会将uaddr传进来，内核会去遍历该队列，查找等待在该uaddr地址上的线程，并将相应的线程唤醒。但是只有一个队列的话查找效率有点低，作为优化，内核实现了多个队列。插入等待队列时，会先计算hash值，然后根据hash插入到对应的链表之中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250225185937315.png"
                      alt="image-20250225185937315"
                ></p>
<p>值得一提的是，futex_wait操作需要的val入参，乍看之下好像没什么用处。事实上并非如此。从用户程序判断锁的值，到调用futex_wait操作是有时间窗口的，在这个时间窗口之内，有可能发生线程解锁的操作，从而可能无须等待。因此futex_wait操作会检查uaddr对应的锁的值是否等于val的值，只有在等于val的情况下，内核才会让线程等待在对应的队列上，否则会立刻返回，让用户程序再次申请锁。</p>
<p>futex_wake操作是用来实现解锁操作的。glibc就是使用该操作来实现互斥量的解锁函数pthread_mutex_unlock的。当线程执行完临界区代码，解锁时，内核需要通知那些正在等待该锁的线程。这时候就需要发挥futex_wake操作的作用了。futex_wake的第二个参数n，对于互斥量而言，该值总是1，表示唤醒1个线程。当然，也可以唤醒所有正在等待该锁的线程，但是这样做并无好处，因为被唤醒的多个线程会再次竞争，却只能有一个线程抢到锁，这时其他线程不得不再次睡去，徒增了很多开销。使用strace跟踪系统调用的时候，看不到futex_wait和futex_wake两个系统调用，看到的是futex系统调用，如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">futex</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> op, <span class="type">int</span> val, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout,<span class="type">int</span> *uaddr2, <span class="type">int</span> val3)</span>;</span><br></pre></td></tr></table></figure></div>

<p>该系统调用是一个综合的系统调用，根据第二个参数op来决定具体的行为。当op为<code>FUTEX_WAIT</code>时，对应的是前面讨论的futex_wait操作，当op为FUTEX_WAKE时，对应的是前面讨论的futex_wake操作。细心的话，可以发现，互斥量加锁和解锁时，调用futex的op参数并非<code>FUTEX_WAIT</code>和<code>FUTEX_WAKE</code>，而是<code>FUTEX_WAIT_PRIVATE</code>和<code>FUTEX_WAKE_PRIVATE</code>，这是为了改进futex的性能而进行的优化。因为futex也可以用在不同的进程之间，加上后缀_PRIVATE是为了明确告知内核，互斥的行为是用在线程之间的。从上面的角度分析，当存在竞争时，如果线程申请不到互斥量，就会让出CPU，系统会发生上下文切换。在线程个数众多，临界区竞争异常激烈的情况下，上下文切换会是一笔不小的开销。如果临界区非常小，线程之间对临界区的竞争并不激烈，只会偶尔发生，这种情况下，忙-等待的策略要优于互斥量的“让出CPU，陷入阻塞，等待唤醒”的策略。采用忙-等待策略的锁为自旋锁。</p>
<h2 id="互斥锁的公平性"><a href="#互斥锁的公平性" class="headerlink" title="互斥锁的公平性"></a>互斥锁的公平性</h2><p>首先要定义什么是公平（fairness）。对于锁而言，如果A在B之前调用lock（）方法，那么A应该先于B获得锁，进入临界区。多处理器条件下，很难确定是哪个线程率先调用的lock（）方法。纵然能判定是哪个线程率先调用的lock（）方法，要实现指令级的公平也是很难的。常见的判断锁公平性的方法是，将锁的实现代码分成如下两个部分：</p>
<ul>
<li>门廊区</li>
<li>等待区</li>
</ul>
<p>如果锁能满足以下条件，就称锁是先来先服务（FCFS）的：如果线程A门廊区的结束在线程B门廊区的开始之前，那么线程A一定不会被线程B赶超。</p>
<p>互斥量也有门廊区和等待区，如果没有竞争，线程执行几个指令就加锁成功，顺利返回了。在这种情况下，互斥量在门廊区就解决了所有的需要。但是如果有竞争，互斥锁在门廊区判断出存在竞争，线程取不到锁，就不得不执行<code>futex_wait</code>，让内核将其挂起，并记录在等待队列上。需要等待多久？不知道。从表面上看，内核会将等待互斥量的线程放入队列，每来一个等待线程，就把线程记录在队列的尾部，当互斥量的持有线程解锁时，内核只会唤醒一个线程，而唤醒的正是队列中等待该互斥量的第一个等待者。队列的先入先出（FIFO），看起来已经保证了互斥量的公平性。但是，这样就能确保公平吗？答案是否定的，互斥锁并没有做到先来先服务。</p>
<p>当互斥量的lock的值是2，或者尝试调用CAS操作将lock从1改成2并且成功时，线程会调用futex_wait陷入阻塞。值得一提的是，CAS操作在尝试将1改成2时，也可能存在竞争，比如其他线程有解锁操作，lock值已经被改成了0，而这时候恰好存在另外一个线程刚刚调用加锁操作，这时就会发生门廊区的争夺，对于这种情况不做详细分析。假设加锁调用了futex_wait，内核将线程挂起在等待队列上，从那时起，线程就进入了漫长的等待区。如果互斥量的持有线程解锁，会首先将互斥量的lock值设置成0，然后唤醒内核等待队列中等待在该地址上的第一个线程。看起来比较公平，但是问题就出在此处，被唤醒的线程并不是自动就持有了互斥锁，反而须要执行while（）中包裹的cmpxchg操作，再次竞争互斥量。如果竞争失败，则被另外一个初来乍到的线程将0改成了1，那么线程刚刚醒来就不得不再次执行futex_wait，再次沉睡。这次竞争失败的代价是巨大的，因为futex_wait操作会将线程挂载到等待队列的队尾。由上面的分析可以得出如下结论：</p>
<ul>
<li>线程可能多次调用futex_wait进入等待区，在线程被futex_wait唤醒后，并不会自动拥有互斥量，而是再次进入门廊区，和其他线程争夺锁。</li>
<li>在已经有很多线程处于内核等待队列的情况下，新来的加锁请求可能会后发先至，率先获得锁。</li>
<li>futex_wait唤醒的线程如果没有竞争到锁，那么会再次调用futex_wait函数，陷入睡眠，不过内核会将其放入等待队列的队尾，这种行为加剧了不公平性。</li>
</ul>
<p>为什么开发者并不在意这种不公平性？因为要实现这种公平性会牺牲性能，而这种牺牲并无必要。绝大多数情况下，由于调度的原因，用户根本无法判断哪个线程会优先调用加锁操作，那么内核或glibc维持这种先来先服务（FCFS）就变得毫无意义。如果可以在不牺牲性能的情况下做到公平，自然最好，但是实际情况并非如此。实现这种公平，对性能的伤害很大。</p>
<h2 id="互斥锁的类型"><a href="#互斥锁的类型" class="headerlink" title="互斥锁的类型"></a>互斥锁的类型</h2><p>互斥量有以下4种类型：</p>
<ul>
<li>PTHREAD_MUTEX_TIMED_NP</li>
<li>PTHREAD_MUTEX_RECURSIVE</li>
<li>PTHREAD_MUTEX_ERRORCHECK</li>
<li>PTHREAD_MUTEX_ADAPTIVE_NP</li>
</ul>
<p>glibc提供了接口来查询和设置互斥锁的类型：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr,<span class="type">int</span> *<span class="keyword">restrict</span> type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_settype</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr,<span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure></div>

<p>可以仿照如下代码来设置互斥量的类型：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*忽略了出错判断，真实代码中需要判断error*/</span></span><br><span class="line">pthread_mutex  mtx;</span><br><span class="line"><span class="type">pthread_mutexattr_t</span> mtxAttr;</span><br><span class="line">pthread_mutexattr_init(&amp;mtxAttr);</span><br><span class="line">pthread_mutexattr_settype(&amp;mtxAttr,PTHREAD_MUTEX_ADAPTIVE_NP);</span><br><span class="line">pthread_mutex_init(&amp;mtx,&amp;mtxAttr);</span><br></pre></td></tr></table></figure></div>

<p>下面来分别介绍这几个互斥量的特点。</p>
<ul>
<li><p>PTHREAD_MUTEX_NORMAL：最普通的一种互斥锁。前文讨论的就是这种类型的锁。它不具备死锁检测功能，如线程对自己锁定的互斥量再次加锁，则会发生死锁。</p>
</li>
<li><p>PTHREAD_MUTEX_RECURSIVE_NP：支持递归的一种互斥锁，该互斥量的内部维护有互斥锁的所有者和一个锁计数器。当线程第一次取到互斥锁时，会将锁计数器置1，后续同一个线程再次执行加锁操作时，会递增该锁计数器的值。解锁则递减该锁计数器的值，直到降至0，才会真正释放该互斥量，此时其他线程才能获取到该互斥量。解锁时，如果互斥量的所有者不是调用解锁的线程，则会返回EPERM。</p>
</li>
<li><p>PTHREAD_MUTEX_ERRORCHECK_NP：支持死锁检测的互斥锁。互斥量的内部会记录互斥锁的当前所有者的线程ID（调度域的线程ID）。如果互斥量的持有线程再次调用加锁操作，则会返回EDEADLK。解锁时，如果发现调用解锁操作的线程并不是互斥锁的持有者，则会返回EPERM。</p>
</li>
<li><p>THREAD_MUTEX_ADAPTIVE_NP：自旋锁副作用大，而互斥量在某些情况下效率可能不够高，有没有一种方法能够结合两种方法的长处呢？答案是肯定的。这就是PTHREAD_MUTEX_ADAPTIVE_NP类型的互斥量，也被称为自适应锁。libc的文档里面直接将其称为fast mutex。</p>
<ul>
<li><p>glibc引入了线程自旋锁。自旋锁采用了和互斥量完全不同的策略，自旋锁加锁失败，并不会让出CPU，而是不停地尝试加锁，直到成功为止。这种机制在临界区非常小且对临界区的争夺并不激烈的场景下，效果非常好，</p>
</li>
<li><pre><code class="c">#include &lt;pthread.h&gt;
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
int pthread_spin_lock(pthread_spinlock_t *lock);
int pthread_spin_trylock(pthread_spinlock_t *lock);
int pthread_spin_unlock(pthread_spinlock_t *lock);
int pthread_spin_destroy(pthread_spinlock_t *lock);
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 自旋锁的效果好，但是副作用也大，如果使用不当，自旋锁的持有者迟迟无法释放锁，那么，自旋接近于死循环，会消耗大量的CPU资源，造成CPU使用率飙高。因此，使用自旋锁时，一定要确保临界区尽可能地小，不要有系统调用，不要调用sleep。使用strcpy/memcpy等函数也需要谨慎判断操作内存的大小，以及是否会引起缺页中断。</span><br><span class="line"></span><br><span class="line">* 大多数操作系统（Solaris、Mac OS X、FreeBSD）都有类似的接口，如果竞争锁失败，首先与自旋锁一样，持续尝试获取，但过了一定时间仍然不能申请到锁，就放弃尝试，让出CPU并等待。PTHREAD_MUTEX_ADAPTIVE_NP类型的互斥量，采用的就是这种机制，如下：</span><br><span class="line"></span><br><span class="line">* ```c</span><br><span class="line">  if (LLL_MUTEX_TRYLOCK (mutex) != 0)</span><br><span class="line">  &#123;</span><br><span class="line">      int cnt = 0;</span><br><span class="line">      int max_cnt = MIN (MAX_ADAPTIVE_COUNT,</span><br><span class="line">             mutex-&gt;__data.__spins * 2 + 10);</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">          if (cnt++ &gt;= max_cnt)</span><br><span class="line">          &#123;</span><br><span class="line">              /*自旋也没有等到锁，只能睡去*/</span><br><span class="line">              LLL_MUTEX_LOCK (mutex);</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">  #ifdef BUSY_WAIT_NOP</span><br><span class="line">          BUSY_WAIT_NOP;</span><br><span class="line">  #endif</span><br><span class="line">      &#125;</span><br><span class="line">      while (LLL_MUTEX_TRYLOCK (mutex) != 0);</span><br><span class="line">      mutex-&gt;__data.__spins += (cnt - mutex-&gt;__data.__spins) / 8;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
<li><p>到底等待多长时间才合适呢？这种互斥量定义了一个名为<code>__spins</code>的变量，该值和<code>MAX_ADAPTIVE_COUNT</code>共同决定自旋多久。该类型之所以叫自适应（ADAPTIVE），是因为带有反馈机制，它会根据实际情况，智能地调整<code>__spins</code>的值。当然自旋不是无止境的向上增长时，MAX_ADAPTIVE_COUNT决定了上限，即调用BUSY_WAIT_NOP的最大次数。</p>
</li>
<li><p>对global_cnt自加1000万次的程序，如果把for循环体内的锁换成自适应互斥锁，会比普通的互斥量更快吗？答案是否定的，在这种时时刻刻要加锁和解锁的激烈竞争下，让其他线程睡去，利用上下文切换的时间间隔，让一个线程飞快地自加，执行时间反而是最短的。但是，真实场景下临界区的争夺不可能激烈到这种程度，如果竞争真的激烈到这种程度，那首先需要反省的是设计问题。在临界区非常小，偶尔发生竞争的情况下，自适应互斥锁的性能要优于普通的互斥锁。</p>
</li>
</ul>
</li>
</ul>
<h2 id="死锁和活锁"><a href="#死锁和活锁" class="headerlink" title="死锁和活锁"></a>死锁和活锁</h2><p>对于互斥量而言，可能引起的最大问题就是死锁（dead lock）了。最简单、最好构造的死锁就是下图所示的这种场景了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250226101816478.png"
                      alt="image-20250226101816478"
                ></p>
<p>线程1已经成功拿到了互斥量1，正在申请互斥量2，而同时在另一个CPU上，线程2已经拿到了互斥量2，正在申请互斥量1。彼此占有对方正在申请的互斥量，结局就是谁也没办法拿到想要的互斥量，于是死锁就发生了。</p>
<p>上面的例子比较简单，但实际工程中死锁可能会发生在复杂的函数调用之中。可以想象随着程序复杂度的增加，很多死锁并不像上面的例子那样一目了然，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250226101858380.png"
                      alt="image-20250226101858380"
                ></p>
<p>在多线程程序中，如果存在多个互斥量，一定要小心防范死锁的形成。存在多个互斥量的情况下，避免死锁最简单的方法就是总是按照一定的先后顺序申请这些互斥量。还是以刚才的例子为例，如果每个线程都按照先申请互斥量1，再申请互斥量2的顺序执行，死锁就不会发生。有些互斥量有明显的层级关系，但是也有一些互斥量原本就没有特定的层级关系，不过没有关系，可以人为干预，让所有的线程必须遵循同样的顺序来申请互斥量。另一种方法是尝试一下，如果取不到锁就返回。Linux提供了如下接口来表达这种思想：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span>?*<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abs_timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这两个函数反应了这种尝试一下，不行就算了的思想。</p>
<p>对于pthread_mutex_trylock（）接口，如果互斥量已然被锁定，那么当即返回EBUSY错误，而不像pthread_mutex_lock（）接口一样陷入阻塞。</p>
<p>对于pthread_mutex_timedlock（）接口，提供了一个时间参数abs_timeout，如果申请互斥量的时候，互斥量已被锁定，那么等待；如果到了abs_timeout指定的时间，仍然没有申请到互斥量，那么返回ETIMEOUT错误。</p>
<p>除此以外，这两个接口的表现与pthread_mutex_lock是一致的。在实际的应用中，这两个接口使用的频率远低于pthread_mutex_lock函数。</p>
<p>trylock不行就回退的思想有可能会引发活锁（live lock）。生活中也经常遇到两个人迎面走来，双方都想给对方让路，但是让的方向却不协调，反而互相堵住的情况，锁现象与这种场景有点类似。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250226102112277.png"
                      alt="image-20250226102112277"
                ></p>
<p>考虑下面两个线程，线程1首先申请锁mutex_a后，之后尝试申请mutex_b，失败以后，释放mutex_a进入下一轮循环，同时线程2会因为尝试申请mutex_a失败，而释放mutex_b，如果两个线程恰好一直保持这种节奏，就可能在很长的时间内两者都一次次地擦肩而过。当然这毕竟不是死锁，终究会有一个线程同时持有两把锁而结束这种情况。尽管如此，活锁的确会降低性能。这种情况的示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock (&amp;mutex_b))</span><br><span class="line">        &#123;</span><br><span class="line">            counter++;</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock (&amp;mutex_b);</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock (&amp;mutex_a))</span><br><span class="line">         &#123;</span><br><span class="line">            counter++;</span><br><span class="line">            pthread_mutex_unlock (&amp;mutex_a);</span><br><span class="line">            pthread_mutex_unlock (&amp;mutex_b);</span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            pthread_mutex_unlock (&amp;mutex_b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>很多时候，对共享变量的访问有以下特点：大多数情况下线程只是读取共享变量的值，并不修改，只有极少数情况下，线程才会真正地修改共享变量的值。对于这种情况，读请求之间是无需同步的，它们之间的并发访问是安全的。然而写请求必须锁住读请求和其他写请求。这种情况在实际中是存在的，比如配置项。大多数时间内，配置是不会发生变化的，偶尔会出现修改配置的情况。如果使用互斥量，完全阻止读请求并发，则会造成性能的损失。出于这种考虑，POSIX引入了读写锁。</p>
<p>读写锁比较简单，从表中可以看出，对于这种情况，读写锁做了优化，允许大家一起读。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250226102506203.png"
                      alt="image-20250226102506203"
                ></p>
<h2 id="读写锁的接口"><a href="#读写锁的接口" class="headerlink" title="读写锁的接口"></a>读写锁的接口</h2><p><strong>创建和销毁读写锁</strong></p>
<p>NTPL提供了<code>pthread_rwlock_t</code>类型来表示读写锁。和互斥量一样，它也提供了两种初始化的方法：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock=PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure></div>

<p>对于静态变量，可以采用<code>PTHREAD_RWLOCK_INITIALIZER</code>赋值的方式初始化，对于动态分配的读写锁，或者非默认属性的读写锁，需要用<code>pthread_rwlock_init</code>函数进行初始化。如果第二个属性的参数为NULL，那么采用默认属性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250226102901543.png"
                      alt="image-20250226102901543"
                ></p>
<p>所谓读者优先的策略，是指当前锁的状态是读锁，如果线程申请读锁，此时纵然有写锁在等待队列上，仍然允许申请者获得读锁，而不是被写锁阻塞。后面会详细讨论读者优先和写者优先对读写锁的影响。对于调用pthread_rwlock_init初始化的读写锁，在不需要读写锁的时候，需要调用pthread_rwlock_destroy销毁，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>读写锁的加锁和解锁</strong></p>
<p>读写锁又称共享-独占锁，有共享，也有独占。下面是三个读锁上锁的接口：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_timedrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock,<span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span>;</span><br></pre></td></tr></table></figure></div>

<p>而下面三个是写锁上锁的接口：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_timedwrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock,<span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span>;</span><br></pre></td></tr></table></figure></div>

<p>读锁用于共享模式。如果当前读写锁已经被某线程以读模式占有了，那么其他线程调用<code>pthread_rwlock_rdlock</code>会立刻获得读锁；如果当前读写锁已经被某线程以写模式占有了，那么调用<code>pthread_rwlock_rdlock</code>会陷入阻塞。</p>
<p>写锁用的是独占模式。如果当前读写锁被某线程以写模式占有，则不允许任何读锁请求通过，也不允许任何写锁请求通过，读锁请求和写锁请求都要陷入阻塞，直到线程释放写锁。</p>
<p>无论是读锁还是写锁，锁的释放都是一个接口：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<p>无论是读锁还是写锁，都提供了trylock的功能，当不能获得读锁或写锁时，调用线程不会阻塞，而会立即返回，错误码是EBUSY。</p>
<p>无论是读锁还是写锁都提供了限时等待，如果不能获取读写锁，则会陷入阻塞，最多等待到abstime，如果仍然无法获得锁，则返回，错误码是ETIMEOUT。</p>
<p>从表面上看，读写锁介绍到此处就可以打完收工了，其实不然，读写锁是两种类型的锁，当它们都存在时，它们之间的竞争关系如何？如果同时到来一大拨读锁请求和写锁请求，它们之间的响应又有什么特点？事实上，这些是由读写锁的策略决定的。</p>
<h2 id="读写锁的竞争策略"><a href="#读写锁的竞争策略" class="headerlink" title="读写锁的竞争策略"></a>读写锁的竞争策略</h2><p>读写锁的属性是pthread_rwlockattr_t类型，属性中有两个部分：lockkind和pshared。所谓lockkind，表示读写锁表现出什么样的行为艺术。对于读写锁，目前有两种策略，一是读者优先，一是写者优先。glibc引入了如下接口来查询和改变读写锁的类型：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_getkind_np</span><span class="params">(<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> * attr, <span class="type">int</span> * pref)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_setkind_np</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> * attr, <span class="type">int</span> * pref)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中，读写锁类型的可能值有如下几种：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PTHREAD_RWLOCK_PREFER_READER_NP, <span class="comment">//读者优先</span></span><br><span class="line">  PTHREAD_RWLOCK_PREFER_WRITER_NP, <span class="comment">//很唬人，但是也是读者优先</span></span><br><span class="line">  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, <span class="comment">//写者优先</span></span><br><span class="line">  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>前两个都是读者优先的策略，尤其要注意其中的第二个，名字取得很“变态”，名为PREFER_WRITE却干着“挂羊头卖狗肉”的勾当。只有第三个是写者优先的策略。从<code>pthread_rwlock_init</code>函数中可以看出端倪：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwlock-&gt;__data.__flags = iattr-&gt;lockkind == PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;</span><br></pre></td></tr></table></figure></div>

<p>可以看到，只有<code>PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</code>是写者优先，其他一律都是读者优先。读写锁的默认行为是读者优先。</p>
<p>那么，什么是读者优先呢？如果当前锁的状态是读锁，并存在写锁请求被阻塞，那么在写锁后面到来的读锁请求该如何处理就成了问题的关键。如果在写锁请求后面到来的读锁请求不被写锁请求阻塞，就可以立即响应，写锁的下场可能会比较悲惨。如果读锁请求前赴后继源源不断地到来，只要有一个读锁没完成，写锁就没份。这就是所谓的读者优先。这种策略是不公平的，极端情况下，写请求很可能被饿死。这就是多线程中的饥饿（Starvation）现象，即某些线程总是得不到锁资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250226103745551.png"
                      alt="image-20250226103745551"
                ></p>
<p>晚于写锁请求到来的读锁请求不排队乱加塞的行为引起了写锁申请者的强烈不满：凭啥仅仅因为当前是读锁，比我晚来的读锁申请者就不用排队，直接响应？鉴于此，glibc又实现了写者优先的策略。所谓写者优先是指，如果当前是读锁，有很多线程在共享读锁，这是允许的，但是一旦线程申请写锁，在写锁请求后面到来的读锁请求就会统统被阻塞，不能先于写请求拿到锁。glibc是如何做到这点的？它引入了下表中的变量。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250226103907274.png"
                      alt="image-20250226103907274"
                ></p>
<p>无论是申请读锁还是申请写锁，还是解锁，都至少会做一次全局互斥锁（对应__lock）的加锁和解锁，若不考虑阻塞，单单考虑操作本身的开销，读写锁的加解锁开销是互斥锁的两倍。当然，函数结束前或进入阻塞之前，会将全局的互斥锁释放。下面的讨论先暂时忽略该全局的互斥锁。</p>
<p>对于读锁请求而言，如果：</p>
<ul>
<li>无线程持有写锁，即<code>__writer==0</code>。</li>
<li>采用的是读者优先策略或没有写锁等待者（<code>__nr_writers_queued=0</code>）。</li>
</ul>
<p>当满足这两个条件时，读锁请求都可以立刻获得读锁，返回之前执行<code>__nr_readers++</code>，表示多了一个线程占有读锁。</p>
<p>不满足的话，则执行<code>__nr_readers_queued++</code>，表示增加一个读锁等待者，然后调用futex，陷入阻塞。醒来之后，会先执行<code>__nr_readers_queued--</code>，然后再次判断是否同时满足条件1和2。</p>
<p>对于写请求而言，如果：</p>
<ul>
<li>无线程持有写锁，即<code>__writer==0</code>。</li>
<li>没有线程持有读锁，即<code>__nr_readers==0</code>。</li>
</ul>
<p>只要满足上述条件，就会立刻拿到写锁，将<code>__writer</code>置为线程的ID（调度域）。如果不满足，那么执行<code>__nr_writers_queued++</code>，表示增加一个写锁等待者线程，然后执行futex陷入等待。醒来后，限制性<code>__nr_writers_queued--</code>，然后重新判断条件1和2。</p>
<p>对于解锁而言，如果当前锁是写锁，则执行如下操作：</p>
<p>（1）执行<code>__writer=0</code>，表示释放写锁。</p>
<p>（2）根据<code>__nr_writers_queued</code>判断有没有写锁等待者，如果有，则唤醒一个写锁等待者。如果没有写锁等待者，则判断有没有读锁等待者；如果有，则将所有的读锁等待者一起唤醒。</p>
<p>如果当前锁是读锁，则执行如下操作：</p>
<p>（1）执行<code>__nr_readers--</code>，表示读锁占有者少了一个。</p>
<p>（2）判断<code>__nr_readers</code>是否等于0，是的话则表示自己是最后一个读锁占有者，需要唤醒写锁等待者或读锁等待者，根据<code>__nr_writers_queued</code>判断是否存在写锁等待者，若有，则唤醒一个写锁等待线程。如果没有写锁等待者，判断是否存在读锁等待者，若有，则唤醒所有的读锁等待者。</p>
<p>通过上面的分析可以看到，如果存在大量的读写请求，竞争非常激烈的条件下，读写锁存在很大的惯性，如果当前锁的状态是读锁状态，在读者优先的策略下，几乎总是读锁请求先得到响应，写锁被阻塞，因此会出现写请求被饿死的情况。解决的方法是设定成写者优先。如果当前锁的状态是写锁，而写锁也源源不断地到来，这时候，读请求就会被饿死。</p>
<p>那么能否实现一款公平的读写锁呢？答案是肯定的。Locklessinc.com中有一篇题为《Sleeping Read-Write Locks》，在分析glibc实现的基础上，给出了一种公平的实现读写锁的方法，测试下来效率很不错。对锁的实现感兴趣的话，可以阅读该文章。</p>
<hr>
<p>从宏观意义上看，读写锁要比互斥量并发性好，因为读写锁在更多的时间区域内允许并发。</p>
<p>读写锁存在如下的短处。</p>
<ul>
<li>性能：如果临界区比较大，读写锁高并发的优势就会显现出来，但是如果临界区非常小，读写锁的性能短板就会暴露出来。由于读写锁无论是加锁还是解锁，首先都会执行互斥操作，加上读写锁还需要维护当前读者线程的个数、写锁等待线程的个数、读锁等待线程的个数，因此这就决定了读写锁的开销不会小于互斥量。</li>
<li>饿死：互斥量虽然不是绝对意义上的公正，但是线程不会饿死。但是如上一小节的讨论，读者优先的策略下，写线程可能会饿死。写者优先的情况下，读线程可能会饿死。</li>
<li>死锁：读锁是可重入的，这就可能会引发死锁。考虑如下场景，读写锁采用写者优先的策略，A线程已经持有读锁，B线程申请了写锁，正处于等待状态，而持有读锁的A线程再次申请读锁，就会发生死锁。</li>
</ul>
<p>比较适合读写锁的场景是：临界区的大小比较可观，绝大多数情况下是读，只有非常少的写。</p>
<h1 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h1><p>根据局部性原理，存储器是分层的。从距离CPU最近的寄存器到主内存，依次为CPU寄存器、L1 Cache、L2 Cache、L3 Cache和主存。从高层往底层走，存储设备变得更慢，容量更大，单位字节也更便宜。最高层是很少量的寄存器，通常可以在1个时钟周期内访问它们，而接下来的L1 Cache通常可以在4个时钟周期内访问到，L2Cache通常需要10个时钟周期才能访问到，而到了主存，通常需要几百个时钟周期才能访问得到，对这个延迟数据感兴趣的话，可以阅读一下相关文献。在这种分层的存储结构中，对于每一个k，位于k层的更快更小的存储被作为位于k+1层的更大更慢的存储设备的缓存。换句话说更快更小的存储设备的数据来自更慢更大的低一级存储设备。访问的数据在高速缓存中，被称为缓存命中，这种情况下访问速度比较快。如果访问的数据d在k级缓存中不存在，就不得不从k+1级中取出包含d的那个块（block）。如果k级缓存已经满了的话，就可能会覆盖现存的一个块。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250226185554125.png"
                      alt="image-20250226185554125"
                ></p>
<p>由于高一级缓存的性能远远超过低一级的缓存，所以一旦缓存不命中（Cache miss），对性能的损害就会是比较大的。在典型的多核架构中，每个CPU都有自己的Cache。如果一个内存中的变量在多个CPU Cache中都有副本，则需要保证变量的Cache的一致性。现在大多数的架构实现Cache一致性都是采用MESI协议。</p>
<p>需要注意的是，CPU Cache是以缓存线（Cache line）为单位进行读写的。通常来说，一条缓存线的大小为64字节。换言之，就是访问1字节的数据，系统也会将该字节所在的整条缓存线的数据都搬到缓存中。因为CPU Cache具有以Cache line为单位进行读写的性质，所以在多线程编程中，稍有不慎，就会掉入伪共享的陷阱，造成性能恶化。</p>
<hr>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum1;</span><br><span class="line"><span class="type">int</span> sum2;</span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">(<span class="type">int</span> v[], <span class="type">int</span> v_count)</span> </span><br><span class="line">&#123;</span><br><span class="line">    sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v_count; i++)        </span><br><span class="line">        sum1 += v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">(<span class="type">int</span> v[], <span class="type">int</span> v_count)</span> </span><br><span class="line">&#123; </span><br><span class="line">    sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v_count; i++)</span><br><span class="line">        sum2 += v[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分代码定义了两个全局变量sum1和sum2，两个线程分别将计算结果放入各自的全局变量中，看起来并行不悖。但是由于这两个全局变量紧挨着定义，编译器给这两个变量分配的内存几乎总是紧挨着的，因此这两个变量很可能在同一条Cache line中。</p>
<p>尽管线程1所在的CPU并不需要sum2的值，但是由于sum2和sum1在同一条Cache line中，因此sum2的值也随同sum1一并被加载到了thread1所在CPU的Cache中了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250227102350556.png"
                      alt="image-20250227102350556"
                ></p>
<p>当thread1修改sum1的值时，尽管并未更新sum2的值，但影响的是整条Cache line，它会将thread2所在CPU对应的Cache line置为Invalidate。如果thread2尝试更新sum2，会触发缓存不命中。反过来，thread2修改sum2时，也会影响到sum1的缓存命中。可以想见，就因为两个值彼此毗邻，落在同一条Cache line中，会导致大量的缓存不命中，从而影响性能。</p>
<h1 id="条件等待"><a href="#条件等待" class="headerlink" title="条件等待"></a>条件等待</h1><p>条件等待是线程间同步的另一种方法。</p>
<p>线程经常遇到这种情况：要想继续执行，可能要依赖某种条件。如果条件不满足，它能做的事情就是等待，等到条件满足为止。通常条件的达成，很可能取决于另一个线程，比如生产者-消费者模型。当另外一个线程发现条件符合的时候，它会选择一个时机去通知等待在这个条件上的线程。有两种可能性，一种是唤醒一个线程，一种是广播，唤醒其他线程。</p>
<p>线程在条件不满足的情况下，主动让出互斥量，让其他线程去折腾，线程在此处等待，等待条件的满足；一旦条件满足，线程就可以立刻被唤醒。线程之所以可以安心等待，依赖的是其他线程的协作，它确信会有一个线程在发现条件满足以后，将向它发送信号，并且让出互斥量。</p>
<h2 id="条件变量的创建和销毁"><a href="#条件变量的创建和销毁" class="headerlink" title="条件变量的创建和销毁"></a>条件变量的创建和销毁</h2><p>NPTL使用pthread_cond_t类型的变量来表示条件变量。条件变量不是一个值，我们无法给条件变量赋值。一个线程如果要等待某个事件的发生，或者某个条件的满足，那么这个线程需要的是条件变量：线程等待在条件变量上。</p>
<p>和互斥锁一样，条件变量在使用之前要先初始化。互斥锁有静态初始化，条件变量也一样。简单地把PTHREAD_COND_INITIALIZER赋值给pthread_cond_t类型的变量就可完成条件变量的初始化：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></div>

<p>动态分配条件变量，或者对条件变量的属性有所定制，都需要用pthread_cond_init进行初始化，如果采用默认属性，可以将NULL作为第二个参数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure></div>

<p>对于pthread_cond_init初始化的条件变量，不要忘记调用pthread_cond_destroy来销毁。其接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<p>对于条件变量的初始化和销毁，需要注意以下几点：</p>
<ul>
<li>永远不要用一个条件变量对另一个条件变量赋值，即<code>pthread_cond_t cond_b=cond_a</code>不合法，这种行为是未定义的。</li>
<li>使用<code>PTHREAD_COND_INITIALIZE</code>静态初始化的条件变量，不需要被销毁。</li>
<li>要调用<code>pthread_cond_destroy</code>销毁的条件变量可以调用pthread_cond_init重新进行初始化。</li>
<li>不要引用已经销毁的条件变量，这种行为是未定义的。</li>
</ul>
<h2 id="条件变量的使用"><a href="#条件变量的使用" class="headerlink" title="条件变量的使用"></a>条件变量的使用</h2><p>条件变量，天生就是与条件的满足与否相伴而生的。通常，线程会对一个条件进行测试，如果条件不满足，就等待（<code>pthread_cond_wait</code>），或者等待一段有限的时间（<code>pthread_cond_timedwait</code>）。相关函数的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                      <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">       					   <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure></div>

<p>条件等待是线程间同步的一种手段，如果只有一个线程，条件不满足，那么等待千年也是枉然，所以必须要有一个线程通过某些操作，改变共享数据，使原先不满足的条件变得满足了，并且友好地通知等待在条件变量上的线程。条件不会无缘无故地突然变得满足了，必然会牵扯到共享数据的变化。所以一定要有互斥锁来保护。没有互斥锁，就无法安全地获取和修改共享数据。</p>
<p>下面的伪代码显示了POSIX如何使用条件变量v和互斥量m来等待条件的发生：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;m);</span><br><span class="line"><span class="keyword">while</span>(condition_is_false)</span><br><span class="line">    pthread_cond_wait(&amp;v,&amp;m);<span class="comment">//此处会阻塞</span></span><br><span class="line"><span class="comment">/*如果代码运行到此处，则表示我们等待的条件已经满足了，并且在此持有了互斥量*/</span></span><br><span class="line"><span class="comment">/*在满足条件的情况下，做你想做的事情。*/</span></span><br><span class="line">pthread_mutex_unlock(&amp;m);</span><br></pre></td></tr></table></figure></div>

<p><code>pthread_cond_wait</code>函数只能由拥有互斥量的线程来调用，当该函数返回的时候，系统会确保该线程再次持有互斥量，所以这个接口容易给人一种误解，就是该线程一直在持有互斥量。事实上并不是这样的。这个接口向系统声明了我在等待之后，就把互斥量给释放了。这样其他线程就有机会持有互斥量，操作共享数据，触发变化，使线程等待的条件得到满足。</p>
<p><code>pthread_cond_timedwait</code>函数与<code>pthread_cond_wait</code>的工作方式几乎是一样的，只是调用时需要指定一个超时的时间。注意这个时间是绝对时间，而不是相对时间。如果最多等待2分钟，那么这个值应该是当前时间加上2分钟。</p>
<p>上面将互斥量和条件变量配合使用的示范代码中有个很有意思的地方，就是用了<code>while</code>语句，醒来之后要再次判断条件是否满足。</p>
<p>唤醒以后，再次检查条件是否满足，是不是多此一举？答案是不得不如此。因为唤醒中存在<strong>虚假唤醒（spurious wakeup）</strong>，换言之，条件尚未满足，<code>pthread_cond_wait</code>就返回了。在一些实现中，即使没有其他线程向条件变量发送信号，等待此条件变量的线程也有可能会醒来。看起来这像是个bug，但它是实实在在存在的。为什么会存在虚假唤醒？一个原因是pthread_cond_wait是futex系统调用，属于阻塞型的系统调用，当系统调用被信号中断的时候，会返回-1，并且把errno置为EINTR。很多这种系统调用为了防止被信号中断都会重启系统调用，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">r_wait</span><span class="params">(<span class="type">int</span> *stat_loc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">while</span>(((retval = wait(stat_loc)) ==<span class="number">-1</span> &amp;&amp; (errno == EINTR));</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是futex不一样，在futex返回之后，到重启系统调用之前，可能已经调用过<code>pthread_cond_signal</code>或<code>pthread_cond_broadcast</code>。一旦错失，再次调用<code>pthread_cond_wait</code>可能就会导致无限制地等待下去。为了防止这种情况，宁可虚假唤醒，也不能再次调用<code>pthread_cond_wait</code>，以免陷入无穷的等待中。</p>
<p>除了上面的信号因素外，还存在以下情况：条件满足了发送信号，但等到调用<code>pthread_cond_wait</code>的线程得到CPU资源时，条件又再次不满足了。好在无论是哪种情况，醒来之后再次测试条件是否满足就可以解决虚假等待的问题。</p>
<hr>
<p>条件等待，等于把控制权交给了别的线程，它信任别的线程会在合适的时机通知它，这是多大的信任啊。如果其他线程忘记发送信号了，那么条件等待的线程就彻底“悲剧”了。如何发送信号来通知等待的线程呢？POSIX提供了如下两个接口：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<p>pthread_cond_signal负责唤醒等待在条件变量上的一个线程，pthread_cond_broadcast，顾名思义，就是广播唤醒等待在条件变量上的所有线程。等一下，刚才讲解pthread_cond_wait的时候曾提到过，线程醒来时会确保持有互斥量，为何广播还能唤醒等待在条件变量上的所有线程呢，不是前后矛盾吗？答案是不矛盾，<strong>所有的线程被广播唤醒了之后，集体争夺互斥锁，没抢到的继续睡</strong>。从内核中醒来，然后继续睡去，是一种性能的浪费。使用通知机制来完成线程同步，代码范例如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为让流程更加清晰，此处忽略了error handle</span></span><br><span class="line">pthread_mutex_lock(&amp;m);</span><br><span class="line"><span class="comment">/*一些对共享数据的操作，会导致另一个线程等待的条件满足*/</span></span><br><span class="line"><span class="comment">//此处也可以是pthread_cond_broadcast函数</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="comment">// 先通知条件变量、后解锁互斥量，</span></span><br><span class="line"><span class="comment">// pthread_cond_signal(&amp;cond);</span></span><br></pre></td></tr></table></figure></div>

<p>发送信号，通知等待在条件上的线程，然后解锁互斥量。注意范例代码中先发送信号，然后解锁互斥量，这个顺序不是必须的，也可以颠倒。标准允许任意顺序执行这两个调用。有什么区别吗？先通知条件变量、后解锁互斥量，效率会比先解锁、后通知条件变量低。因为先通知后解锁，执行pthread_cond_wait的线程可能在互斥量已然处于加锁状态的时候醒来，发现互斥量仍然没有解锁，就会再次休眠，从而导致了多余的上下文切换。某些实现使用等待变形（wait morphing）来优化这个问题：并不真正地唤醒执行<code>pthread_cond_wait</code>的线程，而是将线程从条件变量的等待队列转移到互斥量的等待队列上，从而消除无谓的上下文切换。</p>
<p>glibc对<code>pthread_cond_broadcast</code>做了类似的优化，即只唤醒一个线程，将其他线程从条件变量的等待队列搬移到了互斥量的等待队列中。</p>
<p>先解锁、后通知条件变量虽然可能会有性能上的优势，但是也会带来其他的问题。如果存在一个高优先级的线程，既等待在互斥量上，也等待在条件变量上；同时还存在一个低优先级的线程，只等待在互斥量上。一旦先解锁互斥量，低优先级的进程就可能会抢先获得互斥量，待调用<code>pthread_cond_signal</code>之后，高优先级的进程会发现互斥量已经被低优先级的进程抢走了。</p>
<h1 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h1><p>线程可以通过调用<code>pthread_cancel</code>函数来请求取消同一进程中的其他线程。从编程的角度来讲，不建议使用这个接口。笔者对该接口的评价不高，该接口实现了一个似是而非的功能，却引入了一堆问题。</p>
<p>Linux提供了如下函数来控制线程的取消：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure></div>

<p>一个线程可以通过调用该函数向另一个线程发送取消请求。这不是个阻塞型接口，发出请求后，函数就立刻返回了，而不会等待目标线程退出之后才返回。如果成功，该函数返回0，否则将错误码返回。对于glibc实现而言，调用<code>pthread_cancel</code>时，会向目标线程发送一个<code>SIGCANCEL</code>的信号，该信号就是被NPTL征用的32号信号。线程收到取消请求后，会采取什么行动呢？这取决于该线程的设定。NPTL提供了函数来设置线程是否允许取消，以及在允许取消的情况下，如何取消。<code>pthread_setcancelstate</code>函数用来设置线程是否允许取消，函数定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br></pre></td></tr></table></figure></div>

<p>取消类型有两种值：</p>
<ul>
<li>PTHREAD_CANCEL_DEFERRED</li>
<li>PTHREAD_CANCEL_ASYNCHRONOUS</li>
</ul>
<p>PTHREAD_CANCEL_ASYNCHRONOUS为异步取消，即线程可能在任何时间点（可能是立即取消，但也不一定）取消线程。这种取消方式的最大问题在于，你不知道取消时线程执行到了哪一步。所以，这种取消方式太粗暴，很容易造成后续的混乱。因此不建议使用该取消方式。PTHREAD_CANCEL_DEFERRED是延迟取消，线程会一直执行，直到遇到一个取消点，这种方式也是新建线程的默认取消类型。</p>
<p>什么是取消点？就是对于某些函数，如果线程允许取消且取消类型是延迟取消，并且线程也收到了取消请求，那么当执行到这些函数的时候，线程就可以退出了。标准规定了很多函数必须是取消点，由于太多（有好几十个之多），就不一一罗列了，通过man pthreads可以查询到这些取消点函数。</p>
<p>线程执行到取消点，会自动处理取消请求，但是如果线程没有用到任何取消点函数，那该怎么办，如何响应取消请求？为了应对这种场景，系统引入了<code>pthread_testcancel</code>函数，该函数一定是取消点。所以编程者可以周期性地调用该函数，只要有取消请求，线程就能响应。该函数定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_testcancel</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果线程被取消，并且其分离状态是可连接的，那么需要由其他线程对其进行连接。连接之后，pthread_join函数的第二个参数会被置成PTHREAD_CANCELED，通过该值可以知道线程并不是“寿终正寝”，而是被其他线程取消而导致的退出。</p>
<p>接口都介绍完了，是时候讨论下线程取消的弊端了。线程取消是一种在线程的外部强行终止线程的执行做法，由于无法预知目标线程内部的情况，尤其是第一种异步取消类型，因此可能会带来毁灭性的结果。目标线程可能会持有互斥量、信号量或其他类型的锁，这时候如果收到取消请求，并且取消类型是异步取消，那么可能目标线程掌握的资源还没有来得及释放就被迫退出了，这可能会给其他线程带来不可恢复的后果，比如死锁（其他线程再也无法获得资源）。即使执行异步取消也安然无恙的函数称为异步取消安全函数（async-cancel-safe function），手册里说只有下述三个函数是异步取消安全函数，所以对于其他函数，一律都不是异步取消安全函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_cancel()</span><br><span class="line">pthread_setcancelstate()</span><br><span class="line">pthread_setcanceltype()</span><br></pre></td></tr></table></figure></div>

<p>所以对编程人员而言，应该遵循以下原则：</p>
<ul>
<li>第一，轻易不要调用pthread_cancel函数，在外部杀死线程是很糟糕的做法，毕竟如果想通知目标线程退出，还可以采取其他方法。</li>
<li>第二，如果不得不允许线程取消，那么在某些非常关键不容有失的代码区域，暂时将线程设置成不可取消状态，退出关键区域之后，再恢复成可以取消的状态。</li>
<li>第三，在非关键的区域，也要将线程设置成延迟取消，永远不要设置成异步取消。</li>
</ul>
<hr>
<p>假设遇到取消请求，线程执行到了取消点，却没有来得及做清理动作（如动态申请的内存没有释放，申请的互斥量没有解锁等），可能会导致错误的产生，比如死锁，甚至是进程崩溃。</p>
<p>为了避免这种情况，线程可以设置一个或多个清理函数，线程取消或退出时，会自动执行这些清理函数，以确保资源处于一致的状态。其相关接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *),<span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure></div>

<p>标准允许用宏（macro）来实现这两个接口，Linux就是用宏来实现的。这意味着这两个函数必须同时出现，并且属于同一个语法块。</p>
<p>其中<code>pthread_cleanup_pop</code>的用处是，删除注册的清理函数。如果参数是非0值，那么执行一次，再删除清理函数。否则的话，就直接删除清理函数。</p>
<p>第三个问题最关键，何时会触发注册的清理函数：</p>
<ul>
<li>当线程的主函数是调用pthread_exit返回的，清理函数总是会被执行。</li>
<li>当线程是被其他线程调用pthread_cancel取消的，清理函数总是会被执行。</li>
<li>当线程的主函数是通过return返回的，并且<code>pthread_cleanup_pop</code>的唯一参数execute是0时，清理函数不会被执行。</li>
<li>当线程的主函数是通过return返回的，并且<code>pthread_cleanup_pop</code>的唯一参数execute是非零值时，清理函数会执行一次。</li>
</ul>
<h1 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h1><p>使用线程局部存储（Thread Local Storage）技术能为每一个线程都分别维护一个变量的副本，尽管名字相同却分别存储，并行不悖。在Linux下有两种方法可以实现线程局部存储：</p>
<ul>
<li>使用NPTL提供的函数。</li>
<li>使用编译器扩展的<code>__thread</code>关键字。</li>
</ul>
<h2 id="NPTL库"><a href="#NPTL库" class="headerlink" title="NPTL库"></a>NPTL库</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key,<span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>pthread_key_create</code>函数会为线程局部存储创建一个新键，并通过给key赋值，返回给用户使用。因为进程中的所有线程都可以使用返回的键，所以参数key应该指向一个全局变量。参数destructor指向一个自定义的函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">destructor</span><span class="params">(<span class="type">void</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*多是为了释放value指针指向的资源*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>线程终止时，如果key关联的值不是NULL，那么NTPL会自动执行定义的destructor函数。如果无须解构，可以将destructor设置为NULL。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 用于为每个线程保存文件指针的 TSD 键值,根据键值可以找到线程各自的Data。*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span>    thread_log_key;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_thread_log</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* thread_log=(FILE*)pthread_getspecific(thread_log_key);</span><br><span class="line">    <span class="built_in">fprintf</span>(thread_log, <span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fn_close_thread_log</span><span class="params">(<span class="type">void</span> *thread_log)</span></span><br><span class="line">&#123;</span><br><span class="line">    fclose((FILE *)thread_log);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> thread_log_filename[<span class="number">128</span>];</span><br><span class="line">    FILE *thread_log;</span><br><span class="line">    <span class="built_in">sprintf</span>(thread_log_filename, <span class="string">&quot;thread%ld.log&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)pthread_self());</span><br><span class="line">    thread_log = fopen(thread_log_filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">/* 将文件指针保存在thread_log_key标识的 TSD 中。*/</span></span><br><span class="line">    pthread_setspecific(thread_log_key,thread_log);</span><br><span class="line">    write_to_thread_log(<span class="string">&quot;Thread starting.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">/* 创建一个键值，用于将线程日志文件指针保存在TSD中。</span></span><br><span class="line"><span class="comment">     * 调用close_thread_log以关闭这些文件指针。*/</span></span><br><span class="line">    pthread_key_create(&amp;thread_log_key, fn_close_thread_log);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        pthread_create(&amp;(threads[i]), <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>记录槽位分配情况的数据结构pthread_keys是进程唯一的。对于上面的示例代码而言，第一次调用pthread_key_create毫无疑问会领到slot 0。即thread_log_key的值为0，表示占用了0号槽位.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250303162328824.png"
                      alt="image-20250303162328824"
                ></p>
<p>目前，各个线程还没有数据和该key相关联。接下来线程函数通过调用pthread_setspecific函数，将key分别与各自的线程数据关联起来。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_setspecific(thread_log_key,thread_log);</span><br></pre></td></tr></table></figure></div>

<p>每个线程槽位号0各自指向了线程自己的数据。从此处开始分家，key是同一个key，但每个线程指向的数据各不相同.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E7%BA%BF%E7%A8%8B/image-20250303162437154.png"
                      alt="image-20250303162437154"
                ></p>
<p>线程如果想要使用各自的值怎么办？拿这个key，去找到与key关联的数据结构，这是<code>pthread_getspecific</code>函数的职责所在。</p>
<p>因为线程知道key关联的数据结构是什么类型，所以可以从key直接获取到key指向的value。取到线程的特有数据之后，就可以操作了。由于key属于全局变量，因此取到的线程特有数据value就变成了线程内部的“全局变量”。1024个key，对于普通的应用来说足够了。如果一个多线程应用确实需要很多的线程特有数据，那么可以将其封装在一个数据结构之内。这种方法，允许的键值个数有限并不是问题的关键，问题的关键是它的接口太难用了，接口设计得有点反人类。</p>
<h2 id="thread关键字"><a href="#thread关键字" class="headerlink" title="__thread关键字"></a><code>__thread</code>关键字</h2><p>由于NPTL提供的接口太难用，有人想到了在编译器中增加新功能，支持特定的关键字<code>__thread</code>，隐式地构造线程局部变量。它的使用方法非常简单：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="type">int</span> val = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>凡是带有<code>__thread</code>关键字的变量，每个线程都会有该变量的一个拷贝，并行不悖，互不干扰。该局部变量一直都在，直到线程退出为止。使用线程局部变量需要注意以下几点：</p>
<ul>
<li>如果变量生命中使用了关键字static或extern，那么关键字<code>__thread</code>应该紧随其后。</li>
<li>声明时，可以正常初始化。</li>
<li>可以通过取地址操作符（&amp;）获取到线程局部变量的地址。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">__thread FILE* thread_log = <span class="literal">NULL</span> ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_thread_log</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(thread_log, <span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> thread_log_filename[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(thread_log_filename, <span class="string">&quot;thread%ld.log&quot;</span>,(<span class="type">unsigned</span> <span class="type">long</span>)pthread_self());</span><br><span class="line">    thread_log = fopen(thread_log_filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    write_to_thread_log(<span class="string">&quot;Thread starting.&quot;</span>);</span><br><span class="line">    fclose(thread_log);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        pthread_create(&amp;(threads[i]), <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h1><p>信号出现地要比线程早，所以设计信号时，尚没有线程。在引入线程之后，如何设计信号成了一个难点。既要保证传统的语义不变，又要设计出适用于多线程环境的信号模型，确实难度不小。</p>
<ul>
<li>信号处理函数是进程层面的概念，或者说是线程组层面的概念，线程组内所有线程共享对信号的处理函数。</li>
<li>对于发送给进程的信号，内核会任选一个线程来执行信号处理函数，执行完后，会将其从挂起信号队列中去除，其他进程不会对一个信号重复响应。</li>
<li>可以针对进程中的某个线程发送信号，那么只有该线程能响应，执行相应的信号处理函数。</li>
<li>信号掩码是线程层面的概念，信号处理函数在线程组内是统一的，但是信号掩码是各自独立可配置的，各个线程独立配置自己要阻止或放行的信号集合。</li>
<li>挂起信号（内核已经收到，但尚未递送给线程处理的信号）既是针对进程的，又是针对线程的。内核维护两个挂起信号队列，一个是进程共享的挂起信号队列，一个是线程特有的挂起信号队列。调用函数sigpending返回的是两者的并集。对于线程而言，优先递送发给线程自身的信号。</li>
</ul>
<p>上面这些内容，基本概括了多线程条件下信号的模型。内核如何做到这些模型，在信号篇中基本都有介绍，在此处就不再赘述了。</p>
<h2 id="设置线程的信号掩码"><a href="#设置线程的信号掩码" class="headerlink" title="设置线程的信号掩码"></a>设置线程的信号掩码</h2><p>前面已提到过，信号掩码是针对线程的，每个线程都可以自行设置自己的信号掩码。如果自己不设置，就会继承创建者的信号掩码。NPTL实现了如下接口来设置线程的信号掩码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *new, <span class="type">sigset_t</span> *old)</span>;</span><br></pre></td></tr></table></figure></div>

<p>how 的值用来指定如何更改信号组：</p>
<ul>
<li><code>SIG_BLOCK</code>向当前信号掩码中添加new，其中new表示要阻塞的信号组。</li>
<li><code>SIG_UNBLOCK</code>从当前信号掩码中删除new，其中new表示要取消阻塞的信号组。</li>
<li><code>SIG_SETMASK</code>将当前信号掩码替换为new，其中new表示新的信号掩码。</li>
</ul>
<p>该接口的使用方式和sigprocmask一模一样，在Linux上，两个函数的实现是相同的。</p>
<blockquote>
<p>IGCANCEL和SIGSETXID信号被用于NPTL实现，因此用户不能也不应该改变这两个信号的行为方式。好在用户不用操心这两个信号，sigprocmask函数和pthread_sigmask函数对这两者都做了特殊处理。</p>
</blockquote>
<h2 id="向线程发送信号"><a href="#向线程发送信号" class="headerlink" title="向线程发送信号"></a>向线程发送信号</h2><p>之前提到过向线程发送信号的系统调用<code>tkill/tgkill</code>，无奈<code>glibc</code>并未将它们封装成可以直接调用的函数。不过，幸好提供了另外一个函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div>

<p>由于<code>pthread_t</code>类型的线程ID只在线程组内是唯一的，其他进程完全可能存在线程ID相同的线程，所以<code>pthread_kill</code>只能向同一个进程的线程发送信号。除了这个接口外，Linux还提供了特有的函数将<code>pthread_kill</code>和<code>sigqueue</code>功能累加在一起：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigqueue</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这个接口和<code>sigqueue</code>一样，可以发送携带数据的信号。当然，只能发给同一个进程内的线程。</p>
<h2 id="多线程程序对信号的处理"><a href="#多线程程序对信号的处理" class="headerlink" title="多线程程序对信号的处理"></a>多线程程序对信号的处理</h2><p>单线程的程序，对信号的处理已经比较复杂了。因为信号打断了进程的控制流，所以信号处理函数只能调用异步信号安全的函数。而异步信号安全是个很苛刻的条件。多线程的引入，加剧了这种复杂度。因为信号可以发送给进程，也可以发送给进程内的某一线程。不同线程还可以设置自己的掩码来实现对信号的屏蔽。而且，没有一个线程相关的函数是异步信号安全的，信号处理函数不能调用任何<code>pthread</code>函数，也不能通过条件变量来通知其他线程。</p>
<p><strong>在多线程程序中，使用信号的第一原则就是不要使用信号。</strong></p>
<p><strong>在多线程程序中，使用信号的第一原则就是不要使用信号。</strong></p>
<p><strong>在多线程程序中，使用信号的第一原则就是不要使用信号。</strong></p>
<ul>
<li>不要主动使用信号作为进程间通信的手段，收益和引入的风险完全不成比例。</li>
<li>不主动改变异常处理信号的信号处理函数。用于管道和<code>socket</code>的<code>SIGPIPE</code>可能是例外，默认语义是终止进程，很多情况下，需要忽略该信号。</li>
<li>如果无法避免，必须要处理信号，那么就采用<code>sigwaitinfo</code>或<code>signalfd</code>的方式同步处理信号，减少异步处理带来的风险和引入bug的可能。</li>
</ul>
<h1 id="多线程与fork"><a href="#多线程与fork" class="headerlink" title="多线程与fork"></a>多线程与fork</h1><p>多线程和fork函数的协作性非常差。对于多线程和fork，最重要的建议就是：</p>
<p><strong>永远不要在多线程程序里面调用fork。</strong></p>
<p><strong>永远不要在多线程程序里面调用fork。</strong></p>
<p><strong>永远不要在多线程程序里面调用fork。</strong></p>
<p>Linux的fork函数，会复制一个进程，对于多线程程序而言，fork函数复制的是调用fork的那个线程，而并不复制其他的线程。fork之后其他线程都不见了。Linux不存在forkall语义的系统调用，无法做到将多线程全部复制。多线程程序在fork之前，其他线程可能正持有互斥量处理临界区的代码。fork之后，其他线程都不见了，那么互斥量的值可能处于不可用的状态，也不会有其他线程来将互斥量解锁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        setenv(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigalrm</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    write(fileno(<span class="built_in">stderr</span>), &amp;a, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> setenv_thread;</span><br><span class="line">    pthread_create(&amp;setenv_thread, <span class="literal">NULL</span>, worker, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            signal(SIGALRM, sigalrm);</span><br><span class="line">            alarm(<span class="number">1</span>);</span><br><span class="line">            unsetenv(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait3(<span class="literal">NULL</span>, WNOHANG, <span class="literal">NULL</span>);</span><br><span class="line">        usleep(<span class="number">2500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码比较简单，创建了一个线程周期性地执行setenv函数，修改环境变量。主线程会fork子进程，子进程负责执行<code>unsetenv</code>函数，同时调用了alarm，一秒钟后会收到<code>SIGALRM</code>信号。子进程通过执行signal函数，注册了<code>SIGALRM</code>信号的处理函数，即向标准错误打印字母<code>a</code>。fork创建的子进程在调用alarm注册的闹钟之后，只执行<code>unsetenv</code>函数，然后就会调用exit退出。因此，在正常情况下子进程很快就会退出，alarm约定的1秒钟时间还未到就退出了。也就是说，信号处理函数不应该被执行，自然也就不应该打印出字母<code>a</code>。</p>
<p>实际上：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./thread_fork</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa^C</span><br></pre></td></tr></table></figure></div>

<p>原因何在？在某些情况下，子进程为什么不能及时退出，以至于过了1秒之后，子进程还没有退出？选择一个阻塞的线程，用gdb调试下，看看到底阻塞在何处。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  __lll_lock_wait_private () at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:<span class="number">95</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00007fd5c50270f6</span> in _L_lock_740 () from /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00007fd5c5026f2a</span> in __unsetenv (name=<span class="number">0x400b24</span> <span class="string">&quot;bar&quot;</span>) at setenv.c:<span class="number">325</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0x0000000000400a6d</span> in <span class="title function_">main</span> <span class="params">()</span> at fork.c:41</span><br></pre></td></tr></table></figure></div>

<p>现在的库函数，为了做到可重入，其内部维护的变量通常会使用互斥量来保护。这些锁对用户一般是透明的，用户也不关心。setenv和unsetenv就是这样。尽管上述代码并没有显式地定义，但是进程内部已经维护了一个互斥量。互斥量中维护了一个锁的值：0表示未上锁，1表示已上锁但是没有等待线程，2表示已上锁，并且有线程等待该锁。</p>
<p>对于我们的例子而言，由于线程每100微秒就执行一次setenv，很有可能在主线程调用fork创建子进程的瞬间，互斥量的值是1。而这个值1被拷贝到了子进程。对于父进程而言互斥量的值是1自然没有关系，因为父进程中有线程worker不停地加锁、解锁。但是子进程的情况就不同了，子进程中没有worker。子进程自创建成功开始，setenv相关的互斥量的值就一直是1。子进程调用unsetenv函数时，“地雷”被引爆了。unsetenv无法获得互斥量，反而是通过调用futex系统调用陷入休眠，内核将其挂入对应的等待队列。父进程的worker线程的解锁操作会唤醒子进程吗？下面是内核<code>get_futex_key</code>函数中的部分代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fshared) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!access_ok(VERIFY_WRITE, uaddr, <span class="keyword">sizeof</span>(u32))))</span><br><span class="line">       <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    key-&gt;private.mm = mm;</span><br><span class="line">    key-&gt;private.address = address;</span><br><span class="line">    get_futex_key_refs(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>新建立的<code>futex</code>使用mm结构指针和地址<code>address</code>作为futex的键值，由于父子进程之间并不共享<code>mm_struct</code>，也就是说子进程的futex和父进程futex并不共享等待队列。换句话说，父进程通过setenv解锁时，根本就不会唤醒子进程。因此，子进程永远都不可能被唤醒了。这仅仅是<code>setenv/unsetenv</code>函数，库函数中类似这种的函数并不少见：</p>
<ul>
<li>malloc函数的内部实现一定会有锁。</li>
<li>printf系列的函数，其他线程可能持有stdout&#x2F;stderr的锁。</li>
<li>syslog函数内部实现也会用到锁。</li>
</ul>
<p>综合上面的讨论，唯一安全的做法是，fork之后子进程立即调用exec执行另外的程序，彻底断绝子进程与父进程之间的关系，注意是立即，不要在调用exec之前执行任何语句，哪怕是不起眼的printf。</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><h3 id="pthread-attr-t-结构体"><a href="#pthread-attr-t-结构体" class="headerlink" title="pthread_attr_t 结构体"></a><code>pthread_attr_t</code> 结构体</h3><p><code>pthread_attr_t</code> 是POSIX线程库中定义的一个结构体类型，用于设置和获取线程属性。通过这类属性，可以控制线程的行为和特性，比如栈大小、调度策略等。</p>
<h4 id="常用的线程属性功能"><a href="#常用的线程属性功能" class="headerlink" title="常用的线程属性功能"></a>常用的线程属性功能</h4><p><code>pthread_attr_t</code> 结构体的具体定义通常是隐藏的，它通过API来进行交互。在使用线程属性时，涉及到以下一些常用的函数：</p>
<ol>
<li><p><strong>初始化和销毁属性对象</strong></p>
<ul>
<li><code>pthread_attr_init(pthread_attr_t *attr)</code>: 初始化线程属性对象，设置为默认值。</li>
<li><code>pthread_attr_destroy(pthread_attr_t *attr)</code>: 释放线程属性对象。</li>
</ul>
</li>
<li><p><strong>设置和获取线程栈大小</strong></p>
<ul>
<li><code>pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize)</code>: 设置线程的栈大小。</li>
<li><code>pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize)</code>: 获取线程的栈大小。</li>
</ul>
</li>
<li><p><strong>设置和获取线程调度策略</strong></p>
<ul>
<li><code>pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)</code>: 设置线程的调度策略（如 <code>SCHED_FIFO</code>, <code>SCHED_RR</code>, <code>SCHED_OTHER</code>）。</li>
<li><code>pthread_attr_getschedpolicy(pthread_attr_t *attr, int *policy)</code>: 获取线程的调度策略。</li>
</ul>
</li>
<li><p><strong>设置和获取调度参数</strong></p>
<ul>
<li><code>pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param)</code>: 设置线程的调度参数，通常用于设置优先级。</li>
<li><code>pthread_attr_getschedparam(pthread_attr_t *attr, struct sched_param *param)</code>: 获取线程的调度参数。</li>
</ul>
</li>
<li><p><strong>设置和获取线程是否为可加入</strong></p>
<ul>
<li><code>pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)</code>: 设置线程的可加入状态（<code>PTHREAD_CREATE_JOINABLE</code>, <code>PTHREAD_CREATE_DETACHED</code>）。</li>
<li><code>pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate)</code>: 获取线程的可加入状态。</li>
</ul>
</li>
<li><p><strong>设置和获取继承调度属性</strong></p>
<ul>
<li><code>pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched)</code>: 设置调度属性继承方式。</li>
<li><code>pthread_attr_getinheritsched(pthread_attr_t *attr, int *inheritsched)</code>: 获取调度属性继承方式。</li>
</ul>
</li>
</ol>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>下面是一个简单示例，演示如何设置线程的栈大小：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr); <span class="comment">// 初始化线程属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程栈大小</span></span><br><span class="line">    result = pthread_attr_setstacksize(&amp;attr, <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">// Set stack size to 1MB</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_attr_setstacksize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设置的线程栈大小</span></span><br><span class="line">    pthread_attr_getstacksize(&amp;attr, &amp;stacksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack size set: %zu bytes\n&quot;</span>, stacksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并应用属性</span></span><br><span class="line">    result = pthread_create(&amp;thread, &amp;attr, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>); <span class="comment">// 等待线程完成</span></span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr); <span class="comment">// 销毁属性对象</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过上述API与<code>pthread_attr_t</code>结构体互动，我们可以灵活管理线程的各种属性以适应不同应用场景。</p>
<h3 id="pthread-spinlock-t-结构体"><a href="#pthread-spinlock-t-结构体" class="headerlink" title="pthread_spinlock_t 结构体"></a><code>pthread_spinlock_t</code> 结构体</h3><p><code>pthread_spinlock_t</code> 是 POSIX 线程库中用于实现自旋锁的结构体。自旋锁是一种简单的锁机制，用于在多处理器系统中实现线程同步。与互斥锁不同，自旋锁在等待锁释放时不会使线程进入休眠状态，而是不断地检查锁的状态（即“自旋”），直到获得锁或满足其他条件。</p>
<h4 id="自旋锁的特性"><a href="#自旋锁的特性" class="headerlink" title="自旋锁的特性"></a>自旋锁的特性</h4><ul>
<li><strong>忙等待</strong>: 自旋锁在等待锁释放时会一直占用 CPU 资源进行循环检查，因此适合用于锁持有时间非常短的场景。</li>
<li><strong>低开销</strong>: 由于不涉及线程调度和上下文切换，自旋锁的开销较低。</li>
<li><strong>适用场景</strong>: 适用于多处理器系统中短时间的锁定操作，不适合单处理器系统或长时间的锁定操作，因为会导致 CPU 资源浪费。</li>
</ul>
<p><code>pthread_spinlock_t</code> 通常是一个简单的整数或指针类型，用于表示锁的状态。具体实现可能因平台和编译器而异，但通常它是一个原子类型，以便在多线程环境中安全地进行操作。</p>
<h4 id="使用自旋锁的函数"><a href="#使用自旋锁的函数" class="headerlink" title="使用自旋锁的函数"></a>使用自旋锁的函数</h4><p>POSIX 线程库提供了一组函数用于操作自旋锁：</p>
<ol>
<li><p><strong>初始化和销毁</strong>:</p>
<ul>
<li><code>int pthread_spin_init(pthread_spinlock_t *lock, int pshared);</code><ul>
<li>初始化自旋锁。</li>
<li><code>pshared</code> 参数指定锁是否在进程间共享，通常为 <code>PTHREAD_PROCESS_PRIVATE</code>。</li>
</ul>
</li>
<li><code>int pthread_spin_destroy(pthread_spinlock_t *lock);</code><ul>
<li>销毁自旋锁。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>锁定和解锁</strong>:</p>
<ul>
<li><code>int pthread_spin_lock(pthread_spinlock_t *lock);</code><ul>
<li>获取自旋锁。如果锁已经被持有，调用线程将一直自旋等待。</li>
</ul>
</li>
<li><code>int pthread_spin_trylock(pthread_spinlock_t *lock);</code><ul>
<li>尝试获取自旋锁。如果锁已经被持有，立即返回而不自旋。</li>
</ul>
</li>
<li><code>int pthread_spin_unlock(pthread_spinlock_t *lock);</code><ul>
<li>释放自旋锁。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><p>下面是一个简单的示例，演示如何使用自旋锁进行线程同步：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        pthread_spin_lock(&amp;spinlock);</span><br><span class="line">        shared_resource++;</span><br><span class="line">        pthread_spin_unlock(&amp;spinlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化自旋锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_spin_init&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印共享资源的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared resource value: %d\n&quot;</span>, shared_resource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁自旋锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_spin_destroy(&amp;spinlock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_spin_destroy&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><strong>忙等待的代价</strong>: 自旋锁在等待时会消耗 CPU 资源，因此在锁持有时间较长时可能导致性能下降。</li>
<li><strong>适用场景</strong>: 自旋锁适用于多处理器系统中短时间的锁定操作，不适合单处理器系统或长时间的锁定操作。</li>
<li><strong>正确初始化和销毁</strong>: 确保在使用自旋锁之前正确初始化，并在不再需要时销毁以释放资源。</li>
</ul>
<p>通过合理使用 <code>pthread_spinlock_t</code>，可以在合适的场景中实现高效的线程同步。</p>
<h3 id="pthread-rwlock-t-结构体"><a href="#pthread-rwlock-t-结构体" class="headerlink" title="pthread_rwlock_t 结构体"></a><code>pthread_rwlock_t</code> 结构体</h3><p><code>pthread_rwlock_t</code> 是 POSIX 线程库中用于实现读写锁的结构体。读写锁允许多个线程同时读取共享资源，但在写入时，只有一个线程可以进行操作。这种机制提高了对共享资源的并发访问效率，特别是在读操作远多于写操作的场景中。</p>
<h4 id="读写锁的基本概念"><a href="#读写锁的基本概念" class="headerlink" title="读写锁的基本概念"></a>读写锁的基本概念</h4><ul>
<li><strong>读锁（共享锁）</strong>: 多个线程可以同时持有读锁，只要没有线程持有写锁。</li>
<li><strong>写锁（独占锁）</strong>: 当一个线程持有写锁时，其他线程不能持有读锁或写锁。</li>
</ul>
<p><code>pthread_rwlock_t</code> 是一个不透明的数据类型，其具体实现是由系统库提供的。用户不需要关心其内部结构，只需通过提供的 API 进行操作。</p>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><p>以下是与 <code>pthread_rwlock_t</code> 相关的主要函数：</p>
<p><strong>初始化和销毁</strong></p>
<ul>
<li><p><strong>初始化</strong>:</p>
<ul>
<li><p><code>pthread_rwlock_init</code>: 初始化读写锁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>rwlock</code>: 指向读写锁对象的指针。</li>
<li><code>attr</code>: 指向读写锁属性对象的指针，通常为 <code>NULL</code> 表示使用默认属性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>销毁</strong>:</p>
<ul>
<li><p><code>pthread_rwlock_destroy</code>: 销毁读写锁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>rwlock</code>: 指向读写锁对象的指针。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>加锁和解锁</strong></p>
<ul>
<li><p><strong>读锁</strong>:</p>
<ul>
<li><p><code>pthread_rwlock_rdlock</code>: 获取读锁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>pthread_rwlock_tryrdlock</code>: 尝试获取读锁（非阻塞）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>写锁</strong>:</p>
<ul>
<li><p><code>pthread_rwlock_wrlock</code>: 获取写锁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>pthread_rwlock_trywrlock</code>: 尝试获取写锁（非阻塞）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>解锁</strong>:</p>
<ul>
<li><p><code>pthread_rwlock_unlock</code>: 释放读锁或写锁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><p>以下是一个简单的示例，演示如何使用读写锁：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reader: shared_resource = %d\n&quot;</span>, shared_resource);</span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">    shared_resource++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Writer: shared_resource = %d\n&quot;</span>, shared_resource);</span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> r1, r2, w1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_rwlock_init&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;r1, <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;w1, <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;r2, <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    pthread_join(r1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(w1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(r2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><strong>初始化后使用</strong>: 在使用读写锁之前，必须先初始化。</li>
<li><strong>正确解锁</strong>: 确保在持有锁的线程完成操作后，正确地释放锁。</li>
<li><strong>避免死锁</strong>: 小心避免死锁，特别是在多个锁交替使用的情况下。</li>
<li><strong>性能考虑</strong>: 读写锁在读操作多于写操作时可以提高性能，但在写操作频繁的情况下，可能会导致写线程饥饿。</li>
</ul>
<h3 id="pthread-cond-t-结构体"><a href="#pthread-cond-t-结构体" class="headerlink" title="pthread_cond_t 结构体"></a><code>pthread_cond_t</code> 结构体</h3><p><code>pthread_cond_t</code> 是 POSIX 线程库中用于条件变量的结构体。条件变量提供了一种线程间的同步机制，允许线程在等待某个条件满足时进入睡眠状态，并在条件满足时被唤醒。条件变量通常与互斥锁结合使用，以确保对共享资源的安全访问。</p>
<p><code>pthread_cond_t</code> 是一个用于条件变量的结构体类型。它的具体实现细节在不同的操作系统和库版本中可能有所不同，因此通常不直接访问其内部成员，而是通过提供的 API 函数进行操作。</p>
<h4 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h4><p>以下是与 <code>pthread_cond_t</code> 相关的一些主要函数：</p>
<p><strong>初始化和销毁</strong></p>
<ul>
<li><p><strong>pthread_cond_init</strong>: 初始化条件变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>cond</code>: 指向条件变量的指针。</li>
<li><code>attr</code>: 指向条件变量属性的指针，通常为 <code>NULL</code> 使用默认属性。</li>
</ul>
</li>
<li><p><strong>pthread_cond_destroy</strong>: 销毁条件变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>cond</code>: 指向要销毁的条件变量的指针。</li>
</ul>
</li>
</ul>
<p><strong>等待和唤醒</strong></p>
<ul>
<li><p><strong>pthread_cond_wait</strong>: 使线程等待条件变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>cond</code>: 指向条件变量的指针。</li>
<li><code>mutex</code>: 指向互斥锁的指针。调用此函数时，互斥锁必须已被锁定。函数会自动释放锁并等待条件变量，条件满足时重新锁定互斥锁。</li>
</ul>
</li>
<li><p><strong>pthread_cond_timedwait</strong>: 使线程等待条件变量，带有超时功能。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>abstime</code>: 指定绝对时间的 <code>timespec</code> 结构体，超时后函数返回。</li>
</ul>
</li>
<li><p><strong>pthread_cond_signal</strong>: 唤醒一个等待条件变量的线程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>cond</code>: 指向条件变量的指针。</li>
</ul>
</li>
<li><p><strong>pthread_cond_broadcast</strong>: 唤醒所有等待条件变量的线程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>cond</code>: 指向条件变量的指针。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h4><p>条件变量通常与互斥锁结合使用，以确保对共享资源的安全访问。以下是一个简单的示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Worker thread proceeding\n&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程准备好后唤醒工作线程</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ready = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><strong>互斥锁配合使用</strong>: 在等待条件变量时，必须持有相关的互斥锁，以防止竞争条件。</li>
<li><strong>避免虚假唤醒</strong>: <code>pthread_cond_wait</code> 可能会出现虚假唤醒，因此通常在循环中检查条件。</li>
<li><strong>资源管理</strong>: 确保在程序结束时正确销毁条件变量和互斥锁，以避免资源泄漏。</li>
</ul>
<h3 id="pthread-key-t-类型"><a href="#pthread-key-t-类型" class="headerlink" title="pthread_key_t 类型"></a><code>pthread_key_t</code> 类型</h3><p><code>pthread_key_t</code> 是用于线程特定数据（Thread-Specific Data, TSD）的键类型。是一个类型定义，用于标识线程特定数据的键。每个线程都有自己独立的线程特定数据副本，这些数据可以通过键来访问。</p>
<h4 id="线程特定数据概述"><a href="#线程特定数据概述" class="headerlink" title="线程特定数据概述"></a>线程特定数据概述</h4><p>线程特定数据允许每个线程拥有自己的数据副本，而不需要显式地将数据传递给每个函数。这在需要线程本地存储的情况下非常有用，例如在多线程环境中使用全局变量的替代方案。</p>
<h4 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h4><p>以下是与 <code>pthread_key_t</code> 相关的主要函数：</p>
<p><strong><code>pthread_key_create</code></strong></p>
<p>用于创建一个新的线程特定数据键。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>key</code>: 指向 <code>pthread_key_t</code> 类型的指针，用于存储创建的键。</li>
<li><code>destructor</code>: 可选的析构函数指针，当线程退出时用于清理线程特定数据。如果不需要，可以传递 <code>NULL</code>。</li>
</ul>
<p><strong><code>pthread_key_delete</code></strong></p>
<p>用于删除一个线程特定数据键。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>key</code>: 要删除的键。</li>
</ul>
<p><strong><code>pthread_setspecific</code></strong></p>
<p>用于为当前线程设置与键关联的线程特定数据。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>key</code>: 线程特定数据的键。</li>
<li><code>value</code>: 要与键关联的值。</li>
</ul>
<p><strong><code>pthread_getspecific</code></strong></p>
<p>用于获取当前线程与键关联的线程特定数据。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>key</code>: 线程特定数据的键。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是一个简单的示例，演示如何使用线程特定数据：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_key_t</span> key;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destructor</span><span class="params">(<span class="type">void</span> *value)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Destructor called for thread-specific data: %s\n&quot;</span>, (<span class="type">char</span> *)value);</span><br><span class="line">    <span class="built_in">free</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *thread_data = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(thread_data, <span class="number">20</span>, <span class="string">&quot;Thread %ld data&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_setspecific(key, thread_data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld: %s\n&quot;</span>, (<span class="type">long</span>)arg, (<span class="type">char</span> *)pthread_getspecific(key));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pthread_key_create(&amp;key, destructor);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_key_delete(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><strong>析构函数</strong>: 如果为 <code>pthread_key_create</code> 提供了析构函数，当线程退出时，系统会自动调用该函数来清理线程特定数据。</li>
<li><strong>内存管理</strong>: 线程特定数据的内存管理由程序员负责，确保在适当的时候释放内存。</li>
<li><strong>性能</strong>: 使用线程特定数据可能会有一定的性能开销，尤其是在频繁访问的情况下，因此应根据具体需求合理使用。</li>
</ul>
<h2 id="线程相关API"><a href="#线程相关API" class="headerlink" title="线程相关API"></a>线程相关API</h2><h3 id="gettid"><a href="#gettid" class="headerlink" title="gettid"></a><code>gettid</code></h3><p><code>gettid</code> 函数用于获取调用线程的线程ID（Thread ID）。线程ID在Linux系统中用来标识一个线程，通常在多线程应用程序中使用。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">gettid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>gettid</code> 不接受任何参数。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>返回调用线程的线程ID。</li>
<li>在错误的情况下，通常不返回任何错误值。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><code>gettid</code> 并不是POSIX标准的一部分，而是Linux特有的系统调用。在某些系统上，可能需要通过<code>syscall</code>来调用。</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> tid = syscall(SYS_gettid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current thread ID: %d\n&quot;</span>, tid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><strong>线程标识</strong>: <code>gettid</code> 返回的线程ID是全局唯一的，类似于进程ID（PID），但其与线程的生命周期密切相关。</li>
<li><strong>区别于<code>pthread_self</code></strong>: 与<code>pthread_self</code>返回的线程标识符不同，<code>gettid</code>提供的是内核级的线程ID。使用POSIX线程库时通常用<code>pthread_self</code>，因为<code>gettid</code>在移植性和可读性上可能不如POSIX函数。</li>
<li><strong>系统相关性</strong>: 因为<code>gettid</code>是一个系统调用，在不同的Unix或类Unix操作系统上可能存在差异，因此在需要跨平台的场景下，应谨慎使用这一函数。</li>
</ul>
<h3 id="pthread-create-1"><a href="#pthread-create-1" class="headerlink" title="pthread_create"></a><code>pthread_create</code></h3><p><code>pthread_create</code> 函数用于创建一个新的线程，并执行指定的函数。它是POSIX线程（<code>pthreads</code>）库的一部分，主要用于实现多线程并发程序。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, </span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), </span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><p><code>thread</code>: 一个指向 <code>pthread_t</code> 类型的指针，用于输出新创建线程的标识符。</p>
</li>
<li><p><code>attr</code>: 一个指向 <code>pthread_attr_t</code> 的指针，用于设置线程的属性。如果使用默认属性，传递 <code>NULL</code>。</p>
</li>
<li><p><code>start_routine</code>: 线程要运行的函数，该函数的签名必须是 <code>void *function(void *)</code> 类型。</p>
</li>
<li><p><code>arg</code>: 传递给 <code>start_routine</code> 的参数。如果不需要传参，可以传递 <code>NULL</code>。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回错误号码（errno）。</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print_message</span><span class="params">(<span class="type">void</span>* message)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)message);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello from the thread!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = pthread_create(&amp;thread, <span class="literal">NULL</span>, print_message, (<span class="type">void</span>*)message);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the created thread to complete</span></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><p><strong>并发执行</strong>: <code>pthread_create</code> 启动的线程与调用线程并发执行，可以利用多核以及处理器的多线程能力提高程序性能。</p>
</li>
<li><p><strong>可选属性</strong>: 可以通过 <code>attr</code> 设置线程的各种属性，如栈大小、调度策略等；使用 <code>NULL</code> 默认属性。</p>
</li>
<li><p><strong>线程同步</strong>: 通常与 <code>pthread_join</code> 配合使用，确保主线程等待子线程完成。</p>
</li>
<li><p><strong>强制转换</strong>: 如果在 C++ 中使用，应对 <code>start_routine</code> 函数进行 <code>extern &quot;C&quot;</code> 声明，避免名字修饰导致的链接错误。</p>
</li>
</ul>
<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a><code>pthread_exit</code></h3><p><code>pthread_exit</code> 函数用于终止调用它的线程并返回一个退出状态给已经加入此线程的线程。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>retval</code>: 是一个指向任意类型的指针，用于返回线程的退出状态或结果信息。</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 为返回值分配内存</span></span><br><span class="line">    *result = <span class="number">42</span>;  <span class="comment">// 设置返回值</span></span><br><span class="line">    pthread_exit((<span class="type">void</span> *)result);  <span class="comment">// 退出线程并传递返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">void</span>* retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(thread, &amp;retval) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread exited with value %d\n&quot;</span>, *(<span class="type">int</span> *)retval);</span><br><span class="line">    <span class="built_in">free</span>(retval);  <span class="comment">// 释放分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><strong>线程终止</strong>: 通过<code>pthread_exit</code>终止线程时，线程的状态可以由<code>retval</code>返回。</li>
<li><strong>资源清理</strong>: <code>pthread_exit</code>会在线程退出前自动执行使用<code>pthread_cleanup_push</code>注册的清理处理程序。</li>
<li><strong>避免主线程提前退出</strong>: 在主线程调用<code>pthread_exit</code>可以避免程序在子线程完成之前退出。</li>
</ul>
<h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a><code>pthread_self</code></h3><p><code>pthread_self</code> 函数用于获取调用它的线程自身的线程标识符。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>返回值</strong></p>
<ul>
<li>返回调用线程的 <code>pthread_t</code> 类型的线程标识符。</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> self_id = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)self_id);  <span class="comment">// 打印线程的ID</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(thread, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><strong>线程标识</strong>: <code>pthread_self</code> 可以用来获取当前线程的标识符，这在调试、日志记录或需要线程标识的操作中非常有用。</li>
<li><strong>可移植的类型</strong>: <code>pthread_t</code> 类型可能在不同平台上有不同的实现，因此打印或比较时通常需要进行适当的转换，例如转为 <code>unsigned long</code>。</li>
</ul>
<h3 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a><code>pthread_equal</code></h3><p><code>pthread_equal</code> 函数用于比较两个线程标识符以确定它们是否表示同一个线程。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>t1</code>: 第一个线程标识符。</li>
<li><code>t2</code>: 第二个线程标识符。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>如果两个线程标识符表示同一个线程，返回非零值。</li>
<li>如果两个线程标识符表示不同的线程，返回零。</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread_id = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较当前线程ID是否与给定的ID相同</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(thread_id, *(<span class="type">pthread_t</span>*)arg)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Same thread\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Different thread\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)&amp;thread) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(thread, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><strong>线程比较</strong>: <code>pthread_equal</code> 提供了一种兼容并可移植的方式来比较线程标识符，因为 <code>pthread_t</code> 类型的具体实现可能因平台而异，不能简单使用 <code>==</code> 运算符直接比较。</li>
<li><strong>常用于验证</strong>: 适用于需要验证两个线程是否为同一个的场景，例如在复杂多线程环境中进行一致性检查。</li>
</ul>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a><code>pthread_join</code></h3><p><code>pthread_join</code> 函数用于等待一个线程的终止。调用它的线程将阻塞，直到指定的线程完成其执行。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>thread</code>: 要等待的线程的标识符。</li>
<li><code>retval</code>: 指向存储线程退出状态的指针。如果调用 <code>pthread_exit</code> 提供了一个返回值，<code>retval</code> 将指向这个值。传 <code>NULL</code> 表示不关心线程的返回值。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功返回 0。</li>
<li>失败返回错误码，可能的错误有：<ul>
<li><code>EINVAL</code>: 线程不可连接，或已连接过。</li>
<li><code>ESRCH</code>: 无法找到指定线程。</li>
<li><code>EDEADLK</code>: 死锁检测到（例如，线程尝试连接自己）。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *result = <span class="number">42</span>;  <span class="comment">// 假设线程完成的任务返回值是42</span></span><br><span class="line">    pthread_exit((<span class="type">void</span>*)result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">int</span>* thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(thread, (<span class="type">void</span>**)&amp;thread_result) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出线程返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %d\n&quot;</span>, *thread_result);</span><br><span class="line">    <span class="built_in">free</span>(thread_result);  <span class="comment">// 记得释放分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><strong>同步机制</strong>: <code>pthread_join</code> 是一个常用的线程同步机制，用于确保一个线程在使用线程结果之前等待其他线程完成。</li>
<li><strong>资源回收</strong>: 确保线程已经终止，并为它分配的所有资源（如线程栈）被正确回收。如果不调用 <code>pthread_join</code>，在某些实现中可能导致资源泄漏。</li>
<li><strong>线程的可连接性</strong>: 一个线程只能被连接一次。多次对同一线程调用 <code>pthread_join</code> 会导致未定义行为或错误。</li>
</ul>
<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a><code>pthread_detach</code></h3><p><code>pthread_detach</code> 函数用于将一个线程的状态设置为“分离”，即表示该线程将独立运行，它的退出状态不需要被其他线程关心，系统资源可以在线程终止后立即回收。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>thread</code>: 要分离的线程的标识符。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功返回 0。</li>
<li>失败返回错误码，可能的错误包括：<ul>
<li><code>EINVAL</code>: 无效的线程标识或者线程已经处于分离状态。</li>
<li><code>ESRCH</code>: 无法找到指定线程。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Detached thread running...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Detached thread exiting...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将线程设置为分离状态</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_detach(thread) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_detach&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread is continuing without joining the detached thread.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续工作或退出</span></span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">// 确保主线程不立即终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><strong>不需等待</strong>: 分离状态的线程不需要被其他线程 <code>pthread_join</code>，它的资源将在终止时被自动回收。</li>
<li><strong>资源管理</strong>: 如果一个线程没有被分离状态也没有被 <code>pthread_join</code>，可能会导致内存泄漏，因为系统不能自动回收线程的资源。</li>
<li><strong>单独使用</strong>: 一旦线程被分离，不能再被 <code>pthread_join</code>，即程序无法获取线程的退出状态。</li>
<li><strong>适用场景</strong>: 适用于不需要关心线程完成状态或返回值的情况，例如一些后台任务或操作。</li>
</ul>
<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a><code>pthread_cancel</code></h3><p><code>pthread_cancel</code> 用于请求取消一个线程的执行。当线程接收到取消请求时，它会尝试退出。这个函数并不会立即终止被请求的线程，而是发送一个取消信号，该线程将在某个取消点（cancelation point）响应该信号。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>thread</code>: 要取消的线程的标识符。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功返回 0。</li>
<li>失败返回错误码，例如：<ul>
<li><code>ESRCH</code>: 无法找到指定的线程。</li>
</ul>
</li>
</ul>
<p><strong>线程的取消状态</strong></p>
<p>每个线程都有一个取消状态和取消类型，可以使用 <code>pthread_setcancelstate</code> 和 <code>pthread_setcanceltype</code> 来设置。</p>
<ul>
<li><p><strong>取消状态</strong>:</p>
<ul>
<li><code>PTHREAD_CANCEL_ENABLE</code>（默认）: 线程可以被取消。</li>
<li><code>PTHREAD_CANCEL_DISABLE</code>: 线程不响应取消请求。</li>
</ul>
</li>
<li><p><strong>取消类型</strong>:</p>
<ul>
<li><code>PTHREAD_CANCEL_DEFERRED</code>（默认）: 取消请求要等到线程到达取消点时才生效。常见的取消点包括：<code>pthread_join</code>、<code>pthread_cond_wait</code>、<code>read</code>、<code>write</code>等。</li>
<li><code>PTHREAD_CANCEL_ASYNCHRONOUS</code>: 取消请求尽快生效（可能会有不安全行为，因此很少使用）。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread started.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Working... (%d)\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 模拟工作</span></span><br><span class="line">        <span class="comment">// 在这里可以是取消点，取决于特定函数调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread finished normally.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程休眠2秒，模拟其他工作</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求取消线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_cancel(thread) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_cancel&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程终止</span></span><br><span class="line">    <span class="type">void</span>* retval;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(thread, &amp;retval) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == PTHREAD_CANCELED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread was canceled.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread terminated normally.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><strong>安全性</strong>: 使用 <code>pthread_cancel</code> 要谨慎，尤其是在资源管理方面，因为线程可能在不安全点被取消。</li>
<li><strong>清理处理程序</strong>: 可以使用 <code>pthread_cleanup_push</code> 和 <code>pthread_cleanup_pop</code> 注册清理代码，以确保在线程取消时释放资源。</li>
<li><strong>取消点</strong>: 注意线程取消是在取消点生效的，代码编写时应该识别并合理使用这些点，确保数据一致性和资源管理。</li>
</ul>
<h3 id="pthread-cleanup-push-pthread-cleanup-pop"><a href="#pthread-cleanup-push-pthread-cleanup-pop" class="headerlink" title="pthread_cleanup_push &#x2F; pthread_cleanup_pop"></a><code>pthread_cleanup_push</code> &#x2F; <code>pthread_cleanup_pop</code></h3><p><code>pthread_cleanup_push</code> 和 <code>pthread_cleanup_pop</code> 是用于在 POSIX 线程中注册清理处理程序的宏。这些处理程序在线程被取消时或在退出函数之前被调用，以确保释放资源并进行必要的清理操作。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>使用语法</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>pthread_cleanup_push</code>：注册一个清理处理程序 <code>routine</code>。当线程被取消或通过 <code>pthread_exit</code> 退出时，<code>routine</code> 将会被调用，并且传递 <code>arg</code> 作为参数。</p>
</li>
<li><p><code>pthread_cleanup_pop</code>：从清理处理程序栈中移除最顶层的处理程序。如果 <code>execute</code> 非零，则调用此处理程序。</p>
</li>
</ul>
<p>注意：这两个宏必须成对使用，并且在同一层次的代码块中，通常是同一作用域内。</p>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_handler</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cleanup: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread started.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册清理处理程序</span></span><br><span class="line">    pthread_cleanup_push(cleanup_handler, <span class="string">&quot;Resource A&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_handler, <span class="string">&quot;Resource B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread working: %d\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用清理处理程序</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>); <span class="comment">// 如果为1，则调用&quot;Resource B&quot;</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>); <span class="comment">// 如果为1，则调用&quot;Resource A&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread finished normally.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程休眠2秒，模拟主程序的工作</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求取消线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_cancel(thread) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_cancel&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(thread, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread done.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong></p>
<ul>
<li><strong>清理顺序</strong>: 清理处理程序按照后进先出（LIFO）的顺序调用。</li>
<li><strong>资源管理</strong>: 可以用于管理线程资源，如锁、动态分配的内存等，以确保在线程取消或正常退出时资源能够被正确释放。</li>
<li><strong>逻辑一致性</strong>: <code>pthread_cleanup_push</code> 和 <code>pthread_cleanup_pop</code> 必须成对使用且在同一代码块中，典型用法是围绕一个可能导致线程退出的函数调用。</li>
<li><strong>线程安全</strong>: 确保在处理不期而遇的取消请求时，不会破坏数据和导致死锁。</li>
</ul>
<p><code>pthread_cleanup_pop</code> 是一个与 <code>pthread_cleanup_push</code> 成对使用的重要宏，用于从清理处理程序栈中移除最顶层的清理处理程序。这个清理处理程序可以在线程因取消或正常退出时被调用，以实现资源管理和清理操作。</p>
<h2 id="互斥量相关API"><a href="#互斥量相关API" class="headerlink" title="互斥量相关API"></a>互斥量相关API</h2><h3 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init()"></a><code>pthread_mutex_init()</code></h3><p><code>pthread_mutex_init</code> 是一个用于初始化互斥锁（mutex）的函数。在多线程编程中，互斥锁用于保护共享资源，以确保只有一个线程能够在任意给定时间访问该资源。这是实现线程同步的重要机制之一。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_mutex_t *mutex</code>: 指向需要初始化的互斥锁对象。</li>
<li><code>const pthread_mutexattr_t *attr</code>: 可选的互斥锁属性。通常传递为 <code>NULL</code>，它表示使用默认的互斥锁属性。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>如果出错，则返回一个错误码，用于指示具体的错误类型。</li>
</ul>
</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li><p><strong>声明互斥锁对象</strong>:<br>在使用互斥锁之前，需要声明一个 <code>pthread_mutex_t</code> 类型的变量。</p>
</li>
<li><p><strong>初始化互斥锁</strong>:<br>调用 <code>pthread_mutex_init</code> 函数来初始化互斥锁对象。这通常在创建线程或使用互斥锁的任何代码之前完成。</p>
</li>
<li><p><strong>使用互斥锁</strong>:<br>在需要保护的代码块之前调用 <code>pthread_mutex_lock</code> 和在之后调用 <code>pthread_mutex_unlock</code>。</p>
</li>
<li><p><strong>销毁互斥锁</strong>:<br>当互斥锁不再需要时，使用 <code>pthread_mutex_destroy</code> 来销毁它。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld has entered the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟处理资源的时间</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld is leaving the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_unlock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_join(threads[i], <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_destroy(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program completed successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>属性参数</strong>: <code>pthread_mutex_init</code> 中的 <code>attr</code> 通常使用 <code>NULL</code>，表示使用默认属性。如果需要指定属性，可以使用 <code>pthread_mutexattr_init</code> 和相关函数来设置。</p>
</li>
<li><p><strong>错误处理</strong>: 在 <code>pthread_mutex_lock</code> 和 <code>pthread_mutex_unlock</code> 失败时，要进行适当的错误处理，尤其是相应的资源管理。</p>
</li>
<li><p><strong>使用互斥锁</strong>: 在访问共享资源时，确保正确的锁操作，以避免死锁或竞争条件。</p>
</li>
<li><p><strong>销毁互斥锁</strong>: 在销毁互斥锁之前，确保没有任何线程持有它，否则会引发未定义行为。</p>
</li>
</ul>
<h3 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy()"></a><code>pthread_mutex_destroy()</code></h3><p><code>pthread_mutex_destroy</code> 是用于销毁（释放）一个互斥锁对象的函数。当互斥锁不再需要使用时，应使用此函数以确保释放相关资源。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_mutex_t *mutex</code>: 指向需要销毁的互斥锁对象。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>如果出错，返回一个错误码，例如互斥锁仍然被锁定。</li>
</ul>
</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li><p><strong>确保互斥锁未被锁定</strong>: 在调用 <code>pthread_mutex_destroy</code> 之前，确保没有线程持有该互斥锁。</p>
</li>
<li><p><strong>销毁互斥锁</strong>: 调用 <code>pthread_mutex_destroy</code> 来释放与互斥锁相关的资源。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld has entered the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些操作</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld is leaving the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_unlock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_join(threads[i], <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_destroy(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program completed successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>未定义行为</strong>: 在互斥锁被持有时销毁它会导致未定义行为。</p>
</li>
<li><p><strong>资源管理</strong>: 在不使用 <code>pthread_mutex_destroy</code> 释放互斥锁之前，可能会导致内存泄漏。</p>
</li>
<li><p><strong>互斥锁重用</strong>: 销毁后的互斥锁不能再使用，除非重新初始化。</p>
</li>
<li><p><strong>正确释放</strong>: 没有正在持有或等待的情况下销毁互斥锁，避免不必要的资源占用或内存泄漏。</p>
</li>
</ul>
<h3 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock()"></a><code>pthread_mutex_lock()</code></h3><p><code>pthread_mutex_lock</code> 是一个用于锁定互斥锁的函数。在多线程编程中，互斥锁用于确保只有一个线程可以在同一时间访问共享资源。通过使用 <code>pthread_mutex_lock</code>，线程可以进入临界区，确保对共享资源的独占访问。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_mutex_t *mutex</code>: 指向需要锁定的互斥锁对象。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>如果出错，返回一个错误码。例如，<code>EDEADLK</code> 表示检测到死锁。</li>
</ul>
</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li><p><strong>初始化互斥锁</strong>: 在使用互斥锁之前，必须先初始化它，通常使用 <code>pthread_mutex_init</code>。</p>
</li>
<li><p><strong>锁定互斥锁</strong>: 使用 <code>pthread_mutex_lock</code> 来锁定互斥锁。如果互斥锁已经被其他线程锁定，则调用线程会阻塞，直到互斥锁可用。</p>
</li>
<li><p><strong>进入临界区</strong>: 在互斥锁成功锁定后，线程可以安全地访问共享资源。</p>
</li>
<li><p><strong>解锁互斥锁</strong>: 完成对共享资源的访问后，使用 <code>pthread_mutex_unlock</code> 解锁互斥锁，以便其他线程可以访问。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld has entered the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟处理资源的时间</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld is leaving the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_unlock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_join(threads[i], <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_destroy(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program completed successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>死锁检测</strong>: 如果同一线程尝试再次锁定已经持有的互斥锁，可能会导致死锁。某些系统会返回 <code>EDEADLK</code> 错误码。</p>
</li>
<li><p><strong>阻塞行为</strong>: <code>pthread_mutex_lock</code> 是阻塞调用，如果互斥锁不可用，线程会阻塞直到锁可用。</p>
</li>
<li><p><strong>正确的锁&#x2F;解锁对</strong>: 确保每个 <code>pthread_mutex_lock</code> 都有对应的 <code>pthread_mutex_unlock</code>，否则可能会导致资源不可用或死锁。</p>
</li>
<li><p><strong>错误处理</strong>: 在锁定失败时进行适当的错误处理，以确保程序的健壮性。</p>
</li>
</ul>
<h3 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="pthread_mutex_trylock()"></a><code>pthread_mutex_trylock()</code></h3><p><code>pthread_mutex_trylock</code> 是一个用于尝试锁定互斥锁的非阻塞函数。与 <code>pthread_mutex_lock</code> 不同的是，如果互斥锁已经被其他线程锁定，<code>pthread_mutex_trylock</code> 不会阻塞当前线程，而是立即返回一个错误码。这对于需要在不阻塞的情况下尝试获取锁的场景非常有用。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_mutex_t *mutex</code>: 指向需要尝试锁定的互斥锁对象。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0，表示锁定成功。</li>
<li>如果互斥锁已经被锁定，返回 <code>EBUSY</code>。</li>
<li>其他错误码可能指示其他错误情况。</li>
</ul>
</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li><p><strong>初始化互斥锁</strong>: 在使用互斥锁之前，必须先初始化它，通常使用 <code>pthread_mutex_init</code>。</p>
</li>
<li><p><strong>尝试锁定互斥锁</strong>: 使用 <code>pthread_mutex_trylock</code> 来尝试锁定互斥锁。如果互斥锁已经被其他线程锁定，则立即返回 <code>EBUSY</code>，而不是阻塞。</p>
</li>
<li><p><strong>进入临界区</strong>: 如果锁定成功，线程可以安全地访问共享资源。</p>
</li>
<li><p><strong>解锁互斥锁</strong>: 完成对共享资源的访问后，使用 <code>pthread_mutex_unlock</code> 解锁互斥锁，以便其他线程可以访问。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_trylock(&amp;lock) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld has entered the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟处理资源的时间</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld is leaving the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_unlock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld could not enter the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_join(threads[i], <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_destroy(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program completed successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>非阻塞行为</strong>: <code>pthread_mutex_trylock</code> 不会阻塞调用线程，这使得它适用于需要在不阻塞的情况下尝试获取锁的场景。</p>
</li>
<li><p><strong>错误处理</strong>: 如果返回 <code>EBUSY</code>，表示锁已经被其他线程持有，调用线程可以选择执行其他操作或重试。</p>
</li>
<li><p><strong>死锁预防</strong>: 与 <code>pthread_mutex_lock</code> 一样，确保每个成功的锁定都有对应的解锁操作。</p>
</li>
<li><p><strong>使用场景</strong>: 适用于需要在不阻塞的情况下检查锁状态的场景，例如在事件循环中或需要执行其他任务时。</p>
</li>
</ul>
<h3 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock()"></a><code>pthread_mutex_unlock()</code></h3><p><code>pthread_mutex_unlock</code> 是一个用于解锁互斥锁的函数。在多线程编程中，互斥锁用于确保对共享资源的独占访问。当一个线程完成对共享资源的访问后，必须使用 <code>pthread_mutex_unlock</code> 来释放互斥锁，以便其他线程可以获取锁并访问资源。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_mutex_t *mutex</code>: 指向需要解锁的互斥锁对象。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>如果出错，返回一个错误码。例如，如果当前线程并未持有锁，行为是未定义的。</li>
</ul>
</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li><p><strong>锁定互斥锁</strong>: 在进入临界区之前，线程应使用 <code>pthread_mutex_lock</code> 或 <code>pthread_mutex_trylock</code> 来锁定互斥锁。</p>
</li>
<li><p><strong>访问共享资源</strong>: 在互斥锁成功锁定后，线程可以安全地访问共享资源。</p>
</li>
<li><p><strong>解锁互斥锁</strong>: 完成对共享资源的访问后，使用 <code>pthread_mutex_unlock</code> 解锁互斥锁。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld has entered the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟处理资源的时间</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld is leaving the critical section.\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_unlock(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_join(threads[i], <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_destroy(&amp;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program completed successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>正确的锁&#x2F;解锁对</strong>: 确保每个 <code>pthread_mutex_lock</code> 或 <code>pthread_mutex_trylock</code> 都有对应的 <code>pthread_mutex_unlock</code>，否则可能会导致死锁或资源不可用。</p>
</li>
<li><p><strong>未定义行为</strong>: 如果一个线程试图解锁一个它没有锁定的互斥锁，行为是未定义的。这可能会导致程序崩溃或其他不可预测的行为。</p>
</li>
<li><p><strong>错误处理</strong>: 在解锁失败时进行适当的错误处理，以确保程序的健壮性。</p>
</li>
<li><p><strong>多次解锁</strong>: 不要尝试多次解锁一个已经解锁的互斥锁，这会导致未定义行为。</p>
</li>
</ul>
<p>通过正确使用 <code>pthread_mutex_unlock</code>，可以确保共享资源在多线程环境中的安全访问。</p>
<h3 id="futex"><a href="#futex" class="headerlink" title="futex()"></a><code>futex()</code></h3><p><code>futex</code> 是通过 <code>syscall</code> 系统调用实现的，通常不直接调用，而是通过封装函数。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">futex</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> futex_op, <span class="type">int</span> val, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout, <span class="type">int</span> *uaddr2, <span class="type">int</span> val3)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>int *uaddr</code>: 指向用户空间的整型地址，表示要操作的 futex。</li>
<li><code>int futex_op</code>: 指定要执行的操作，如 <code>FUTEX_WAIT</code> 或 <code>FUTEX_WAKE</code>。</li>
<li><code>int val</code>: 用于 <code>FUTEX_WAIT</code> 时，指定期望的 <code>*uaddr</code> 值。</li>
<li><code>const struct timespec *timeout</code>: 用于 <code>FUTEX_WAIT</code> 时，指定超时时间。</li>
<li><code>int *uaddr2</code>: 用于某些高级操作，通常为 <code>NULL</code>。</li>
<li><code>int val3</code>: 用于某些高级操作，通常为 <code>0</code>。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0 或唤醒的线程数量。</li>
<li>失败时返回 -1，并设置 <code>errno</code> 来指示错误。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<p>下面是一个简单的示例，演示如何使用 <code>futex</code> 实现基本的等待和唤醒机制。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futex_wait</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> val, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_futex, uaddr, FUTEX_WAIT, val, timeout, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futex_wake</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_futex, uaddr, FUTEX_WAKE, num, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> futex_var = <span class="number">0</span>; <span class="comment">// 初始化 futex 变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子进程模拟等待</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child: Waiting on futex...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (futex_wait(&amp;futex_var, <span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;futex_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child: Woken up!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主进程模拟唤醒</span></span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 模拟一些处理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: Waking up child...\n&quot;</span>);</span><br><span class="line">    futex_var = <span class="number">1</span>; <span class="comment">// 修改 futex 变量以满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (futex_wake(&amp;futex_var, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;futex_wake&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: Done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>用户空间条件检查</strong>: 在调用 <code>futex_wait</code> 之前，应该在用户空间检查条件是否满足，以避免不必要的系统调用。</p>
</li>
<li><p><strong>内核态开销</strong>: <code>futex</code> 的优势在于它只在必要时进入内核态，因此在条件满足时，用户空间的条件检查可以避免系统调用的开销。</p>
</li>
<li><p><strong>超时处理</strong>: 可以使用 <code>timeout</code> 参数来指定超时时间，以避免线程无限期等待。</p>
</li>
<li><p><strong>错误处理</strong>: 在使用 <code>futex</code> 操作时，注意检查返回值并处理错误。</p>
</li>
</ul>
<p>通过正确使用 <code>futex</code>，可以实现高效的用户空间同步机制，减少内核态切换的开销。</p>
<p><code>futex</code>（fast user-space mutex）是 Linux 内核提供的一种轻量级同步原语，主要用于实现用户空间的锁机制。<code>futex</code> 的主要优势在于它在用户空间和内核空间之间的切换非常高效，只有在必要时才进入内核空间。</p>
<h3 id="futex-wait"><a href="#futex-wait" class="headerlink" title="futex_wait()"></a><code>futex_wait()</code></h3><p><code>futex_wait</code> 是 <code>futex</code> 操作的一部分，用于在用户空间等待一个特定条件满足。它通常与 <code>futex_wake</code> 一起使用。</p>
<p><code>futex_wait</code> 的基本思想是：线程在用户空间检测到某个条件不满足时，调用 <code>futex_wait</code> 进入睡眠状态，直到其他线程通过 <code>futex_wake</code> 唤醒它。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>函数原型</strong></p>
<p><code>futex_wait</code> 是通过 <code>syscall</code> 系统调用实现的，通常不直接调用，而是通过封装函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">futex_wait</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> val, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>int *uaddr</code>: 指向用户空间的整型地址，表示要等待的 futex。</li>
<li><code>int val</code>: 期望 <code>*uaddr</code> 的值。如果 <code>*uaddr</code> 不等于 <code>val</code>，<code>futex_wait</code> 立即返回。</li>
<li><code>const struct timespec *timeout</code>: 指定等待的超时时间。如果为 <code>NULL</code>，则无限期等待。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回 -1，并设置 <code>errno</code> 来指示错误。</li>
</ul>
</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li><p><strong>初始化</strong>: 在用户空间初始化一个整型变量作为 futex。</p>
</li>
<li><p><strong>等待条件</strong>: 当线程检测到某个条件不满足时，调用 <code>futex_wait</code> 进入睡眠状态。</p>
</li>
<li><p><strong>唤醒线程</strong>: 其他线程在条件满足时调用 <code>futex_wake</code> 来唤醒等待的线程。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futex_wait</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> val, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_futex, uaddr, FUTEX_WAIT, val, timeout, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futex_wake</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_futex, uaddr, FUTEX_WAKE, num, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> futex_var = <span class="number">0</span>; <span class="comment">// 初始化 futex 变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个线程等待</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child: Waiting on futex...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (futex_wait(&amp;futex_var, <span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;futex_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child: Woken up!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程模拟唤醒</span></span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 模拟一些处理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: Waking up child...\n&quot;</span>);</span><br><span class="line">    futex_var = <span class="number">1</span>; <span class="comment">// 修改 futex 变量以满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (futex_wake(&amp;futex_var, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;futex_wake&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: Done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>用户空间条件检查</strong>: 在调用 <code>futex_wait</code> 之前，应该在用户空间检查条件是否满足，以避免不必要的系统调用。</p>
</li>
<li><p><strong>内核态开销</strong>: <code>futex</code> 的优势在于它只在必要时进入内核态，因此在条件满足时，用户空间的条件检查可以避免系统调用的开销。</p>
</li>
<li><p><strong>超时处理</strong>: 可以使用 <code>timeout</code> 参数来指定超时时间，以避免线程无限期等待。</p>
</li>
<li><p><strong>错误处理</strong>: 在使用 <code>futex_wait</code> 和 <code>futex_wake</code> 时，注意检查返回值并处理错误。</p>
</li>
</ul>
<p>通过正确使用 <code>futex_wait</code> 和 <code>futex_wake</code>，可以实现高效的用户空间同步机制，减少内核态切换的开销。</p>
<h3 id="futex-wake"><a href="#futex-wake" class="headerlink" title="futex_wake()"></a><code>futex_wake()</code></h3><p><code>futex_wake</code> 是 <code>futex</code> 操作的一部分，用于唤醒等待在指定地址上的一个或多个线程。它通常与 <code>futex_wait</code> 配合使用，以实现用户空间的同步机制。</p>
<p><code>futex_wake</code> 的基本功能是通知等待在某个地址上的线程，使其从休眠状态中唤醒。</p>
<p><strong>头文件</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>函数原型</strong></p>
<p><code>futex_wake</code> 是通过 <code>syscall</code> 系统调用实现的，通常不直接调用，而是通过封装函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">futex_wake</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>int *uaddr</code>: 指向用户空间的整型地址，表示要唤醒的 futex。</li>
<li><code>int num</code>: 指定唤醒的线程数量。如果为 <code>1</code>，则唤醒一个等待线程；如果为 <code>INT_MAX</code>，则唤醒所有等待线程。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回唤醒的线程数量。</li>
<li>失败时返回 -1，并设置 <code>errno</code> 来指示错误。</li>
</ul>
</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li><p><strong>初始化</strong>: 在用户空间初始化一个整型变量作为 futex。</p>
</li>
<li><p><strong>等待线程</strong>: 使用 <code>futex_wait</code> 让线程在某个条件不满足时进入睡眠。</p>
</li>
<li><p><strong>唤醒线程</strong>: 使用 <code>futex_wake</code> 在条件满足时唤醒等待的线程。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futex_wait</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> val, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_futex, uaddr, FUTEX_WAIT, val, timeout, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futex_wake</span><span class="params">(<span class="type">int</span> *uaddr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_futex, uaddr, FUTEX_WAKE, num, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> futex_var = <span class="number">0</span>; <span class="comment">// 初始化 futex 变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个线程等待</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child: Waiting on futex...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (futex_wait(&amp;futex_var, <span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;futex_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child: Woken up!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程模拟唤醒</span></span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 模拟一些处理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: Waking up child...\n&quot;</span>);</span><br><span class="line">    futex_var = <span class="number">1</span>; <span class="comment">// 修改 futex 变量以满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (futex_wake(&amp;futex_var, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;futex_wake&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: Done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>用户空间条件检查</strong>: 在调用 <code>futex_wake</code> 之前，通常需要在用户空间检查条件是否满足。</p>
</li>
<li><p><strong>唤醒数量</strong>: <code>num</code> 参数允许指定唤醒的线程数量，合理使用可以控制并发程度。</p>
</li>
<li><p><strong>错误处理</strong>: 在使用 <code>futex_wake</code> 时，注意检查返回值并处理错误。</p>
</li>
<li><p><strong>同步机制</strong>: <code>futex</code> 本身只是一个低级原语，通常与其他同步机制（如条件变量、信号量）结合使用以实现复杂的同步逻辑。</p>
</li>
</ul>
<p>通过正确使用 <code>futex_wake</code>，可以高效地唤醒等待线程，减少内核态切换的开销，实现用户空间的同步机制。</p>
<p><code>futex</code>（fast user-space mutex）是 Linux 内核提供的一种高效的同步原语，用于在用户空间实现锁和其他同步机制。<code>futex</code> 的主要优点在于，它在大多数情况下不需要进入内核空间，只有在竞争激烈或需要等待时才会进行系统调用，从而减少了上下文切换的开销。</p>
<h3 id="pthread-mutexattr-gettype"><a href="#pthread-mutexattr-gettype" class="headerlink" title="pthread_mutexattr_gettype()"></a><code>pthread_mutexattr_gettype()</code></h3><p><code>pthread_mutexattr_gettype</code> 是一个用于获取互斥锁属性类型的函数。它与 <code>pthread_mutexattr_settype</code> 一起使用，用于设置和获取互斥锁的类型属性。互斥锁类型决定了锁的行为，特别是在递归锁和错误检查方面。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *type)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>const pthread_mutexattr_t *attr</code>: 指向互斥锁属性对象的指针。</li>
<li><code>int *type</code>: 指向一个整数的指针，用于存储互斥锁的类型。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码。</li>
</ul>
</li>
</ul>
<p><strong>互斥锁类型</strong></p>
<p>互斥锁类型决定了锁的行为，主要有以下几种：</p>
<ol>
<li><p><strong>PTHREAD_MUTEX_NORMAL</strong>: 普通锁，不支持递归锁定。如果一个线程再次锁定它已经持有的锁，会导致死锁。</p>
</li>
<li><p><strong>PTHREAD_MUTEX_RECURSIVE</strong>: 递归锁，允许同一线程多次锁定。锁需要被解锁相同次数才能释放。</p>
</li>
<li><p><strong>PTHREAD_MUTEX_ERRORCHECK</strong>: 错误检查锁，如果一个线程再次锁定它已经持有的锁，会返回错误而不是死锁。</p>
</li>
<li><p><strong>PTHREAD_MUTEX_DEFAULT</strong>: 默认锁类型，通常与 <code>PTHREAD_MUTEX_NORMAL</code> 相同，但具体行为可能依赖于实现。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<p>下面是一个简单的示例，演示如何使用 <code>pthread_mutexattr_gettype</code> 获取互斥锁的类型。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁属性对象</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_init(&amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutexattr_init&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置互斥锁类型为递归锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutexattr_settype&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁类型</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_gettype(&amp;attr, &amp;type) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutexattr_gettype&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印互斥锁类型</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> PTHREAD_MUTEX_NORMAL:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mutex type: PTHREAD_MUTEX_NORMAL\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PTHREAD_MUTEX_RECURSIVE:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mutex type: PTHREAD_MUTEX_RECURSIVE\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PTHREAD_MUTEX_ERRORCHECK:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mutex type: PTHREAD_MUTEX_ERRORCHECK\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PTHREAD_MUTEX_DEFAULT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mutex type: PTHREAD_MUTEX_DEFAULT\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown mutex type\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁属性对象</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_destroy(&amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutexattr_destroy&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>初始化和销毁</strong>: 在使用 <code>pthread_mutexattr_gettype</code> 之前，确保互斥锁属性对象已经通过 <code>pthread_mutexattr_init</code> 初始化，并在使用完后通过 <code>pthread_mutexattr_destroy</code> 销毁。</p>
</li>
<li><p><strong>错误检查</strong>: 在调用 <code>pthread_mutexattr_gettype</code> 时，检查返回值以确保操作成功。</p>
</li>
<li><p><strong>互斥锁类型选择</strong>: 根据应用需求选择合适的互斥锁类型，以避免死锁或不必要的错误。</p>
</li>
</ul>
<p>通过正确使用 <code>pthread_mutexattr_gettype</code>，可以有效地管理和调试互斥锁的行为，确保线程同步的正确性和效率。</p>
<h3 id="pthread-mutexattr-settype"><a href="#pthread-mutexattr-settype" class="headerlink" title="pthread_mutexattr_settype()"></a><code>pthread_mutexattr_settype()</code></h3><p><code>pthread_mutexattr_settype</code> 是一个用于设置互斥锁属性类型的函数。它允许你指定互斥锁的行为类型，这对于控制锁的递归性和错误检查特性非常重要。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_settype</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_mutexattr_t *attr</code>: 指向互斥锁属性对象的指针。</li>
<li><code>int type</code>: 要设置的互斥锁类型。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，例如 <code>EINVAL</code>，表示提供的类型无效。</li>
</ul>
</li>
</ul>
<p><strong>互斥锁类型</strong></p>
<p>互斥锁类型决定了锁的行为，主要有以下几种：</p>
<ol>
<li><p><strong>PTHREAD_MUTEX_NORMAL</strong>: 普通锁，不支持递归锁定。如果一个线程再次锁定它已经持有的锁，会导致死锁。</p>
</li>
<li><p><strong>PTHREAD_MUTEX_RECURSIVE</strong>: 递归锁，允许同一线程多次锁定。锁需要被解锁相同次数才能释放。</p>
</li>
<li><p><strong>PTHREAD_MUTEX_ERRORCHECK</strong>: 错误检查锁，如果一个线程再次锁定它已经持有的锁，会返回错误而不是死锁。</p>
</li>
<li><p><strong>PTHREAD_MUTEX_DEFAULT</strong>: 默认锁类型，通常与 <code>PTHREAD_MUTEX_NORMAL</code> 相同，但具体行为可能依赖于实现。</p>
</li>
</ol>
<p><strong>使用示例</strong></p>
<p>下面是一个简单的示例，演示如何使用 <code>pthread_mutexattr_settype</code> 设置互斥锁的类型。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">int</span> type = PTHREAD_MUTEX_RECURSIVE; <span class="comment">// 设置为递归锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁属性对象</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_init(&amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutexattr_init&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置互斥锁类型</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_settype(&amp;attr, type) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutexattr_settype&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;mutex, &amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁属性对象</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_destroy(&amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutexattr_destroy&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用互斥锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Locked mutex\n&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unlocked mutex\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_destroy(&amp;mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_destroy&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>初始化和销毁</strong>: 在使用 <code>pthread_mutexattr_settype</code> 之前，确保互斥锁属性对象已经通过 <code>pthread_mutexattr_init</code> 初始化，并在使用完后通过 <code>pthread_mutexattr_destroy</code> 销毁。</p>
</li>
<li><p><strong>错误检查</strong>: 在调用 <code>pthread_mutexattr_settype</code> 时，检查返回值以确保操作成功。</p>
</li>
<li><p><strong>互斥锁类型选择</strong>: 根据应用需求选择合适的互斥锁类型，以避免死锁或不必要的错误。递归锁适用于需要在同一线程中多次锁定的场景，而错误检查锁可以帮助调试锁定错误。</p>
</li>
</ul>
<p>通过正确使用 <code>pthread_mutexattr_settype</code>，可以有效地管理互斥锁的行为，确保线程同步的正确性和效率。</p>
<h2 id="自旋锁相关API"><a href="#自旋锁相关API" class="headerlink" title="自旋锁相关API"></a>自旋锁相关API</h2><h3 id="pthread-spin-init"><a href="#pthread-spin-init" class="headerlink" title="pthread_spin_init()"></a><code>pthread_spin_init()</code></h3><p><code>pthread_spin_init</code> 是用于初始化自旋锁的函数。自旋锁是一种轻量级的锁机制，适用于短时间的锁定操作，特别是在多处理器系统中。自旋锁在等待锁释放时会一直占用 CPU 资源进行循环检查，而不是使线程进入休眠状态。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_init</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock, <span class="type">int</span> pshared)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_spinlock_t *lock</code>: 指向自旋锁对象的指针。这个对象在初始化后用于表示锁的状态。</li>
<li><code>int pshared</code>: 指定锁是否可以在进程间共享。<ul>
<li><code>PTHREAD_PROCESS_PRIVATE</code>: 自旋锁用于单个进程中的线程同步。</li>
<li><code>PTHREAD_PROCESS_SHARED</code>: 自旋锁可以在多个进程间共享（如果系统支持）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，例如 <code>EINVAL</code>（参数无效）或 <code>ENOMEM</code>（内存不足）。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<p>以下是一个简单的示例，演示如何使用 <code>pthread_spin_init</code> 初始化自旋锁，并在多线程环境中进行同步：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        pthread_spin_lock(&amp;spinlock);</span><br><span class="line">        shared_resource++;</span><br><span class="line">        pthread_spin_unlock(&amp;spinlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化自旋锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_spin_init&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印共享资源的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared resource value: %d\n&quot;</span>, shared_resource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁自旋锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_spin_destroy(&amp;spinlock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_spin_destroy&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>初始化</strong>: 在使用自旋锁之前，必须通过 <code>pthread_spin_init</code> 进行初始化。</li>
<li><strong>共享选项</strong>: <code>pshared</code> 参数决定了自旋锁的共享范围。通常情况下，使用 <code>PTHREAD_PROCESS_PRIVATE</code>，除非需要在多个进程间共享锁。</li>
<li><strong>销毁</strong>: 在不再需要自旋锁时，使用 <code>pthread_spin_destroy</code> 销毁它，以释放相关资源。</li>
<li><strong>适用场景</strong>: 自旋锁适用于锁持有时间非常短的场景，因为它会在等待时消耗 CPU 资源。对于长时间的锁定操作，互斥锁可能是更好的选择。</li>
</ul>
<p>通过正确地初始化和使用自旋锁，可以在合适的场景中实现高效的线程同步。</p>
<h3 id="pthread-spin-destroy"><a href="#pthread-spin-destroy" class="headerlink" title="pthread_spin_destroy()"></a><code>pthread_spin_destroy()</code></h3><p><code>pthread_spin_destroy</code> 是用于销毁自旋锁的函数。自旋锁在使用完毕后需要被销毁，以释放相关资源并避免内存泄漏。销毁自旋锁是线程同步机制中资源管理的重要部分。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_destroy</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_spinlock_t *lock</code>: 指向需要销毁的自旋锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，例如 <code>EINVAL</code>（表示锁无效或未初始化）。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<p>以下是一个简单的示例，演示如何使用 <code>pthread_spin_destroy</code> 销毁自旋锁：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        pthread_spin_lock(&amp;spinlock);</span><br><span class="line">        shared_resource++;</span><br><span class="line">        pthread_spin_unlock(&amp;spinlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化自旋锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_spin_init&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印共享资源的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared resource value: %d\n&quot;</span>, shared_resource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁自旋锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_spin_destroy(&amp;spinlock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_spin_destroy&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>正确销毁</strong>: 在不再需要自旋锁时，务必调用 <code>pthread_spin_destroy</code> 销毁它。未销毁的锁可能导致资源泄漏。</li>
<li><strong>锁状态</strong>: 确保在销毁自旋锁之前，所有使用该锁的线程都已经完成操作，并且锁未被持有。否则，可能导致未定义行为。</li>
<li><strong>重复销毁</strong>: 不要重复销毁同一个自旋锁。重复销毁可能导致错误或未定义行为。</li>
<li><strong>初始化后销毁</strong>: 自旋锁必须在初始化后才能被销毁。未初始化或已经销毁的锁不能再次销毁。</li>
</ul>
<p>通过正确地销毁自旋锁，可以确保程序的资源管理更加高效和安全。</p>
<p><code>pthread_spin_lock</code>、<code>pthread_spin_trylock</code> 和 <code>pthread_spin_unlock</code> 是用于操作自旋锁的函数。自旋锁是一种轻量级的锁机制，适用于短时间的锁定操作，尤其是在多处理器系统中。以下是这些函数的用法解析：</p>
<h3 id="pthread-spin-lock"><a href="#pthread-spin-lock" class="headerlink" title="pthread_spin_lock()"></a><code>pthread_spin_lock()</code></h3><p><code>pthread_spin_lock</code> 用于获取自旋锁。如果锁已经被其他线程持有，调用线程将一直忙等待（自旋）直到锁可用。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_lock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_spinlock_t *lock</code>: 指向自旋锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码（通常不会发生）。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_spin_lock(&amp;spinlock);</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line"><span class="comment">// Perform operations on shared resources</span></span><br><span class="line">pthread_spin_unlock(&amp;spinlock);</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-spin-trylock"><a href="#pthread-spin-trylock" class="headerlink" title="pthread_spin_trylock()"></a><code>pthread_spin_trylock()</code></h3><p><code>pthread_spin_trylock</code> 尝试获取自旋锁。如果锁已经被其他线程持有，它不会阻塞，而是立即返回一个错误码。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_trylock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_spinlock_t *lock</code>: 指向自旋锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>如果锁已经被持有，返回 <code>EBUSY</code>。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pthread_spin_trylock(&amp;spinlock) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Critical section</span></span><br><span class="line">    <span class="comment">// Perform operations on shared resources</span></span><br><span class="line">    pthread_spin_unlock(&amp;spinlock);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the case where the lock is already held</span></span><br><span class="line">    <span class="comment">// For example, try again later or perform alternative actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-spin-unlock"><a href="#pthread-spin-unlock" class="headerlink" title="pthread_spin_unlock()"></a><code>pthread_spin_unlock()</code></h3><p><code>pthread_spin_unlock</code> 用于释放自旋锁，使其他线程可以获取该锁。</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_unlock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_spinlock_t *lock</code>: 指向自旋锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码（通常不会发生）。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_spin_lock(&amp;spinlock);</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line"><span class="comment">// Perform operations on shared resources</span></span><br><span class="line">pthread_spin_unlock(&amp;spinlock);</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>忙等待</strong>: <code>pthread_spin_lock</code> 会导致忙等待，因此在锁持有时间较长的情况下，可能会导致 CPU 资源浪费。</li>
<li><strong>适用场景</strong>: 自旋锁适用于锁持有时间非常短的场景。对于长时间的锁定操作，互斥锁（<code>pthread_mutex_t</code>）可能是更好的选择。</li>
<li><strong>锁的状态</strong>: 确保在调用 <code>pthread_spin_unlock</code> 之前，锁已经被当前线程持有，否则可能导致未定义行为。</li>
<li><strong>错误处理</strong>: 使用 <code>pthread_spin_trylock</code> 时，应处理锁不可用的情况，以避免程序逻辑错误。</li>
</ul>
<p>通过正确地使用这些函数，可以在多线程环境中实现高效的同步机制。</p>
<h2 id="读写锁相关API"><a href="#读写锁相关API" class="headerlink" title="读写锁相关API"></a>读写锁相关API</h2><h3 id="pthread-rwlock-init"><a href="#pthread-rwlock-init" class="headerlink" title="pthread_rwlock_init"></a><code>pthread_rwlock_init</code></h3><p><code>pthread_rwlock_init</code> 用于初始化一个读写锁对象。在使用读写锁之前，必须先调用此函数进行初始化。</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_rwlock_t *rwlock</code>: 指向要初始化的读写锁对象的指针。</li>
<li><code>const pthread_rwlockattr_t *attr</code>: 指向读写锁属性对象的指针。如果为 <code>NULL</code>，则使用默认属性。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>ENOMEM</code>（内存不足）或 <code>EINVAL</code>（无效的属性）。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_init&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-rwlock-destroy"><a href="#pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_destroy"></a><code>pthread_rwlock_destroy</code></h3><p><code>pthread_rwlock_destroy</code> 用于销毁一个读写锁对象。当一个读写锁不再需要使用时，应调用此函数释放相关资源。</p>
<h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_rwlock_t *rwlock</code>: 指向要销毁的读写锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>EBUSY</code>（锁仍然被持有）。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pthread_rwlock_destroy(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_destroy&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a><code>pthread_rwlock_rdlock</code></h3><p><code>pthread_rwlock_rdlock</code> 用于获取一个读锁。如果其他线程持有写锁，则调用线程会阻塞，直到写锁被释放。</p>
<h4 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_rwlock_t *rwlock</code>: 指向要获取读锁的读写锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>EDEADLK</code>（检测到死锁）或 <code>EINVAL</code>（无效的锁对象）。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="使用示例"></a>使用示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 rwlock 已经初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_rdlock&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行读操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_unlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_unlock&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-rwlock-tryrdlock"><a href="#pthread-rwlock-tryrdlock" class="headerlink" title="pthread_rwlock_tryrdlock"></a><code>pthread_rwlock_tryrdlock</code></h3><p><code>pthread_rwlock_tryrdlock</code> 尝试获取一个读锁，但不会阻塞。如果读锁不可用（例如，其他线程持有写锁），则立即返回。</p>
<h4 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_rwlock_t *rwlock</code>: 指向要获取读锁的读写锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>EBUSY</code>（锁不可用）或 <code>EINVAL</code>（无效的锁对象）。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-7"><a href="#使用示例-7" class="headerlink" title="使用示例"></a>使用示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 rwlock 已经初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_tryrdlock(&amp;rwlock) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功获取读锁，进行读操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_rwlock_unlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_rwlock_unlock&quot;</span>);</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 读锁不可用，处理失败情况</span></span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_tryrdlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-rwlock-wrlock"><a href="#pthread-rwlock-wrlock" class="headerlink" title="pthread_rwlock_wrlock"></a><code>pthread_rwlock_wrlock</code></h3><p><code>pthread_rwlock_wrlock</code> 用于获取一个写锁。如果其他线程持有读锁或写锁，则调用线程会阻塞，直到所有读锁和写锁被释放。</p>
<h4 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_rwlock_t *rwlock</code>: 指向要获取写锁的读写锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>EDEADLK</code>（检测到死锁）或 <code>EINVAL</code>（无效的锁对象）。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-8"><a href="#使用示例-8" class="headerlink" title="使用示例"></a>使用示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 rwlock 已经初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_wrlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_wrlock&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行写操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_unlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_unlock&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-rwlock-trywrlock"><a href="#pthread-rwlock-trywrlock" class="headerlink" title="pthread_rwlock_trywrlock"></a><code>pthread_rwlock_trywrlock</code></h3><p><code>pthread_rwlock_trywrlock</code> 尝试获取一个写锁，但不会阻塞。如果写锁不可用（例如，其他线程持有读锁或写锁），则立即返回。</p>
<h4 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_rwlock_t *rwlock</code>: 指向要获取写锁的读写锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>EBUSY</code>（锁不可用）或 <code>EINVAL</code>（无效的锁对象）。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-9"><a href="#使用示例-9" class="headerlink" title="使用示例"></a>使用示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">zpthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 rwlock 已经初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_trywrlock(&amp;rwlock) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功获取写锁，进行写操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_rwlock_unlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_rwlock_unlock&quot;</span>);</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 写锁不可用，处理失败情况</span></span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_trywrlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-rwlock-unlock"><a href="#pthread-rwlock-unlock" class="headerlink" title="pthread_rwlock_unlock"></a><code>pthread_rwlock_unlock</code></h3><p><code>pthread_rwlock_unlock</code> 是用于释放先前获取的读写锁的函数。无论是读锁还是写锁，都可以使用这个函数来解锁。</p>
<h4 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>pthread_rwlock_t *rwlock</code>: 指向要释放的读写锁对象的指针。</li>
</ul>
</li>
<li><p><strong>返回值</strong>:</p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>EPERM</code>（当前线程没有持有该锁）或 <code>EINVAL</code>（无效的锁对象）。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-10"><a href="#使用示例-10" class="headerlink" title="使用示例"></a>使用示例</h4><p>在使用读写锁时，无论是读锁还是写锁，都需要在操作完成后调用 <code>pthread_rwlock_unlock</code> 来释放锁。</p>
<p><strong>释放读锁</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 rwlock 已经初始化并且当前线程持有读锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_rdlock&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行读操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_unlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_unlock&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>释放写锁</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 rwlock 已经初始化并且当前线程持有写锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_wrlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_wrlock&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行写操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_rwlock_unlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_rwlock_unlock&quot;</span>);</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="条件等待相关API"><a href="#条件等待相关API" class="headerlink" title="条件等待相关API"></a>条件等待相关API</h2><p><code>pthread_cond_init</code> 和 <code>pthread_cond_destroy</code> 是用于初始化和销毁条件变量的函数。条件变量用于线程间的同步，允许线程等待某个条件的发生。</p>
<h3 id="pthread-cond-init"><a href="#pthread-cond-init" class="headerlink" title="pthread_cond_init"></a><code>pthread_cond_init</code></h3><h4 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>cond</code>: 指向要初始化的条件变量的指针。</li>
<li><code>attr</code>: 指向条件变量属性对象的指针。如果使用默认属性，可以传递 <code>NULL</code>。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>ENOMEM</code>（内存不足）或 <code>EINVAL</code>（无效的属性）。</li>
</ul>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>静态初始化: 如果不需要自定义属性，可以使用 PTHREAD_COND_INITIALIZER 进行静态初始化。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></div>

<p>动态初始化: 使用 pthread_cond_init 进行动态初始化，适用于需要自定义属性的情况。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);  <span class="comment">// 使用默认属性</span></span><br></pre></td></tr></table></figure></div>

<p>自定义属性: 如果需要自定义条件变量的属性，可以先使用 pthread_condattr_init 初始化属性对象，然后在 pthread_cond_init 中传递该对象。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_condattr_t</span> attr;</span><br><span class="line">pthread_condattr_init(&amp;attr);</span><br><span class="line"><span class="comment">// 设置属性（如果需要）</span></span><br><span class="line">pthread_cond_init(&amp;cond, &amp;attr);</span><br><span class="line">pthread_condattr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure></div>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="comment">// 模拟等待某个条件</span></span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Worker thread proceeding\n&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);  <span class="comment">// 初始化条件变量</span></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 主线程准备好后唤醒工作线程</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 销毁条件变量和互斥锁</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-cond-destroy"><a href="#pthread-cond-destroy" class="headerlink" title="pthread_cond_destroy"></a><code>pthread_cond_destroy</code></h3><h4 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>cond</code>: 指向要销毁的条件变量的指针。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，如 <code>EBUSY</code>（条件变量上仍有线程在等待）或 <code>EINVAL</code>（无效的条件变量）。</li>
</ul>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><ol>
<li><strong>确保没有线程在等待</strong>: 在调用 <code>pthread_cond_destroy</code> 之前，必须确保没有线程在等待该条件变量。否则，会导致 <code>EBUSY</code> 错误。</li>
<li><strong>与互斥锁配合</strong>: 通常，条件变量与互斥锁一起使用。在销毁条件变量之前，确保相关的互斥锁已经被正确处理。</li>
<li><strong>初始化和销毁匹配</strong>: 确保每个通过 <code>pthread_cond_init</code> 初始化的条件变量都被正确地销毁。</li>
</ol>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="comment">// 模拟等待某个条件</span></span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程可以在某个时刻准备好后唤醒工作线程</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量和互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_cond_destroy(&amp;cond) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_cond_destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_destroy(&amp;mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait"></a><code>pthread_cond_wait</code></h3><h4 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>cond</code>: 指向条件变量的指针。</li>
<li><code>mutex</code>: 指向互斥锁的指针。调用此函数时，互斥锁必须已被锁定。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码。</li>
</ul>
<h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><ul>
<li>在调用 <code>pthread_cond_wait</code> 时，线程必须持有互斥锁。函数会自动释放该锁并使线程进入等待状态。</li>
<li>当条件变量被其他线程信号（通过 <code>pthread_cond_signal</code> 或 <code>pthread_cond_broadcast</code>）时，线程会被唤醒并重新锁定互斥锁。</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Worker thread proceeding\n&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程准备好后唤醒工作线程</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ready = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-cond-timedwait"><a href="#pthread-cond-timedwait" class="headerlink" title="pthread_cond_timedwait"></a><code>pthread_cond_timedwait</code></h3><h4 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>cond</code>: 指向条件变量的指针。</li>
<li><code>mutex</code>: 指向互斥锁的指针。调用此函数时，互斥锁必须已被锁定。</li>
<li><code>abstime</code>: 指向 <code>timespec</code> 结构体的指针，指定绝对时间（相对于 Epoch 时间）作为超时时间。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 0。</li>
<li>超时时返回 <code>ETIMEDOUT</code>。</li>
<li>失败时返回其他错误码。</li>
</ul>
<h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><ul>
<li>与 <code>pthread_cond_wait</code> 类似，但增加了超时功能。</li>
<li>如果在指定时间内没有收到信号，函数会返回 <code>ETIMEDOUT</code>。</li>
</ul>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    ts.tv_sec += <span class="number">5</span>; <span class="comment">// 等待5秒</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        <span class="type">int</span> res = pthread_cond_timedwait(&amp;cond, &amp;mutex, &amp;ts);</span><br><span class="line">        <span class="keyword">if</span> (res == ETIMEDOUT) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Timeout occurred\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Worker thread proceeding\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程可以在某个时刻准备好后唤醒工作线程</span></span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ready = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>pthread_cond_signal</code> 和 <code>pthread_cond_broadcast</code> 是用于唤醒等待条件变量的线程的函数。它们通常与条件变量和互斥锁一起使用，以实现线程间的同步。</p>
<h3 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal"></a><code>pthread_cond_signal</code></h3><h4 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>cond</code>: 指向条件变量的指针。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码。</li>
</ul>
<h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><ul>
<li><code>pthread_cond_signal</code> 用于唤醒至少一个正在等待该条件变量的线程。</li>
<li>如果有多个线程在等待，具体唤醒哪个线程是由实现决定的。</li>
<li>通常用于通知一个等待线程某个条件已经满足。</li>
</ul>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Worker thread proceeding\n&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程准备好后唤醒一个工作线程</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ready = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast"></a><code>pthread_cond_broadcast</code></h3><h4 id="函数原型-12"><a href="#函数原型-12" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>cond</code>: 指向条件变量的指针。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码。</li>
</ul>
<h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h4><ul>
<li><code>pthread_cond_broadcast</code> 用于唤醒所有正在等待该条件变量的线程。</li>
<li>通常用于需要通知所有等待线程某个条件已经满足的情况。</li>
</ul>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Worker thread %ld proceeding\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程准备好后唤醒所有工作线程</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ready = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_broadcast(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="局部存储相关API"><a href="#局部存储相关API" class="headerlink" title="局部存储相关API"></a>局部存储相关API</h2><p><strong>仅作记录，推荐使用<code>__thread</code> 关键字。</strong></p>
<p><code>pthread_key_create</code> 和 <code>pthread_key_delete</code> 是用于管理线程特定数据（Thread-Specific Data, TSD）的函数。它们用于创建和删除线程特定数据的键，允许每个线程拥有自己的数据副本。</p>
<h3 id="pthread-key-create"><a href="#pthread-key-create" class="headerlink" title="pthread_key_create"></a><code>pthread_key_create</code></h3><h4 id="函数原型-13"><a href="#函数原型-13" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>key</code>: 指向 <code>pthread_key_t</code> 类型的指针，用于存储创建的键。</li>
<li><code>destructor</code>: 可选的析构函数指针，当线程退出时用于清理线程特定数据。如果不需要清理，可以传递 <code>NULL</code>。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，例如：<ul>
<li><code>EAGAIN</code>: 系统资源不足，无法创建更多的键。</li>
<li><code>ENOMEM</code>: 内存不足，无法分配键。</li>
</ul>
</li>
</ul>
<h4 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h4><ul>
<li>创建一个线程特定数据键，并指定一个可选的析构函数。</li>
<li>每个线程可以使用该键来存储和检索自己的数据。</li>
</ul>
<h3 id="pthread-key-delete"><a href="#pthread-key-delete" class="headerlink" title="pthread_key_delete"></a><code>pthread_key_delete</code></h3><h4 id="函数原型-14"><a href="#函数原型-14" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>key</code>: 要删除的键。</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，例如：<ul>
<li><code>EINVAL</code>: 提供的键无效。</li>
</ul>
</li>
</ul>
<h4 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h4><ul>
<li>删除一个线程特定数据键。</li>
<li>删除键后，不能再使用该键来存储或检索数据。</li>
</ul>
<h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的示例，演示如何使用 <code>pthread_key_create</code> 和 <code>pthread_key_delete</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_key_t</span> key;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destructor</span><span class="params">(<span class="type">void</span> *value)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Destructor called for thread-specific data: %s\n&quot;</span>, (<span class="type">char</span> *)value);</span><br><span class="line">    <span class="built_in">free</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *thread_data = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(thread_data, <span class="number">20</span>, <span class="string">&quot;Thread %ld data&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_setspecific(key, thread_data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld: %s\n&quot;</span>, (<span class="type">long</span>)arg, (<span class="type">char</span> *)pthread_getspecific(key));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程特定数据键</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_key_create(&amp;key, destructor) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error creating key\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除线程特定数据键</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_key_delete(key) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error deleting key\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>析构函数</strong>: 如果提供了析构函数，当线程退出时，系统会自动调用该函数来清理线程特定数据。</li>
<li><strong>内存管理</strong>: 线程特定数据的内存管理由程序员负责，确保在适当的时候释放内存。</li>
<li><strong>键的生命周期</strong>: 在不再需要使用键时，应调用 <code>pthread_key_delete</code> 删除它，以释放系统资源。</li>
<li><strong>线程安全</strong>: <code>pthread_key_create</code> 和 <code>pthread_key_delete</code> 是线程安全的，可以在多线程环境中安全使用。</li>
</ul>
<p><code>pthread_setspecific</code> 和 <code>pthread_getspecific</code> 是用于管理线程特定数据（Thread-Specific Data, TSD）的函数。它们允许每个线程存储和检索与特定键关联的数据。</p>
<hr>
<h3 id="pthread-setspecific"><a href="#pthread-setspecific" class="headerlink" title="pthread_setspecific"></a><code>pthread_setspecific</code></h3><h4 id="函数原型-15"><a href="#函数原型-15" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>key</code>: 线程特定数据的键，必须是通过 <code>pthread_key_create</code> 创建的。</li>
<li><code>value</code>: 要与键关联的值。可以是任意类型的数据指针。</li>
</ul>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功时返回 0。</li>
<li>失败时返回一个错误码，例如：<ul>
<li><code>EINVAL</code>: 提供的键无效。</li>
<li><code>ENOMEM</code>: 内存不足，无法存储数据。</li>
</ul>
</li>
</ul>
<h4 id="用法-8"><a href="#用法-8" class="headerlink" title="用法"></a>用法</h4><ul>
<li>将一个数据指针与指定的键关联。每个线程可以为同一个键存储不同的数据。</li>
</ul>
<h3 id="pthread-getspecific"><a href="#pthread-getspecific" class="headerlink" title="pthread_getspecific"></a><code>pthread_getspecific</code></h3><h4 id="函数原型-16"><a href="#函数原型-16" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>key</code>: 线程特定数据的键，必须是通过 <code>pthread_key_create</code> 创建的。</li>
</ul>
<h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>返回与键关联的值。</li>
<li>如果没有为该键设置值，则返回 <code>NULL</code>。</li>
</ul>
<h4 id="用法-9"><a href="#用法-9" class="headerlink" title="用法"></a>用法</h4><ul>
<li>检索与指定键关联的线程特定数据。</li>
</ul>
<h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的示例，演示如何使用 <code>pthread_setspecific</code> 和 <code>pthread_getspecific</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_key_t</span> key;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destructor</span><span class="params">(<span class="type">void</span> *value)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Destructor called for thread-specific data: %s\n&quot;</span>, (<span class="type">char</span> *)value);</span><br><span class="line">    <span class="built_in">free</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *thread_data = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(thread_data, <span class="number">20</span>, <span class="string">&quot;Thread %ld data&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_setspecific(key, thread_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并打印线程特定数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld: %s\n&quot;</span>, (<span class="type">long</span>)arg, (<span class="type">char</span> *)pthread_getspecific(key));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程特定数据键</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_key_create(&amp;key, destructor) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error creating key\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除线程特定数据键</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_key_delete(key) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error deleting key\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>线程隔离</strong>: 每个线程对同一个键可以存储不同的数据，<code>pthread_setspecific</code> 和 <code>pthread_getspecific</code> 操作仅影响调用线程。</li>
<li><strong>内存管理</strong>: 由 <code>pthread_setspecific</code> 设置的值的内存管理由程序员负责。确保在适当的时候释放内存，通常通过析构函数。</li>
<li><strong>初始值</strong>: 如果没有为某个键设置值，<code>pthread_getspecific</code> 将返回 <code>NULL</code>。这可以用来检查是否已经为键设置了值。</li>
</ul>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Linux环境编程与内核之线程</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2025-02-06 14:49:11</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-08-06 18:44:18
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2025/02/06/Linux环境编程与内核之线程/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Linux环境编程与内核之进程间通信</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/02/06/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E4%BF%A1%E5%8F%B7/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Linux环境编程与内核之信号</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Linux环境编程与内核之线程</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-text">线程和进程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8BID%E5%92%8C%E7%BA%BF%E7%A8%8BID"><span class="nav-text">进程ID和线程ID</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pthread-%E5%BA%93%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="nav-text">pthread 库接口介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%A0%87%E8%AF%86"><span class="nav-text">线程的创建和标识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pthread-create"><span class="nav-text">pthread_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8BID%E5%8F%8A%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-text">线程ID及进程地址空间布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7"><span class="nav-text">线程创建的默认属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-text">线程退出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%86%E7%A6%BB"><span class="nav-text">线程的连接与分离</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-text">线程的连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E9%80%80%E5%87%BA%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-text">连接退出的线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BB"><span class="nav-text">线程的分离</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-text">互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-text">互斥量的接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-text">临界区的大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-text">互斥量的性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">互斥锁的公平性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">互斥锁的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E6%B4%BB%E9%94%81"><span class="nav-text">死锁和活锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-text">读写锁的接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89%E7%AD%96%E7%95%A5"><span class="nav-text">读写锁的竞争策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="nav-text">伪共享</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85"><span class="nav-text">条件等待</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81"><span class="nav-text">条件变量的创建和销毁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">条件变量的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="nav-text">线程取消</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-text">线程局部存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NPTL%E5%BA%93"><span class="nav-text">NPTL库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">__thread关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="nav-text">线程和信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="nav-text">设置线程的信号掩码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-text">向线程发送信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E5%AF%B9%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">多线程程序对信号的处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Efork"><span class="nav-text">多线程与fork</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">相关结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-attr-t-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">pthread_attr_t 结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-spinlock-t-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">pthread_spinlock_t 结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-rwlock-t-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">pthread_rwlock_t 结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-t-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">pthread_cond_t 结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-key-t-%E7%B1%BB%E5%9E%8B"><span class="nav-text">pthread_key_t 类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3API"><span class="nav-text">线程相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gettid"><span class="nav-text">gettid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-create-1"><span class="nav-text">pthread_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-exit"><span class="nav-text">pthread_exit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-self"><span class="nav-text">pthread_self</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-equal"><span class="nav-text">pthread_equal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-join"><span class="nav-text">pthread_join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-detach"><span class="nav-text">pthread_detach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cancel"><span class="nav-text">pthread_cancel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cleanup-push-pthread-cleanup-pop"><span class="nav-text">pthread_cleanup_push &#x2F; pthread_cleanup_pop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%9B%B8%E5%85%B3API"><span class="nav-text">互斥量相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-init"><span class="nav-text">pthread_mutex_init()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-destroy"><span class="nav-text">pthread_mutex_destroy()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-lock"><span class="nav-text">pthread_mutex_lock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-trylock"><span class="nav-text">pthread_mutex_trylock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-unlock"><span class="nav-text">pthread_mutex_unlock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#futex"><span class="nav-text">futex()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#futex-wait"><span class="nav-text">futex_wait()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#futex-wake"><span class="nav-text">futex_wake()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutexattr-gettype"><span class="nav-text">pthread_mutexattr_gettype()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutexattr-settype"><span class="nav-text">pthread_mutexattr_settype()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9B%B8%E5%85%B3API"><span class="nav-text">自旋锁相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-spin-init"><span class="nav-text">pthread_spin_init()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-spin-destroy"><span class="nav-text">pthread_spin_destroy()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-spin-lock"><span class="nav-text">pthread_spin_lock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-spin-trylock"><span class="nav-text">pthread_spin_trylock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-spin-unlock"><span class="nav-text">pthread_spin_unlock()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9B%B8%E5%85%B3API"><span class="nav-text">读写锁相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-rwlock-init"><span class="nav-text">pthread_rwlock_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-rwlock-destroy"><span class="nav-text">pthread_rwlock_destroy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-rwlock-rdlock"><span class="nav-text">pthread_rwlock_rdlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-rwlock-tryrdlock"><span class="nav-text">pthread_rwlock_tryrdlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-rwlock-wrlock"><span class="nav-text">pthread_rwlock_wrlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-rwlock-trywrlock"><span class="nav-text">pthread_rwlock_trywrlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-rwlock-unlock"><span class="nav-text">pthread_rwlock_unlock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85%E7%9B%B8%E5%85%B3API"><span class="nav-text">条件等待相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-init"><span class="nav-text">pthread_cond_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-destroy"><span class="nav-text">pthread_cond_destroy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-wait"><span class="nav-text">pthread_cond_wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-timedwait"><span class="nav-text">pthread_cond_timedwait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-signal"><span class="nav-text">pthread_cond_signal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-broadcast"><span class="nav-text">pthread_cond_broadcast</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3API"><span class="nav-text">局部存储相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-key-create"><span class="nav-text">pthread_key_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-key-delete"><span class="nav-text">pthread_key_delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-setspecific"><span class="nav-text">pthread_setspecific</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-getspecific"><span class="nav-text">pthread_getspecific</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="nav-text">注意事项</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        125 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>