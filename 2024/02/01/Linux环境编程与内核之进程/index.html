<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2024/02/01/linux环境编程与内核之进程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="前言在Linux内核源码分析进程一篇中，讲解了内核中进程的实现原理，本文从开发角度来审视进程。 进程环境程序的开始12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; source#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;static void __attribute__">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux环境编程与内核之进程">
<meta property="og:url" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="前言在Linux内核源码分析进程一篇中，讲解了内核中进程的实现原理，本文从开发角度来审视进程。 进程环境程序的开始12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; source#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;static void __attribute__">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_71.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_73.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_75.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_76.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_79.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_80.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_81.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_84.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_87.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_88.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_90.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_93.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_95.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_99.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_102.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_103.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_104.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_105.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_106.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_110.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_111.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_114.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_119.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_121.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_126.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_127.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_130.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_131.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_132.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_133.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_135.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_141.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_142.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_143.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_146.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_148.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_149.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_150.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_152.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_154.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_157.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_159.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_160.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_161.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_162.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_163-1739157516356-14.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_167.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_169.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_170.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_176.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_181.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_185.jpg">
<meta property="article:published_time" content="2024-02-01T03:01:40.000Z">
<meta property="article:modified_time" content="2025-03-16T07:26:00.607Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_71.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            Linux环境编程与内核之进程 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">121</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Linux环境编程与内核之进程</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-02-01 11:01:40</span>
        <span class="mobile">2024-02-01 11:01:40</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-03-16 15:26</span>
            <span class="mobile">2025-03-16 15:26</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Linux内核源码分析进程一篇中，讲解了内核中进程的实现原理，本文从开发角度来审视进程。</p>
<h1 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h1><h2 id="程序的开始"><a href="#程序的开始" class="headerlink" title="程序的开始"></a>程序的开始</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__ ((constructor)) before_main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before main...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// complier</span></span><br><span class="line">$ gcc -v first.c -o first</span><br><span class="line">[...]</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;...&quot;</span> search starts here:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span> search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search <span class="built_in">list</span>.</span><br><span class="line">[...]</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;first&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> as -v -<span class="number">-64</span> -o /tmp/cckaqfwB.o /tmp/cc6KuP5q.s</span><br><span class="line">GNU assembler version <span class="number">2.38</span> (x86_64-linux-gnu) using BFD version (GNU Binutils <span class="keyword">for</span> Ubuntu) <span class="number">2.38</span></span><br><span class="line">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/:/usr/lib/gcc/x86_64-linux-gnu/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;first&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span> <span class="string">&#x27;-dumpdir&#x27;</span> <span class="string">&#x27;first.&#x27;</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/lto-wrapper -plugin-opt=-fresolution=/tmp/ccL3y8nT.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> -pie -z now -z relro -o first /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span> -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../.. /tmp/cckaqfwB.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu/crtn.o</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;first&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span> <span class="string">&#x27;-dumpdir&#x27;</span> <span class="string">&#x27;first.&#x27;</span></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Before main...</span><br><span class="line">Main!</span><br></pre></td></tr></table></figure></div>

<p>在链接生成最后的可执行文件时，有大量的C库二进制文件参与进来，如crt1.o、crti.o等。可见最终的可执行文件，除了我们编写的这个简单的C代码以外，还有大量的C库文件参与了链接，并包含在最终的可执行文件中。这个“组装”的过程，是由链接器ld的链接脚本来决定的。在没有指定链接脚本的情况下，会使用ld的默认脚本，可以通过ld–verbose来查看，</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">❯ ld -verbose</span><br><span class="line">[...]</span><br><span class="line"><span class="comment">// 这里定义了输出的文件格式、目标机器的类型，以及重要的信息和程序的入口ENTRY（_start）​。</span></span><br><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf64-x86-64&quot;</span>, <span class="string">&quot;elf64-x86-64&quot;</span>,</span><br><span class="line">	      <span class="string">&quot;elf64-x86-64&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(i386:x86<span class="number">-64</span>)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/local/lib/x86_64-linux-gnu&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/lib/x86_64-linux-gnu&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/lib/x86_64-linux-gnu&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/lib/x86_64-linux-gnu64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/local/lib64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/lib64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/lib64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/local/lib&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/lib&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/lib&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/x86_64-linux-gnu/lib64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/x86_64-linux-gnu/lib&quot;</span>);</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 这里定义了.ctors section，而我们的例子中before_main函数使用的gcc扩展属性__attribute__（​（constructor）​）</span></span><br><span class="line"><span class="comment">  * 就是将函数对应的指令归属于.ctors section中。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  .ctors          :</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* gcc uses crtbegin.o to find the start of</span></span><br><span class="line"><span class="comment">       the constructors, so we make sure it is</span></span><br><span class="line"><span class="comment">       first.  Because this is a wildcard, it</span></span><br><span class="line"><span class="comment">       doesn&#x27;t matter if the user does not</span></span><br><span class="line"><span class="comment">       actually link against crtbegin.o; the</span></span><br><span class="line"><span class="comment">       linker won&#x27;t look for a file to match a</span></span><br><span class="line"><span class="comment">       wildcard.  The wildcard also means that it</span></span><br><span class="line"><span class="comment">       doesn&#x27;t matter which directory crtbegin.o</span></span><br><span class="line"><span class="comment">       is in.  */</span></span><br><span class="line">    KEEP (*crtbegin.o(.ctors))</span><br><span class="line">    KEEP (*crtbegin?.o(.ctors))</span><br><span class="line">    <span class="comment">/* We don&#x27;t want to include the .ctor section from</span></span><br><span class="line"><span class="comment">       the crtend.o file until after the sorted ctors.</span></span><br><span class="line"><span class="comment">       The .ctor section from the crtend file contains the</span></span><br><span class="line"><span class="comment">       end of ctors marker and it must be last */</span></span><br><span class="line">    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))</span><br><span class="line">    KEEP (*(SORT(.ctors.*)))</span><br><span class="line">    KEEP (*(.ctors))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 这里定义了.dtors section，是main函数结束调用的代码。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  .dtors          :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP (*crtbegin.o(.dtors))</span><br><span class="line">    KEEP (*crtbegin?.o(.dtors))</span><br><span class="line">    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))</span><br><span class="line">    KEEP (*(SORT(.dtors.*)))</span><br><span class="line">    KEEP (*(.dtors))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面我们来追溯一下Linux可执行程序完整的启动过程。前面的链接脚本明确了入口为<code>_start</code>。在32位的x86平台中，<code>_start</code>位于<code>sysdeps/i386/start.S</code>中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .globl _start</span><br><span class="line">    .type _start,@function</span><br><span class="line">_start:</span><br><span class="line">    <span class="comment">/* Clear the frame pointer.  The ABI suggests this be done, to mark</span></span><br><span class="line"><span class="comment">       the outermost frame obviously.  */</span></span><br><span class="line">    xorl %ebp, %ebp</span><br><span class="line">    <span class="comment">/* Extract the arguments as encoded on the stack and set up</span></span><br><span class="line"><span class="comment">       the arguments for `main&#x27;: argc, argv.  envp will be determined</span></span><br><span class="line"><span class="comment">       later in __libc_start_main.  */</span></span><br><span class="line">    popl %esi       <span class="comment">/* Pop the argument count.  */</span></span><br><span class="line">    movl %esp, %ecx     <span class="comment">/* argv starts just at the current stack top.*/</span></span><br><span class="line">    <span class="comment">/* Before pushing the arguments align the stack to a 16-byte</span></span><br><span class="line"><span class="comment">    (SSE needs 16-byte alignment) boundary to avoid penalties from</span></span><br><span class="line"><span class="comment">    misaligned accesses.  Thanks to Edward Seidl &lt;seidl@janed.com&gt;</span></span><br><span class="line"><span class="comment">    for pointing this out.  */</span></span><br><span class="line">    andl $<span class="number">0xfffffff0</span>, %esp</span><br><span class="line">    pushl %eax      <span class="comment">/* Push garbage because we allocate</span></span><br><span class="line"><span class="comment">                   28 more bytes.  */</span></span><br><span class="line">    <span class="comment">/* Provide the highest stack address to the user code (for stacks</span></span><br><span class="line"><span class="comment">       which grow downwards).  */</span></span><br><span class="line">    pushl %esp</span><br><span class="line">    pushl %edx      <span class="comment">/* Push address of the shared library</span></span><br><span class="line"><span class="comment">                   termination function.  */</span></span><br><span class="line">    <span class="comment">/* Push address of our own entry points to .fini and .init.  */</span></span><br><span class="line">    pushl $__libc_csu_fini</span><br><span class="line">    pushl $__libc_csu_init</span><br><span class="line">    pushl %ecx      <span class="comment">/* Push second argument: argv.  */</span></span><br><span class="line">    pushl %esi      <span class="comment">/* Push first argument: argc.  */</span></span><br><span class="line">    pushl $BP_SYM (main)</span><br><span class="line">    <span class="comment">/* Call the user&#x27;s main function, and exit with its value.</span></span><br><span class="line"><span class="comment">       But let the libc call main.    */</span></span><br><span class="line">    call <span class="title function_">BP_SYM</span> <span class="params">(__libc_start_main)</span></span><br></pre></td></tr></table></figure></div>

<p>上面列出的虽然是汇编代码，但是每一行都有清楚的注释，这段代码主要是为程序的运行创建好运行环境，其中需要注意的是，<code>__libc_csu_fini</code>和<code>__libc_csu_init</code>都被作为参数传给了<code>__libc_start_main</code>。从这两个函数的名字上可以推测它们是用来处理退出和初始化阶段的函数，那么<code>.ctors section</code>中的函数很可能就是由<code>__libc_csu_init</code>来调用的。我们先来关注<code>__libc_csu_init</code>是在何时被调用的，然后再分析其实现。上面的汇编代码将这两个函数作为参数传递给了<code>__libc_start_main</code>，然后又调用了<code>generic_start_main</code>函数。这个函数初始化了C库所需要的环境，如环境变量、函数栈、多线程环境等，最后调用main函数——进入普通应用程序的真正入口。而在此之前，以下代码先被执行：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line"><span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line">    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br></pre></td></tr></table></figure></div>

<p>init即为<code>__libc_csu_init</code>，上面的代码保证了<code>__libc_csu_init</code>在main之前被调用。<code>.ctors</code>的函数调用流程：<code>__libc_csu_init-&gt;_init-&gt;__libc_global_ctors</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_global_ctors (<span class="type">void</span>)</span><br><span class="line">&#123;<span class="comment">/* Call constructor functions.  */</span></span><br><span class="line">    run_hooks (__CTOR_LIST__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">run_hooks</span> <span class="params">(<span class="type">void</span> (*<span class="type">const</span> <span class="built_in">list</span>[]) (<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (*++<span class="built_in">list</span>)</span><br><span class="line">        (**<span class="built_in">list</span>) ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*<span class="type">const</span> __CTOR_LIST__[<span class="number">1</span>])</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">  __<span class="title function_">attribute__</span> <span class="params">((used, section (<span class="string">&quot;.ctors&quot;</span>)))</span></span><br><span class="line">  = &#123; (<span class="type">void</span> (*) (<span class="type">void</span>)) <span class="number">-1</span> &#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>__CTOR_LIST__</code>是一个函数指针数组，数组的大小为1。该数组使用gcc的扩展属性，使<code>__CTOR_LIST__</code>位于<code>.ctors section</code>中。因此，在上面的代码中，<code>__libc_global_ctors</code>将<code>__CTOR_LIST__</code>传递给了<code>run_hooks</code>，实际上就是将<code>.ctors section</code>的起始地址传递给了<code>run_hooks</code>。而<code>__CTOR_LIST__</code>位于<code>.ctors</code>的第一个位置，其本身并不是一个真正的<code>.ctors</code>属性函数，因此<code>run_hooks</code>的<code>while（*++list）</code>先执行自增操作，即跳过了<code>__CTOR_LIST__</code>。</p>
<p>可以通过 <code>r2</code> 反汇编查看二进制的可执行程序来验证：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">080483e4 &lt;before_main&gt;:</span><br><span class="line">80483e4:       55                      push   %ebp</span><br><span class="line">80483e5:       89 e5                   mov    %esp,%ebp</span><br><span class="line">80483e7:       83 ec 18                sub    $0x18,%esp</span><br><span class="line">80483ea:       c7 04 24 e0 84 04 08    movl   $0x80484e0,(%esp)</span><br><span class="line">80483f1:       e8 22 ff ff ff          call   8048318 &lt;puts@plt&gt;</span><br><span class="line">80483f6:       c9                      leave</span><br><span class="line">80483f7:       c3                      ret</span><br></pre></td></tr></table></figure></div>

<p>可以看到，函数<code>before_main</code>的地址为<code>0x080483e4</code>。然后使用<code>objdump</code>来查看<code>.ctors section：</code></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objdump -s -j .ctors a.out</span><br><span class="line">a.out:     file format elf32-i386</span><br><span class="line">Contents of section .ctors:</span><br><span class="line">8049f08 ffffffff e4830408 00000000           ……</span><br></pre></td></tr></table></figure></div>

<p>可以看到，<code>.ctors section</code>的第一个元素即上文中的<code>__CTOR_LIST__</code>，第二个元素为<code>before_main</code>——由于x86是小端CPU，因此0xe4830408实际上表示的地址值为0x080483e4。</p>
<p>需要注意的是，在新版本的gcc中，.ctors属性的函数并不会位于<code>.ctors section</code>中，而是被gcc合并到了<code>.init_array section</code>中，<code>.dtors section</code>也被合并到了<code>.fini_array section</code>中。下面来看一下这种情况下的objdump输出：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到，在.ctors section中，没有任何有效的.ctors函数，</span></span><br><span class="line">[fgao@fgao chapter3]<span class="comment">#objdump -s -j .ctors a.out</span></span><br><span class="line">a.out:     file format elf32-i386</span><br><span class="line">Contents of section .ctors:</span><br><span class="line">8049600 ffffffff 00000000</span><br><span class="line"><span class="comment"># 保存在.init_array section中的函数调用机制与之前分析的.ctors section机制类似的。</span></span><br><span class="line">[fgao@fgao chapter3]<span class="comment">#objdump -s -j .init_array a.out</span></span><br><span class="line">a.out:     file format elf32-i386</span><br><span class="line">Contents of section .init_array:</span><br><span class="line">80495fc b4830408</span><br></pre></td></tr></table></figure></div>

<h2 id="关于-exit"><a href="#关于-exit" class="headerlink" title="关于 exit"></a>关于 exit</h2><p>在刚刚学习C语言的时候，我们就被告知分配内存以后，如果不使用free来释放内存，就会造成内存的泄漏。同样，打开文件以后，如果忘记close也会造成资源的泄漏。那么，在进程退出以后，这些资源是否真的泄漏了呢？</p>
<p>当进程正常退出时，会调用C库的exit；而当进程崩溃或被kill掉时，C库的exit则不会被调用，只会执行内核退出进程的操作。</p>
<p>首先，我们来分析C库的退出函数exit，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>C库的exit主要用来执行所有注册的退出函数，比如使用atexit或on_exit注册的函数。执行完注册的退出函数后，<code>__run_exit_handlers</code>会调用<code>_exit</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_exit (status)</span><br><span class="line">     <span class="type">int</span> status;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NR_exit_group</span></span><br><span class="line">      INLINE_SYSCALL (exit_group, <span class="number">1</span>, status);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      INLINE_SYSCALL (<span class="built_in">exit</span>, <span class="number">1</span>, status);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ABORT_INSTRUCTION</span></span><br><span class="line">      ABORT_INSTRUCTION;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码很简单，当平台有<code>exit_group</code>时，就调用<code>exit_group</code>，否则就调用exit。从Linux内核2.5.35版本以后，为了支持线程，就有了<code>exit_group</code>。这个系统调用不仅仅是用于退出当前线程，还会让所有线程组的线程全部退出。下面来看看系统调用<code>exit_group</code>的实现：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(exit_group, <span class="type">int</span>, error_code)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* do_group_exit做真正的工作 */</span></span><br><span class="line">    do_group_exit((error_code &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="comment">/* NOTREACHED */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">NORET_TYPE <span class="type">void</span></span><br><span class="line"><span class="title function_">do_group_exit</span><span class="params">(<span class="type">int</span> exit_code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span> =</span> current-&gt;signal;</span><br><span class="line">    BUG_ON(exit_code &amp; <span class="number">0x80</span>); <span class="comment">/* core dumps don&#x27;t get here */</span></span><br><span class="line">    <span class="comment">/* 检查该线程组是否正在退出，如果条件为真，则不需要设置线程组退出的条件，直接执行本线程task退出流程do_exit即可 */</span></span><br><span class="line">    <span class="keyword">if</span> (signal_group_exit(sig))</span><br><span class="line">        exit_code = sig-&gt;group_exit_code;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!thread_group_empty(current)) &#123; <span class="comment">/* 线程组不为空 */</span></span><br><span class="line">        <span class="keyword">struct</span> sighand_struct *<span class="type">const</span> sighand = current-&gt;sighand;</span><br><span class="line">        spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">        <span class="comment">/* 标准的双重条件检查机制。因为第一次检查signal_group_exit时为假，</span></span><br><span class="line"><span class="comment">        *  但是另外一个线程已经拿到锁，并设置了状态。当拿到锁的时候，需要再次检查</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (signal_group_exit(sig)) &#123;</span><br><span class="line">            <span class="comment">/* Another thread got here before we took the lock.  */</span></span><br><span class="line">            exit_code = sig-&gt;group_exit_code;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 设置线程组的退出值和退出状态 */</span></span><br><span class="line">            sig-&gt;group_exit_code = exit_code;</span><br><span class="line">            sig-&gt;flags = SIGNAL_GROUP_EXIT;</span><br><span class="line">            <span class="comment">/* 使用SIGKILL“干掉”线程组的其他线程 */</span></span><br><span class="line">            zap_other_threads(current);</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 真正的退出动作，退出当前线程task */</span></span><br><span class="line">    do_exit(exit_code);</span><br><span class="line">    <span class="comment">/* NOTREACHED */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面来看看<code>do_exit</code>的实现：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">NORET_TYPE <span class="type">void</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> group_dead;</span><br><span class="line">    profile_task_exit(tsk);</span><br><span class="line">    WARN_ON(blk_needs_flush_plug(tsk));</span><br><span class="line">    <span class="comment">/* 中断上下文不能使用退出，因为没有进程上下文 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(in_interrupt()))</span><br><span class="line">        panic(<span class="string">&quot;Aiee, killing interrupt handler!&quot;</span>);</span><br><span class="line">    <span class="comment">/* pid为0，即内核的idle进程。这个task也是不应该退出的 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!tsk-&gt;pid))</span><br><span class="line">        panic(<span class="string">&quot;Attempted to kill the idle task!&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If do_exit is called because this processes oopsed, it&#x27;s possible</span></span><br><span class="line"><span class="comment">     * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before</span></span><br><span class="line"><span class="comment">     * continuing. Amongst other possible reasons, this is to prevent</span></span><br><span class="line"><span class="comment">     * mm_release()-&gt;clear_child_tid() from writing to a user-controlled</span></span><br><span class="line"><span class="comment">     * kernel address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    set_fs(USER_DS);</span><br><span class="line">    <span class="comment">/* 如果task正在被跟踪如gdb，则发送ptrace事件 */</span></span><br><span class="line">    ptrace_event(PTRACE_EVENT_EXIT, code);</span><br><span class="line">    validate_creds_for_do_exit(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;re taking recursive faults here in do_exit. Safest is to just</span></span><br><span class="line"><span class="comment">     * leave this task alone and wait for reboot.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 当task退出的时候，会被设置上PF_EXITING标志。如果发现此时flags已经设置了该标志，则说明发生了错误。此时就要按照注释所说的，最安全的方法是什么都不做，通知并等待重启 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tsk-&gt;flags &amp; PF_EXITING)) &#123;</span><br><span class="line">        printk(KERN_ALERT</span><br><span class="line">            <span class="string">&quot;Fixing recursive fault but reboot is needed!\n&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We can do this unlocked here. The futex code uses</span></span><br><span class="line"><span class="comment">         * this flag just to verify whether the pi state</span></span><br><span class="line"><span class="comment">         * cleanup has been done or not. In the worst case it</span></span><br><span class="line"><span class="comment">         * loops once more. We pretend that the cleanup was</span></span><br><span class="line"><span class="comment">         * done as there is no way to return. Either the</span></span><br><span class="line"><span class="comment">         * OWNER_DIED bit is set by now or we push the blocked</span></span><br><span class="line"><span class="comment">         * task into the wait for ever nirwana as well.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">        <span class="comment">/* 将当前task设置为不可中断的状态，然后放弃CPU。 */</span></span><br><span class="line">        set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果当前task是中断线程，即每个CPU中断由一个线程来处理，则设置对应的中断停止来唤醒本线程。</span></span><br><span class="line"><span class="comment">    * 这是一个编译选项，默认情况下是关闭的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    exit_irq_thread();</span><br><span class="line">    <span class="comment">/* 给task设置退出标志PF_EXITING */</span></span><br><span class="line">    exit_signals(tsk);  <span class="comment">/* sets PF_EXITING */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * tsk-&gt;flags are checked in the futex code to protect against</span></span><br><span class="line"><span class="comment">     * an exiting task cleaning up the robust pi futexes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    raw_spin_unlock_wait(&amp;tsk-&gt;pi_lock);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(in_atomic()))</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;note: %s[%d] exited with preempt_count %d\n&quot;</span>,</span><br><span class="line">                current-&gt;comm, task_pid_nr(current),</span><br><span class="line">                preempt_count());</span><br><span class="line">    acct_update_integrals(tsk);</span><br><span class="line">    <span class="comment">/* sync mm&#x27;s RSS info before statistics gathering */</span></span><br><span class="line">    <span class="comment">/* 该task有自己的内存空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;mm)</span><br><span class="line">        sync_mm_rss(tsk, tsk-&gt;mm); <span class="comment">//更新内存统计计数</span></span><br><span class="line">    <span class="comment">/* 判断整个线程组是否都已经退出。*/</span></span><br><span class="line">    group_dead = atomic_dec_and_test(&amp;tsk-&gt;signal-&gt;live);</span><br><span class="line">    <span class="keyword">if</span> (group_dead) &#123;</span><br><span class="line">        <span class="comment">/* 取消高精度定时器 */</span></span><br><span class="line">        hrtimer_cancel(&amp;tsk-&gt;signal-&gt;real_timer);</span><br><span class="line">        <span class="comment">/* 删除task的内部定时器，对应系统调用getitimer和setitimer */</span></span><br><span class="line">        exit_itimers(tsk-&gt;signal);</span><br><span class="line">        <span class="keyword">if</span> (tsk-&gt;mm)</span><br><span class="line">            setmax_mm_hiwater_rss(&amp;tsk-&gt;signal-&gt;maxrss, tsk-&gt;mm);</span><br><span class="line">    &#125;</span><br><span class="line">    acct_collect(code, group_dead);</span><br><span class="line">    <span class="comment">/* 如果整个线程组都已经退出，则释放授权资源 */</span></span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        tty_audit_exit();</span><br><span class="line">    <span class="keyword">if</span> (unlikely(tsk-&gt;audit_context))</span><br><span class="line">        audit_free(tsk);</span><br><span class="line">    <span class="comment">/* 设置task的退出值 */</span></span><br><span class="line">    tsk-&gt;exit_code = code;</span><br><span class="line">    <span class="comment">/* 释放任务统计资源 */</span></span><br><span class="line">    taskstats_exit(tsk, group_dead);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    释放task的内存空间。task使用的所有内存页都由内核来维护。对于用户程序，如果忘记释放申请的内存，则只会造成用户程序无法再使用该内存，因为内核认为该内存仍然在被用户程序使用。当task退出时，内核会负责释放所有的内存地址。因此当进程退出时，所有申请的内存都会被释放，不会有任何的内存泄漏。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    exit_mm(tsk);</span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        acct_process();</span><br><span class="line">    trace_sched_process_exit(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    检查是否释放了semphore资源，如没有释放则执行semphore的undo操作。这点用于保证在进程意外退出时，能恢复semphore的正确状态，也可以用于预防错误的程序逻辑所导致的semphore释放操作遗漏。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    exit_sem(tsk);</span><br><span class="line">    <span class="comment">/* 释放共享内存 */</span></span><br><span class="line">    exit_shm(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果文件资源没有被共享，则释放所有的文件资源。即使用户程序有文件泄漏也不必担心，一旦task退出，文件资源都会得到正确的释放—因为内核维护了所有的、打开的文件。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    exit_files(tsk);</span><br><span class="line">    <span class="comment">/* 释放task的文件系统资源，如当前目录、根目录等*/</span></span><br><span class="line">    exit_fs(tsk);</span><br><span class="line">    check_stack_usage();</span><br><span class="line">    <span class="comment">/* 释放task资源，如TSS段等 */</span></span><br><span class="line">    exit_thread();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Flush inherited counters to the parent - before the parent</span></span><br><span class="line"><span class="comment">     * gets woken up by child-exit notifications.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">     * because of cgroup mode, must be called before cgroup_exit()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    perf_event_exit_task(tsk);</span><br><span class="line">    <span class="comment">/* 从控制组退出，并释放相关资源 */</span></span><br><span class="line">    cgroup_exit(tsk, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 如果线程组都已经退出，则断开控制终端即tty */</span></span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        disassociate_ctty(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 后面仍然是一些task退出的清理工作，因与本节关系不大，所以在此不再一一列出了 */</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从<code>exit</code>的源码可以得知，即使应用程序在应用层有内存泄漏或文件句柄泄漏也不必担心，当进程退出时，内核的<code>exit_group</code>调用将会默默地在后面做着清理工作，释放所有内存，关闭所有文件，以及其他资源——当然，前提条件是这些资源是该进程独享的。</p>
<h2 id="关于-atexit"><a href="#关于-atexit" class="headerlink" title="关于 atexit"></a>关于 atexit</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">callback1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">callback2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">callback3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    atexit(callback1);</span><br><span class="line">    atexit(callback2);</span><br><span class="line">    atexit(callback3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">main <span class="built_in">exit</span></span><br><span class="line">callback3</span><br><span class="line">callback2</span><br><span class="line">callback1</span><br></pre></td></tr></table></figure></div>

<p>从上面的代码输出可以看出，我们顺序地注册callback1、callback2和callback3，当进程退出时，其调用顺序为callback3、callback2和callback1。</p>
<p>使用atexit注册的退出函数是在进程正常退出时，才会被调用。这里的正常退出是指，使用exit退出或使用main中最后的return语句退出。若是因为收到信号而导致程序退出，atexit注册的退出函数则不会被调用。下面我们通过一个测试程序来验证这一观点：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">callback1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    atexit(callback1);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// terminal</span></span><br><span class="line">&gt;                                | &gt; ./atexit_signal;</span><br><span class="line">&gt; killall atexit_signal  		 |  </span><br><span class="line">&gt;    							 |    Terminated</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们会发现atexit注册的退出函数并没有被调用，下面我们来看一下其在 glibc 中的源码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> atexit</span></span><br><span class="line">attribute_hidden</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">atexit (<span class="type">void</span> (*func) (<span class="type">void</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* __dso_handle是动态共享对象的句柄，此处可以略过 */</span></span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) func, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">__cxa_atexit (<span class="type">void</span> (*func) (<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* __exit_funcs为退出函数的链表 */</span></span><br><span class="line">    <span class="keyword">return</span> __internal_atexit (func, arg, d, &amp;__exit_funcs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__internal_atexit (<span class="type">void</span> (*func) (<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d,</span><br><span class="line">          <span class="keyword">struct</span> exit_function_list **listp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 在退出函数链表中，得到一个新的节点 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">new</span> =</span> __new_exitfn (listp);</span><br><span class="line">  <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">  PTR_MANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* 初始化这个节点，将函数及其参数赋给这个节点 */</span></span><br><span class="line">  new-&gt;func.cxa.fn = (<span class="type">void</span> (*) (<span class="type">void</span> *, <span class="type">int</span>)) func;</span><br><span class="line">  new-&gt;func.cxa.arg = arg;</span><br><span class="line">  new-&gt;func.cxa.dso_handle = d;</span><br><span class="line">  atomic_write_barrier ();</span><br><span class="line">  new-&gt;flavor = ef_cxa;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码揭示了atexit是如何把函数注册到退出函数链表中的。那么，这些函数又是何时被调用的呢？回忆atexit的介绍，退出注册函数只有在程序正常退出或调用exit时才会被执行。程序正常退出时，系统就会调用exit。因此，问题的关键就在于exit函数了：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这里，<code>__run_exit_handlers</code>会遍历<code>__exit_funcs</code>，一一调用注册的退出函数，在此就不再罗列其代码了。从atexit的实现机制上进行分析，我们可以得出atexit的实现是依赖于C库的代码的。当进程收到信号时，如果没有注册对应的信号处理函数，那么内核就会执行信号的默认动作，一般是直接终止进程。这时，进程的退出完全由内核来完成，自然不会调用到C库的exit函数，也就无法调用注册的退出函数了。</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>Linux环境下，程序在启动的时候都会从shell环境下继承当前的环境变量，如<code>PATH、HOME、TZ</code>等。我们也可以通过C库的接口来增加、修改或删除当前进程的环境变量，<code>putenv</code>用于增加或修改当前的环境变量。<code>string</code>的格式为“名字&#x3D;值”。如果当前环境变量没有该名称的环境变量，则增加这个新的环境变量；如果已经存在，则使用新值。看似功能很简单，但实际上使用这个接口时，却很容易犯错。请看下面的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_env_string</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> test_env[] = <span class="string">&quot;test_env=test&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != putenv(test_env)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to putenv\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1. The test_evn string is %s\n&quot;</span>, getenv(<span class="string">&quot;test_env&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_env_string</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2. The test_env string is %s\n&quot;</span>, getenv(<span class="string">&quot;test_env&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    set_env_string();</span><br><span class="line">    show_env_string();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">1.</span> The test_evn <span class="built_in">string</span> is test</span><br><span class="line"><span class="number">2.</span> The test_env <span class="built_in">string</span> <span class="title function_">is</span> <span class="params">(null)</span></span><br></pre></td></tr></table></figure></div>

<p>使用putenv添加环境变量时，参数直接被当作环境变量的一部分了。对于本例而言，<code>set_env_string</code>中的<code>test_env</code>数组直接被环境变量引用了。而<code>test_env</code>是一个局部变量，在执行<code>set_env_string</code>的时候，<code>test_env</code>已经不存在了，对应栈上的内存会在后面的函数调用中使用，并存入其他值。因此，在进入<code>show_env_string</code>的时候，就无法得到正确的值了。</p>
<blockquote>
<p>笔者曾经修改过一个因为putenv引起的bug，当时也是费了很大一番力气才找到根本原因，所以颇为气愤当时的开发人员为什么在使用putenv的时候，不认真阅读该接口的说明。Martin Golding曾说过一句话“编程的时候，要总是想着那个维护你代码的人会是一个知道你住在哪儿的、有暴力倾向的精神病患者”。</p>
</blockquote>
<p>如果非要用putenv来设置环境变量，就必须要保证参数是一个长期存在的内容。因此，只能选择全局变量、常量或动态内存等。为了避免犯错，我们应该尽量使用另外一个接口<code>setenv</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* @name：要加入的环境变量名称。</span></span><br><span class="line"><span class="comment">*  @value：该环境变量的值。</span></span><br><span class="line"><span class="comment">*  @overwrite：用于指示是否覆盖已存在的重名环境变量。0不覆盖，非0则覆盖。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_env_string</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setenv(<span class="string">&quot;test_env&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1. The test_evn string is %s\n&quot;</span>, getenv(<span class="string">&quot;test_env&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_env_string</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2. The test_env string is %s\n&quot;</span>, getenv(<span class="string">&quot;test_env&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    set_env_string();</span><br><span class="line">    show_env_string();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">1.</span> The test_evn <span class="built_in">string</span> is test</span><br><span class="line"><span class="number">2.</span> The test_env <span class="built_in">string</span> is test</span><br></pre></td></tr></table></figure></div>

<h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><h2 id="编译生成和使用动态库"><a href="#编译生成和使用动态库" class="headerlink" title="编译生成和使用动态库"></a>编译生成和使用动态库</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="number">4</span>_5_2_dlib.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dynamic_lib_call</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dynamic lib call\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ gcc -Wall -shared <span class="number">4</span>_5_2_dlib.c -o libdlib.so</span><br><span class="line">$ cat <span class="number">4</span>_5_2_main.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">dynamic_lib_call</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    dynamic_lib_call();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ gcc -Wall <span class="number">4</span>_5_2_main.c -o test_dlib -L ./-ldlib</span><br><span class="line">$ ./test_dlib</span><br><span class="line">./test_dlib: error <span class="keyword">while</span> loading shared libraries: libdlib.so: cannot open shared object file: No such file or directory</span><br><span class="line"></span><br><span class="line">$ ldd test_dlib</span><br><span class="line">        linux-gate.so<span class="number">.1</span> =&gt;  (<span class="number">0xb7785000</span>)</span><br><span class="line">        libdlib.so =&gt; not found</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/i386-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0xb75ce000</span>)</span><br><span class="line">        /lib/ld-linux.so<span class="number">.2</span> (<span class="number">0xb7786000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>显示无法找到<code>libdlib.so</code>。原因在于-L只是在gcc编译的过程中指示库的位置，而在程序运行的时候，动态库的加载路径默认为<code>/lib</code>和<code>/usr/lib</code>。在Linux环境下，还可以通过<code>/etc/ld.so.conf</code>配置文件和环境变量<code>LD_LIBRARY_PATH</code>指示额外的动态库路径，或者使用<code>patch_elf</code>修改动态库路径。为简单起见，我们在这里将<code>libdlib.so</code>复制到<code>/usr/lib</code>目录下，再运行test_dlib试试：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> /home/fgao/works/my_git_codes/my_books/understanding_apue/sample_codes/chapter3/libdlib.so .</span><br><span class="line">$ ./test_dlib</span><br><span class="line">dynamic lib call</span><br></pre></td></tr></table></figure></div>

<p>上面的例子中，动态库是由系统自动加载的，所以需要将动态库放在指定的目录下。然而，C库还提供了dlopen等接口来支持手工加载动态库的功能，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *dlib = dlopen(<span class="string">&quot;./libdlib.so&quot;</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (!dlib) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dlopen failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> (*dfunc) (<span class="type">void</span>) = dlsym(dlib, <span class="string">&quot;dynamic_lib_call&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dfunc) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dlsym failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfunc();</span><br><span class="line">    dlclose(dlib);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">$ gcc -Wall <span class="number">4</span>_5_2_main_mlib.c -ldl -o test_mlib</span><br><span class="line">$ ./test_dlib</span><br><span class="line">dynamic lib call </span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程。</span></span><br><span class="line"><span class="comment">// flag中必须设置以下的mode：</span></span><br><span class="line"><span class="comment">// RTLD_LAZY 暂缓决定，等有需要时再解出符号 </span></span><br><span class="line"><span class="comment">// RTLD_NOW 立即决定，返回前解除所有未决定的符号。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当动态链接库操作函数执行失败时，可以返回出错信息，返回值为NULL时，表示没有错误信息。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle是由dlopen打开动态链接库后返回的指针，symbol就是要求获取的函数的名称，函数返回值是void*,指向函数的地址，供调用使用。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将该.so的引用计数减一，当引用计数为0时，将它从系统中卸载。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="动态升级"><a href="#动态升级" class="headerlink" title="动态升级"></a>动态升级</h2><p>动态库的一个重要优点就是，可执行程序并不包含动态库中的任何指令，而是在运行时加载动态库并完成调用。这就给我们提供了升级动态库的机会。只要保证接口不变，使用新版本的动态库替换原来的动态库，就完成了动态库的升级。</p>
<p>更新完库文件以后启动的可执行程序都会使用新的动态库。这样的更新方法只能够影响更新以后启动的程序，对于正在运行的程序则无法产生效果，因为程序在运行时，旧的动态库文件已经加载到内存中了。我们只能更新位于磁盘上的动态库的物理文件，而不能影响已经位于内存中的库了。</p>
<p>对于服务程序来说，重启会付出很大的代价并带来糟糕的用户体验。但可以使用前面介绍的手工加载动态库的方法。下面的伪代码将给出一个比较简单的解决方案。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) 使用一个结构体来管理动态库的接口：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlib_manager</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *dlib_handle; <span class="comment">//保存动态库的句柄</span></span><br><span class="line">    <span class="type">int</span> (service_func) (<span class="type">void</span> *);</span><br><span class="line">    <span class="type">int</span> (service_func2) (<span class="type">void</span> *);</span><br><span class="line">&#125; g_dlib_manager;</span><br><span class="line"><span class="comment">/* g_dlib_manager作为动态库接口的全局变量 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlib_manager</span> *<span class="title">g_dlib_manager</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2)c利用dlopen、dlsym等来加载动态库，更新接口。重新申请新的内存，来保存新的动态库接口：</span></span><br><span class="line"><span class="comment">/* 更新动态库接口 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlib_manager</span> *<span class="title">new_manager</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new_manager));</span><br><span class="line">new_manager-&gt;dlib_handle = dlopen(<span class="string">&quot;libupgrade.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">new_manager-&gt;service_func = dlsym(g_dlib_handle, <span class="string">&quot;service_call&quot;</span>);</span><br><span class="line">new_manager-&gt;service_func2 = dlsym(g_dlib_handle, <span class="string">&quot;service_call2&quot;</span>);</span><br><span class="line"><span class="comment">/* 在多核环境下，使用内存屏障，以保证在交换new_manager和g_dlib_manager时，new_manager已经完成了赋值 */</span></span><br><span class="line">wmb();</span><br><span class="line"><span class="comment">// 交换新指针与当前正在使用的接口指针，因为目前，无论是新指针还是旧指针都是有效的接口，所以并不会对业务产生影响</span></span><br><span class="line">swap(new_manager, g_dlib_manager);</span><br><span class="line"><span class="comment">// 交换完成以后，新的请求都会交由新接口来处理。由于当前旧接口仍然可能正在使用中，所以要使用推迟释放或是等待正在服务的接口完成</span></span><br><span class="line">delay_free(new_manager);</span><br><span class="line"><span class="comment">// (3) 在调用服务接口时，要利用局部变量保存服务接口：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 之所以这里使用局部变量来进行接口调用，是为了避免在调用了一部分接口后，g_dlib_manager才发生更新，</span></span><br><span class="line"><span class="comment">* 从而导致前后的服务接口属于不同的动态库，造成不可预料的问题。通过临时变量来保存服务接口，能确保所有接口的一致性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlib_manager</span> *<span class="title">local_dlib_manager</span> =</span> g_dlib_manager;</span><br><span class="line">local_dlib_manager-&gt;service_func1(data);</span><br><span class="line">local_dlib_manager-&gt;service_func2(data);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 释放旧接口的关键在于，要保证没有旧接口正在被使用。根据自己的业务，找到一个时间点——在这个时间点上，</span></span><br><span class="line"><span class="comment">* 所有的线程（准确地说是请求流程）都已经服务过一次。这时，新来的请求就会使用新的接口，</span></span><br><span class="line"><span class="comment">* 于是我们也就可以安全地释放旧接口了。其实整个实现方案是借鉴了Linux内核的RCU实现方式。</span></span><br><span class="line"><span class="comment">* 通过这种方法，可以进行“平滑无缝”的升级，而不影响运行状态下的业务功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<h1 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于良好的代码风格，有一项很重要的要求是一个函数只专注于做一件事情。如果该函数像瑞士军刀一样能实现多个功能，那基本上可以断言这不是一个设计良好的函数。C库中的realloc函数就是一个典型的反面教材：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数ptr为NULL，而size不为0，则等同于malloc（size）。</span></span><br><span class="line"><span class="comment">* 参数ptr不为NULL，而size为0，则等同于free（ptr）。</span></span><br><span class="line"><span class="comment">* 参数ptr和size均不为0，其行为类似于free（ptr）；malloc（size）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这里就会因为realloc的第三种行为引入一个bug。当realloc分配内存失败的时候，ptr会返回NULL。</span></span><br><span class="line"><span class="comment">* 但是这时ptr原来指向的内存并没有被释放，而ptr却已经被赋值为NULL了，这就造成了ptr原有内存泄漏。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> * ptr = <span class="built_in">realloc</span>(ptr, new_size);</span><br><span class="line"><span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* realloc只有在分配内存成功的情况下，才会让ptr等于new_ptr。</span></span><br><span class="line"><span class="comment">* 这样，在分配内存失败的情况下，ptr指向的内存并不会丢失。</span></span><br><span class="line"><span class="comment">* realloc使用不当还会引发其他几种bug，在此就不一一罗列了。</span></span><br><span class="line"><span class="comment">* 需要吸取的教训就是，慎用realloc，甚至最好不用realloc。如果真的需要使用realloc，</span></span><br><span class="line"><span class="comment">* 一定要确保在realloc的三种行为下代码都可以正常工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> * new_ptr = <span class="built_in">realloc</span>(ptr, new_size);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br><span class="line">ptr = new_ptr</span><br></pre></td></tr></table></figure></div>

<h2 id="内存越界"><a href="#内存越界" class="headerlink" title="内存越界"></a>内存越界</h2><p>通过良好的编程习惯基本上是可以避免内存越界问题的。防范的根本思想在于在对缓冲区（一般为数组）进行拷贝前，要保证复制的长度不要超过缓冲区的空间大小。比如在memcpy前，要检查目的地址是否有足够的空间。使用宏或sizeof可保证缓冲长度的一致性；</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当缓冲大小改变为32的时候，需要改动两处代码。一旦忘记修改memcpy处的拷贝长度，就会造成内存越界。</span></span><br><span class="line"><span class="comment">// bad code</span></span><br><span class="line"><span class="type">char</span> dst_buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dst_buf, src_buf,<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就可以做到缓存大小和复制长度的同步修改。</span></span><br><span class="line"><span class="comment">// good code</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE    64</span></span><br><span class="line"><span class="type">char</span> dst_buf[BUF_SIZE];</span><br><span class="line"><span class="built_in">memcpy</span>(dst_buf, src_buf, BUF_SIZE);</span><br><span class="line"><span class="comment">// good code</span></span><br><span class="line"><span class="type">char</span> dst_buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dst_buf, src_buf, <span class="keyword">sizeof</span>(dst_buf));</span><br></pre></td></tr></table></figure></div>

<p>使用安全的库函数也可以保证复制的长度不超过缓冲区的空间，下面来介绍4种库函数。</p>
<p>1）使用strncat代替strcat，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<p>从src中最多追加n个字符到dest字符串的后面。需要注意的是，当src包含n个以上的字符时，dest的空间至少为<code>strlen（dest）+n+1</code>，因为该函数还会追加字符串结束符<code>&#39;\0&#39;</code>到dest后面。</p>
<p>2）使用strncpy代替strcpy，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<p>从src中最多复制n个字符到dest字符串中。与strncat相同的是，当src包含n个以上的字符时，dest的空间需要为<code>n+1</code>，因为该函数还会再复制一个字符串结束符<code>&#39;\0&#39;</code>。</p>
<p>3）使用snprintf代替sprintf，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>snprintf比前面两个函数strncat和strncpy更为友好，在往str中写数据时，最多会写入n字节，其中已包括字符串结束符’\0’。</p>
<p>4）使用fgets代替gets，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure></div>

<p>危险的gets函数从来不检查缓冲区的大小，并且还是从标准输入中读取数据，这是极其危险的行为。再大的缓存空间也无法满足永无终止的标准输入，因此一定要使用fgets代替。fgets最多会复制<code>size-1</code>字节到缓存s中，并且会在最后一个字符后面追加<code>&#39;\0&#39;</code>。</p>
<blockquote>
<p>由于历史原因，标准C库中还存在其他不安全的接口，不过后来C库中也发展了相应的安全接口。在日常的编程中，除非特殊情况，都要使用安全函数来替代非安全函数的调用。</p>
</blockquote>
<h2 id="内存检查"><a href="#内存检查" class="headerlink" title="内存检查"></a>内存检查</h2><p>工欲善其事，必先利其器。valgrind作为一个免费且优秀的工具包，提供了很多有用的功能，其中最有名的就是对内存问题的检测和定位。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_leak1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_leak2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_overrun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    *(<span class="type">short</span>*)p = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_overrun2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="built_in">array</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_double_free</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_free_wild_pointer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    mem_leak1();</span><br><span class="line">    mem_leak2();</span><br><span class="line">    mem_overrun1();</span><br><span class="line">    mem_overrun2();</span><br><span class="line">    mem_double_free();</span><br><span class="line">    mem_free_wild_pointer();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码中包含了六种常见的内存问题：</p>
<ul>
<li>动态内存泄漏；</li>
<li>资源泄漏，代码中以文件描述符为例；</li>
<li>动态内存越界；</li>
<li>数组越界；</li>
<li>动态内存double free；</li>
<li>使用野指针。</li>
</ul>
<p>下面来看看怎样执行valgrind来检测内存错误：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --track-fds=yes --leak-check=full --undef-value-errors=yes ./mem_test</span><br><span class="line">==<span class="number">2326</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">2326</span>== Copyright (C) <span class="number">2002</span><span class="number">-2009</span>, and GNU GP<span class="string">L&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==2326== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==2326== Command: ./mem_test</span></span><br><span class="line"><span class="string">==2326==</span></span><br><span class="line"><span class="string">/* 此处检测到了动态内存的越界，提示Invalid write*/</span></span><br><span class="line"><span class="string">==2326== Invalid write of size 2</span></span><br><span class="line"><span class="string">==2326== at 0x80484B4: mem_overrun1 (in /home/fgao/works/test/a.out)</span></span><br><span class="line"><span class="string">==2326== by 0x8048553: main (in /home/fgao/works/test/a.out)</span></span><br><span class="line"><span class="string">==2326== Address 0x40211f0 is 0 bytes inside a block of size 1 alloc&#x27;</span>d</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x4005BDC</span>: <span class="built_in">malloc</span> (vg_replace_malloc.c:<span class="number">195</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x80484AD</span>: mem_overrun1 (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048553</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"> <span class="comment">/* 此处检测到了double free的问题，提示Invalid Free */</span></span><br><span class="line">==<span class="number">2326</span>== Invalid <span class="built_in">free</span>() / delete / delete[]</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057F6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048514</span>: mem_double_free (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804855D</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== Address <span class="number">0x4021228</span> is <span class="number">0</span> bytes inside a block of size <span class="number">1</span> <span class="built_in">free</span><span class="number">&#x27;</span>d</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057F6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048509</span>: mem_double_free (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804855D</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/* 此处检测到了未初始化变量的问题 */</span></span><br><span class="line">==<span class="number">2326</span>== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057B6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804853C</span>: mem_free_wild_pointer (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048562</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"> <span class="comment">/* 此处检测到了非法使用野指针 */</span></span><br><span class="line">==<span class="number">2326</span>== Invalid <span class="built_in">free</span>() / delete / delete[]</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057F6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804853C</span>: mem_free_wild_pointer (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048562</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== Address <span class="number">0x4021228</span> is <span class="number">0</span> bytes inside a block of size <span class="number">1</span> <span class="built_in">free</span><span class="number">&#x27;</span>d</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057F6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048509</span>: mem_double_free (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804855D</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/*此处检测到了文件指针资源的泄漏，下面提示说有4个文件描述符在退出时仍是打开的描述符0、1、2无须关心，通过报告，可以发现程序中自己明确打开的文件描述符没有关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">==<span class="number">2326</span>== FILE DESCRIPTORS: <span class="number">4</span> open at <span class="built_in">exit</span>.</span><br><span class="line">==<span class="number">2326</span>== Open file descriptor <span class="number">3</span>: test.txt</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x68D613</span>: __open_nocancel (in /lib/libc<span class="number">-2.12</span>.so)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x61F8EC</span>: __fopen_internal (in /lib/libc<span class="number">-2.12</span>.so)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x61F94B</span>: fopen@@GLIBC_2<span class="number">.1</span> (in /lib/libc<span class="number">-2.12</span>.so)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048496</span>: mem_leak2 (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804854E</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>== Open file descriptor <span class="number">2</span>: /dev/pts/<span class="number">4</span></span><br><span class="line">==<span class="number">2326</span>== &lt;inherited from parent&gt;</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>== Open file descriptor <span class="number">1</span>: /dev/pts/<span class="number">4</span></span><br><span class="line">==<span class="number">2326</span>== &lt;inherited from parent&gt;</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>== Open file descriptor <span class="number">0</span>: /dev/pts/<span class="number">4</span></span><br><span class="line">==<span class="number">2326</span>== &lt;inherited from parent&gt;</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/* 堆信息的总结：一共调用了4次alloc，4次free。之所以正好相等，是因为上面有一个函数少了free，有一个函数正好又多了一个free */</span></span><br><span class="line">==<span class="number">2326</span>== HEAP SUMMARY:</span><br><span class="line">==<span class="number">2326</span>== in use at <span class="built_in">exit</span>: <span class="number">353</span> bytes in <span class="number">2</span> blocks</span><br><span class="line">==<span class="number">2326</span>== total heap usage: <span class="number">4</span> allocs, <span class="number">4</span> frees, <span class="number">355</span> bytes allocated</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/* 检测到一字节的内存泄漏 */</span></span><br><span class="line">==<span class="number">2326</span>== <span class="number">1</span> bytes in <span class="number">1</span> blocks are definitely lost in loss record <span class="number">1</span> of <span class="number">2</span></span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x4005BDC</span>: <span class="built_in">malloc</span> (vg_replace_malloc.c:<span class="number">195</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048475</span>: mem_leak1 (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048549</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/* 内存泄漏的总结 */</span></span><br><span class="line">==<span class="number">2326</span>== LEAK SUMMARY:</span><br><span class="line">==<span class="number">2326</span>== definitely lost: <span class="number">1</span> bytes in <span class="number">1</span> blocks</span><br><span class="line">==<span class="number">2326</span>== indirectly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">2326</span>== possibly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">2326</span>== still reachable: <span class="number">352</span> bytes in <span class="number">1</span> blocks</span><br><span class="line">==<span class="number">2326</span>== suppressed: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">2326</span>== Reachable blocks (those to which a pointer was found) are not shown.</span><br><span class="line">==<span class="number">2326</span>== To see them, rerun with: --leak-check=full --show-reachable=yes</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==<span class="number">2326</span>== Use --track-origins=yes to see where uninitialised values come from</span><br><span class="line">==<span class="number">2326</span>== ERROR SUMMARY: <span class="number">5</span> errors from <span class="number">5</span> contexts (suppressed: <span class="number">12</span> from <span class="number">8</span>)</span><br></pre></td></tr></table></figure></div>

<p>这只是一个简单的示例程序，即使没有valgrind，我们也可以很轻易地发现问题。但是在真实的项目中，当代码量达到万行、十万行甚至百万行时，由于申请的内存可能不是在一个地方被使用，它不可避免地会被传来传去。这时，如果只是靠review代码来检查问题，可能很难找到根本原因，而使用valgrind则可以很容易地发现问题所在。</p>
<p>当然，valgrind也不是万能的。笔者就遇到过valgrind无法找到问题，最后是通过不断地检查代码才找到症结所在的情况。发现问题，再解决问题，毕竟是末流。最好的方法，就是从一开始就不引入问题，防微杜渐。这点可以通过良好的代码风格和设计来实现。写代码不是一件容易的事情，要用心，把代码当作自己的作品，真心地去写好它。这样，自然而然的就会把代码写好。</p>
<h1 id="长跳转"><a href="#长跳转" class="headerlink" title="长跳转"></a>长跳转</h1><h2 id="setjmp与longjmp"><a href="#setjmp与longjmp" class="headerlink" title="setjmp与longjmp"></a>setjmp与longjmp</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* setjmp用于保存当前栈的上下文，将其保存到参数env中。</span></span><br><span class="line"><span class="comment">* 若返回0值，则为setjmp直接返回的结果；若返回非0值，则为从longjmp恢复栈空间时返回的结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* longjmp用于将上下文恢复至env保存的状态，参数val用于作为恢复点setjmp的返回值。</span></span><br><span class="line"><span class="comment">* 一般情况下，保存的jmp_buf env为全局变量。跳转一次后，保存的env上下文环境就会失效。请看下面的示例：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> jmp_buf g_stack_env;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == setjmp(g_stack_env)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Normal flow\n&quot;</span>);</span><br><span class="line">        func1();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Longjump flow\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter func1\n&quot;</span>);</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter func2\n&quot;</span>);</span><br><span class="line">    longjmp(g_stack_env, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Leave func2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Normal flow</span><br><span class="line">Enter func1</span><br><span class="line">Enter func2</span><br><span class="line">Longjump flow</span><br></pre></td></tr></table></figure></div>

<p>在main函数中，使用setjmp将当前的栈环境保存到<code>g_stack_env</code>中，然后调用<code>func1-&gt;func2</code>，在func2中，使用longjmp来恢复保存的栈环境<code>g_stack_env</code>，从而完成“长跳转”。</p>
<h2 id="长跳转机制"><a href="#长跳转机制" class="headerlink" title="长跳转机制"></a>长跳转机制</h2><p>etjmp和longjmp分别用于保存和恢复栈的上下文，来实现长跳转。而栈的实现肯定是与平台相关的，因此setjmp和longjmp的实现也是与平台相关的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calling environment, plus possibly a saved signal mask.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">jmp_buf_tag</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> The machine-dependent definitions of `__sigsetjmp&#x27;</span></span><br><span class="line"><span class="comment">       assume that a `jmp_buf&#x27; begins with a `__jmp_buf&#x27; and that `__mask_was_saved&#x27; follows it.  Do not move these members or add others before it.  */</span></span><br><span class="line">    __jmp_buf __jmpbuf;     <span class="comment">/* Calling environment.  */</span></span><br><span class="line">    <span class="type">int</span> __mask_was_saved;   <span class="comment">/* Saved the signal mask?  */</span></span><br><span class="line">    <span class="type">__sigset_t</span> __saved_mask;    <span class="comment">/* Saved signal mask.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">jmp_buf_tag</span> <span class="title">jmp_buf</span>[1];</span></span><br></pre></td></tr></table></figure></div>

<p>x86平台的__jmp_buf的定义为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __jmp_buf[<span class="number">8</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> defined  __x86_64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __jmp_buf[<span class="number">8</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> __jmp_buf[<span class="number">6</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>x86平台的setjmp和longjmp的实现均位于<code>glibc-2.17/sysdeps/i386/setjmp.S</code>中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ENTRY (BP_SYM (__sigsetjmp))</span><br><span class="line">    ENTER</span><br><span class="line">    <span class="comment">/* 将jmpbuf的地址赋给eax */</span></span><br><span class="line">    movl <span class="title function_">JMPBUF</span><span class="params">(%esp)</span>, %eax</span><br><span class="line">    <span class="title function_">CHECK_BOUNDS_BOTH_WIDE</span> <span class="params">(%eax, JMPBUF(%esp), $JB_SIZE)</span></span><br><span class="line">    <span class="comment">/* 保存寄存器 */</span></span><br><span class="line">    movl %ebx, <span class="params">(JB_BX*<span class="number">4</span>)</span><span class="params">(%eax)</span></span><br><span class="line">    movl %esi, <span class="params">(JB_SI*<span class="number">4</span>)</span><span class="params">(%eax)</span></span><br><span class="line">    movl %edi, <span class="params">(JB_DI*<span class="number">4</span>)</span><span class="params">(%eax)</span></span><br><span class="line">    leal <span class="title function_">JMPBUF</span><span class="params">(%esp)</span>, %ecx <span class="comment">/* Save SP as it will be after we return.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">    <span class="title function_">PTR_MANGLE</span> <span class="params">(%ecx)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    movl %ecx, <span class="params">(JB_SP*<span class="number">4</span>)</span><span class="params">(%eax)</span></span><br><span class="line">    movl <span class="title function_">PCOFF</span><span class="params">(%esp)</span>, %ecx  <span class="comment">/* Save PC we are returning to now.  */</span></span><br><span class="line">    <span class="title function_">LIBC_PROBE</span> <span class="params">(setjmp, <span class="number">3</span>, <span class="number">4</span>@%eax, <span class="number">-4</span>@SIGMSK(%esp), <span class="number">4</span>@%ecx)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">    <span class="title function_">PTR_MANGLE</span> <span class="params">(%ecx)</span></span><br><span class="line"><span class="meta">#endifmovl %ecx, (JB_PC*4)(%eax)</span></span><br><span class="line">    LEAVE <span class="comment">/* pop frame pointer to prepare for tail-call.  */</span></span><br><span class="line">    movl %ebp, <span class="params">(JB_BP*<span class="number">4</span>)</span><span class="params">(%eax)</span> <span class="comment">/* Save caller&#x27;s frame pointer.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined NOT_IN_libc &amp;&amp; defined IS_IN_rtld</span></span><br><span class="line">    <span class="comment">/* In ld.so we never save the signal mask.  */</span></span><br><span class="line">    xorl %eax, %eax</span><br><span class="line">    ret</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Make a tail call to __sigjmp_save; it takes the same args.  */</span></span><br><span class="line">    jmp __sigjmp_save</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="title function_">END</span> <span class="params">(BP_SYM (__sigsetjmp))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>上面的汇编代码，主要是将寄存器EBX、ESI、EDI、ESP、PC和EBP寄存器保存到jmp_buf中。回想前面<code>__jmp_buf</code>的定义，它在x86_32位平台上是大小为6的int型数组，正好用于保存这6个寄存器。</p>
<p>看完了<code>__sigsetjmp</code>的实现，自然就轮到longjmp了：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ENTRY (__longjmp)</span><br><span class="line">    movl <span class="number">4</span>(%esp), %ecx  <span class="comment">/* User&#x27;s jmp_buf in %ecx.  */</span></span><br><span class="line">    movl <span class="number">8</span>(%esp), %eax  <span class="comment">/* Second argument is return value.  */</span></span><br><span class="line">    <span class="comment">/* Save the return address now.  */</span></span><br><span class="line">    movl (JB_PC*<span class="number">4</span>)(%ecx), %edx</span><br><span class="line">    <span class="title function_">LIBC_PROBE</span> <span class="params">(longjmp, <span class="number">3</span>, <span class="number">4</span>@%ecx, <span class="number">-4</span>@%eax, <span class="number">4</span>@%edx)</span></span><br><span class="line">    <span class="comment">/* 恢复保存的寄存器  */</span></span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_BX*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %ebx</span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_SI*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %esi</span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_DI*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %edi</span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_BP*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %ebp</span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_SP*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %esp</span><br><span class="line">    <span class="title function_">LIBC_PROBE</span> <span class="params">(longjmp_target, <span class="number">3</span>, <span class="number">4</span>@%ecx, <span class="number">-4</span>@%ecx, <span class="number">4</span>@%edx)</span></span><br><span class="line">    <span class="comment">/* Jump to saved PC.  */</span></span><br><span class="line">    jmp *%edx</span><br><span class="line"><span class="title function_">END</span> <span class="params">(__longjmp)</span></span><br></pre></td></tr></table></figure></div>

<p><code>setjmp</code>保存寄存器的内容，longjmp自然是恢复寄存器的内容。上面的代码很简单，把寄存器<code>PC、EBX、ESI、EDI、EBP</code>和ESP的内容恢复后，将第二个参数val保存到EAX中，最后跳转到恢复的PC寄存器处——也就是<code>setjmp</code>的下一条指令的位置。</p>
<h2 id="长跳转陷阱"><a href="#长跳转陷阱" class="headerlink" title="长跳转陷阱"></a>长跳转陷阱</h2><p>longjmp的man手册给出了如下说明：</p>
<p>当满足以下条件时，局部变量的值是不能确定的：</p>
<ul>
<li>它们是调用setjmp所在函数的局部变量。</li>
<li>其值在setjmp和longjmp之间有变化。</li>
<li>它们没有被声明为volatile变量。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> jmp_buf g_stack_env;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> ret = setjmp(g_stack_env);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Normal flow\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">        func1(&amp;a, &amp;b, &amp;c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Longjump flow\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c);&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter func1\n&quot;</span>);</span><br><span class="line">    ++(*a);</span><br><span class="line">    ++(*b);</span><br><span class="line">    ++(*c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1: a = %d, b = %d, c = %d\n&quot;</span>, *a, *b, *c);</span><br><span class="line">    longjmp(g_stack_env, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Leave func1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从结果上看，变量a、b、c的值均没有被恢复。这点符合我们的预期，毕竟longjmp只是恢复了6个寄存器的内容。</span></span><br><span class="line"><span class="meta"># gcc 4_7_3_longjmp_var.c -Wall</span></span><br><span class="line"># ./a.out</span><br><span class="line">Normal flow</span><br><span class="line">a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">Enter func1</span><br><span class="line">func1: a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">4</span></span><br><span class="line">Longjump flow</span><br><span class="line">a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">4</span></span><br><span class="line"><span class="comment">// 然而当我们加上编译选项-O2以后，结果就完全不同了。在longjmp跳转以后，a、b和c的值仍然是原来的值。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 -O2 优化级别下，编译器会执行大量的优化，例如：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    消除重复计算（Common Subexpression Elimination）</span></span><br><span class="line"><span class="comment">    死代码消除（Dead Code Elimination）</span></span><br><span class="line"><span class="comment">    循环优化（Loop Optimization）</span></span><br><span class="line"><span class="comment">    寄存器分配优化</span></span><br><span class="line"><span class="comment">    函数内联（Inline Functions）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[fgao@ubuntu chapter3]<span class="meta">#gcc 4_7_3_longjmp_var.c -Wall -O2</span></span><br><span class="line">[fgao@ubuntu chapter3]#./a.out</span><br><span class="line">Normal flow</span><br><span class="line">a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">Enter func1</span><br><span class="line">func1: a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">4</span></span><br><span class="line">Longjump flow</span><br><span class="line">a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<p>除了上面这个缺陷以外，如果我们的思维再开阔些，还能发现由longjmp实现原理引发的其他缺陷。比如因为它不能处理局部变量的问题，因此在C++中局部变量的析构肯定也是有问题的。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> jmp_buf g_stack_env;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">setjmp</span>(g_stack_env);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Normal flow&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Longjump flow&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="meta"># g++ 4_7_3_longjmp_destructor.cpp -Wall</span></span><br><span class="line"># ./a.out</span><br><span class="line">Normal flow</span><br><span class="line">Enter func1</span><br><span class="line">Constructor</span><br><span class="line">Longjump flow</span><br></pre></td></tr></table></figure></div>

<h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>进程是操作系统的一个核心概念。每个进程都有自己唯一的标识：进程ID，也有自己的生命周期。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_71.jpg"
                      alt="epub_831302_71"
                ></p>
<h2 id="进程-ID"><a href="#进程-ID" class="headerlink" title="进程 ID"></a>进程 ID</h2><p>Linux下每个进程都会有一个非负整数表示的唯一进程ID，简称pid。Linux提供了getpid函数来获取进程的pid，同时还提供了getppid函数来获取父进程的pid，相关接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>每个进程都有自己的父进程，父进程又会有自己的父进程，最终都会追溯到1号进程即init进程。这就决定了操作系统上所有的进程必然会组成树状结构，就像一个家族的家谱一样。可以通过pstree的命令来查看进程的家族树。</p>
<p>procfs文件系统会在&#x2F;proc下为每个进程创建一个目录，名字是该进程的pid。目录下有很多文件，用于记录进程的运行情况和统计信息等，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ll /proc总用量 <span class="number">0</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">1</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">10</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">100</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">101</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">102</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">103</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">1039</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">104</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>

<p>因为进程有创建，也有终止，所以&#x2F;proc&#x2F;下记录进程信息的目录（以及目录下的文件）也会发生变化。操作系统必须保证在任意时刻都不能出现两个进程有相同pid的情况。虽然进程ID是唯一的，但是进程ID可以重用。进程退出以后，其进程ID还可以再次分配给其他的进程使用。</p>
<p>Linux分配进程ID的算法不同于给进程分配文件描述符的最小可用算法，它采用了延迟重用的算法，即分配给新创建进程的ID尽量不与最近终止进程的ID重复，这样就可以防止将新创建的进程误判为使用相同进程ID的已经退出的进程。</p>
<p>那么如何实现延迟重用呢？内核采用的方法如下：</p>
<p>1）位图记录进程ID的分配情况（0为可用，1为已占用）。</p>
<p>2）将上次分配的进程ID记录到last_pid中，分配进程ID时，从last_pid+1开始找起，从位图中寻找可用的ID。</p>
<p>3）如果找到位图集合的最后一位仍不可用，则回滚到位图集合的起始位置，从头开始找。</p>
<p>既然是位图记录进程ID的分配情况，那么位图的大小就必须要考虑周全。位图的大小直接决定了系统允许同时存在的进程的最大个数，这个最大个数在系统中称为pid_max。上面的第3步提到，回绕到位图集合的起始位置，从头寻找可用的进程ID。事实上，严格说来，这种说法并不正确，回绕时并不是从0开始找起，而是从300开始找起。内核在kernel&#x2F;pid.c文件中定义了RESERVED_PIDS，其值是300，300以下的pid会被系统占用，而不能分配给用户进程：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define RESERVED_PIDS       <span class="number">300</span></span><br><span class="line"><span class="type">int</span> pid_max = PID_MAX_DEFAULT;</span><br></pre></td></tr></table></figure></div>

<p>Linux系统下可以通过procfs或sysctl命令来查看pid_max的值：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ <span class="built_in">cat</span> /proc/sys/kernel/pid_max</span><br><span class="line">131072</span><br><span class="line">manu@manu-rush:~$ sysctl kernel.pid_max</span><br><span class="line">kernel.pid_max = 131072</span><br><span class="line"><span class="comment"># 其实，此上限值是可以调整的，系统管理员可以通过如下方法来修改此上限值：</span></span><br><span class="line">root@manu-rush:~<span class="comment"># sysctl -w kernel.pid_max=4194304</span></span><br><span class="line">kernel.pid_max = 4194304</span><br><span class="line"><span class="comment"># 但是内核自己也设置了硬上限，如果尝试将pid_max的值设成一个大于硬上限的值就会失败。</span></span><br><span class="line">root@manu-rush:~<span class="comment"># sysctl -w kernel.pid_max=4194305</span></span><br><span class="line">error: <span class="string">&quot;Invalid argument&quot;</span> setting key <span class="string">&quot;kernel.pid_max&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>从上面的操作可以看出，Linux系统将系统进程数的硬上限设置为4194304（4M）。内核又是如何决定系统进程个数的硬上限的呢？对此，内核定义了如下的宏：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PID_MAX_LIMIT (CONFIG_BASE_SMALL ? PAGE_SIZE * 8 : \</span></span><br><span class="line"><span class="meta">    (sizeof(long) &gt; 4 ? 4 * 1024 * 1024 :PID_MAX_DEFAULT))</span></span><br></pre></td></tr></table></figure></div>

<p>从上面代码中可以看出决定系统进程个数硬上限的逻辑为：</p>
<ul>
<li>如果选择了CONFIG_BASE_SMALL编译选项，则为页面（PAGE_SIZE）的位数。</li>
<li>如果选择了CONFIG_BASE_FULL编译选项，那么：<ul>
<li>对于32位系统，系统进程个数硬上限为32768（即32K）。</li>
<li>对于64位系统，系统进程个数硬上限为4194304（即4M）。</li>
</ul>
</li>
</ul>
<p>通过上面的讨论可以看出，在64位系统中，系统容许创建的进程的个数超过了400万，这个数字是相当庞大的，足够应用层使用。对于单线程的程序，进程ID比较好理解，就是唯一标识进程的数字。对于多线程的程序，每一个线程调用getpid函数，其返回值都是一样的，即进程的ID。</p>
<h2 id="进程层次"><a href="#进程层次" class="headerlink" title="进程层次"></a>进程层次</h2><p>每个进程都有父进程，父进程也有父进程，这就形成了一个以init进程为根的家族树。除此以外，进程还有其他层次关系：进程、进程组和会话。进程组和会话在进程之间形成了两级的层次：进程组是一组相关进程的集合，会话是一组相关进程组的集合。</p>
<p>这样说来，一个进程会有如下ID：</p>
<ul>
<li>PID：进程的唯一标识。对于多线程的进程而言，所有线程调用getpid函数会返回相同的值。</li>
<li>PGID：进程组ID。每个进程都会有进程组ID，表示该进程所属的进程组。默认情况下新创建的进程会继承父进程的进程组ID。</li>
<li>SID：会话ID。每个进程也都有会话ID。默认情况下，新创建的进程会继承父进程的会话ID。</li>
</ul>
<p>可以调用如下指令来查看所有进程的层次关系：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ejH</span><br><span class="line">$ ps axjf</span><br></pre></td></tr></table></figure></div>

<p>对于进程而言，可以通过如下函数调用来获取其进程组ID和会话ID。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure></div>

<p>前面提到过，新进程默认继承父进程的进程组ID和会话ID，如果都是默认情况的话，那么追根溯源可知，所有的进程应该有共同的进程组ID和会话ID。但是调用ps axjf可以看到，实际情况并非如此，系统中存在很多不同的会话，每个会话下也有不同的进程组。</p>
<p>进程组和会话是为了支持shell作业控制而引入的概念。当有新的用户登录Linux时，登录进程会为这个用户创建一个会话。用户的登录shell就是会话的首进程。会话的首进程ID会作为整个会话的ID。会话是一个或多个进程组的集合，囊括了登录用户的所有活动。</p>
<p>在登录shell时，用户可能会使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组。当用户通过SSH客户端工具连入Linux时，与上述登录的情景是类似的。</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>修改进程组ID的接口如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这个函数的含义是，找到进程ID为pid的进程，将其进程组ID修改为pgid，</span></span><br><span class="line"><span class="comment">* 如果pid的值为0，则表示要修改调用进程的进程组ID。该接口一般用来创建一个新的进程组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 下面三个接口含义一致，都是创立新的进程组，并且指定的进程会成为进程组的首进程。</span></span><br><span class="line"><span class="comment">* 如果参数pid和pgid的值不匹配，那么setpgid函数会将一个进程从原来所属的进程组迁移到pgid对应的进程组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">setpgid(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">setpgid(getpid(),<span class="number">0</span>)</span><br><span class="line">setpgid(getpid(),getpid())</span><br></pre></td></tr></table></figure></div>

<p>setpgid函数有很多限制：</p>
<ul>
<li>pid参数必须指定为调用setpgid函数的进程或其子进程，不能随意修改不相关进程的进程组ID，如果违反这条规则，则返回-1，并置errno为ESRCH。</li>
<li>pid参数可以指定调用进程的子进程，但是子进程如果已经执行了exec函数，则不能修改子进程的进程组ID。如果违反这条规则，则返回-1，并置errno为EACCESS。</li>
<li>在进程组间移动，调用进程，pid指定的进程及目标进程组必须在同一个会话之内。如果违反这条规则，则返回-1，并置errno为EPERM。</li>
<li>pid指定的进程，不能是会话首进程。如果违反这条规则，则返回-1，并置errno为EPERM。</li>
</ul>
<p>有了创建进程组的接口，新创建的进程组就不必继承父进程的进程组ID了。最常见的创建进程组的场景就是在shell中执行管道命令，代码如下：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd1 | cmd2 | cmd3</span><br></pre></td></tr></table></figure></div>

<p>下面用一个最简单的命令来说明，其进程之间的关系如图:</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ax|grep nfsd</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_73.jpg"
                      alt="epub_831302_73"
                ></p>
<p>ps进程和grep进程都是bash创建的子进程，两者通过管道协同完成一项工作，它们隶属于同一个进程组，其中ps进程是进程组的组长。</p>
<p>引入了进程组的概念，可以更方便地管理这一组进程了。比如这项工作放弃了，不必向每个进程一一发送信号，可以直接将信号发送给进程组，进程组内的所有进程都会收到该信号。</p>
<blockquote>
<p>前文曾提到过，子进程一旦执行exec，父进程就无法调用setpgid函数来设置子进程的进程组ID了，这条规则会影响shell的作业控制。出于保险的考虑，一般父进程在调用fork创建子进程后，会调用setpgid函数设置子进程的进程组ID，同时子进程也要调用setpgid函数来设置自身的进程组ID。这两次调用有一次是多余的，但是这样做能够保证无论是父进程先执行，还是子进程先执行，子进程一定已经进入了指定的进程组中。由于fork之后，父子进程的执行顺序是不确定的，因此如果不这样做，就会造成在一定的时间窗口内，无法确定子进程是否进入了相应的进程组。</p>
</blockquote>
<p>可以通过跟踪bash进程的系统调用来证明这一点，下面的2258进程是bash，我们在该bash上执行sleep 200，在执行之前，在另一个终端用strace跟踪bash的系统调用，可以看到，父进程和子进程都执行了一遍setpgid函数，代码如下所示：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ sudo strace -f -p 2258</span><br><span class="line">Process 2258 attached</span><br><span class="line">    ．．．</span><br><span class="line">/*父进程调用setpgid函数*/</span><br><span class="line">[pid  2258] setpgid(2509, 2509 &lt;unfinished ...&gt;．．．</span><br><span class="line">/*子进程调用setpgid函数*/</span><br><span class="line">[pid  2509] setpgid(2509, 2509 &lt;unfinished ...&gt;．．．</span><br><span class="line">/*子进程执行execve*/</span><br><span class="line">[pid  2509] execve(<span class="string">&quot;/bin/sleep&quot;</span>, [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;200&quot;</span>], [/* 31 vars */]) = 0．．．</span><br></pre></td></tr></table></figure></div>

<p>用户在shell中可以同时执行多个命令。对于耗时很久的命令（如编译大型工程），用户不必傻傻等待命令运行完毕才执行下一个命令。用户在执行命令时，可以在命令的结尾添加<code>“&amp;”</code>符号，表示将命令放入后台执行。这样该命令对应的进程组即为后台进程组。在任意时刻，可能同时存在多个后台进程组，但是不管什么时候都只能有一个前台进程组。只有在前台进程组中进程才能在控制终端读取输入。当用户在终端输入信号生成终端字符（如<code>ctrl+c、ctrl+z、ctr+\</code>等）时，对应的信号只会发送给前台进程组。</p>
<p>shell中可以存在多个进程组，无论是前台进程组还是后台进程组，它们或多或少存在一定的联系，为了更好地控制这些进程组（或者称为作业），系统引入了会话的概念。会话的意义在于将很多的工作囊括在一个终端，选取其中一个作为前台来直接接收终端的输入及信号，其他的工作则放在后台执行。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话是一个或多个进程组的集合，以用户登录系统为例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_75.jpg"
                      alt="epub_831302_75"
                ></p>
<p>系统提供setsid函数来创建会话，其接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果这个函数的调用进程不是进程组组长，那么调用该函数会发生以下事情：</p>
<p>1）创建一个新会话，会话ID等于进程ID，调用进程成为会话的首进程。</p>
<p>2）创建一个进程组，进程组ID等于进程ID，调用进程成为进程组的组长。</p>
<p>3）该进程没有控制终端，如果调用setsid前，该进程有控制终端，这种联系就会断掉。</p>
<p>调用setsid函数的进程不能是进程组的组长，否则调用会失败，返回-1，并置errno为EPERM。这个限制是比较合理的。如果允许进程组组长迁移到新的会话，而进程组的其他成员仍然在老的会话中，那么，就会出现同一个进程组的进程分属不同的会话之中的情况，这就破坏了进程组和会话的严格的层次关系了。Linux提供了setsid命令，可以在新的会话中执行命令，通过该命令可以很容易地验证上面提到的三点：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ setsid <span class="built_in">sleep</span> 100</span><br><span class="line">$ ps ajxf</span><br><span class="line">PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND…</span><br><span class="line">1     4469  4469  4469 ?           -1   Ss   1000   0:00 <span class="built_in">sleep</span> 100</span><br></pre></td></tr></table></figure></div>

<p>从输出中可以看出，系统创建了新的会话4469，新的会话下又创建了新的进程组，会话ID和进程组ID都等于进程ID，而该进程已经不再拥有任何控制终端了（TTY对应的值为“？”表示进程没有控制终端）。常用的调用setsid函数的场景是login和shell。除此以外创建daemon进程也要调用setsid函数。</p>
<h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Linux系统下，进程可以调用fork函数来创建新的进程。调用进程为父进程，被创建的进程为子进程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>与普通函数不同，fork函数会返回两次。一般说来，创建两个完全相同的进程并没有太多的价值。大部分情况下，父子进程会执行不同的代码分支。fork函数的返回值就成了区分父子进程的关键。fork函数向子进程返回0，并将子进程的进程ID返给父进程。当然了，如果fork失败，该函数则返回-1，并设置errno。</p>
<p>常见的出错情景如表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_76.jpg"
                      alt="epub_831302_76"
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ret = fork();</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    …<span class="comment">//此处是子进程的代码分支</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    …<span class="comment">//此处是父进程的代码分支</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     …<span class="comment">// fork失败，执行error handle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>fork可能失败。检查返回值进行正确的出错处理，是一个非常重要的习惯。设想如果fork返回-1，而程序没有判断返回值，直接将-1当成子进程的进程号，那么后面的代码执行kill（child_pid，9）就相当于执行kill（-1，9）。这会发生什么？后果是惨重的，它将杀死除了init以外的所有进程，只要它有权限。</p>
</blockquote>
<p>从内核2.6.32开始，在默认情况下，父进程将成为fork之后优先调度的对象。采取这种策略的原因是：fork之后，父进程在CPU中处于活跃的状态，并且其内存管理信息也被置于硬件内存管理单元的转译后备缓冲器（TLB），所以先调度父进程能提升性能。从2.6.24起，Linux采用完全公平调度（Completely Fair Scheduler，CFS）。用户创建的普通进程，都采用CFS调度策略。对于CFS调度策略，procfs提供了如下控制选项：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/kernel/sched_child_runs_first</span><br></pre></td></tr></table></figure></div>

<p>该值默认是0，表示父进程优先获得调度。如果将该值改成1，那么子进程会优先获得调度。POSIX标准和Linux都没有保证会优先调度父进程。因此在应用中，决不能对父子进程的执行顺序做任何的假设。如果确实需要某一特定执行的顺序，那么需要使用进程间同步的手段。</p>
<blockquote>
<p><strong>从 Linux 内核版本 5.9 开始，<code>kernel.sched_child_runs_first</code> 参数被移除了</strong>。在移除该参数后，内核默认的行为是 <strong>父进程在 <code>fork()</code> 后优先运行</strong>，并且无法通过参数进行更改。</p>
</blockquote>
<p>fork之后的子进程完全拷贝了父进程的地址空间，包括栈、堆、代码段等。通过下面的示例代码，我们一起来查看父子进程的内存关系：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> g_int = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> local_int = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *malloc_int = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *malloc_int = <span class="number">1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        local_int = <span class="number">0</span>;</span><br><span class="line">        g_int = <span class="number">0</span>;</span><br><span class="line">        *malloc_int = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[CHILD ] child change local global malloc value to 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(malloc_int);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[CHILD ] child exit\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork failed (%s)&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[PARENT] wait child exit\n&quot;</span>);</span><br><span class="line">    waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[PARENT] child have exit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[PARENT] g_int = %d\n&quot;</span>,g_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[PARENT] local_int = %d\n&quot;</span>,local_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[PARENT] malloc_int = %d\n&quot;</span>,local_int);</span><br><span class="line">    <span class="built_in">free</span>(malloc_int);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">[PARENT] wait child <span class="built_in">exit</span></span><br><span class="line">[CHILD ] child change local global <span class="built_in">malloc</span> value to <span class="number">0</span></span><br><span class="line">[CHILD ] child <span class="built_in">exit</span></span><br><span class="line">[PARENT] child have <span class="built_in">exit</span></span><br><span class="line">[PARENT] g_int = <span class="number">1</span></span><br><span class="line">[PARENT] local_int = <span class="number">1</span></span><br><span class="line">[PARENT] malloc_int = <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p>这里刻意定义了三个变量，一个是位于数据段的全局变量，一个是位于栈上的局部变量，还有一个是通过malloc动态分配位于堆上的变量，三者的初始值都是1。然后调用fork创建子进程，子进程将三个变量的值都改成了0。按照fork的语义，子进程完全拷贝了父进程的数据段、栈和堆上的内存，如果父子进程对相应的数据进行修改，那么两个进程是并行不悖、互不影响的。因此，在上面示例代码中，尽管子进程将三个变量的值都改成了0，对父进程而言这三个值都没有变化，仍然是1，代码的输出也证实了这一点。</p>
<p>前文提到过，子进程和父进程执行一模一样的代码的情形比较少见。Linux提供了execve系统调用，构建在该系统调用之上，glibc提供了exec系列函数。这个系列函数会丢弃现存的程序代码段，并构建新的数据段、栈及堆。调用fork之后，子进程几乎总是通过调用exec系列函数，来执行新的程序。在这种背景下，fork时子进程完全拷贝父进程的数据段、栈和堆的做法是不明智的，因为接下来的exec系列函数会毫不留情地抛弃刚刚辛苦拷贝的内存。为了解决这个问题，Linux引入了写时拷贝（copy-on-write）的技术。</p>
<p>写时拷贝是指子进程的页表项指向与父进程相同的物理内存页，这样只拷贝父进程的页表项就可以了，当然要把这些页面标记成只读。如果父子进程都不修改内存的内容，大家便相安无事，共用一份物理内存页。但是一旦父子进程中有任何一方尝试修改，就会引发缺页异常（page fault）。此时，内核会尝试为该页面创建一个新的物理页面，并将内容真正地复制到新的物理页面中，让父子进程真正地各自拥有自己的物理内存页，然后将页表中相应的表项标记为可写。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_79.jpg"
                      alt="epub_831302_79"
                ></p>
<p>从上面的描述可以看出，对于没有修改的页面，内核并没有真正地复制物理内存页，仅仅是复制了父进程的页表。这种机制的引入提升了fork的性能，从而使内核可以快速地创建一个新的进程。</p>
<p>Linux的内存管理使用的是四级页表，如图4-6所示，看了四级页表的名字，也就不难推测图中那些函数的作用了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_80.jpg"
                      alt="epub_831302_80"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_81.jpg"
                      alt="epub_831302_81"
                ></p>
<p>在最后的<code>copy_one_pte</code>函数中有如下代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果是写时拷贝，那么无论是初始页表，还是拷贝的页表，都设置了写保护</span></span><br><span class="line"><span class="comment"> *后面无论父子进程，修改页表对应位置的内存时，都会触发page fault</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">if</span> (is_cow_mapping(vm_flags)) &#123;</span><br><span class="line">     ptep_set_wrprotect(src_mm, addr, src_pte);</span><br><span class="line">     pte = pte_wrprotect(pte);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>该代码将页表设置成写保护，父子进程中任意一个进程尝试修改写保护的页面时，都会引发缺页中断，内核会走向do_wp_page函数，该函数会负责创建副本，即真正的拷贝。写时拷贝技术极大地提升了fork的性能，在一定程度上让vfork成为了鸡肋。</p>
<hr>
<p>执行fork函数，内核会复制父进程所有的文件描述符。对于父进程打开的所有文件，子进程也是可以操作的。那么父子进程同时操作同一个文件是并行不悖的，还是互相影响的呢？</p>
<p>下面通过对一个例子的讨论来说明这个问题。read函数并没有将偏移量作为参数传入，但是每次调用read函数或write函数时，却能够接着上次读写的位置继续读写。原因是内核已经将偏移量的信息记录在与文件描述符相关的数据结构里了。那么问题来了，父子进程是共用一个文件偏移量还是各有各的文件偏移量呢？</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFILE <span class="string">&quot;./in.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTFILE <span class="string">&quot;./out.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE  S_IRUSR |S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd_in,fd_out;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    fd_in = open(INFILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd_in &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;failed to open %s, reason(%s)\n&quot;</span>, INFILE,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_out = open(OUTFILE,O_WRONLY|O_CREAT|O_TRUNC,MODE);</span><br><span class="line">    <span class="keyword">if</span>(fd_out &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;failed to open %s, reason(%s)\n&quot;</span>, OUTFILE,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fork();<span class="comment">/*此处忽略错误检查*/</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd_in, buf, <span class="number">2</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s&quot;</span>,getpid(),buf);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d Hello,World!\n&quot;</span>,getpid());</span><br><span class="line">        write(fd_out,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>INFILE的内容是：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure></div>

<p>上面的程序中，父子进程都会去读INFILE，如果父子进程各维护各的文件偏移量，那么父子进程都会打印出1~6。事实如何呢？请看输出内容：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./fork_file</span><br><span class="line">6610: 1</span><br><span class="line">6611: 2</span><br><span class="line">6610: 3</span><br><span class="line">6611: 4</span><br><span class="line">6610: 5</span><br><span class="line">6611: 5</span><br><span class="line">6610: 6</span><br></pre></td></tr></table></figure></div>

<p>如果父子进程各自维护自己的文件偏移量，那么一定是打印出两套1~6，但是事实并非如此。无论父进程还是子进程调用read函数导致文件偏移量后移都会被对方获知，这表明父子进程共用了一套文件偏移量。对于第二个输出，为什么父子进程都打印5呢？这是因为我的机器是多核的，父子进程同时执行，发现当前文件偏移量是4*2，然后各自去读了第8和第9字节，也就是“5\n”。写文件也是一样，如果fork之前打开了某文件，之后父子进程写入同一个文件描述符而又不采取任何同步的手段，那么就会因为共享文件偏移量而使输出相互混合，不可阅读。</p>
<p>文件描述符还有一个文件描述符标志（file descriptor flag）。目前只定义了一个标志位：FD_CLOSEXEC，这是close_on_exec标志位。细心阅读open函数手册也会发现，open函数也有一个类似的标志位，即O_CLOSEXEC，该标志位也是用于设置文件描述符标志的。那么这个标志位到底有什么作用呢？如果文件描述符中将这个标志位置位，那么调用exec时会自动关闭对应的文件。可是为什么需要这个标志位呢？主要是出于安全的考虑。对于fork之后子进程执行exec这种场景，如果子进程可以操作父进程打开的文件，就会带来严重的安全隐患。一般来讲，调用exec的子进程时，因为它会另起炉灶，因此父进程打开的文件描述符也应该一并关闭，但事实上内核并没有主动这样做。试想如下场景，Webserver首先以root权限启动，打开只有拥有root权限才能打开的端口和日志等文件，再降到普通用户，fork出一些worker进程，在进程中进行解析脚本、写日志、输出结果等操作。由于子进程完全可以操作父进程打开的文件，因此子进程中的脚本只要继续操作这些文件描述符，就能越权操作root用户才能操作的文件。</p>
<p>为了解决这个问题，Linux引入了close on exec机制。设置了FD_CLOSEXEC标志位的文件，在子进程调用exec家族函数时会将相应的文件关闭。</p>
<p>而设置该标志位的方法有两种：</p>
<ul>
<li>open时，带上O_CLOSEXEC标志位。</li>
<li>open时如果未设置，那就在后面调用fcntl函数的F_SETFD操作来设置。</li>
</ul>
<p>建议使用第一种方法。原因是第二种方法在某些时序条件下并不那么绝对的安全。</p>
<p>考虑以下的场景：Thread 1还没来得及将FD_CLOSEXEC置位，由于Thread 2已经执行过fork，这时候fork出来的子进程就不会关闭相应的文件。尽管Thread1后来调用了fcntl的F_SETFD操作，但是为时已晚，文件已经泄露了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_84.jpg"
                      alt="epub_831302_84"
                ></p>
<blockquote>
<p>多线程程序执行了fork，仅仅是为了示意，实际中并不鼓励这种做法。正相反，这种做法是十分危险的。多线程程序不应该调用fork来创建子进程。</p>
</blockquote>
<p>前面提到，执行fork时，子进程会获取父进程所有文件描述符的副本，但是测试结果表明，父子进程共享了文件的很多属性。这到底是怎么回事？让我们深入内核一探究竟。</p>
<p>在内核的进程描述符task_struct结构体中，与打开文件相关的变量如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用fork时，内核会在copy_files函数中处理拷贝父进程打开的文件的相关事宜：</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_files</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">oldf</span>, *<span class="title">newf</span>;</span></span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    oldf = current-&gt;files;</span><br><span class="line">    <span class="keyword">if</span> (!oldf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"> <span class="comment">/*创建线程和vfork，都不用复制父进程的文件描述符，增加引用计数即可*/</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_FILES) &#123;</span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;oldf-&gt;count);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*对于fork而言，需要复制父进程的文件描述符*/</span></span><br><span class="line">    newf = dup_fd(oldf, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (!newf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    tsk-&gt;files = newf;</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>CLONE_FILES标志位用来控制是否共享父进程的文件描述符。如果该标志位置位，则表示不必费劲复制一份父进程的文件描述符了，增加引用计数，直接共用一份就可以了。对于vfork函数和创建线程的pthread_create函数来说都是如此。但是fork函数却不同，调用fork函数时，该标志位为0，表示需要为子进程拷贝一份父进程的文件描述符。文件描述符的拷贝是通过内核的dup_fd函数来完成的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> files_struct *<span class="title function_">dup_fd</span><span class="params">(<span class="keyword">struct</span> files_struct *oldf, <span class="type">int</span> *errorp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">newf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> **<span class="title">old_fds</span>, **<span class="title">new_fds</span>;</span></span><br><span class="line">    <span class="type">int</span> open_files, size, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">old_fdt</span>, *<span class="title">new_fdt</span>;</span></span><br><span class="line">    *errorp = -ENOMEM;</span><br><span class="line">    newf = kmem_cache_alloc(files_cachep, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!newf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure></div>

<p><code>dup_fd</code>函数首先会给子进程分配一个<code>file_struct</code>结构体，然后做一些赋值操作。这个结构体是进程描述符中与打开文件相关的数据结构，每一个打开的文件都会记录在该结构体中。其定义代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="type">int</span> next_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">close_on_exec_init</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">open_fds_init</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line">    fd_set *close_on_exec;</span><br><span class="line">    fd_set *open_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fds_bits[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>初看之下struct fdtable的内容与struct files_struct的内容有颇多重复之处，包括close_on_exec文件描述符位图、打开文件描述符位图及file指针数组等，但事实上并非如此。struct files_struct中的成员是相应数据结构的实例，而struct fdtable中的成员是相应的指针。</p>
<p>Linux系统假设大多数的进程打开的文件不会太多。于是Linux选择了一个long类型的位数（32位系统下为32位，64位系统下为64位）作为经验值。以64位系统为例，file_struct结构体自带了可以容纳64个struct file类型指针的数组fd_array，也自带了两个大小为64的位图，其中open_fds_init位图用于记录文件的打开情况，close_on_exec_init位图用于记录文件描述符的FD_CLOSEXCE标志位是否置位。只要进程打开的文件个数小于64，file_struct结构体自带的指针数组和两个位图就足以满足需要。因此在分配了file_struct结构体后，内核会初始化file_struct自带的fdtable，代码如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_set</span>(&amp;newf-&gt;count, <span class="number">1</span>);</span><br><span class="line">spin_lock_init(&amp;newf-&gt;file_lock);</span><br><span class="line">newf-&gt;next_fd = <span class="number">0</span>;</span><br><span class="line">new_fdt = &amp;newf-&gt;fdtab;</span><br><span class="line">new_fdt-&gt;max_fds = NR_OPEN_DEFAULT;</span><br><span class="line">new_fdt-&gt;close_on_exec = (fd_set *)&amp;newf-&gt;close_on_exec_init;</span><br><span class="line">new_fdt-&gt;open_fds = (fd_set *)&amp;newf-&gt;open_fds_init;</span><br><span class="line">new_fdt-&gt;fd = &amp;newf-&gt;fd_array[<span class="number">0</span>];</span><br><span class="line">new_fdt-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></div>

<p>初始化之后，子进程的file_struct的情况如图所示。注意，此时file_struct结构体中的fdt指针并未指向file_struct自带的struct fdtable类型的fdtab变量。原因很简单，因为此时内核还没有检查父进程打开文件的个数，因此并不确定自带的结构体能否满足需要。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_87.jpg"
                      alt="epub_831302_87"
                ></p>
<p>接下来，内核会检查父进程打开文件的个数。如果父进程打开的文件超过了64个，struct files_struct中自带的数组和位图就不能满足需要了。这种情况下内核会分配一个新的struct fdtable，代妈如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> spin_lock(&amp;oldf-&gt;file_lock);</span><br><span class="line"> old_fdt = files_fdtable(oldf);</span><br><span class="line"> open_files = count_open_files(old_fdt);</span><br><span class="line"><span class="comment">/*如果父进程打开文件的个数超过NR_OPEN_DEFAULT*/</span></span><br><span class="line"> <span class="keyword">while</span> (unlikely(open_files &gt; new_fdt-&gt;max_fds)) &#123;</span><br><span class="line">     spin_unlock(&amp;oldf-&gt;file_lock);  <span class="comment">/* 如果不是自带的fdtable而是曾经分配的fdtable，则需要先释放*/</span></span><br><span class="line">     <span class="keyword">if</span> (new_fdt != &amp;newf-&gt;fdtab)</span><br><span class="line">     __free_fdtable(new_fdt);</span><br><span class="line">    <span class="comment">/*创建新的fdtable*/</span></span><br><span class="line">     new_fdt = alloc_fdtable(open_files - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (!new_fdt) &#123;</span><br><span class="line">     *errorp = -ENOMEM;</span><br><span class="line">     <span class="keyword">goto</span> out_release;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*如果超出了系统限制，则返回EMFILE*/</span></span><br><span class="line">     <span class="keyword">if</span> (unlikely(new_fdt-&gt;max_fds &lt; open_files)) &#123;</span><br><span class="line">     __free_fdtable(new_fdt);</span><br><span class="line">     *errorp = -EMFILE;</span><br><span class="line">     <span class="keyword">goto</span> out_release;</span><br><span class="line">     &#125;</span><br><span class="line">     spin_lock(&amp;oldf-&gt;file_lock);</span><br><span class="line">     old_fdt = files_fdtable(oldf);</span><br><span class="line">     open_files = count_open_files(old_fdt);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>alloc_fdtable所做的事情，不过是分配fdtable结构体本身，以及分配一个指针数组和两个位图。分配之前会根据父进程打开文件的数目，计算出一个合理的值nr，以确保分配的数组和位图能够满足需要。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_88.jpg"
                      alt="epub_831302_88"
                ></p>
<p>无论是使用file_struct结构体自带的fdtable，还是使用alloc_fdtable分配的fdtable，接下来要做的事情都一样，即将父进程的两个位图信息和打开文件的struct file类型指针拷贝到子进程的对应数据结构中，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    old_fds = old_fdt-&gt;fd;  <span class="comment">/*父进程的struct file 指针数组*/</span></span><br><span class="line">    new_fds = new_fdt-&gt;fd;  <span class="comment">/*子进程的struct file 指针数组*/</span></span><br><span class="line">    <span class="comment">/* 拷贝打开文件位图 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_fdt-&gt;open_fds-&gt;fds_bits,old_fdt-&gt;open_fds-&gt;fds_bits, open_files/<span class="number">8</span>);</span><br><span class="line">    <span class="comment">/* 拷贝 close_on_exec位图 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_fdt-&gt;close_on_exec-&gt;fds_bits,old_fdt-&gt;close_on_exec-&gt;fds_bits, open_files/<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = open_files; i != <span class="number">0</span>; i--) </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> *old_fds++;</span><br><span class="line">        <span class="keyword">if</span> (f) &#123;        </span><br><span class="line">            get_file(f); <span class="comment">/* f对应的文件的引用计数加1 */</span>    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">            FD_CLR(open_files - i, new_fdt-&gt;open_fds);    </span><br><span class="line">        &#125;<span class="comment">/* 子进程的struct file类型指针，*指向和父进程相同的struct file 结构体*/</span>    </span><br><span class="line">        rcu_assign_pointer(*new_fds++, f);   </span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;oldf-&gt;file_lock);<span class="comment">/* compute the remainder to be cleared */</span></span><br><span class="line">    size = (new_fdt-&gt;max_fds - open_files) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="comment">/*将尚未分配到的struct file结构的指针清零*/</span></span><br><span class="line">    <span class="built_in">memset</span>(new_fds, <span class="number">0</span>, size);<span class="comment">/*将尚未分配到的位图区域清零*/</span></span><br><span class="line">    <span class="keyword">if</span> (new_fdt-&gt;max_fds &gt; open_files) &#123;    </span><br><span class="line">        <span class="type">int</span> left = (new_fdt-&gt;max_fds-open_files)/<span class="number">8</span>;    </span><br><span class="line">        <span class="type">int</span> start = open_files / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>));    </span><br><span class="line">        <span class="built_in">memset</span>(&amp;new_fdt-&gt;open_fds-&gt;fds_bits[start], <span class="number">0</span>, left);    </span><br><span class="line">        <span class="built_in">memset</span>(&amp;new_fdt-&gt;close_on_exec-&gt;fds_bits[start], <span class="number">0</span>, left);</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_assign_pointer(newf-&gt;fdt, new_fdt);</span><br><span class="line">    <span class="keyword">return</span> newf;</span><br><span class="line">out_release:</span><br><span class="line">    kmem_cache_free(files_cachep, newf);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>procfs的&#x2F;proc&#x2F;PID&#x2F;status中的FDSize，记录了当前fdtable的大小：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/1/status </span><br><span class="line">FDSize: 128</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>当然了，FDSize记录的是目前fdtable能容纳的struct file指针，而不是已经打开的文件个数，已经打开的文件记录在&#x2F;proc&#x2F;PID&#x2F;fd中。通过对上述流程的梳理，不难看出，父子进程之间拷贝的是struct file的指针，而不是struct file的实例，父子进程的struct file类型指针，都指向同一个struct file实例。fork之后，父子进程的文件描述符关系如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_90.jpg"
                      alt="epub_831302_90"
                ></p>
<p>下面来看看struct file成员变量：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    f_flags</span><br><span class="line">    <span class="type">fmode_t</span>         f_mode</span><br><span class="line">    <span class="type">loff_t</span>          f_pos;<span class="comment">/*文件位置指针的当前值，即文件偏移量*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看到此处，就不难理解父子进程是如何共享文件偏移量的了，那是因为父子进程的指针都指向了同一个struct file结构体。</p>
<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h2><p>在早期的实现中，fork没有实现写时拷贝机制，而是直接对父进程的数据段、堆和栈进行完全拷贝，效率十分低下。很多程序在fork一个子进程后，会紧接着执行exec家族函数，这更是一种浪费。所以BSD引入了vfork。既然fork之后会执行exec函数，拷贝父进程的内存数据就变成了一种无意义的行为，所以引入的vfork压根就不会拷贝父进程的内存数据，而是直接共享。再后来Linux引入了写时拷贝的机制，其效率提高了很多，这样一来，vfork其实就可以退出历史舞台了。除了一些需要将性能优化到极致的场景，大部分情况下不需要再使用vfork函数了。</p>
<p>vfork会创建一个子进程，该子进程会共享父进程的内存数据，而且系统将保证子进程先于父进程获得调度。子进程也会共享父进程的地址空间，而父进程将被一直挂起，直到子进程退出或执行exec。注意，vfork之后，子进程如果返回，则不要调用return，而应该使用<code>_exit</code>函数。如果使用return，就会出现诡异的错误。请看下面的示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> glob = <span class="number">88</span> ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = vfork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vfork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* 子进程 */</span></span><br><span class="line">        var++;</span><br><span class="line">        glob++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d, glob=%d, var=%d\n&quot;</span>,getpid(), glob, var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用子进程，如果使用return返回，就意味着main函数返回了，因为栈是父子进程共享的，所以程序的函数栈发生了变化。main函数return之后，通常会调用exit系的函数，父进程收到子进程的exit之后，就会开始从vfork返回，但是这时整个main函数的栈都已经不复存在了，所以父进程压根无法执行。于是会返回一个诡异的栈地址，对于在某些内核版本中，进程会直接报栈错误然后退出，但是在某些内核版本中，有可能就会再次进出main，于是进入一个无限循环，直到vfork返回错误。笔者的Ubuntu版本就是后者。一般来说，vfork创建的子进程会执行exec，执行完exec后应该调用<code>_exit</code>返回。注意是<code>_exit</code>而不是exit。因为exit会导致父进程stdio缓冲区的冲刷和关闭。我们会在后面讲述exit和<code>_exit</code>的区别。</p>
<blockquote>
<p>高版本内核修复了这个问题。</p>
</blockquote>
<h1 id="Daemon进程的创建"><a href="#Daemon进程的创建" class="headerlink" title="Daemon进程的创建"></a>Daemon进程的创建</h1><p>daemon进程又被称为守护进程，一般来说它有以下两个特点：</p>
<ul>
<li>生命周期很长，一旦启动，正常情况下不会终止，一直运行到系统退出。但凡事无绝对：daemon进程其实也是可以停止的，如很多daemon提供了stop命令，执行stop命令就可以终止daemon，或者通过发送信号将其杀死，又或者因为daemon进程代码存在bug而异常退出。这些退出一般都是由手工操作或因异常引发的。</li>
<li>在后台执行，并且不与任何控制终端相关联。即使daemon进程是从终端命令行启动的，终端相关的信号如SIGINT、SIGQUIT和SIGTSTP，以及关闭终端，都不会影响到daemon进程的继续执行。</li>
</ul>
<p>习惯上daemon进程的名字通常以d结尾，如sshd、rsyslogd等。但这仅仅是习惯，并非一定要如此。如何使一个进程变成daemon进程，或者说编写daemon进程，需要遵循哪些规则或步骤呢？一般来讲，创建一个daemon进程的步骤被概括地称为double-fork magic。细细说来，需要以下步骤：</p>
<p>（1）<strong>执行fork（）函数，父进程退出，子进程继续执行这一步。</strong></p>
<p>原因有二：</p>
<ul>
<li>父进程有可能是进程组的组长（在命令行启动的情况下），从而不能够执行后面要执行的setsid函数，子进程继承了父进程的进程组ID，并且拥有自己的进程ID，一定不会是进程组的组长，所以子进程一定可以执行后面要执行的setsid函数。</li>
<li>如果daemon是从终端命令行启动的，那么父进程退出会被shell检测到，shell会显示shell提示符，让子进程在后台执行。</li>
</ul>
<p>（2）<strong>子进程执行如下三个步骤，以摆脱与环境的关系。</strong></p>
<ul>
<li><p><strong>修改进程的当前目录为根目录（&#x2F;）</strong>。这样做是有原因的，因为daemon一直在运行，如果当前工作路径上包含有根文件系统以外的其他文件系统，那么这些文件系统将无法卸载。因此，常规是将当前工作目录切换成根目录，当然也可以是其他目录，只要确保该目录所在的文件系统不会被卸载即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>调用setsid函数。这个函数的目的是切断与控制终端的所有关系，并且创建一个新的会话。</strong>这一步比较关键，因为这一步确保了子进程不再归属于控制终端所关联的会话。因此无论终端是否发送SIGINT、SIGQUIT或SIGTSTP信号，也无论终端是否断开，都与要创建的daemon进程无关，不会影响到daemon进程的继续执行。</p>
</li>
<li><p><strong>设置文件模式创建掩码为0。</strong>这一步的目的是让daemon进程创建文件的权限属性与shell脱离关系。因为默认情况下，进程的umask来源于父进程shell的umask。如果不执行umask（0），那么父进程shell的umask就会影响到daemon进程的umask。如果用户改变了shell的umask，那么也就相当于改变了daemon的umask，就会造成daemon进程每次执行的umask信息可能会不一致。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>（3）<strong>再次执行fork，父进程退出，子进程继续。</strong></p>
<p>执行完前面两步之后，可以说已经比较圆满了：新建会话，进程是会话的首进程，也是进程组的首进程。进程ID、进程组ID和会话ID，三者的值相同，进程和终端无关联。那么这里为何还要再执行一次fork函数呢？原因是，daemon进程有可能会打开一个终端设备，即daemon进程可能会根据需要，执行类似如下的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/console&quot;</span>, O_RDWR);</span><br></pre></td></tr></table></figure></div>

<p>这个打开的终端设备是否会成为daemon进程的控制终端，取决于两点：</p>
<ul>
<li>daemon进程是不是会话的首进程。</li>
<li>系统实现。（BSD风格的实现不会成为daemon进程的控制终端，但是POSIX标准说这由具体实现来决定）。</li>
</ul>
<p>既然如此，为了确保万无一失，只有确保daemon进程不是会话的首进程，才能保证打开的终端设备不会自动成为控制终端。因此，不得不执行第二次fork，fork之后，父进程退出，子进程继续。这时，子进程不再是会话的首进程，也不是进程组的首进程了。</p>
<p>（4）<strong>关闭标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。</strong></p>
<p>因为文件描述符0、1和2指向的就是控制终端。daemon进程已经不再与任意控制终端相关联，因此这三者都没有意义。一般来讲，关闭了之后，会打开&#x2F;dev&#x2F;null，并执行dup2函数，将0、1和2重定向到&#x2F;dev&#x2F;null。这个重定向是有意义的，防止了后面的程序在文件描述符0、1和2上执行I&#x2F;O库函数而导致报错。</p>
<p>至此，即完成了daemon进程的创建，进程可以开始自己真正的工作了。</p>
<p>上述步骤比较繁琐，对于C语言而言，glibc提供了daemon函数，从而帮我们将程序转化成daemon进程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  @nochdir: 用来控制是否将当前工作目录切换到根目录。</span></span><br><span class="line"><span class="comment">*           0：将当前工作目录切换到/。</span></span><br><span class="line"><span class="comment">*           1：保持当前工作目录不变。</span></span><br><span class="line"><span class="comment">*  @noclose: 用来控制是否将标准输入、标准输出和标准错误重定向到/dev/null。</span></span><br><span class="line"><span class="comment">*           0：将标准输入、标准输出和标准错误重定向到/dev/null。</span></span><br><span class="line"><span class="comment">*           1：保持标准输入、标准输出和标准错误不变。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon</span><span class="params">(<span class="type">int</span> nochdir, <span class="type">int</span> noclose)</span>;</span><br><span class="line"><span class="comment">// 一般情况下，这两个入参都要为0。</span></span><br><span class="line">ret = daemon(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 成功时，daemon函数返回0；失败时，返回-1，并置errno。</span></span><br><span class="line"><span class="comment">* 因为daemon函数内部会调用fork函数和setsid函数，所以出错时errno可以查看fork函数和setsid函数的出错情形。</span></span><br><span class="line"><span class="comment">* glibc的daemon函数做的事情，和前面讨论的大体一致，但是做得并不彻底，没有执行第二次的fork。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (daemon(<span class="number">0</span>, <span class="number">0</span>)) &#123;<span class="comment">//调用glibc库函数daemon,创建daemon守护进程</span></span><br><span class="line">        perror(<span class="string">&quot;daemon&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon</span><span class="params">( <span class="type">int</span> nochdir, <span class="type">int</span> noclose )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">if</span> ( !nochdir &amp;&amp; chdir(<span class="string">&quot;/&quot;</span>) != <span class="number">0</span> )   <span class="comment">//如果nochdir=0,那么改变到&quot;/&quot;根目录</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> ( !noclose )                      <span class="comment">//如果没有noclose=0，那么开始输入,输出以及错误输出重定向到/dev/null </span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);<span class="comment">//打开神奇的黑洞文件.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//每个进程都拥有自己fds文件描述符表，</span></span><br><span class="line"><span class="comment">//fdt-&gt;fd[0],fdt-&gt;fd[1],fdt-&gt;fd[2],</span></span><br><span class="line"><span class="comment">//表中fd[0],fd[1],和fd[2]文件句柄位置对应的fops文件操作函数集,分别与标准输入,标准输出,标准错误输出相关联</span></span><br><span class="line"><span class="comment">//所以用户应用程序调用open函数打开文件时,默认都是以3索引为开始句柄,也就是fd[3]，故当前open返回的文件句柄最小值为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dup2(unsigned int oldfd, unsigned int newfd)系统调用就是用oldfd的fops操作文件集file,复制到newfd所在处</span></span><br><span class="line"><span class="comment">//即：fdt-&gt;fd[newfd] = fdt-&gt;fd[oldfd];</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ( dup2( fd, <span class="number">0</span> ) &lt; <span class="number">0</span> || <span class="comment">//使用字符设备/dev/null的fops函数操作集,替换0句柄对应的文件操作集.</span></span><br><span class="line">     dup2( fd, <span class="number">1</span> ) &lt; <span class="number">0</span> ||      <span class="comment">//使用字符设备/dev/null的fops函数操作集,替换1句柄对应的文件操作集.</span></span><br><span class="line">          dup2( fd, <span class="number">2</span> ) &lt; <span class="number">0</span> )  <span class="comment">//使用字符设备/dev/null的fops函数操作集,替换2句柄对应的文件操作集.</span></span><br><span class="line">     &#123;</span><br><span class="line">       close(fd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果替换成功,那么键盘的任何操作将不会对该进程产生任何影响,因为0,1,2句柄所在处的fops文件操作集已经都变成了,</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//被重定向为&quot;/dev/null&quot;空洞设备的fops.所以对0,1,2句柄的读写操作,也就是在对/dev/null设备作读写操作.</span></span><br><span class="line">     close(fd); <span class="comment">//关闭打开的/dev/null</span></span><br><span class="line">  &#125;</span><br><span class="line">   pid = fork();<span class="comment">//创建子进程.</span></span><br><span class="line">   <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);  <span class="comment">//返回执行的是父进程,那么父进程退出,让子进程变成真正的孤儿进程.</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//ok,我们期望的daemon子进程执行到这里了.</span></span><br><span class="line">   <span class="keyword">if</span> ( setsid() &lt; <span class="number">0</span> ) <span class="comment">//设置session id.</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//成功创建daemon子进程[luther.gliethttp].</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h1><p>在不考虑线程的情况下，进程的退出有以下5种方式。</p>
<p>正常退出有3种：</p>
<ul>
<li>从main函数return返回</li>
<li>调用<code>exit</code></li>
<li>调用<code>_exit</code></li>
</ul>
<p>异常退出有两种：</p>
<ul>
<li>调用abort</li>
<li>接收到信号，由信号终止</li>
</ul>
<h2 id="exit"><a href="#exit" class="headerlink" title="_exit"></a><code>_exit</code></h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure></div>

<p><code>_exit</code> 函数中status参数定义了进程的终止状态，父进程可以通过<code>wait（）</code>来获取该状态值。需要注意的是返回值，虽然status是int型，但是仅有低8位可以被父进程所用。所以写<code>_exit（-1）</code>结束进程时，在终端执行<code>“$？”</code>会发现返回值是255。如果是shell相关的编程，shell可能需要获取进程的退出值，那么退出值最好不要大于128。如果退出值大于128，会给shell带来困扰。POSIX标准规定了退出状态及其含义如表4-2所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_93.jpg"
                      alt="epub_831302_93"
                ></p>
<p>下面的命令被SIGINT信号（signo&#x3D;2）中断，返回了130。如程序通过exit返回130，与其配合工作的shell就可能会误判为收到信号而退出。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sleep</span> 10000</span><br><span class="line">^C</span><br><span class="line">$ $?</span><br><span class="line">130：未找到命令</span><br></pre></td></tr></table></figure></div>

<p>用户调用<code>_exit</code>函数，本质上是调用<code>exit_group</code>系统调用。这点在前面已经详细介绍过，在此就不再赘述了。</p>
<h2 id="exit-1"><a href="#exit-1" class="headerlink" title="exit"></a>exit</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure></div>

<p>exit（）函数的最后也会调用<code>_exit（）</code>函数，但是exit在调用<code>_exit</code>之前，还做了其他工作：</p>
<p>1）执行用户通过调用<code>atexit</code>函数或<code>on_exit</code>定义的清理函数。</p>
<p>2）关闭所有打开的流（stream），所有缓冲的数据均被写入（flush），通过tmpfile创建的临时文件都会被删除。</p>
<p>3）调用_exit。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_95.jpg"
                      alt="epub_831302_95"
                ></p>
<p>下面介绍<code>exit</code>函数和<code>_exit</code>函数的不同之处。</p>
<p>首先是<code>exit</code>函数会执行用户注册的清理函数。用户可以通过调用<code>atexit（）</code>函数或<code>on_exit（）</code>函数来定义清理函数。这些清理函数在调用<code>return</code>或调用<code>exit</code>时会被执行。执行顺序与函数注册的顺序相反。当进程收到致命信号而退出时，注册的清理函数不会被执行；当进程调用<code>_exit</code>退出时，注册的清理函数不会被执行；当执行到某个清理函数时，若收到致命信号或清理函数调用了<code>_exit（）</code>函数，那么该清理函数不会返回，从而导致排在后面的需要执行的清理函数都会被丢弃。</p>
<p>其次是exit函数会冲刷（flush）标准I&#x2F;O库的缓冲并关闭流。glibc提供的很多与I&#x2F;O相关的函数都提供了缓冲区，用于缓存大块数据。缓冲有三种方式：<code>无缓冲（_IONBF）、行缓冲（_IOLBF）和全缓冲（_IOFBF）</code>。</p>
<ul>
<li>无缓冲：就是没有缓冲区，每次调用stdio库函数都会立刻调用<code>read/write</code>系统调用。</li>
<li>行缓冲：对于输出流，收到换行符之前，一律缓冲数据，除非缓冲区满了。对于输入流，每次读取一行数据。</li>
<li>全缓冲：就是缓冲区满之前，不会调用<code>read/write</code>系统调用来进行读写操作。</li>
</ul>
<p>对于后两种缓冲，可能会出现这种情况：进程退出时，缓冲区里面可能还有未冲刷的数据。如果不冲刷缓冲区，缓冲区的数据就会丢失。比如行缓冲迟迟没有等到换行符，又或者全缓冲没有等到缓冲区满。尤其是后者，很容易出现，因为glibc的缓冲区默认是8192字节。exit函数在关闭流之前，会冲刷缓冲区的数据，确保缓冲区里的数据不会丢失。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;foo says bye.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;bar says bye.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    atexit(foo);</span><br><span class="line">    atexit(bar);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;Oops ... forgot a newline!&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;_exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意上面的示例代码，fprintf打印的字符串是没有换行符的，对于标准输出流stdout，采用的是行缓冲，收到换行符之前是不会有输出的。输出情况如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$ ./test <span class="built_in">exit</span></span><br><span class="line">bar says bye.</span><br><span class="line">foo says bye.</span><br><span class="line">Oops ... forgot a newline!manu@manu-hacks:<span class="built_in">exit</span>$</span><br><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$</span><br><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$ ./test</span><br><span class="line">bar says bye.</span><br><span class="line">foo says bye.</span><br><span class="line">Oops ... forgot a newline!manu@manu-hacks:<span class="built_in">exit</span>$</span><br><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$</span><br><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$ ./test _exit</span><br><span class="line">manu@manu-hacks:~/code/self/c/<span class="built_in">exit</span>$</span><br></pre></td></tr></table></figure></div>

<p>尽管缓冲区里的数据没有等到换行符，但是无论是调用return返回还是调用exit返回，缓冲区里的数据都会被冲刷，<code>“Oops...forgot a newline！”</code>都会被输出。因为<code>exit（）</code>函数会负责此事。从测试代码的输出也可以看出，<code>exit（）</code>函数首先执行的是用户注册的清理函数，然后才执行了缓冲区的冲刷。第三，存在临时文件，exit函数会负责将临时文件删除，这点在第3章中已经介绍过，此处就不再赘述了。<code>exit</code>函数的最后调用了<code>_exit（）</code>函数，最终殊途同归，走向内核清理。</p>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>return是一种更常见的终止进程的方法。执行return（n）等同于执行exit（n），因为调用main（）的运行时函数会将main的返回值当作exit的参数。</p>
<h1 id="等待子进程"><a href="#等待子进程" class="headerlink" title="等待子进程"></a>等待子进程</h1><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>进程就像一个生命体，通过<code>fork（）</code>函数，子进程呱呱坠地。有的子进程子承父业，继续执行与父进程一样的程序（相同的代码段，尽管可能是不同的程序分支），有的子进程则比较叛逆，通过exec离家出走，走向与父进程完全不同的道路。</p>
<p>令人悲伤的是，如同所有的生命体一样，进程也会消亡。进程退出时会进行内核清理，基本就是释放进程所有的资源，这些资源包括内存资源、文件资源、信号量资源、共享内存资源，或者引用计数减一，或者彻底释放。不过，进程的退出其实并没有将所有的资源完全释放，仍保留了少量的资源，比如进程的PID依然被占用着，不可被系统分配。此时的进程不可运行，事实上也没有地址空间让其运行，进程进入僵尸状态。</p>
<p>为什么进程退出之后不将所有的资源释放，从此灰飞烟灭，一了百了，反而非要保留少量资源，进入僵尸状态呢？看看僵尸进程依然占有的系统资源，我们就能获得答案。僵尸进程依然保留的资源有进程控制块task_struct、内核栈等。这些资源不释放是为了提供一些重要的信息，比如进程为何退出，是收到信号退出还是正常退出，进程退出码是多少，进程一共消耗了多少系统CPU时间，多少用户CPU时间，收到了多少信号，发生了多少次上下文切换，最大内存驻留集是多少，产生多少缺页中断？等等。这些信息，就像墓志铭，总结了进程的一生。如果没有这个僵尸状态，进程的这些信息也会随之流逝，系统也将再也没有机会获知该进程的相关信息了。因此进程退出后，会保留少量的资源，等待父进程前来收集这些信息。一旦父进程收集了这些信息之后（通过调用下面提到的wait&#x2F;waitpid等函数），这些残存的资源完成了它的使命，就可以释放了，进程就脱离僵尸状态，彻底消失了。</p>
<p>从上面的讨论可以看出，制造一个僵尸进程是一件很容易的事情，只要父进程调用fork创建子进程，子进程退出后，父进程如果不调用wait或waitpid来获取子进程的退出信息，子进程就会沦为僵尸进程。示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果出错 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error occurred!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        sleep(<span class="number">300</span>);  <span class="comment">/* 休眠300秒 */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">/* 获取僵尸进程的退出信息 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的例子中父进程休眠300秒后才会调用wait来获取子进程的退出信息。而子进程退出之后会变成僵尸状态，苦苦等待父进程来获取退出信息。在这300秒左右的时间里，子进程就是一个僵尸进程。</p>
<p>如何查看一个进程是否处于僵尸状态呢？ps命令输出的进程状态Z，就表示进程处于僵尸状态，另外procfs提供的status信息中的State给出的值是Z（zombie），也表明进程处于僵尸状态。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ps ax</span><br><span class="line">......</span><br><span class="line"><span class="number">3940</span> pts/<span class="number">10</span>   S      <span class="number">0</span>:<span class="number">00</span> ./zombie</span><br><span class="line"><span class="number">3941</span> pts/<span class="number">10</span>   Z      <span class="number">0</span>:<span class="number">00</span> [zombie] &lt;defunct&gt;</span><br><span class="line">cat /proc/<span class="number">3941</span>/status</span><br><span class="line">Name:    zombie</span><br><span class="line">State:    Z (zombie)</span><br><span class="line">Tgid:    <span class="number">3941</span></span><br><span class="line">Ngid:    <span class="number">0</span></span><br><span class="line">Pid:    <span class="number">3941</span></span><br><span class="line">PPid:    <span class="number">3940</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure></div>

<p>进程一旦进入僵尸状态，就进入了一种刀枪不入的状态，“杀人不眨眼”的kill-9也无能为力，因为谁也没有办法杀死一个已经死去的进程。</p>
<p>清除僵尸进程有以下两种方法：</p>
<ul>
<li>父进程调用wait函数，为子进程“收尸”。</li>
<li>父进程退出，init进程会为子进程“收尸”。</li>
</ul>
<p>一般而言，系统不希望大量进程长期处于僵尸状态，因为会浪费系统资源。除了少量的内存资源外，比较重要的是进程ID。僵尸进程并没有将自己的进程ID归还给系统，而是依然占有这个进程ID，因此系统不能将该ID分配给其他进程。</p>
<p>对于编程来说，如何防范僵尸进程的产生呢？答案是具体情况具体分析。如果我们不关心子进程的退出状态，就应该将父进程对SIGCHLD的处理函数设置为SIG_IGN，或者在调用sigaction函数时设置SA_NOCLDWAIT标志位。这两者都会明确告诉子进程，父进程很“绝情”，不会为子进程“收尸”。子进程退出的时候，内核会检查父进程的SIGCHLD信号处理结构体是否设置了SA_NOCLDWAIT标志位，或者是否将信号处理函数显式地设为SIG_IGN。如果是，则autoreap为true，子进程发现autoreap为true也就“死心”了，不会进入僵尸状态，而是调用release_task函数“自行了断”了。如果父进程关心子进程的退出信息，则应该在流程上妥善设计，能够及时地调用wait，使子进程处于僵尸状态的时间不会太久。对于创建了很多子进程的应用来说，知道子进程的返回值是有意义的。比如说父进程维护一个进程池，通过进程池里的子进程来提供服务。当子进程退出的时候，父进程需要了解子进程的返回值来确定子进程的“死因”，从而采取更有针对性的措施。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;sys/wait.h&gt;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure></div>

<p>成功时，返回已退出子进程的进程ID；失败时，则返回-1并设置errno，常见的errno及说明见表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_99.jpg"
                      alt="epub_831302_99"
                ></p>
<p>注意父子进程是两个进程，子进程退出和父进程调用wait（）函数来获取子进程的退出状态在时间上是独立的事件，因此会出现以下两种情况：</p>
<ul>
<li><p>子进程先退出，父进程后调用wait（）函数。</p>
<p>对于这种情况，子进程几乎已经销毁了自己所有的资源，只留下少量的信息，苦苦等待父进程来“收尸”。当父进程调用wait（）函数的时候，苦守寒窑十八载的子进程终于等到了父进程来“收尸”，这种情况下，父进程获取到子进程的状态信息，wait函数立刻返回。</p>
</li>
<li><p>父进程先调用wait（）函数，子进程后退出。</p>
<p>对于第二种情况，父进程先调用wait（）函数，调用时并无子进程退出，该函数调用就会陷入阻塞状态，直到某个子进程退出。</p>
</li>
</ul>
<p>wait（）函数等待的是任意一个子进程，任何一个子进程退出，都可以让其返回。当多个子进程都处于僵尸状态，wait（）函数获取到其中一个子进程的信息后立刻返回。由于wait（）函数不会接受pid_t类型的入参，所以它无法明确地等待特定的子进程。</p>
<p>一个进程如何等待所有的子进程退出呢？wait（）函数返回有三种可能性：</p>
<ul>
<li>等到了子进程退出，获取其退出信息，返回子进程的进程ID。</li>
<li>等待过程中，收到了信号，信号打断了系统调用，并且注册信号处理函数时并没有设置SA_RESTART标志位，系统调用不会被重启，wait（）函数返回-1，并且将errno设置为EINTR。</li>
<li>已经成功地等待了所有子进程，没有子进程的退出信息需要接收，在这种情况下，wait（）函数返回-1，errno为ECHILD。</li>
</ul>
<blockquote>
<p>《Linux&#x2F;Unix系统编程手册》给出下面的代码来等待所有子进程的退出：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((childPid = wait(<span class="literal">NULL</span>)) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(errno !=ECHILD)</span><br><span class="line">    errExit(<span class="string">&quot;wait&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这种方法并不完全，因为这里忽略了wait（）函数被信号中断这种情况，如果wait（）函数被信号中断，上面的代码并不能成功地等待所有子进程退出。若将上面的wait（）函数封装一下，使其在信号中断后，自动重启wait就完备了。代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">r_wait</span><span class="params">(<span class="type">int</span> *stat_loc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">while</span>(((retval = wait(stat_loc)) == <span class="number">-1</span> &amp;&amp; (errno == EINTR));</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>((childPid = r_wait(<span class="literal">NULL</span>)) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">If(errno != ECHILD)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*some error happened*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>如果父进程调用wait（）函数时，已经有多个子进程退出且都处于僵尸状态，那么哪一个子进程会被先处理是不一定的（标准并未规定处理的顺序）。</p>
<p>通过上面的讨论，可以看出wait（）函数存在一定的局限性：</p>
<ul>
<li>不能等待特定的子进程。如果进程存在多个子进程，而它只想获取某个子进程的退出状态，并不关心其他子进程的退出状态，此时wait（）只能一一等待，通过查看返回值来判断是否为关心的子进程。</li>
<li>如果不存在子进程退出，wait（）只能阻塞。有些时候，仅仅是想尝试获取退出子进程的退出状态，如果不存在子进程退出就立刻返回，不需要阻塞等待，类似于trywait的概念。wait（）函数没有提供trywait的接口。</li>
<li>wait（）函数只能发现子进程的终止事件，如果子进程因某信号而停止，或者停止的子进程收到SIGCONT信号又恢复执行，这些事件wait（）函数是无法获知的。换言之，wait（）能够探知子进程的死亡，却不能探知子进程的昏迷（暂停），也无法探知子进程从昏迷中苏醒（恢复执行）。由于上述三个缺点的存在，所以Linux又引入了waitpid（）函数。</li>
</ul>
<h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure></div>

<p>先说说waitpid（）与wait（）函数相同的地方：</p>
<ul>
<li>返回值的含义相同，都是终止子进程或因信号停止或因信号恢复而执行的子进程的进程ID。</li>
<li>status的含义相同，都是用来记录子进程的相关事件，后面一节将会详细介绍。</li>
</ul>
<p>接下来介绍waitpid（）函数特有的功能。其第一个参数是pid_t类型，有了此值，不难看出waitpid函数肯定具备了精确打击的能力。waitpid函数可以明确指定要等待哪一个子进程的退出（以及停止和恢复执行）。事实上，扩展的功能不仅仅如此：</p>
<ul>
<li>pid＞0：表示等待进程ID为pid的子进程，也就是上文提到的精确打击的对象。</li>
<li>pid＝0：表示等待与调用进程同一个进程组的任意子进程；因为子进程可以设置自己的进程组，所以某些子进程不一定和父进程归属于同一个进程组，这样的子进程，waitpid函数就毫不关心了。</li>
<li>pid＝-1：表示等待任意子进程，同wait类似。waitpid（-1，&amp;status，0）与wait（&amp;status）完全等价。</li>
<li>pid＜-1：等待所有子进程中，进程组ID与pid绝对值相等的所有子进程。</li>
</ul>
<p>内核之中，wait函数和waitpid函数调用的都是wait4系统调用。下面是wait4系统调用的实现。函数的中间部分，根据pid的正负或是否为0和-1来定义<code>wait_opts</code>类型的变量wo，后面会根据wo来控制到底关心哪些进程的事件。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(wait4, <span class="type">pid_t</span>, upid, <span class="type">int</span> __user *, stat_addr, <span class="type">int</span> options, <span class="keyword">struct</span> rusage __user *, ru)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wait_opts</span> <span class="title">wo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pid_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; ~(WNOHANG|WUNTRACED|WCONTINUED|</span><br><span class="line">            __WNOTHREAD|__WCLONE|__WALL))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (upid == <span class="number">-1</span>)</span><br><span class="line">        type = PIDTYPE_MAX;   <span class="comment">/*任意子进程*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (upid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        type = PIDTYPE_PGID;</span><br><span class="line">        pid = find_get_pid(-upid);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (upid == <span class="number">0</span>) &#123;</span><br><span class="line">        type = PIDTYPE_PGID;</span><br><span class="line">        pid = get_task_pid(current, PIDTYPE_PGID);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">/* upid &gt; 0 */</span> &#123;</span><br><span class="line">        type = PIDTYPE_PID;</span><br><span class="line">        pid = find_get_pid(upid);</span><br><span class="line">    &#125;</span><br><span class="line">    wo.wo_type    = type;</span><br><span class="line">    wo.wo_pid    = pid;</span><br><span class="line">    wo.wo_flags    = options | WEXITED;</span><br><span class="line">    wo.wo_info    = <span class="literal">NULL</span>;</span><br><span class="line">    wo.wo_stat    = stat_addr;</span><br><span class="line">    wo.wo_rusage    = ru;</span><br><span class="line">    ret = do_wait(&amp;wo);</span><br><span class="line">    put_pid(pid);</span><br><span class="line">    <span class="comment">/* avoid REGPARM breakage on x86: */</span></span><br><span class="line">    asmlinkage_protect(<span class="number">4</span>, ret, upid, stat_addr, options, ru);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到，内核的<code>do_wait</code>函数会根据<code>wait_opts</code>类型的wo变量来控制到底在等待哪些子进程的状态。当前进程中的每一个线程（在内核层面，线程就是进程，每个线程都有独立的task_struct），都会遍历其子进程。在内核中，<code>task_struct</code>中的<code>children</code>成员变量是个链表头，该进程的所有子进程都会链入该链表，遍历起来比较方便。代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_wait_thread</span><span class="params">(<span class="keyword">struct</span> wait_opts *wo, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">       list_for_each_entry(p, &amp;tsk-&gt;children, sibling) &#123;</span><br><span class="line">           <span class="comment">/*遍历进程所有的子进程*/</span></span><br><span class="line">        <span class="type">int</span> ret = wait_consider_task(wo, <span class="number">0</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是我们并不一定关心所有的子进程。当wait（）函数或waitpid（）函数的第一个参数pid等于-1的时候，表示任意子进程我们都关心。但是如果是waitpid（）函数的其他情况，则表示我们只关心其中的某些子进程或某个子进程。内核需要对所有的子进程进行过滤，找到关心的子进程。这个过滤的环节是在内核的<code>eligible_pid</code>函数中完成的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当waitpid的第一个参数为-1时，wo-&gt;wo_type 赋值为PIDTYPE_MAX</span></span><br><span class="line"><span class="comment">* 其他三种情况task_pid_type(p, wo-&gt;wo_type)== wo-&gt;wo_pid检验</span></span><br><span class="line"><span class="comment">* 或者检查pid是否相等，或者检查进程组ID是否等于指定值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eligible_pid</span><span class="params">(<span class="keyword">struct</span> wait_opts *wo, <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> wo-&gt;wo_type == PIDTYPE_MAX || task_pid_type(p, wo-&gt;wo_type) == wo-&gt;wo_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>waitpid函数的第三个参数options是一个位掩码（bit mask），可以同时存在多个标志。当options没有设置任何标志位时，其行为与wait类似，即阻塞等待与pid匹配的子进程退出。options的标志位可以是如下标志位的组合：</p>
<ul>
<li>WUNTRACE：除了关心终止子进程的信息，也关心那些因信号而停止的子进程信息。</li>
<li>WCONTINUED：除了关心终止子进程的信息，也关心那些因收到信号而恢复执行的子进程的状态信息。</li>
<li>WNOHANG：指定的子进程并未发生状态变化，立刻返回，不会阻塞。这种情况下返回值是0。如果调用进程并没有与pid匹配的子进程，则返回-1，并设置errno为ECHILD，根据返回值和errno可以区分这两种情况。</li>
</ul>
<p>传统的wait函数只关注子进程的终止，而waitpid函数则可以通过前两个标志位来检测子进程的停止和从停止中恢复这两个事件。讲到这里，需要解释一下什么是“使进程停止”，什么是“使进程继续”，以及为什么需要这些。设想如下的场景，正在某机器上编译一个大型项目，编译过程需要消耗很多CPU资源和磁盘I&#x2F;O资源，并且耗时很久。如果我暂时需要用机器做其他事情，虽然可能只需要占用几分钟时间。但这会使这几分钟内的用户体验非常糟糕，那怎么办？当然，杀掉编译进程是一个选择，但是这个方案并不好。因为编译耗时很久，贸然杀死进程，你将不得不从头编译起。这时候，我们需要的仅仅是让编译大型工程的进程停下来，把CPU资源和I&#x2F;O资源让给我，让我从容地做自己想做的事情，几分钟后，我用完了，让编译的进程继续工作就行了。</p>
<p>Linux提供了SIGSTOP（信号值19）和SIGCONT（信号值18）两个信号，来完成暂停和恢复的动作，可以通过执行kill-SIGSTOP或kill-19来暂停一个进程的执行，通过执行kill-SIGCONT或kill-18来让一个暂停的进程恢复执行。waitpid（）函数可以通过WUNTRACE标志位关注停止的事件，如果有子进程收到信号处于暂停状态，waitpid就可以返回。同样的道理，通过WCONTINUED标志位可以关注恢复执行的事件，如果有子进程收到SIGCONT信号而恢复执行，waitpid就可以返回。但是上述两个事件和子进程的终止事件是并列的关系，waitpid成功返回的时候，可能是等到了子进程的终止事件，也可能是等到了暂停或恢复执行的事件。这需要通过status的值来区分。那么，现在应该分析status的值了。</p>
<h2 id="等待状态值"><a href="#等待状态值" class="headerlink" title="等待状态值"></a>等待状态值</h2><p>无论是wait（）函数还是waitpid（）函数，都有一个status变量。这个变量是一个int型指针。可以传递NULL，表示不关心子进程的状态信息。如果不为空，则根据填充的status值，可以获取到子进程的很多信息，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_102.jpg"
                      alt="epub_831302_102"
                ></p>
<p>上图可知，直接根据status值可以获得进程的退出方式，但是为了保证可移植性，不应该直接解析status值来获取退出状态。因此系统提供了相应的宏（macro），用来解析返回值。下面分别介绍各种情况。</p>
<ul>
<li>进程是正常退出的</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_103.jpg"
                      alt="epub_831302_103"
                ></p>
<p>所谓截取退出状态8~15位的值，也就是<code>exit_group</code>系统调用用户传入的int型的值。当然只有最低的8位：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    __WEXITSTATUS(status)    (((status) &amp; 0xff00) &gt;&gt; 8)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>进程收到信号，导致退出</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_104.jpg"
                      alt="epub_831302_104"
                ></p>
<ul>
<li>进程收到信号，被停止</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_105.jpg"
                      alt="epub_831302_105"
                ></p>
<ul>
<li>子进程恢复执行</li>
</ul>
<p>有一个宏与这种情况相关。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_106.jpg"
                      alt="epub_831302_106"
                ></p>
<p>为何没有返回使子进程恢复的信号值的宏？原因是只有SIGCONT信号能够使子进程从停止状态中恢复过来。如果子进程恢复执行，只可能是收到了SIGCONT信号，所以不需要宏来取信号的值。下面给出了判断子进程终止的示例代码。等待子进程暂停或恢复执行的情况，可以根据下面的示例代码自行实现。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_wait_exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;status = %d\n&quot;</span>,status);</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;normal termination,exit status = %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abnormal termination,signal number =%d%s\n&quot;</span>,WTERMSIG(status),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">                WCOREDUMP(status)?<span class="string">&quot;core file generated&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>尽管waitpid函数对wait函数做了很多的扩展，但waitpid函数还是存在不足之处：waitpid固然通过WUNTRACE和WCONTINUED标志位，增加了对子进程停止事件和子进程恢复执行事件的支持，但是这种支持并不完美，这两种事件都和子进程的终止事件混在一起了。wait和waitpid函数都会调用wait4系统调用，无论用户传递的参数为何，总会添上WEXITED事件，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wo.wo_flags         = options | WEXITED;</span><br></pre></td></tr></table></figure></div>

<p>如果用户不关心子进程的终止事件，只关心子进程的停止事件，能否使用waitpid（）明确做到？答案是不行。当waitpid返回时，可能是因为子进程终止，也可能是因为子进程停止。这是waitpid和wait的致命缺陷。为了解决这个缺陷，wait家族的最重要成员，waitid（）函数就要闪亮登场了。</p>
<h2 id="waitid"><a href="#waitid" class="headerlink" title="waitid"></a>waitid</h2><p>前面提到过，waitpid函数是wait函数的超集，wait函数能干的事情，waitpid函数都能做到。但是waitpid函数的控制还是不太精确，无论用户是否关心相关子进程的终止事件，终止事件都可能会返回给用户。因此Linux提供了waitid系统调用。glibc封装了waitid系统调用从而实现了waitid函数。尽管目前普遍使用的是wait和waitpid两个函数，但是waitid函数的设计显然更加合理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  @ @ 该函数的第一个入参idtype和第二个入参id用于选择用户关心的子进程。</span></span><br><span class="line"><span class="comment">      idtype==P_PID：精确打击，等待进程ID等于id的进程。</span></span><br><span class="line"><span class="comment">      idtype==P_PGID：在所有子进程中等待进程组ID等于id的进程。</span></span><br><span class="line"><span class="comment">      idtype==P_ALL：等待任意子进程，第二个参数id被忽略。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @ 第三个参数infop本质是个返回值，系统调用负责将子进程的相关信息填充到infop指向的结构体中。</span></span><br><span class="line"><span class="comment">      如果成功获取到信息，下面的字段将会被填充：</span></span><br><span class="line"><span class="comment">      si_pid：子进程的进程ID，相当于wait和waitpid成功时的返回值。</span></span><br><span class="line"><span class="comment">      si_uid：子进程真正的用户ID。</span></span><br><span class="line"><span class="comment">      si_signo：该字段总被填成SIGCHLD。</span></span><br><span class="line"><span class="comment">      si_code：指示子进程发生的事件，该字段可能的取值是：</span></span><br><span class="line"><span class="comment">      		   CLD_EXIT（子进程正常退出）</span></span><br><span class="line"><span class="comment">      		   CLD_KILLED（子进程被信号杀死）</span></span><br><span class="line"><span class="comment">      		   CLD_DUMPED（子进程被信号杀死，并且产生了core dump）</span></span><br><span class="line"><span class="comment">      		   CLD_STOPPED（子进程被信号暂停）</span></span><br><span class="line"><span class="comment">      		   CLD_CONTINUED（子进程被SIGCONT信号恢复执行）</span></span><br><span class="line"><span class="comment">      		   CLD_TRAPPED（子进程被跟踪）</span></span><br><span class="line"><span class="comment">      si_status：status值的语义与wait函数及waitpid函数一致，对于返回值，在两种情况下会返回0：</span></span><br><span class="line"><span class="comment">                成功等到子进程的变化，并取回相应的信息。</span></span><br><span class="line"><span class="comment">                设置了WNOHANG标志位，并且子进程状态无变化。</span></span><br><span class="line"><span class="comment">           如何区分这两种情况呢？解决的方法就是判断返回的siginfo_t结构体中的si_pid，</span></span><br><span class="line"><span class="comment">           如果是因为子进程的状态变化而导致的返回，则si_pid必不等于0，而是等于子进程的进程ID；</span></span><br><span class="line"><span class="comment">           若子进程状态没有变化，则si_pid等于0。</span></span><br><span class="line"><span class="comment">           但是标准并没有规定，waitid函数负责将siginfo_t结构体的内容清零，</span></span><br><span class="line"><span class="comment">           所以为了正确区分这两种情况，唯一安全的做法就是首先将siginfo_t结构体清零，</span></span><br><span class="line"><span class="comment">           返回后，通过判断si_pid是否为0来分辨这两种情况。示例代码如 (1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @ 该函数的改进在于第四个参数options。options参数是下面标志位的按位或：</span></span><br><span class="line"><span class="comment">      WEXITED：等待子进程的终止事件。</span></span><br><span class="line"><span class="comment">      WSTOPPED：等待被信号暂停的子进程事件。</span></span><br><span class="line"><span class="comment">      WCONTINUED：等待先前被暂停，但是被SIGCONT信号恢复执行的子进程。</span></span><br><span class="line"><span class="comment">      WNOHANG：这个标志位语义与waitpid一致，与id匹配的子进程若并无状态信息需要返回，则不阻塞，立刻返回，返回值是0。</span></span><br><span class="line"><span class="comment">      如果调用进程并无子进程与id匹配，则返回-1，并且设置errno为ECHILD。</span></span><br><span class="line"><span class="comment">      WNOWAIT：该标志位指示内核，只负责获取信息，不要改变子进程的状态(僵尸状态)。</span></span><br><span class="line"><span class="comment">      带有WNOWAIT标志位调用waitid函数，稍后还可以调用wait或waitpid或waitid再次获得同样的信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// (1) </span></span><br><span class="line"><span class="type">siginfo_t</span> info ;</span><br><span class="line"><span class="built_in">memset</span>(&amp;info,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">siginfo_t</span>));</span><br><span class="line"><span class="keyword">if</span>(waited(idtype,id,&amp;info,options | WNOHANG) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*发生错误*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(info.si_pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*子进程没有发生变化*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*若有子进程状态发生变化，则进一步处理之*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="进程退出和等待的内核实现"><a href="#进程退出和等待的内核实现" class="headerlink" title="进程退出和等待的内核实现"></a>进程退出和等待的内核实现</h2><p>Linux引入多线程之后，为了支持进程的所有线程能够整体退出，内核引入了<code>exit_group</code>系统调用。对于进程而言，无论是调用exit（）函数、<code>_exit（）</code>函数还是在main函数中return，最终都会调用<code>exit_group</code>系统调用。</p>
<p>对于单线程的进程，从<code>do_exit_group</code>直接调用<code>do_exit</code>就退出了。但是对于多线程的进程，如果某一个线程调用了<code>exit_group</code>系统调用，那么该线程在调用<code>do_exit</code>之前，会通过<code>zap_other_threads</code>函数，给每一个兄弟线程挂上一个<code>SIGKILL</code>信号。内核在尝试递送信号给兄弟进程时（通过<code>get_signal_to_deliver</code>函数），会在挂起信号中发现<code>SIGKILL</code>信号。内核会直接调用<code>do_group_exit</code>函数让该线程也退出（如图4-13所示）。这个过程在第3章中已经详细分析过了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_110.jpg"
                      alt="epub_831302_110"
                ></p>
<p>在do_exit函数中，进程会释放几乎所有的资源（文件、共享内存、信号量等）。该进程并不甘心，因为它还有两桩心愿未了：</p>
<ul>
<li>作为父进程，它可能还有子进程，进程退出以后，将来谁为它的子进程“收尸”。</li>
<li>作为子进程，它需要通知它的父进程来为自己“收尸”。</li>
</ul>
<p>这两件事情是由<code>exit_notify</code>来负责完成的，具体来说<code>forget_original_parent</code>函数和<code>do_notify_parent</code>函数各自负责一件事，如表所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_111.jpg"
                      alt="epub_831302_111"
                ></p>
<p><code>forget_original_parent（）</code>，多么“悲伤”的函数名。顾名思义，该函数用来给自己的子进程安排新的父进程。给自己的子进程安排新的父进程，细分下来，是两件事情：</p>
<p>1）为子进程寻找新的父进程。</p>
<p>2）将子进程的父进程设置为第1）步中找到的新的父亲。</p>
<p>为子进程寻找父进程，是由<code>find_new_reaper（）</code>函数完成的。如果退出的进程是多线程进程，则可以将子进程托付给自己的兄弟线程。如果没有这样的线程，就“托孤”给init进程。</p>
<p>为自己的子进程找到新的父亲之后，内核会遍历退出进程的所有子进程，将新的父亲设置为子进程的父亲。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">forget_original_parent</span><span class="params">(<span class="keyword">struct</span> task_struct *father)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, *<span class="title">n</span>, *<span class="title">reaper</span>;</span></span><br><span class="line">    LIST_HEAD(dead_children);</span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note that exit_ptrace() and find_new_reaper() might</span></span><br><span class="line"><span class="comment">     * drop tasklist_lock and reacquire it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    exit_ptrace(father);</span><br><span class="line">    reaper = find_new_reaper(father);</span><br><span class="line">    list_for_each_entry_safe(p, n, &amp;father-&gt;children, sibling) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span> =</span> p;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            t-&gt;real_parent = reaper;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;parent == father) &#123;</span><br><span class="line">                BUG_ON(t-&gt;ptrace);</span><br><span class="line">                t-&gt;parent = t-&gt;real_parent;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">/*内核提供了机制，允许父进程退出时向子进程发送信号*/</span></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;pdeath_signal)</span><br><span class="line">                group_send_sig_info(t-&gt;pdeath_signal,</span><br><span class="line">                       SEND_SIG_NOINFO, t);</span><br><span class="line">        &#125; while_each_thread(p, t);</span><br><span class="line">        reparent_leader(father, p, &amp;dead_children);</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    BUG_ON(!list_empty(&amp;father-&gt;children));</span><br><span class="line">    list_for_each_entry_safe(p, n, &amp;dead_children, sibling) &#123;</span><br><span class="line">        list_del_init(&amp;p-&gt;sibling);</span><br><span class="line">        release_task(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分代码比较容易引起困扰的是下面这行，我们都知道，子进程“死”的时候，会向父进程发送信号SIGCHLD，Linux也提供了一种机制，允许父进程“死”的时候向子进程发送信号。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;pdeath_signal)</span><br><span class="line">    group_send_sig_info(t-&gt;pdeath_signal,</span><br><span class="line">           SEND_SIG_NOINFO, t);</span><br></pre></td></tr></table></figure></div>

<p>读者可以通过man prctl，查看<code>PR_SET_PDEATHSIG</code>标志位部分。如果应用程序通过prctl函数设置了父进程“死”时要向子进程发送信号，就会执行到这部分内核代码，以通知其子进程。</p>
<p>接下来是第二桩未了的心愿：想办法通知父进程为自己“收尸”。对于单线程的程序来说完成这桩心愿比较简单，但是多线程的情况就复杂些。只有线程组的主线程才有资格通知父进程，线程组的其他线程终止的时候，不需要通知父进程，也没必要保留最后的资源并陷入僵尸态，直接调用release_task函数释放所有资源就好。为什么要这样设计？细细想来，这么做是合理的。父进程创建子进程时，只有子进程的主线程是父进程亲自创建出来的，是父进程的亲生儿子，父进程也只关心它，至于子进程调用pthread_create产生的其他线程，父进程压根就不关心。</p>
<p>由于父进程只认子进程的主线程，所以在线程组中，主线程一定要挺住。在用户层面，可以调用pthread_exit让主线程先“死”，但是在内核态中，主线程的task_struct一定要挺住，哪怕变成僵尸，也不能释放资源。生命在于“折腾”，如果主线程率先退出了，而其他线程还在正常工作，内核又将如何处理？</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (thread_group_leader(tsk)) &#123;</span><br><span class="line">   <span class="comment">/*线程组组长只有在全部线程都已退出的情况下，</span></span><br><span class="line"><span class="comment">    *才能调用do_notify_parent通知父进程*/</span></span><br><span class="line">    autoreap = thread_group_empty(tsk) &amp;&amp;</span><br><span class="line">    do_notify_parent(tsk, tsk-&gt;exit_signal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*如果是线程组的非组长线程，可以立即调用release_task，</span></span><br><span class="line"><span class="comment">    *释放残余的资源，因为通知父进程这件事和它没有关系*/</span></span><br><span class="line">    autoreap = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码给出了答案，如果退出的进程是线程组的主线程，但是线程组中还有其他线程尚未终止（thread_group_empty函数返回false），那么autoreaper就等于false，也就不会调用do_notify_parent向父进程发送信号了。因为子进程的线程组中有其他线程还活着，因此子进程的主线程退出时不能通知父进程，错过了调用do_notify_parent的机会，那么父进程如何才能知晓子进程已经退出了呢？答案会在最后一个线程退出时揭晓。此答案就藏在内核的release_task函数中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leader = p-&gt;group_leader;</span><br><span class="line"><span class="keyword">if</span> (leader != p &amp;&amp; thread_group_empty(leader) &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE) &#123;</span><br><span class="line">     zap_leader = do_notify_parent(leader, leader-&gt;exit_signal);</span><br><span class="line">     <span class="keyword">if</span> (zap_leader)</span><br><span class="line">         leader-&gt;exit_state = EXIT_DEAD;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>当线程组的最后一个线程退出时，如果发现：</p>
<ul>
<li>该线程不是线程组的主线程。</li>
<li>线程组的主线程已经退出，且处于僵尸状态。</li>
<li>自己是最后一个线程。</li>
</ul>
<p>同时满足这三个条件的时候，该子进程就需要冒充线程组的组长，即以子进程的主线程的身份来通知父进程。 </p>
<p>上面讨论了一种比较少见又比较折腾的场景，正常的多线程编程应该不会如此安排。对于多线程的进程，一般情况下会等所有其他线程退出后，主线程才退出。这时，主线程会在exit_notify函数中发现自己是组长，线程组里所有成员均已退出，然后它调用do_notify_parent函数来通知父进程。无论怎样，子进程都走到了do_notify_parent函数这一步。该函数是完成父子进程之间互动的主要函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">do_notify_parent</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">psig</span>;</span></span><br><span class="line">    <span class="type">bool</span> autoreap = <span class="literal">false</span>;</span><br><span class="line">    BUG_ON(sig == <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">/* do_notify_parent_cldstop should have been called instead.  */</span></span><br><span class="line">    BUG_ON(task_is_stopped_or_traced(tsk));</span><br><span class="line">    BUG_ON(!tsk-&gt;ptrace &amp;&amp;</span><br><span class="line">            (tsk-&gt;group_leader != tsk || !thread_group_empty(tsk)));</span><br><span class="line">    <span class="keyword">if</span> (sig != SIGCHLD) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This is only possible if parent == real_parent.</span></span><br><span class="line"><span class="comment">         * Check if it has changed security domain.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (tsk-&gt;parent_exec_id != tsk-&gt;parent-&gt;self_exec_id)</span><br><span class="line">            sig = SIGCHLD;</span><br><span class="line">    &#125;</span><br><span class="line">    info.si_signo = sig;</span><br><span class="line">    info.si_errno = <span class="number">0</span>;</span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    info.si_pid = task_pid_nr_ns(tsk, tsk-&gt;parent-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">    info.si_uid = __task_cred(tsk)-&gt;uid;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    info.si_utime = <span class="type">cputime_to_clock_t</span>(cputime_add(tsk-&gt;utime,</span><br><span class="line">                tsk-&gt;signal-&gt;utime));</span><br><span class="line">    info.si_stime = <span class="type">cputime_to_clock_t</span>(cputime_add(tsk-&gt;stime,</span><br><span class="line">                tsk-&gt;signal-&gt;stime));</span><br><span class="line">    info.si_status = tsk-&gt;exit_code &amp; <span class="number">0x7f</span>;</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;exit_code &amp; <span class="number">0x80</span>)</span><br><span class="line">        info.si_code = CLD_DUMPED;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;exit_code &amp; <span class="number">0x7f</span>)</span><br><span class="line">        info.si_code = CLD_KILLED;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        info.si_code = CLD_EXITED;</span><br><span class="line">        info.si_status = tsk-&gt;exit_code &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    psig = tsk-&gt;parent-&gt;sighand;</span><br><span class="line">    spin_lock_irqsave(&amp;psig-&gt;siglock, flags);</span><br><span class="line">    <span class="keyword">if</span> (!tsk-&gt;ptrace &amp;&amp; sig == SIGCHLD &amp;&amp;</span><br><span class="line">            (psig-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_handler == SIG_IGN ||</span><br><span class="line">             (psig-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_flags &amp; SA_NOCLDWAIT))) &#123;</span><br><span class="line">        autoreap = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (psig-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_handler == SIG_IGN)</span><br><span class="line">            sig = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*子进程向父进程发送信号*/</span></span><br><span class="line">    <span class="keyword">if</span> (valid_signal(sig) &amp;&amp; sig)</span><br><span class="line">        __group_send_sig_info(sig, &amp;info, tsk-&gt;parent);</span><br><span class="line">    <span class="comment">/* 子进程尝试唤醒父进程，如果父进程正在等待其终止 */</span>__wake_up_parent(tsk, tsk-&gt;parent);</span><br><span class="line">    spin_unlock_irqrestore(&amp;psig-&gt;siglock, flags);</span><br><span class="line">    <span class="keyword">return</span> autoreap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>父子进程之间的互动有两种方式：</p>
<p><strong>子进程向父进程发送信号SIGCHLD。</strong></p>
<p>父进程可能并不知道子进程是何时退出的，如果调用wait函数等待子进程退出，又会导致父进程陷入阻塞，无法执行其他任务。那有没有一种办法，让子进程退出的时候，异步通知到父进程呢？答案是肯定的。当子进程退出时，会向父进程发送SIGCHLD信号。父进程收到该信号，默认行为是置之不理。在这种情况下，子进程就会陷入僵尸状态，而这又会浪费系统资源，该状态会维持到父进程退出，子进程被init进程接管，init进程会等待僵尸进程，使僵尸进程释放资源。如果父进程不太关心子进程的退出事件，听之任之可不是好办法，可以采取以下办法：</p>
<ul>
<li><p>父进程调用signal函数或sigaction函数，将SIGCHLD信号的处理函数设置为SIG_IGN。</p>
</li>
<li><p>父进程调用sigaction函数，设置标志位时置上SA_NOCLDWAIT位（如果不关心子进程的暂停和恢复执行，则置上SA_NOCLDSTOP位）。</p>
</li>
</ul>
<p>从内核代码来看，如果父进程的SIGCHLD的信号处理函数为SIG_IGN或sa_flags中被置上了SA_NOCLDWAIT位，子进程运行到此处时就知道了，父进程并不关心自己的退出信息，do_notify_parent函数就会返回true。在外层的exit_notify函数发现返回值是true，就会调用release_task函数，释放残余的资源，自行了断，子进程也就不会进入僵尸状态了。如果父进程关心子进程的退出，情况就不同了。父进程除了调用wait函数之外，还有了另外的选择，即注册SIGCHLD信号处理函数，在信号处理函数中处理子进程的退出事件。</p>
<p>为SIGCHLD写信号处理函数并不简单，原因是SIGCHLD是传统的不可靠信号。信号处理函数执行期间，会将引发调用的信号暂时阻塞（除非显式地指定了SA_NODEFER标志位），在这期间收到的SIGCHLD之类的传统信号，都不会排队。因此，如果在处理SIGCHLD信号时，有多个子进程退出，产生了多个SIGCHLD信号，但父进程只能收到一个。如果在信号处理函数中，只调用一次wait或waitpid，则会造成某些僵尸进程成为漏网之鱼。</p>
<p>正确的写法是，信号处理函数内，带着NOHANG标志位循环调用waitpid。如果返回值大于0，则表示不断等待子进程退出，返回0则表示，当前没有僵尸子进程，返回-1则表示出错，最大的可能就是errno等于ECHLD，表示所有子进程都已退出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(waitpid(<span class="number">-1</span>,&amp;status,WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">/*此处处理返回信息*/</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>信号处理函数中的waitpid可能会失败，从而改变全局的errno的值，当主程序检查errno时，就有可能发生冲突，所以进入信号处理函数前要现保存errno到本地变量，信号处理函数退出前，再恢复errno。</p>
<p><strong>子进程唤醒父进程</strong></p>
<p>上一种方法可以称之为信号通知。另一种情况是父进程调用wait主动等待。如果父进程调用wait陷入阻塞，那么子进程退出时，又该如何及时唤醒父进程呢？前面提到了，子进程会调用<code>__wake_up_parent</code>函数，来及时唤醒父进程。事实上，前提条件是父进程确实在等待子进程的退出。如果父进程并没有调用wait系列函数等待子进程的退出，那么，等待队列为空，子进程的<code>__wake_up_parent</code>对父进程并无任何影响。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __wake_up_parent(<span class="keyword">struct</span> task_struct *p, <span class="keyword">struct</span> task_struct *parent)</span><br><span class="line">&#123;</span><br><span class="line">    __wake_up_sync_key(&amp;parent-&gt;signal-&gt;wait_chldexit,</span><br><span class="line">            TASK_INTERRUPTIBLE, <span class="number">1</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>父进程的进程描述符的signal结构体中有wait_childexit变量，这个变量是等待队列头。父进程调用wait系列函数时，会创建一个<code>wait_opts</code>结构体，并把该结构体挂入等待队列中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_wait</span><span class="params">(<span class="keyword">struct</span> wait_opts *wo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    trace_sched_process_wait(wo-&gt;wo_pid);</span><br><span class="line">    <span class="comment">/*挂入等待队列*/</span></span><br><span class="line">    init_waitqueue_func_entry(&amp;wo-&gt;child_wait, child_wait_callback);</span><br><span class="line">    wo-&gt;child_wait.private = current;</span><br><span class="line">    add_wait_queue(&amp;current-&gt;signal-&gt;wait_chldexit, &amp;wo-&gt;child_wait);</span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    wo-&gt;notask_error = -ECHILD;</span><br><span class="line">    <span class="keyword">if</span> ((wo-&gt;wo_type &lt; PIDTYPE_MAX) &amp;&amp;</span><br><span class="line">            (!wo-&gt;wo_pid || hlist_empty(&amp;wo-&gt;wo_pid-&gt;tasks[wo-&gt;wo_type])))</span><br><span class="line">        <span class="keyword">goto</span> notask;</span><br><span class="line">    set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">    read_lock(&amp;tasklist_lock);</span><br><span class="line">    tsk = current;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        retval = do_wait_thread(wo, tsk);</span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        retval = ptrace_do_wait(wo, tsk);</span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        <span class="keyword">if</span> (wo-&gt;wo_flags &amp; __WNOTHREAD)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; while_each_thread(current, tsk);</span><br><span class="line">    read_unlock(&amp;tasklist_lock);</span><br><span class="line"><span class="comment">/*找了一圈，没有找到满足等待条件的的子进程，下一步的行为将取决于WNOHANG标志位</span></span><br><span class="line"><span class="comment">*如果将WNOHANG标志位置位，则表示不等了，直接退出，</span></span><br><span class="line"><span class="comment">*如果没有置位，则让出CPU，醒来后继续再找一圈*/</span></span><br><span class="line">notask:</span><br><span class="line">    retval = wo-&gt;notask_error;</span><br><span class="line">    <span class="keyword">if</span> (!retval &amp;&amp; !(wo-&gt;wo_flags &amp; WNOHANG)) &#123;</span><br><span class="line">        retval = -ERESTARTSYS;</span><br><span class="line">        <span class="keyword">if</span> (!signal_pending(current)) &#123;</span><br><span class="line">            schedule();</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">end:</span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">    remove_wait_queue(&amp;current-&gt;signal-&gt;wait_chldexit, &amp;wo-&gt;child_wait);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>父进程先把自己设置成<code>TASK_INTERRUPTIBLE</code>状态，然后开始寻找满足等待条件的子进程。如果找到了，则将自己重置成<code>TASK_RUNNING</code>状态，欢乐返回；如果没找到，就要根据WNOHANG标志位来决定等不等待子进程。如果没有WNOHANG标志位，那么，父进程就会让出CPU资源，等待别人将它唤醒。回到另一头，子进程退出的时候，会调用<code>__wake_up_parent</code>，唤醒父进程，父进程醒来以后，回到repeat，再次扫描。这样做，子进程的退出就能及时通知到父进程，从而使父进程的wait系列函数可以及时返回。</p>
<h1 id="exec-族"><a href="#exec-族" class="headerlink" title="exec 族"></a>exec 族</h1><p>整个exec家族有6个函数，这些函数都是构建在execve系统调用之上的。该系统调用的作用是，将新程序加载到进程的地址空间，丢弃旧有的程序，进程的栈、数据段、堆栈等会被新程序替换。</p>
<h2 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@filename 是准备执行的新程序的路径名，可以是绝对路径，也可以是相对于当前工作目录的相对路径。</span></span><br><span class="line"><span class="comment">@argv 字符串指针组成的数组，以NULL结束。argv[0]一般对应可执行文件的文件名，</span></span><br><span class="line"><span class="comment">	  也就是filename中的basename（路径名最后一个/后面的部分）。</span></span><br><span class="line"><span class="comment">	  当然如果argv[0]不遵循这个约定也无妨，因为execve可以从第一个参数获取到要执行文件的路径，只要不是NULL即可。</span></span><br><span class="line"><span class="comment">@envp 字符串指针数组，以NULL结束，指针指向的字符串的格式为name=value。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></div>

<p>一般来说，execve（）函数总是紧随fork函数之后。父进程调用fork之后，子进程执行execve函数，抛弃父进程的程序段，和父进程分道扬镳，从此天各一方，各走各路。但是也可以不执行fork，单独调用execve函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(execve(<span class="string">&quot;/bin/ls&quot;</span>,args, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;execve&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Never get here&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">total <span class="number">20</span></span><br><span class="line">-rwxrwxr-x <span class="number">1</span> jelasin jelasin <span class="number">16088</span> Feb  <span class="number">6</span> <span class="number">13</span>:<span class="number">37</span> first</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> jelasin jelasin   <span class="number">279</span> Feb  <span class="number">6</span> <span class="number">13</span>:<span class="number">37</span> first.c</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到，代码段最后的Never get here没有被打印出来，这是因为execve函数的返回是特殊的。如果失败，则会返回-1，但是如果成功，则永不返回，这是可以理解的。execve做的就是斩断过去，奔向新生活的事情，如果成功，自然不可能再返回来，再次执行老程序的代码。所以无须检查execve的返回值，只要返回，就必然是-1。可以从errno判断出出错的原因。出错的可能性非常多，手册提供了19种不同的errno，罗列了22种失败的情景。很难记住，好在大部分都不常见，常见的情况有以下几种：</p>
<ul>
<li>EACCESS：这个是我们最容易想到的，就是第一个参数filename，不是个普通文件，或者该文件没有赋予可执行的权限，或者目录结构中某一级目录不可搜索，或者文件所在的文件系统是以MS_NOEXEC标志挂载的。</li>
<li>ENOENT：文件不存在。</li>
<li>ETXTBSY：存在其他进程尝试修改filename所指代的文件。</li>
<li>ENOEXEC：这个错误其实是比较高端的一种错误了，文件存在，也可以执行，但是无法执行，比如说，Windows下的可执行程序，拿到Linux下，调用execve来执行，文件的格式不对，就会返回这种错误。</li>
</ul>
<p>上面提到的ENOEXEC错误码，其实已经触及了execve函数的核心，即哪些文件是可以执行的，execve系统调用又是如何执行的呢？这些会在execve系统调用的内核系统调用中详细介绍。</p>
<hr>
<p>从内核的角度来说，提供execve系统调用就足够了，但是从应用层编程的角度来讲，execve函数就并不那么好使了：</p>
<ul>
<li>第一个参数必须是绝对路径或是相对于当前工作目录的相对路径。习惯在shell下工作的用户会觉得不太方便，因为日常工作都是写ls和mkdir之类命令的，没有人会写&#x2F;bin&#x2F;ls或&#x2F;bin&#x2F;mkdir。shell提供了环境变量PATH，即可执行程序的查找路径，对于位于查找路径里的可执行程序，我们不必写出完整的路径，很方便，而execve函数享受不到这个福利，因此使用不便。</li>
<li>execve函数的第三个参数是环境变量指针数组，用户使用execve编程时不得不自己负责环境变量，书写大量的“key&#x3D;value”，但大部分情况下并不需要定制环境变量，只需要使用当前的环境变量即可。正是为了提供相应的便利，所以用户层提供了6个函数，当然，这些函数本质上都是调用execve系统调用，只是使用的方法略有不同，代码如下：</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="type">char</span> * <span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> ps_argv[] = &#123;<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;-ax&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> ps_envp[] = &#123;<span class="string">&quot;PATH=/bin:/usr/bin&quot;</span>,<span class="string">&quot;TERM=console&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">execl(<span class="string">&quot;/bin/ps&quot;</span>,<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;-ax&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*带p的，可以使用环境变量PATH，无须写全路径*/</span></span><br><span class="line">execlp(<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;-ax&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*带e的需要自己组拼环境变量*/</span></span><br><span class="line">execle(<span class="string">&quot;/bin/ps&quot;</span>,<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;-ax&quot;</span>,<span class="literal">NULL</span>,ps_envp);</span><br><span class="line">execv(<span class="string">&quot;/bin/ps&quot;</span>,ps_argv);</span><br><span class="line"><span class="comment">/*带p的，可以使用环境变量PATH，无须写全路径*/</span></span><br><span class="line">execvp(<span class="string">&quot;ps&quot;</span>,ps_argv);</span><br><span class="line"><span class="comment">/*带e的需要自己组拼环境变量*/</span></span><br><span class="line">execve(<span class="string">&quot;/bin/ps&quot;</span>,ps_argv,ps_envp);</span><br></pre></td></tr></table></figure></div>

<p>上述6个函数分成上下两个半区。分类的依据是参数采用列表（l，表示list）还是数组（v，表示vector）。上半区采用列表，它们会罗列所有的参数，下半区采用数组。在每个半区之中，带p的表示可以使用环境变量PATH，带e的表示必须要自己维护环境变量，而不使用当前环境变量。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_114.jpg"
                      alt="epub_831302_114"
                ></p>
<h2 id="execve-系统调用的内核实现"><a href="#execve-系统调用的内核实现" class="headerlink" title="execve 系统调用的内核实现"></a>execve 系统调用的内核实现</h2><p>前面提到的ENOEXEC错误表示内核不知道如何执行对应的可执行文件。Linux支持很多种可执行文件的格式，有渐渐退出历史舞台的a.out格式，有比较通用的ELF格式的文件，还有shell脚本文件、python脚本、java文件、php文件等。对于这些形形色色的可执行文件，内核该如何正确地执行呢？直接将Windows平台上的可执行文件拷贝到Linux下，Linux为什么不能执行（假设没有wine这个执行Windows程序的工具）？这是本节需要解决问题。要解决上述问题，首先还是需要深入内核。</p>
<p>execve是平台相关的系统调用，刨去我们不太关心的平台差异，内核都会走到do_execve_common函数这一步。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_execve_common</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> user_arg_ptr argv,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> user_arg_ptr envp,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> *<span class="title">bprm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">displaced</span>;</span></span><br><span class="line">    <span class="type">bool</span> clear_in_exec;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> current_cred();</span><br><span class="line">    <span class="keyword">if</span> ((current-&gt;flags &amp; PF_NPROC_EXCEEDED) &amp;&amp;</span><br><span class="line">            <span class="type">atomic_read</span>(&amp;cred-&gt;user-&gt;processes) &gt; rlimit(RLIMIT_NPROC)) &#123;</span><br><span class="line">        retval = -EAGAIN;</span><br><span class="line">        <span class="keyword">goto</span> out_ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We&#x27;re below the limit (still or again), so we don&#x27;t want to make</span></span><br><span class="line"><span class="comment">     * further execve() calls fail. */</span></span><br><span class="line">    current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED;</span><br><span class="line">    retval = unshare_files(&amp;displaced);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out_ret;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    bprm = kzalloc(<span class="keyword">sizeof</span>(*bprm), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!bprm)</span><br><span class="line">        <span class="keyword">goto</span> out_files;</span><br><span class="line">    retval = prepare_bprm_creds(bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out_free;</span><br><span class="line">    retval = check_unsafe_exec(bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_free;</span><br><span class="line">    clear_in_exec = retval;</span><br><span class="line">    current-&gt;in_execve = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*读取可执行文件*/</span></span><br><span class="line">    file = open_exec(filename);</span><br><span class="line">    retval = PTR_ERR(file);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">        <span class="keyword">goto</span> out_unmark;</span><br><span class="line">    <span class="comment">/*选择负载最小的CPU来执行新程序*/</span></span><br><span class="line">    sched_exec();</span><br><span class="line">    bprm-&gt;file = file;</span><br><span class="line">    bprm-&gt;filename = filename;</span><br><span class="line">    bprm-&gt;interp = filename;</span><br><span class="line">    retval = bprm_mm_init(bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out_file;</span><br><span class="line">    bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class="line">    <span class="keyword">if</span> ((retval = bprm-&gt;argc) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class="line">    <span class="keyword">if</span> ((retval = bprm-&gt;envc) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;<span class="comment">/*填充linux_binprm数据结构*/</span></span><br><span class="line">    retval = prepare_binprm(bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/*接下来的3个copy用来拷贝文件名、命令行参数和环境变量*/</span></span><br><span class="line">    retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    bprm-&gt;exec = bprm-&gt;p;</span><br><span class="line">    retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/*核心部分，遍历formats链表，尝试每个load_binary函数*/</span>retval = search_binary_handler(bprm,regs);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* execve succeeded */</span></span><br><span class="line">    current-&gt;fs-&gt;in_exec = <span class="number">0</span>;</span><br><span class="line">    current-&gt;in_execve = <span class="number">0</span>;</span><br><span class="line">    acct_update_integrals(current);</span><br><span class="line">    free_bprm(bprm);</span><br><span class="line">    <span class="keyword">if</span> (displaced)</span><br><span class="line">        put_files_struct(displaced);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (bprm-&gt;mm) &#123;</span><br><span class="line">        acct_arg_size(bprm, <span class="number">0</span>);</span><br><span class="line">        mmput(bprm-&gt;mm);</span><br><span class="line">    &#125;</span><br><span class="line">out_file:</span><br><span class="line">    <span class="keyword">if</span> (bprm-&gt;file) &#123;</span><br><span class="line">        allow_write_access(bprm-&gt;file);</span><br><span class="line">        fput(bprm-&gt;file);</span><br><span class="line">    &#125;</span><br><span class="line">out_unmark:</span><br><span class="line">    <span class="keyword">if</span> (clear_in_exec)</span><br><span class="line">        current-&gt;fs-&gt;in_exec = <span class="number">0</span>;</span><br><span class="line">    current-&gt;in_execve = <span class="number">0</span>;</span><br><span class="line">out_free:</span><br><span class="line">    free_bprm(bprm);</span><br><span class="line">out_files:</span><br><span class="line">    <span class="keyword">if</span> (displaced)</span><br><span class="line">        reset_files_struct(displaced);</span><br><span class="line">out_ret:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中，linux_binprm是重要的结构体，它与稍后提到的linux_binfmt联手，支持了Linux下多种可执行文件的格式。首先，内核会将程序运行需要的参数argv和环境变量搜集到linux_binprm结构体中，比较关键的一步是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval = prepare_binprm(bprm);</span><br></pre></td></tr></table></figure></div>

<p>在prepare_binprm函数中读取可执行文件的头128个字节，存放在linux_binprm结构体的buf[BINPRM_BUF_SIZE]中。我们知道日常写shell脚本、python脚本的时候，总是会在第一行写下如下语句：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br></pre></td></tr></table></figure></div>

<p>开头的<code>#!</code>被称为<code>shebang</code>，又被称为<code>sha-bang</code>、<code>hashbang</code>等，指的就是脚本中开始的字符。在类Unix操作系统中，运行这种程序，需要相应的解释器。使用哪种解释器，取决于shebang后面的路径。<code>#!</code>后面跟随的一般是解释器的绝对路径，或者是相对于当前工作目录的相对路径。格式如下所示：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!interpreter [optional-arg]</span></span><br></pre></td></tr></table></figure></div>

<p>解释器是绝对路径或是相对于当前工作目录的相对路径，这就给脚本的可移植性带来了挑战。以python的解释器为例，python可能位于<code>/usr/bin/python</code>，也可能位于<code>/usr/local/bin/python</code>，甚至有的还位于<code>/home/username/bin/python</code>。这样编写的脚本在新的环境里面运行时，用户就不得不修改脚本了，当大量的脚本移植到新环境中运行时，修改量是巨大的。为了解决这个问题，系统又引入了如下格式：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">在执行时，这种格式会从环境变量<span class="variable">$PATH</span>中查找python解释器。如果存在多个版本的解释器，则会按照<span class="variable">$PATH</span>中查找路径的顺序来查找。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果执行方式是<code>./python_script</code>的方式，就会优先查找<code>/home/manu/bin/python</code>，<code>/usr/local/bin/python</code>次之……如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;/home/manu/bin/python&quot;</span>, [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;./hello.py&quot;</span>], [<span class="comment">/* 25 vars */</span>]) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">execve(<span class="string">&quot;/usr/local/bin/python&quot;</span>, [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;./hello.py&quot;</span>], [<span class="comment">/* 25 vars */</span>]) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">execve(<span class="string">&quot;/usr/local/sbin/python&quot;</span>, [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;./hello.py&quot;</span>], [<span class="comment">/* 25 vars */</span>]) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">execve(<span class="string">&quot;/usr/local/bin/python&quot;</span>, [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;./hello.py&quot;</span>], [<span class="comment">/* 25 vars */</span>]) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">execve(<span class="string">&quot;/usr/sbin/python&quot;</span>, [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;./hello.py&quot;</span>], [<span class="comment">/* 25 vars */</span>]) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">execve(<span class="string">&quot;/usr/bin/python&quot;</span>, [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;./hello.py&quot;</span>], [<span class="comment">/* 25 vars */</span>]) = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<p>上面提到的是脚本文件，除此以外，还有其他格式的文件。Linux平台上最主要的可执行文件格式是ELF格式，当然还有出现较早，逐渐退出历史舞台的的a.out格式，这些文件的特点是最初的128字节中都包含了可执行文件的属性的重要信息。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks：~$  file hello</span><br><span class="line">hello: ELF <span class="number">64</span>-bit LSB  executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically <span class="title function_">linked</span> </span><br><span class="line">    <span class="params">(uses shared libs)</span>, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=<span class="number">657</span>d5ef3eab6741481bb219ef6c2fb21f8e91b51, not stripped</span><br></pre></td></tr></table></figure></div>

<p><code>prepare_binprm</code>函数将文件开始的128字节存入<code>linux_binprm</code>，是为了让后面的程序根据文件开头的<code>magic number</code>选择正确的处理方式。做完准备工作后，开始执行，核心代码位于<code>search_binary_handler()</code>函数中。内核之中存在一个全局链表，名叫<code>formats</code>，挂到此链表的数据结构为<code>struct linux_binfmt</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line">    <span class="type">int</span> (*load_binary)(<span class="keyword">struct</span> linux_binprm *, <span class="keyword">struct</span>  pt_regs * regs);</span><br><span class="line">    <span class="type">int</span> (*load_shlib)(<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*core_dump)(<span class="keyword">struct</span> coredump_params *cprm);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_coredump; <span class="comment">/* minimal dump size */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>操作系统启动的时候，每个编译进内核的可执行文件的“代理人”都会调用<code>register_binfmt</code>函数来注册，把自己挂到<code>formats</code>链表中。每个成员代表一种可执行文件的代理人，前面提到过，会将可执行文件的头128字节存放到<code>linux_binprm</code>的buf中，同时会将运行时的参数和环境变量也存放到<code>linux_binprm</code>的相关结构中。<code>formats</code>链表中的成员依次前来认领，如果是自己代表的可执行文件的格式，后面执行的事情，就委托给了该“代理人”。如果遍历了链表，所有的<code>linux_binfmt</code>都表示不认识该可执行文件，那又当如何呢？这种情况要根据头部的信息，查看是否有为该格式设计的，作为可动态安装的模块实现的“代理人”存在。如果有的话，就把该模块安装进来，挂入全局的<code>formats</code>链表之中，然后让<code>formats</code>链表中的所有成员再试一次。上述逻辑位于<code>search_binary_handler</code>函数之中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search_binary_handler</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm,<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> depth = bprm-&gt;recursion_depth;</span><br><span class="line">    <span class="type">int</span> try,retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">fmt</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> old_pid;</span><br><span class="line">    <span class="comment">/* This allows 4 levels of binfmt rewrites before failing hard. */</span></span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> -ELOOP;</span><br><span class="line">    retval = security_bprm_check(bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    retval = audit_bprm(bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    <span class="comment">/* Need to fetch pid before load_binary changes it */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    old_pid = task_pid_nr_ns(current, task_active_pid_ns(current-&gt;parent));</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    retval = -ENOENT;</span><br><span class="line">    <span class="comment">/*最多尝试两次，第一次遍历formats链表中的所有成员，</span></span><br><span class="line"><span class="comment">    *若没找到，则尝试加载动态模块，再次遍历*/</span></span><br><span class="line">    <span class="keyword">for</span> (try=<span class="number">0</span>; try&lt;<span class="number">2</span>; try++) &#123;</span><br><span class="line">        read_lock(&amp;binfmt_lock);</span><br><span class="line">        list_for_each_entry(fmt, &amp;formats, lh) &#123;</span><br><span class="line">            <span class="type">int</span> (*fn)(<span class="keyword">struct</span> linux_binprm *, <span class="keyword">struct</span> pt_regs *) = fmt-&gt;load_binary;</span><br><span class="line">            <span class="keyword">if</span> (!fn)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!try_module_get(fmt-&gt;module))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            read_unlock(&amp;binfmt_lock);</span><br><span class="line">            bprm-&gt;recursion_depth = depth + <span class="number">1</span>;</span><br><span class="line">            retval = fn(bprm, regs);</span><br><span class="line">            bprm-&gt;recursion_depth = depth;</span><br><span class="line">            <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (depth == <span class="number">0</span>)</span><br><span class="line">                    ptrace_event(PTRACE_EVENT_EXEC,</span><br><span class="line">                           old_pid);</span><br><span class="line">                put_binfmt(fmt);</span><br><span class="line">                allow_write_access(bprm-&gt;file);</span><br><span class="line">                <span class="keyword">if</span> (bprm-&gt;file)</span><br><span class="line">                    fput(bprm-&gt;file);</span><br><span class="line">                bprm-&gt;file = <span class="literal">NULL</span>;</span><br><span class="line">                current-&gt;did_exec = <span class="number">1</span>;</span><br><span class="line">                proc_exec_connector(current);</span><br><span class="line">                <span class="keyword">return</span> retval;</span><br><span class="line">            &#125;</span><br><span class="line">            read_lock(&amp;binfmt_lock);</span><br><span class="line">            put_binfmt(fmt);</span><br><span class="line">            <span class="keyword">if</span> (retval != -ENOEXEC || bprm-&gt;mm == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!bprm-&gt;file) &#123;</span><br><span class="line">                read_unlock(&amp;binfmt_lock);</span><br><span class="line">                <span class="keyword">return</span> retval;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        read_unlock(&amp;binfmt_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">        <span class="keyword">if</span> (retval != -ENOEXEC || bprm-&gt;mm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> printable(c) (((c)==<span class="string">&#x27;\t&#x27;</span>) || ((c)==<span class="string">&#x27;\n&#x27;</span>) || (0x20&lt;=(c) &amp;&amp; (c)&lt;=0x7e))</span></span><br><span class="line">            <span class="keyword">if</span> (printable(bprm-&gt;buf[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">                printable(bprm-&gt;buf[<span class="number">1</span>]) &amp;&amp;</span><br><span class="line">                printable(bprm-&gt;buf[<span class="number">2</span>]) &amp;&amp;</span><br><span class="line">                printable(bprm-&gt;buf[<span class="number">3</span>]))</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* -ENOEXEC */</span></span><br><span class="line">            <span class="keyword">if</span> (try)</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* -ENOEXEC */</span></span><br><span class="line">            request_module(<span class="string">&quot;binfmt-%04x&quot;</span>, *(<span class="type">unsigned</span> <span class="type">short</span> *)(&amp;bprm-&gt;buf[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以通过下面的方式来查看自己机器的编译选项，从而得知支持的可执行文件的类型：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep BINFMT  /boot/config<span class="number">-3.13</span><span class="number">.0</span><span class="number">-43</span>-generic</span><br><span class="line">CONFIG_BINFMT_ELF=y</span><br><span class="line">CONFIG_COMPAT_BINFMT_ELF=y</span><br><span class="line">CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y</span><br><span class="line">CONFIG_BINFMT_SCRIPT=y</span><br><span class="line">CONFIG_BINFMT_MISC=m</span><br></pre></td></tr></table></figure></div>

<p>在内核代码树中fs目录下，Makefile记录了支持的格式，在fs目录下，每一种支持的格式xx都有一个<code>binfmt_xx.c</code>文件。binfmt_aout.c是对应a.out类型的可执行文件，这种文件格式是早期Unix系统使用的可执行文件的格式，由AT&amp;T设计，今天已经退出了历史舞台。<code>binfmt_elf.c</code>对应的是ELF格式的可执行文件。ELF最早由Unix系统实验室（Unix SYSTEM Laboratories USL）开发，目的是取代传统的a.out格式。1994年6月ELF格式出现在Linux系统上，目前，ELF格式已经成为Linux下最主要的可执行文件格式。</p>
<p><code>binfmt_script</code>对应的是script格式的可执行文件，这种格式的可执行文件一般以<code>“#!”</code>开头，查找相应的解释器来执行脚本。比如python脚本、shell脚本和perl脚本等。早期的内核之中，曾经为Java格式提供了专门的binfmt结构，后来取消了，原因是Java并不特殊，不值得为其提供专门的binfmt结构。如果专门为Java提供了，其他语言就会有意见了，没有做到一视同仁。但是需要支持的可执行文件的格式越来越多，大家都可能有自己的解释器，内核支持也不可能无限地增加binfmt结构，这时候，<code>binfmt_misc</code>就出现了。binfmt把这个功能开放给了用户层，用户可以引入自己的可执行文件格式，只要你能定义好magic number，识别出文件是不是自己的这种格式，另外自己定义好解释器就可以了。binfmt_misc这个机制非常好，提供了支持额外可执行格式的可扩展方法。举例来讲，如果想在Linux下执行Windows的exe文件，Wine软件可以在Linux下执行Windows的exe文件。</p>
<p>注册某种可执行文件到binfmt_misc的格式时，echo的内容如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:Name:Type:Offset:String:Mask:Interpreter:Flags</span><br><span class="line"></span><br><span class="line">	Name：产生在/proc/sys/fs/binfmt_misc目录下的文件名，代表一种可执行文件。</span><br><span class="line">    Type：表示识别类型，M表示用magic numer来识别，E表示扩展。</span><br><span class="line">    Offset：magic number数在文件中的起始偏移量。</span><br><span class="line">    String：以magic number或以扩展名匹配的字符串。</span><br><span class="line">    Mask：用来屏蔽String中的一些位的字符串。</span><br><span class="line">    Interpret：解释程序的完整路径名。</span><br><span class="line">    Flags：可选标志，控制必须怎样调用解释程序。</span><br></pre></td></tr></table></figure></div>

<p>例如我们可以将Windows exe文件注册到binfmt_misc，直接使用如下方法即可执行exe文件：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&#x27;:Wine:M::MZ::/usr/bin/wine:&#x27;</span> &gt; /proc/sys/fs/binfmt_misc/<span class="keyword">register</span></span><br><span class="line">./application.exe</span><br></pre></td></tr></table></figure></div>

<p>我们echo语句的含义是：Windows可执行文件的前两个字节是magic number，值为MZ，由解释程序&#x2F;usr&#x2F;bin&#x2F;wine执行这个可执行文件。</p>
<p>关于ELF文件的加载执行，博客中很多其他文章有所介绍。</p>
<h2 id="exec与信号"><a href="#exec与信号" class="headerlink" title="exec与信号"></a>exec与信号</h2><p>exec系列函数，会将现有进程的所有文本段抛弃，直接奔向新生活。调用exec之前，进程可能执行过signal或sigaction，为某些信号注册了新的信号处理函数。一旦决裂，这些新的信号处理函数就无处可寻了。所以内核会为那些曾经改变信号处理函数的信号负责，将它们的处理函数重新设置为SIG_DFL。这里有一个特例，就是将处理函数设置为忽略（SIG_IGN）的SIGCHLD信号。调用exec之后，SIGCHLD的信号处理函数是保持为SIG_IGN还是重置成<code>SIG_DFL</code>，<code>SUSv3</code>语焉不详，这点要取决于操作系统。对于Linux系统而言，采用的是前者：保持为SIG_IGN。</p>
<h2 id="执行exec之后进程继承的属性"><a href="#执行exec之后进程继承的属性" class="headerlink" title="执行exec之后进程继承的属性"></a>执行exec之后进程继承的属性</h2><p>执行exec的进程，其个性虽然叛逆，与过去做了决裂，但是也继承了过去的一些属性。exec运行之后，与进程相关的ID都保持不变。如果进程在执行exec之前，设置了告警（如调用了alarm函数），那么在告警时间到时，它仍然会产生一个信号。在执行exec后，挂起信号依然保留。创建文件时，掩码umask和执行exec之前一样。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_119.jpg"
                      alt="epub_831302_119"
                ></p>
<p>通过fork创建的子进程继承的属性和执行exec之后进程保持的属性，两相比较，差异不小。对于fork而言：</p>
<ul>
<li>告警剩余时间：不仅仅是告警剩余时间，还有其他定时器（<code>setitimer</code>、timer_create等），fork创建的子进程都不继承。</li>
<li>进程挂起信号：子进程会将挂起信号初始化为空。</li>
<li>信号量调整值semadj：子进程不继承父进程的该值，详情请见进程间通信的相关章节。</li>
<li>记录锁（fcntl）：子进程不继承父进程的记录锁。比较有意思的地方是文件锁flock子进程是继承的。</li>
<li>已用的时间times：子进程将该值初始化成0。</li>
</ul>
<h1 id="system"><a href="#system" class="headerlink" title="system"></a>system</h1><p>前面提到了fork函数、exec系列函数、wait系列函数。库将这些接口糅合在一起，提供了一个system函数。程序可以通过调用system函数，来执行任意的shell命令。相信很多程序员都用过system函数，因为它起到了一个粘合剂的作用，可以让C程序很方便地调用其他语言编写的程序。同时，相信有很多程序员被system函数折磨过，当出现错误时，如何根据system函数的返回值，定位失败的原因是个比较头疼的问题。下面我们来细细展开。</p>
<h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这里将需要执行的命令作为<code>command</code>参数，传给system函数，该函数就帮你执行该命令。这样看来system最大的好处就在于使用方便。不需要自己来调用fork、exec和waitpid，也不需要自己处理错误，处理信号，方便省心。</p>
<p>但是system函数的缺点也是很明显的。首先是效率，使用system运行命令时，一般要创建两个进程，一个是shell进程，另外一个或多个是用于shell所执行的命令。如果对效率要求比较高，最好是自己直接调用fork和exec来执行既定的程序。从进程的角度来看，调用system的函数，首先会创建一个子进程shell，然后shell会创建子进程来执行command。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_121.jpg"
                      alt="epub_831302_121"
                ></p>
<p>调用system函数后，命令是否运行成功是我们最关心的事情。但是system的返回值比较复杂，下面通过一个简化的不完备（没有处理信号）的system实现来讲述system函数的返回值，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">char</span>* command)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status ;</span><br><span class="line">    <span class="type">pid_t</span> child;</span><br><span class="line">    <span class="keyword">switch</span>(child = fork())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            execl(<span class="string">&quot;/bin/sh),&quot;</span>sh<span class="string">&quot;,&quot;</span>-c<span class="string">&quot;,command,NULL);</span></span><br><span class="line"><span class="string">            _exit(127);</span></span><br><span class="line"><span class="string">        default:</span></span><br><span class="line"><span class="string">            while(waitpid(child,&amp;status,0) &lt; 0)</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                /*如果系统调用被中断，则重启系统调用*/</span></span><br><span class="line"><span class="string">                if(errno != EINTR)</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                        status = -1;</span></span><br><span class="line"><span class="string">                        break;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            else</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                 return status;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>当command为NULL时，返回0或1正常情况下，不会这样用system。但是command为NULL是有用的，用户可以通过调用<code>system(NULL)</code>来探测shell是否可用。如果shell存在并且可用，则返回1，如果系统里面压根就没有shell，这种情况下，shell就是不可用的，返回0。那么何种情况下shell不可用呢？比如system函数运行在非Unix系统上，再比如程序调用system之前，执行过了chroot，这些情况下shell都可能无法使用。</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">glibc<span class="number">-2.17</span>/sysdeps/posix/system.c</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="type">int</span></span><br><span class="line">__libc_system (<span class="type">const</span> <span class="type">char</span> *line)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (line == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> do_system (<span class="string">&quot;exit 0&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line">weak_alias (__libc_system, system)</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>创建进程（fork）失败，或者获取子进程终止状态（waitpid）失败，则返回-1创建进程失败的情况比较少见，比较容易想到的也就是创建了太多的进程，超出了系统的限制。但是等待子进程终止状态失败，是比较容易造出来的。前面讲过，子进程退出的时候，如果SIGCHLD的信号处理函数是SIG_IGN或用户设置了SA_NOCLDWAIT标志位，那么子进程就不进入僵尸状态等待父进程wait了，直接自行了断，灰飞烟灭。但是system函数的内部实现会调用waitpid来获取子进程的退出状态。这就是父子之前没有协调好造成的错误。这种情况下，system返回-1，errno为ECHLD。</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD,SIG_IGN);<span class="comment">/*返回-1的根源在于此处*/</span></span><br><span class="line"><span class="keyword">if</span>((status = system(command) )&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;system return %d (%s)\n&quot;</span>,status,strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>如果子进程不能执行shell，那么system返回值会与<code>_exit(127)</code>终止时一样</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里如果执行execl失败，就会执行到_exit（127），否则不会执行到_exit（127）。</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	execl(<span class="string">&quot;/bin/sh),&quot;</span>sh<span class="string">&quot;,&quot;</span>-c<span class="string">&quot;,command,NULL);</span></span><br><span class="line"><span class="string">    _exit(127);</span></span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><p>如果所有的系统调用都执行成功，system函数就会返回执行command的子shell的终止状态。因为shell的终止状态是其执行最后一条命令的退出状态。这种情况下就和获取子进程的退出状态一样了。前文详细提到过，可以根据下面的接口来判断：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(status)</span><br><span class="line">WEXITSTATUS(status)</span><br><span class="line">WIFSIGNALED(status)</span><br><span class="line">WTERMSIG(status)</span><br><span class="line">WCOREDUMP(status)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>综上所述，在command不等于NULL的情况下，正确判断system返回值的方法如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((status = system(command) ) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;system() function return -1 (%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == <span class="number">127</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;cannot invoke shell to exec command(%s)\n&quot;</span>,command);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    print_wait_exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="system与信号"><a href="#system与信号" class="headerlink" title="system与信号"></a>system与信号</h2><p>前面介绍了system函数的用法，并且引入了一个system函数的简单不完备的实现。之所以说是不完备的，是因为没有考虑信号。正确地处理信号，将会给system的实现带来复杂度。首先要考虑SIGCHLD。如果调用system函数的进程还存在其他子进程，并且对SIGCHLD信号的处理函数也执行了wait（）。那么这种情况下，由system（）创建的子进程退出并产生SIGCHLD信号时，主程序的信号处理函数就可能先被执行，导致system函数内部的waitpid无法等待子进程的退出，这就产生了竞争。这种竞争带来的危害是双方面的：</p>
<ul>
<li>程序会误认为自己调用fork创建的子进程退出了。</li>
<li>system函数内部的waitpid返回失败，无法获取内部子进程的终止状态。</li>
</ul>
<p>鉴于上述原因，system运行期间必须要暂时阻塞<code>SIGCHLD</code>信号。其他需要考虑的信号还有由终端的中断操作（一般是<code>ctrl+c</code>）和退出操作（一般是<code>ctrl+\</code>）产生的<code>SIGINT</code>信号和<code>SIGQUIT</code>信号。调用system函数会创建shell子进程，然后由shell子进程再创建子进程来执行command。那么这三个进程又是如何应对的呢？SUSv3标准规定：</p>
<ul>
<li>调用system函数的进程，需要忽略SIGINT和SIGQUIT信号。</li>
<li>system函数内部创建的进程，要恢复对SIGINT和SIGQUIT的默认处理。</li>
</ul>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>这部分内容在Linux 内核分析之进程中有较为详细的描述。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>就像人不可能一刻不停地工作一样，进程也无法始终占有CPU运行。原因有三：</p>
<ul>
<li>进程可能需要等待某种外部条件的满足，在条件满足之前，进程是无法继续执行的。这种情况下，该进程继续占有CPU就是对CPU资源的浪费。</li>
<li>Linux是多用户多任务的操作系统，可能同时存在多个可以运行的进程，进程个数可能远远多于CPU的个数。一个进程始终占有CPU对其他进程来说是不公平的，进程调度器会在合适的时机，选择合适的进程使用CPU资源。</li>
<li>Linux进程支持软实时，实时进程的优先级高于普通进程，实时进程之间也有优先级的差别。软实时进程进入可运行状态的时候，可能会发生抢占，抢占当前运行的进程。</li>
</ul>
<p>Linux下，进程的状态有以下7种：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_126.jpg"
                      alt="epub_831302_126"
                ></p>
<p><strong>可运行状态</strong></p>
<p>首先是可运行状态。该状态的名称为TASK_RUNNING，严格来说这个名字是不准确的，因为该状态的确切含义是可运行状态，并非一定是在占有CPU运行，将该状态称为TASK_RUNABLE会更准确。有人说Linux进程有8种状态，这种说法也是对的。因为TASK_RUNNIING可以根据是否在CPU上运行，进一步细分成RUNNING和READY两种状态（如图5-1所示）。处于READY状态的进程表示，它们随时可以投入运行，只不过由于CPU资源有限，调度器暂时并未选中它运行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_127.jpg"
                      alt="epub_831302_127"
                ></p>
<p>处于可运行状态的进程是进程调度的对象。如果进程并不处于可运行状态，进程调度器就不会选择它投入运行。在Linux中，每一个CPU都有自己的运行队列，事实上还不止一个，根据进程所属调度类别的不同，可运行状态的进程也会位于不同的队列上：如果是实时进程（属于实时调度类），则根据优先级的情况，落在相应的优先级的队列上；如果是普通进程（属于完全公平调度类），则根据虚拟运行时间的大小，落在红黑树的相应位置上。这样进程调度器就可以根据一定的算法从运行队列上挑选合适的进程来使用CPU资源。</p>
<p>处于RUNNING状态的进程，可能正在执行用户态（user-mode）代码，也可能正在执行内核态（kernel-mode）代码，内核提供了进一步的区分和统计。Linux提供的time命令可以统计进程在用户态和内核态消耗的CPU时间：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ time sleep <span class="number">2</span></span><br><span class="line">real    <span class="number">0</span>m2<span class="number">.009</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.001</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.002</span>s</span><br></pre></td></tr></table></figure></div>

<p>time命令统计了三种时间：实际时间、用户CPU时间和系统CPU时间。实际时间即进程从开始到终止，一共执行了多久。user一行统计的是进程执行用户态代码消耗的CPU时间；sys一行统计的是进程在内核态运行所消耗的CPU时间。</p>
<p>如何区分用户态CPU时间和内核态CPU时间呢？我们举例来说明。如果进程在执行加减乘除或浮点数计算或排序等操作时，尽管这些操作正在消耗CPU资源，但是和内核并没有太多的关系，CPU大部分时间都在执行用户态的指令。这种场景下，我们称CPU时间消耗在用户态。如果进程频繁地执行创建进程、销毁进程、分配内存、操作文件等操作，那么进程不得不频繁地陷入内核执行系统调用，这些时间都累加在进程的内核态CPU时间。对于这三种时间，最容易产生的误解的是real time&#x3D;user time+sys time。这种想法是错误的。在单核系统上，real time总是不小于user time与sys time的总和。但是在多核系统上，user time与sys time的总和可以大于real time。利用这三个时间，我们可以计算出程序的CPU使用率：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu_usage = ((user time) + (sys time))/(real time)</span><br></pre></td></tr></table></figure></div>

<p>在多核处理器情况下，cpu_usage如果大于1，则表示该进程是计算密集型（CPU bound）的进程，且cpu_usage的值越大，表示越充分地利用了多处理器的并行运行优势；如果<code>cpu_usage</code>的值小于1，则表示进程为I&#x2F;O密集型（I&#x2F;O bound）的进程，多核并行的优势并不明显。time命令的问题在于要等进程运行完毕后，才能获取到进程的统计信息，正所谓盖棺定论。有些时候，我们需要了解正在运行的进程：它运行了多久，内核态CPU时间和用户态CPU时间分别是多少？<code>procfs</code>在<code>/proc/PID/stat</code>中提供了相关的信息：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ cat /proc/<span class="number">8283</span>/stat</span><br><span class="line"><span class="number">8283</span> (stress) R <span class="number">8282</span> <span class="number">8282</span> <span class="number">7015</span> <span class="number">34817</span> <span class="number">8282</span> <span class="number">4218944</span> <span class="number">35</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15988</span> <span class="number">35</span> <span class="number">0</span> <span class="number">0</span> <span class="number">20</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">0</span> <span class="number">3551036</span> <span class="number">7405568</span> <span class="number">24</span> <span class="number">18446744073709551615</span> <span class="number">4194304</span> <span class="number">4213100</span> <span class="number">140736349760736</span> </span><br><span class="line">    <span class="number">140736349760296</span> <span class="number">139793990053869</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">17</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6311448</span> <span class="number">6312216</span> </span><br><span class="line">    <span class="number">17915904</span> <span class="number">140736349767962</span> <span class="number">140736349767974</span> <span class="number">140736349767974</span> <span class="number">140736349769704</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<p>数组中的每个字段都有自己独特的含义。如果从0开始计数，那么字段13对应的是进程消耗的用户态CPU时间，字段14记录的是进程消耗的内核态CPU时间。两者的单位是时钟嘀嗒（clock tick）。一个时钟嘀嗒是多久？可以通过如下命令来获取：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep CONFIG_HZ /boot/config-`uname -r`</span><br><span class="line">CONFIG_HZ_250=y</span><br><span class="line">CONFIG_HZ=<span class="number">250</span></span><br></pre></td></tr></table></figure></div>

<p>当配置内核的时候，有100Hz、250Hz、300Hz和1000Hz这4个选项。如果配置的频率为250Hz，那么1秒钟就有250个时钟嘀嗒，即每过4ms，增加一个时钟嘀嗒（内核的jiffies++）。<code>pidstat</code>可以通过<code>-p</code>参数指定观察的进程，从而可以获取到该进程的CPU使用情况，包括用户态CPU时间和内核态CPU时间。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ ps -p <span class="number">8283</span> -o etime,cmd,pid</span><br><span class="line">    ELAPSED CMD                            PID</span><br><span class="line">      <span class="number">02</span>:<span class="number">39</span> stress -c <span class="number">1</span>                    <span class="number">8283</span></span><br></pre></td></tr></table></figure></div>

<p><strong>可中断睡眠状态和不可中断睡眠状态</strong></p>
<p>进程并不总是处于可运行的状态。有些进程需要和慢速设备打交道。比如进程和磁盘进行交互，相关的系统调用消耗的时间是非常长的（可能在毫秒数量级甚至会更久），进程需要等待这些操作完成才可以执行接下来的指令。有些进程需要等待某种特定条件（比如进程等待子进程退出、等待socket连接、尝试获得锁、等待信号量等）得到满足后方可以执行，而等待的时间往往是不可预估的。在这种情况下，进程依然占用CPU就不合适了，对CPU资源而言，这是一种极大的浪费。因此内核会将该进程的状态改变成其他状态，将其从CPU的运行队列中移除，同时调度器选择其他的进程来使用CPU资源。</p>
<p>Linux存在两种睡眠的状态：可中断的睡眠状态（TASK_INTERRUPTIBLE）和不可中断的睡眠状态（TASK_UNINTERRUPTIBLE）。这两种睡眠状态是很类似的。两者的区别就在于能否响应收到的信号。处于可中断的睡眠状态的进程，返回到可运行的状态有以下两种可能性：</p>
<ul>
<li>等待的事件发生了，继续运行的条件满足了。</li>
<li>收到未被屏蔽的信号。</li>
</ul>
<p>当处于可中断睡眠状态的进程收到信号时，会返回EINTR给用户空间。程序员需要检测返回值，并做出正确的处理。</p>
<p>但是对于不可中断的睡眠状态，只有一种可能性能使其返回到可运行的状态，即等待的事件发生了，继续运行的条件满足了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_130.jpg"
                      alt="epub_831302_130"
                ></p>
<p><code>TASK_UNINTERRUPTIBLE</code>状态存在的意义在于，内核中某些处理流程是不应该被打断的，如果响应异步信号，程序的执行流程中就会插入一段用于处理异步信号的流程，原有的流程就被中断了。因此当进程在对某些硬件进行某些操作时（比如进程调用read系统调用对某个文件进行读操作，read系统调用最终执行对应设备驱动的代码，并与对应的物理设备交互），需要使用TASK_UNINTERRUPTIBLE状态把进程保护起来，以避免进程与设备的交互过程被打断，致使设备陷入不可控的状态。</p>
<p><code>TASK_UNINTERRUPTIBLE</code>是一种很危险的状态，因为进程进入该状态后，刀枪不入，任何信号都无法打断它。我们无法通过信号杀死一个处于不可中断的休眠状态的进程，SIGKILL信号也不行。</p>
<p>正常情况下，进程处于<code>TASK_UNINTERRUPTIBLE</code>状态的时间会非常短暂，进程不应该长时间处于不可中断的睡眠状态，但是这种情况确实可能会发生（内核代码流程中可能有bug，或者用户内核模块中的相关机制不合理都会导致某些进程长时间处于D状态）。举例来讲，当通过NFS访问远程目录时，异地文件系统的异常可能会使进程进入该状态。如果远端的文件系统始终异常，使进程的I&#x2F;O请求得不到满足，该进程会一直处于TASK_UNINTERRUPTIBLE状态，无法杀死，除了重启Linux机器之外，无药可救。</p>
<p>内核提供了<code>hung task</code>检测机制，它会启动一个名为khungtaskd的内核线程来检测处于TASK_UNINTERRUPTIBLE状态的进程是否已经失控。khungtaskd定期被唤醒（默认是120秒），它会遍历所有处于TASK_UNINTERRUPTIBLE状态的进程进行检查，如果某进程超过120秒未获得调度，那么内核就会打印出警告信息和该进程的堆栈信息。120秒这个时间是可以定制的，内核提供了控制选项：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@manu-rush:~<span class="meta"># sysctl  kernel.hung_task_timeout_secs</span></span><br><span class="line">    kernel.hung_task_timeout_secs = <span class="number">120</span></span><br></pre></td></tr></table></figure></div>

<p>关于<code>khungtaskd</code>的更多细节，可以阅读内核<code>kernel/hung_task.c</code>代码。无论进程处于可中断的睡眠状态，还是不可中断的睡眠状态，我们都可能会希望了解进程停在什么位置或在等待什么资源。procfs的wchan提供了这方面的信息，wchan是wait channel的含义。ps命令也可以通过wchan获得该信息：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ echo $$</span><br><span class="line"><span class="number">3828</span></span><br><span class="line">manu@manu-rush:~$ cat /proc/<span class="number">3828</span>/wchan</span><br><span class="line">do_wait</span><br><span class="line">manu@manu-rush:~$ ps -p <span class="number">3828</span> -o pid,wchan,cmd</span><br><span class="line">   PID WCHAN  CMD</span><br><span class="line">  <span class="number">3828</span> wait   -bash</span><br></pre></td></tr></table></figure></div>

<p>另外一种方法是查看进程的stack信息，方法如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ sudo cat /proc/<span class="number">3828</span>/<span class="built_in">stack</span></span><br><span class="line">[&lt;ffffffff8106d2c4&gt;] do_wait+<span class="number">0x1e4</span>/<span class="number">0x260</span></span><br><span class="line">[&lt;ffffffff8106e213&gt;] SyS_wait4+<span class="number">0xa3</span>/<span class="number">0x100</span></span><br><span class="line">[&lt;ffffffff8176847f&gt;] tracesys+<span class="number">0xe1</span>/<span class="number">0xe6</span></span><br><span class="line">[&lt;ffffffffffffffff&gt;] <span class="number">0xffffffffffffffff</span></span><br></pre></td></tr></table></figure></div>

<p>通过procfs的wchan和stack，不难看出，当前的bash正在等待子进程的退出。</p>
<p><strong>睡眠进程和等待队列</strong></p>
<p>进程无论是处于可中断的睡眠状态还是不可中断的睡眠状态，有一个数据结构是绕不开的：等待队列（wait queue）。进程但凡需要休眠，必然是等待某种资源或等待某个事件，内核必须想办法将进程和它等待的资源（或事件）关联起来，当等待的资源可用或等待的事件已发生时，可以及时地唤醒相关的进程。</p>
<p>内核采用的方法是等待队列。等待队列作为Linux内核中的基础数据结构和进程调度紧密地结合在一起。当进程需要等待特定事件时，就将其放置在合适的等待队列上，因此等待队列对应的是一组进入休眠状态的进程，当等待的事件发生时（或者说等待的条件满足时），这组进程会被唤醒，这类事件通常包括：中断（比如DISK I&#x2F;O完成）、进程同步、休眠时间到时等。内核使用双向链表来实现等待队列，每个等待队列都可以用等待队列头来标识，等待队列头的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>进程需要休眠的时候，需要定义一个等待队列元素，将该元素挂入合适的等待队列，等待队列元素的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WQ_FLAG_EXCLUSIVE   0x01</span></span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">    <span class="type">wait_queue_func_t</span> func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>等待队列上的每个等待队列元素，都对应于一个处于睡眠状态的进程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_131.jpg"
                      alt="epub_831302_131"
                ></p>
<p>内核如何使用等待队列完成睡眠，以及条件满足之后如何唤醒对应的进程呢？首先要定义和初始化等待队列头部。等待队列头部相当于一杆大旗，没有这杆大旗，将来的等待队列元素将成为“孤魂野鬼”，无处安放。内核提供了<code>init_waitqueue_head</code>和<code>DECLARE_WAIT_QUEUE_HEAD</code>两个宏，用来初始化等待队列头部。其次，当进程需要睡眠时，需要定义等待队列元素。内核提供了<code>init_waitqueue_entry</code>函数和<code>init_waitqueue_func_entry</code>函数来完成等待队列元素的初始化：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_waitqueue_entry</span><span class="params">(<span class="type">wait_queue_t</span> *q, <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    q-&gt;private = p;</span><br><span class="line">    q-&gt;func = default_wake_function;<span class="comment">/*通用的唤醒回调函数*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_waitqueue_func_entry</span><span class="params">(<span class="type">wait_queue_t</span> *q,</span></span><br><span class="line"><span class="params">                    <span class="type">wait_queue_func_t</span> func)</span></span><br><span class="line">&#123;</span><br><span class="line">    q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    q-&gt;private = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;func = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>除此以外，内核还提供了宏<code>DECLARE_WAITQUEUE</code>，也可用来初始化等待队列元素：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __WAITQUEUE_INITIALIZER(name, tsk) &#123;                \</span></span><br><span class="line"><span class="meta">    .private    = tsk,                      \</span></span><br><span class="line"><span class="meta">    .func       = default_wake_function,            \</span></span><br><span class="line"><span class="meta">    .task_list  = &#123; NULL, NULL &#125; &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk)                    \</span></span><br><span class="line"><span class="meta">    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br></pre></td></tr></table></figure></div>

<p>从等待队列元素的初始化函数或初始化宏不难看出，等待队列元素的private成员变量指向了进程的进程描述符task_struct，因此就有了等待队列元素，就可以将进程挂入对应的等待队列了。第三步是将等待队列元素（即睡眠进程）放入合适的等待队列中。内核同时提供了<code>add_wait_queue</code>和<code>add_wait_queue_exclusive</code>两个函数来把等待队列元素添加到等待队列头部指向的双向链表，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue(q, wait);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_wait_queue_exclusive</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue_tail(q, wait);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这两个函数的区别在于：</p>
<ul>
<li>一个等待队列元素设置了WQ_FLAG_EXCLUSIVE标志位，而另一个则没有。</li>
<li>一个等待队列元素放到了等待队列的尾部，而另一个则放到了等待队列的头部。</li>
</ul>
<p>同样是添加到等待队列，为何同时提供了两个函数，<code>WQ_FLAG_EXCLUSIVE</code>标志位到底有什么作用？不妨来思考如下问题：如果存在多个进程在等待同一个条件满足或同一个事件发生（即等待队列上有多个等待队列元素），那么当条件满足时，应该把所有进程一并唤醒还是只唤醒某一个或某几个进程？</p>
<p>答案是具体情况具体分析。有时候需要唤醒等待队列上的所有进程，但又有些时候唤醒操作需要具有排他性（EXCLUSIVE）。比如多个进程等待临界区资源，当锁的持有者释放锁时，如果内核将所有等待在该锁上的进程一起唤醒，那么最终也只能有一个进程竞争到锁资源，而大多数的竞争者，不过是从休眠中醒来，然后继续休眠，这会浪费CPU资源，如果等待队列中的进程数目很大，还会严重影响性能。这就是所谓的惊群效应（thundering herd problem）。</p>
<p>因此内核提供了<code>WQ_FLAG_EXCLUSEVE</code>标志位来实现互斥等待，<code>add_wait_queue_exclusive</code>函数会将带有该标志位的等待队列元素添加到等待队列的尾部。当内核唤醒等待队列上的进程时，等待队列元素中的<code>WQ_FLAG_EXCLUSEVE</code>标志位会影响唤醒行为，比如<code>wake_up</code>宏，它唤醒第一个带有<code>WQ_FLAG_EXCLUSEVE</code>标志位的进程后就会停止。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait_event(wq, condition)</span><br><span class="line">wait_event_timeout(wq, condition, timeout)</span><br><span class="line">wait_event_interruptible(wq, condition)</span><br><span class="line">wait_event_interruptible_timeout(wq, condition, timeout)</span><br></pre></td></tr></table></figure></div>

<p>第一个参数指向的是等待队列头部，表示进程会睡眠在该等队列上。进程醒来时，<code>condition</code>需要得到满足，否则继续阻塞。其中<code>wait_event</code>和<code>wait_event_interruptible</code>的区别在于，睡眠过程中，前者的进程状态是不可中断的睡眠状态，不能被信号中断，而后者是可中断的睡眠状态，可以被信号中断。名字中带有<code>_timeout</code>的宏意味着阻塞等待的超时时间，以<code>jiffy</code>为单位，当超时时间到达时，无论<code>condition</code>是否满足，均返回。我们不妨以<code>wait_event</code>宏为例，欣赏一下内核是如何使用等待队列，等待某个条件的满足的：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event(wq, condition)                   \</span></span><br><span class="line"><span class="meta">do &#123;                                    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (condition)                          \</span></span><br><span class="line"><span class="meta">        break;                          \</span></span><br><span class="line"><span class="meta">    __wait_event(wq, condition);                    \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event(wq, condition)                     \</span></span><br><span class="line"><span class="meta">do &#123;                                    \</span></span><br><span class="line"><span class="meta">    DEFINE_WAIT(__wait);                        \</span></span><br><span class="line"><span class="meta">                                    \</span></span><br><span class="line"><span class="meta">    for (;;) &#123;                          \</span></span><br><span class="line"><span class="meta">        prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE);    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (condition)                      \</span></span><br><span class="line"><span class="meta">            break;                      \</span></span><br><span class="line"><span class="meta">        schedule();                     \</span></span><br><span class="line"><span class="meta">    &#125;                               \</span></span><br><span class="line"><span class="meta">    finish_wait(&amp;wq, &amp;__wait);                  \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_to_wait</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait, <span class="type">int</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;wait-&gt;task_list))</span><br><span class="line">        __add_wait_queue(q, wait);</span><br><span class="line">    set_current_state(state);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>prepare_to_wait</code>函数负责将等待队列元素添加到对应的等待队列，同时将进程的状态设置成<code>TASK_UNINTERRUPTIBLE</code>，完成<code>prepare_to_wait</code>的工作后，会检查条件是否满足条件，如果条件不满足，则调用<code>schedule()</code>函数，主动让出CPU使用权，等待被唤醒。有睡眠就要有唤醒，有<code>wait_event</code>系列的宏，与之对应的，就要有<code>wake_up</code>系列的宏，它们必须成对出现。这一组宏有：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wake_up(x)</span><br><span class="line">wake_up_nr(x, nr)</span><br><span class="line">wake_up_all(x)</span><br><span class="line">wake_up_interruptible(x)</span><br><span class="line">wake_up_interruptible_nr(x, nr)</span><br><span class="line">wake_up_interruptible_all(x)</span><br></pre></td></tr></table></figure></div>

<p>这些宏和前面<code>wait_event</code>系列宏的配对使用情况如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_132.jpg"
                      alt="epub_831302_132"
                ></p>
<p>其中该系列宏中，名字里带<code>_interruptible</code>的宏只能唤醒处于<code>TASK_INTERRUPTIBLE</code>状态的进程，而名字中不带<code>_interruptible</code>的宏，既可以唤醒<code>TASK_INTERRUPTIBLE</code>状态的进程，也可以唤醒<code>TASK_UNINTERRUPTIBLE</code>状态的进程。<code>wake_up</code>系列函数中为什么有些函数后面有<code>_nr</code>和<code>_all</code>这样的后缀？其实不难猜到这些后缀的含义：不带后缀的表示最多只能唤醒一个带有<code>WQ_FLAG_EXCLUSIVE</code>标志位的进程，带<code>_nr</code>的表示可以唤醒<code>nr</code>个带有<code>WQ_FLAG_EXCLUSIVE</code>标志位的进程，而带<code>_all</code>后缀的则表示唤醒等待队列上的所有进程。这些<code>wake_up</code>系列的宏，其实现部分最终都是通过<code>__wake_up</code>函数的简单封装来实现的，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_133.jpg"
                      alt="epub_831302_133"
                ></p>
<p>下面来分析下<code>__wake_up</code>函数，看看内核是如何唤醒睡眠在等待队列上的进程的，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __wake_up(<span class="type">wait_queue_head_t</span> *q, <span class="type">unsigned</span> <span class="type">int</span> mode, <span class="type">int</span> nr_exclusive, <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __wake_up_common(q, mode, nr_exclusive, <span class="number">0</span>, key);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __wake_up_common(<span class="type">wait_queue_head_t</span> *q, <span class="type">unsigned</span> <span class="type">int</span> mode, <span class="type">int</span> nr_exclusive, <span class="type">int</span> wake_flags, <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wait_queue_t</span> *curr, *next;</span><br><span class="line">    <span class="comment">/*遍历等待队列头部对应的双向链表*/</span></span><br><span class="line">    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</span><br><span class="line">        <span class="type">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line">        <span class="comment">/*最多唤醒nr设置了排他性标志位的等待进程，以防止惊群*/</span></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;</span><br><span class="line">                (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意，遍历等待队列上的所有等待队列元素时，对于每一个需要唤醒的进程，执行的是等待队列元素中定义的func，最多唤醒<code>nr_exclusive</code>个带有<code>WQ_FLAG_EXCLUSIVE</code>的等待队列元素。在初始化等待队列元素的时候，需要注册回调函数func。当内核唤醒该进程时，就会执行等待队列元素中的回调函数。等待队列元素最常用的回调函数是<code>default_wake_function</code>，就像它的名字一样，是默认的唤醒回调函数。无论是<code>DECLARE_WAITQUEUE</code>还是<code>init_waitqueue_entry</code>，都将等待队列元素的func指向<code>default_wake_function</code>。而<code>default_wake_function</code>仅仅是大名鼎鼎的<code>try_to_wake_up</code>函数的简单封装，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">default_wake_function</span><span class="params">(<span class="type">wait_queue_t</span> *curr, <span class="type">unsigned</span> mode, <span class="type">int</span> wake_flags,</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> try_to_wake_up(curr-&gt;private, mode, wake_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>try_to_wake_up</code>是进程调度里非常重要的一个函数，它负责将睡眠的进程唤醒，并将醒来的进程放置到CPU的运行队列中，然后并设置进程的状态为<code>TASK_RUNNING</code>。在本章的后面会对该函数进行详细的分析。</p>
<p><strong>TASK_KILLABLE状态</strong></p>
<p>很多文章在介绍<code>TASK_UNINTERRUPTIBLE</code>状态时，都喜欢通过下面的例子来创建一个处于<code>TASK_UNINTERRUPTIBLE</code>状态的进程：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vfork())</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">root@manu-rush:~<span class="meta"># ps ax | grep state_d</span></span><br><span class="line">  <span class="number">5880</span> pts/<span class="number">2</span>    D+     <span class="number">0</span>:<span class="number">00</span> ./state_d</span><br><span class="line">  <span class="number">5881</span> pts/<span class="number">2</span>    S+     <span class="number">0</span>:<span class="number">00</span> ./state_d</span><br></pre></td></tr></table></figure></div>

<p>很多文章认为，调用vfork函数创建子进程时，子进程在调用exec函数或退出之前，父进程始终处于<code>TASK_UNINTERRUPTIBLE</code>的状态。其实这种说法是错误的。因为很明显，父进程可以轻易地被信号杀死，这证明父进程并不是处于<code>TASK_UNINTERRUPTIBLE</code>的状态。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@manu-hacks:~<span class="meta"># ps ax |grep state_d |grep -v grep</span></span><br><span class="line">  <span class="number">6787</span> pts/<span class="number">2</span>    D+     <span class="number">0</span>:<span class="number">00</span> ./state_d</span><br><span class="line">  <span class="number">6788</span> pts/<span class="number">2</span>    S+     <span class="number">0</span>:<span class="number">00</span> ./state_d</span><br><span class="line">root@manu-hacks:~<span class="meta"># kill -9 6787</span></span><br><span class="line">root@manu-hacks:~<span class="meta"># ps ax |grep state_d |grep -v grep</span></span><br><span class="line">  <span class="number">6788</span> pts/<span class="number">2</span>    S      <span class="number">0</span>:<span class="number">00</span> ./state_d 而在程序运行的终端</span><br><span class="line">manu@manu-hacks:~/code/me/c$ ./state_d</span><br><span class="line">Killed</span><br></pre></td></tr></table></figure></div>

<p>为什么进程的状态显示的是D+，按照ps命令的说法应该是处于不可中断的睡眠状态，可为什么仍然会被信号杀死呢？这好像和前面的讲述并不一致。</p>
<p>事实上，ps命令输出的D状态不能简单地理解成UNINTERRUPTIBLE状态。内核自2.6.25版本起引入了一种新的状态即TASK_KILLABLE状态。可中断的睡眠状态太容易被信号打断，与之对应，不可中断的睡眠状态完全不可以被信号打断，又容易失控，两者都失之极端。而内核新引入的TASK_KILLABLE状态则介于两者之间，是一种调和状态。该状态行为上类似于<code>TASK_UNINTERRUPTIBLE</code>状态，但是进程收到致命信号（即杀死一个进程的信号）时，进程会被唤醒。上面的例子中vfork创建子进程之后，ps显示父进程处于D的状态，却依然可以被杀死的原因就是进程并不是处于不可中断的睡眠状态，而是处于<code>TASK_KILLABLE</code>状态。而这种状态，是可以响应致命信号的。有了该状态，<code>wait_event</code>系列宏也增加了killable的变体，即<code>wait_event_killable</code>宏。该宏会将进程置为<code>TASK_KILLABLE</code>状态，同时睡眠在等待队列上。致命信号SIGKILL可以将其唤醒。</p>
<p><strong>TASK_STOPPED状态和TASK_TRACED状态</strong></p>
<p><code>TASK_STOPPED</code>状态是一种比较特殊的状态。SIGSTOP、SIGTSTP、SIGTTIN和SIGTTOU等信号会将进程暂时停止，停止后进程就会进入到该状态。上述4种信号中的SIGSTOP具有和SIGKILL类似的属性，即不能忽略，不能安装新的信号处理函数，不能屏蔽等。当处于<code>TASK_STOPPED</code>状态的进程收到SIGCONT信号后，可以恢复进程的执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_135.jpg"
                      alt="epub_831302_135"
                ></p>
<p><code>TASK_TRACED</code>是被跟踪的状态，进程会停下来等待跟踪它的进程对它进行进一步的操作。如何才能制造出处于<code>TASK_TRACED</code>状态的进程呢？最简单的例子是用gdb调试程序，当进程在断点处停下来时，此时进程处于该状态。下面用一个最简单的hello程序来验证gdb停下的程序的确处于<code>TASK_TRACED</code>的状态。在一个终端，gdb将程序停下，停在断点处：</p>
<p><code>TASK_TRACED</code>和<code>TASK_STOPPED</code>状态的类似之处是都处于暂停状态，不同之处是<code>TASK_TRACED</code>不会被SIGCONT信号唤醒。只有调试进程通过ptrace系统调用，下达<code>PTRACE_CONT</code>、<code>PTRACE_DETACH</code>等指令，或者调试进程退出，被调试的进程才能恢复<code>TASK_RUNNING</code>的状态。</p>
<p><strong>EXIT_ZOMBIE状态和EXIT_DEAD状态</strong></p>
<p>EXIT_ZOMBIE和EXIT_DEAD是两种退出状态，严格说来，它们并不是运行状态。当进程处于这两种状态中的任何一种时，它其实已经死去了。内核会将这两种状态记录在进程描述符的exit_state中，不过不想细分的话，可以笼统地说进程处于TASK_DEAD状态。</p>
<p>两种状态的区别在于，如果父进程没有将SIGCHLD信号的处理函数重设为SIG_IGN，或者没有为SIGCHLD设置SA_NOCLDWAIT标志位，那么子进程退出后，会进入僵尸状态等待父进程或init进程来收尸，否则直接进入EXIT_DEAD。如果不停留在僵尸状态，进程的退出是非常快的，因此很难观察到一个进程是否处于EXIT_DEAD状态。</p>
<hr>
<p>在proc文件系统中，在<code>/proc/PID/status</code>中，记录了PID对应进程的状态信息。其中State项记录了该进程的瞬时状态。因为进程状态是不断迁移变化的，所以读出来的结果是瞬时的值。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ <span class="built_in">cat</span> /proc/1/status</span><br><span class="line">Name:    init</span><br><span class="line">State:    S (sleeping)</span><br></pre></td></tr></table></figure></div>

<p>procfs中，进程的状态有几种可能的值呢？一起去查看内核的源码。在<code>fs/proc/array.c</code>中，定义了所有可能的值，定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line">    <span class="string">&quot;R (running)&quot;</span>,      <span class="comment">/*   0 */</span></span><br><span class="line">    <span class="string">&quot;S (sleeping)&quot;</span>,      <span class="comment">/*   1 */</span></span><br><span class="line">    <span class="string">&quot;D (disk sleep)&quot;</span>,   <span class="comment">/*   2 */</span></span><br><span class="line">    <span class="string">&quot;T (stopped)&quot;</span>,       <span class="comment">/*   4 */</span></span><br><span class="line">    <span class="string">&quot;t (tracing stop)&quot;</span>, <span class="comment">/*   8 */</span></span><br><span class="line">    <span class="string">&quot;Z (zombie)&quot;</span>,        <span class="comment">/*  16 */</span></span><br><span class="line">    <span class="string">&quot;X (dead)&quot;</span>,     <span class="comment">/*  32 */</span></span><br><span class="line">    <span class="string">&quot;x (dead)&quot;</span>,     <span class="comment">/*  64 */</span></span><br><span class="line">    <span class="string">&quot;K (wakekill)&quot;</span>,     <span class="comment">/* 128 */</span></span><br><span class="line">    <span class="string">&quot;W (waking)&quot;</span>,       <span class="comment">/* 256 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这几种状态都会从procfs中出现吗？并非如此。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">get_task_state</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> state = (tsk-&gt;state &amp; TASK_REPORT) | tsk-&gt;exit_state;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> *p = &amp;task_state_array[<span class="number">0</span>];</span><br><span class="line">    BUILD_BUG_ON(<span class="number">1</span> + ilog2(TASK_STATE_MAX) != ARRAY_SIZE(task_state_array));</span><br><span class="line">    <span class="keyword">while</span> (state) &#123;</span><br><span class="line">        p++;</span><br><span class="line">        state &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>只有在TASK_REPORT宏出现的状态加上两个退出状态时，才能出现在procfs中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_REPORT     (TASK_RUNNING | TASK_INTERRUPTIBLE | \</span></span><br><span class="line"><span class="meta">					TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span></span><br><span class="line"><span class="meta">            		__TASK_TRACED)</span></span><br></pre></td></tr></table></figure></div>

<p>从TASK_REPORT宏中可以看出，并没有<code>TASK_DEAD</code>、<code>TASK_WAKEKILL</code>和<code>TASK_WAKING</code>，也就是说在procfs中，无法观察到下面这三个值，它们从不出现：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;x (dead)&quot;</span>,             <span class="comment">/*  64 */</span></span><br><span class="line"><span class="string">&quot;K (wakekill)&quot;</span>,         <span class="comment">/* 128 */</span></span><br><span class="line"><span class="string">&quot;W (waking)&quot;</span>,           <span class="comment">/* 256 */</span></span><br></pre></td></tr></table></figure></div>

<p>在vfork那个例子中，在procfs中查询进程状态时，父进程处于D（disk sleep）状态，而并没有出现K（wakekill），原因就在于此。那么是时候记住，会在procfs中出现的进程状态了：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;R (running)&quot;</span>,</span><br><span class="line"><span class="string">&quot;S (sleeping)&quot;</span>,</span><br><span class="line"><span class="string">&quot;D (disk sleep)&quot;</span>,</span><br><span class="line"><span class="string">&quot;T (stopped)&quot;</span>,</span><br><span class="line"><span class="string">&quot;t (tracing stop)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Z (zombie)&quot;</span>,</span><br><span class="line"><span class="string">&quot;X (dead)&quot;</span>,</span><br></pre></td></tr></table></figure></div>

<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度器是对处于可运行（TASK_RUNNING）状态的进程进行调度，如果进程并非TASK_RUNNING的状态，那么该进程和进程调度是没有关系的。</p>
<p>Linux是多任务的操作系统，所谓多任务是指系统能够同时并发地执行多个进程，哪怕是单处理器系统。在单处理器系统上支持多任务，会给用户多个进程同时跑的幻觉，事实上多个进程仅仅是轮流使用CPU资源。只有在多处理器系统中，多个进程才能真正地做到同时、并行地执行。多任务系统可以根据是否支持抢占分成两类：非抢占式多任务和抢占式多任务。在非抢占式多任务的系统中，下一个任务被调度的前提是当前进程主动让出CPU的使用权，因此非抢占式多任务又称为合作型多任务。而抢占式多任务由操作系统来决定进程调度，在某些时间点上，操作系统可以将正在运行的进程调度出去，选择其他进程来执行。毫无疑问，Linux属于抢占式多任务系统。事实上，大多数的现代操作系统都是抢占式的多任务系统。</p>
<p>此外，不同的进程之间，其行为模式可能存在着巨大的差异。进程的行为模式可以粗略地分成两类：CPU消耗型（CPU bound）和I&#x2F;O消耗型（I&#x2F;O bound）。所谓CPU消耗型是指进程因为没有太多的I&#x2F;O需求，始终处于可运行的状态，始终在执行指令。而I&#x2F;O消耗型是指进程会有大量I&#x2F;O请求（比如等待键盘键入、读写块设备上的文件、等待网络I&#x2F;O等），它处于可执行状态的时间不多，而是将更多的时间耗费在等待上。当然这种划分方法并非绝对的，可能有些进程某段时间表现出CPU消耗型的特征，另一段时间又表现出I&#x2F;O消耗型的特征。</p>
<p>还有另外一种进程分类的方法，如下。</p>
<ul>
<li>交互型进程：这种类型的进程有很多的人机交互，进程会不断地陷入休眠状态，等待键盘和鼠标的输入。但是这种进程对系统的响应时间要求非常高，用户输入之后，进程必须被及时唤醒，否则用户就会觉得系统反应迟钝。比较典型的例子是文本编辑程序和图形处理程序等。</li>
<li>批处理型进程：这类进程和交互型的进程相反，它不需要和用户交互，通常在后台执行。这样的进程不需要及时的响应。比较典型的例子是编译、大规模科学计算等，一般来说，这种进程总是“被侮辱的和被损害的”。</li>
<li>实时进程：这类进程优先级比较高，不应该被普通进程和优先级比它低的进程阻塞。一般需要比较短的响应时间。</li>
</ul>
<p>计一个优秀的进程调度器绝不是一件容易的事情，它还有很多事情需要考虑，很多目标需要达成：</p>
<ul>
<li>公平：每一个进程都可以获得调度的机会，不能出现“饿死”的现象。</li>
<li>良好的调度延迟：尽量确保进程在一定的时间范围内，总能够获得调度的机会。</li>
<li>差异化：允许重要的进程获得更多的执行时间。</li>
<li>支持软实时进程：软实时进程，比普通进程具有更高的优先级。</li>
<li>负载均衡：多个CPU之间的负载要均衡，不能出现一些CPU很忙，而另一些CPU很闲的情况。·高吞吐量：单位时间内完成的进程个数尽可能多。</li>
<li>简单高效：调度算法要高效。不应该在调度上花费太长的时间。</li>
<li>低耗电量：在系统并不繁忙的情况下，降低系统的耗电量。</li>
</ul>
<p>在对称多处理器（SMP）的系统上，存在着多个处理器，那么所有处于可运行状态的进程是应该位于一个队列上，还是每个处理器都要有自己的队列？这大概是进程调度首先要解决的问题。目前Linux采用的是每个CPU都要有自己的运行队列，即per cpu run queue。每个CPU去自己的运行队列中选择进程，这样就降低了竞争。这种方案还有另外一个好处：缓存重利用。某个进程位于这个CPU的运行队列上，经过多次调度之后，内核趋于选择相同的CPU执行该进程。这种情况下上次运行的变量很可能仍然在CPU的缓存中，这样就提升了效率。</p>
<p>Linux选择了每一个CPU都有自己的运行队列这种解决方案。这种选择也带来了一种风险：CPU之间负载不均衡，可能出现一些CPU闲着而另外一些CPU忙不过来的情况。为了解决这个问题，load_balance就闪亮登场了。load_balance的任务就是在一定的时机下，通过将任务从一个CPU的运行队列迁移到另一个CPU的运行队列，来保持CPU之间的负载均衡。进程调度具体要做哪些事情呢？概括地说，进程调度的职责是挑选下一个执行的进程，如果下一个被调度到的进程和调度前运行的进程不是同一个，则执行上下文切换，将新选择的进程投入运行。下面根据调度的入口点函数schedule（）来看下进程调度做了哪些事情，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __sched <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">    sched_submit_work(tsk);</span><br><span class="line">    __schedule();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __sched __schedule(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *switch_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line">need_resched:</span><br><span class="line">    preempt_disable();</span><br><span class="line">    cpu = smp_processor_id();</span><br><span class="line">    rq = cpu_rq(cpu);</span><br><span class="line">    rcu_note_context_switch(cpu);</span><br><span class="line">    prev = rq-&gt;curr;</span><br><span class="line">    schedule_debug(prev);</span><br><span class="line">    <span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">        hrtick_clear(rq);</span><br><span class="line">    raw_spin_lock_irq(&amp;rq-&gt;lock);</span><br><span class="line">    switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev))) &#123;</span><br><span class="line">            prev-&gt;state = TASK_RUNNING;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*先前的进程不再处于可执行状态，需要将其从运行队列中移除出去*/</span></span><br><span class="line">            deactivate_task(rq, prev, DEQUEUE_SLEEP);</span><br><span class="line">            prev-&gt;on_rq = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;flags &amp; PF_WQ_WORKER) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">to_wakeup</span>;</span></span><br><span class="line">                to_wakeup = wq_worker_sleeping(prev, cpu);</span><br><span class="line">                <span class="keyword">if</span> (to_wakeup)</span><br><span class="line">                    try_to_wake_up_local(to_wakeup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*调度之前的准备工作*/</span></span><br><span class="line">    pre_schedule(rq, prev);<span class="comment">/*当前CPU运行队列上没有可运行的进程了，太闲了，需要负载均衡*/</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!rq-&gt;nr_running))</span><br><span class="line">        idle_balance(cpu, rq);</span><br><span class="line">    <span class="comment">/*将被抢占的进程放入指定的合适的位置*/</span></span><br><span class="line">    put_prev_task(rq, prev);</span><br><span class="line">    <span class="comment">/*挑选下一个执行的进程*/</span></span><br><span class="line">    next = pick_next_task(rq);</span><br><span class="line">    <span class="comment">/*清除被抢占进程的需要调度的标志位*/</span></span><br><span class="line">    clear_tsk_need_resched(prev);</span><br><span class="line">    rq-&gt;skip_clock_update = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*如果选中的进程与原进程不是同一个进程，则需要上下文切换*/</span></span><br><span class="line">    <span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">        rq-&gt;nr_switches++;</span><br><span class="line">        rq-&gt;curr = next;</span><br><span class="line">        ++*switch_count;</span><br><span class="line">        <span class="comment">/*上下文切换，切换之后，新选中的进程投入执行*/</span></span><br><span class="line">        context_switch(rq, prev, next);</span><br><span class="line">        cpu = smp_processor_id();</span><br><span class="line">        rq = cpu_rq(cpu);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        raw_spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line">    post_schedule(rq);</span><br><span class="line">    preempt_enable_no_resched();</span><br><span class="line">    <span class="keyword">if</span> (need_resched())</span><br><span class="line">        <span class="keyword">goto</span> need_resched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Linux是可抢占式内核（Preemptive Kernel），从内核2.6版本开始，Linux不仅支持用户态抢占，也开始支持内核态抢占。可抢占式内核的优势在于可以保证系统的响应时间。当高优先级的任务一旦就绪，总能及时得到CPU的控制权。但是很明显，内核抢占不能随意发生，某些情况下是不允许发生内核抢占的。因此为了更好地支持内核抢占，内核为每一个进程的thread_info引入了preempt_count计数器，数值为0时表示可以抢占，当该计数器的值不为0时，表示禁止抢占。</p>
<p>并不是所有的时机都允许发生内核抢占。以自旋锁为例，在内核可抢占的系统中，自旋锁持有期间不允许发生内核抢占，否则可能会导致其他CPU长期不能获得锁而死等。因此在<code>spin_lock</code>函数中（通过<code>__raw_spin_lock</code>），会调用<code>preempt_disable</code>宏，而该宏会将进程<code>preempt_count</code>计数器的值加1，表示不允许抢占。同样的道理，解锁的时候，会将<code>preempt_count</code>的值减1（通过<code>preempt_enable</code>宏）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">    LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>preempt_count</code>的<code>Bit 28</code>是一个很重要的标志位，即<code>PREEMPT_ACTIVE</code>。该标志位用来标记是否正在进行内核抢占。很明显，设置了该标志位之后，<code>preempt_count</code>就不再为0了，因此也就不允许再次发生内核抢占，从而使得正在执行抢占工作的代码不会再次被抢占。内核的<code>preempt_schedule</code>函数是内核抢占时呼叫调度器的入口，它会调用<code>__schedule</code>函数发起调度。在调用<code>__schedule</code>函数之前，会设置进程的<code>PREEMPT_ACTIVE</code>标志位，表示这是从抢占过程中进入<code>__schedule</code>函数的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __sched notrace <span class="title function_">preempt_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> =</span> current_thread_info();</span><br><span class="line">    <span class="keyword">if</span> (likely(ti-&gt;preempt_count || irqs_disabled()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        add_preempt_count_notrace(PREEMPT_ACTIVE);</span><br><span class="line">        __schedule();</span><br><span class="line">        sub_preempt_count_notrace(PREEMPT_ACTIVE);</span><br><span class="line">        barrier();</span><br><span class="line">    &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在<code>__schedule</code>函数中，内核会检查进程的<code>PREEMPT_ACTIVE</code>标志位，如果发现了该标志位置位，就不会调用<code>deactivate_task</code>函数将其从运行队列中移除。<code>PREEMPT_ACTIVE</code>标志位有一个非常重要的作用，即防止不处于<code>TASK_RUNNING</code>状态的进程被抢占过程错误地从运行队列中移除。这句话非常地绕，我们结合<code>__schedule</code>函数的对应代码来分析该标志位的作用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev))) &#123;</span><br><span class="line">        prev-&gt;state = TASK_RUNNING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deactivate_task(rq, prev, DEQUEUE_SLEEP);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果进程设置了<code>PREEMPT_ACTIVE</code>标志位，上述代码最外层的条件就不会得到满足。这么做的用意是：如果进程是被抢占而进入了<code>schedule</code>函数，那么即使它不处于<code>TASK_RUNNING</code>状态，也不能把它从运行队列中移除。为什么这么做？从运行队列中移除不处于TASK_RUNNING状态的进程是schedule函数份内之事，为什么设置了<code>PREEMPT_ACTIVE</code>标志位就不能移除呢？原因是进程从TASK_RUNNING变成其他状态，是一个过程，在这个过程中可能发生抢占。试想如下场景：一个进程刚把自己设置成<code>TASK_INTERRUPTIBLE</code>，它就被抢占了。因为这时候它还没来得及调用<code>schedule（）</code>主动交出CPU控制权，仍然在CPU上执行，这就是非TASK_RUNNING状态的进程也会被抢占的场景。对于这种场景，抢占流程不应擅自将其从运行队列中移除，因为它的切换过程并未完成。下面的代码在wait_event系列宏中不断出现，我们以它为例分析上面提到的问题：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE);</span><br><span class="line">    <span class="keyword">if</span> (condition)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行完<code>prepare_to_wait</code>语句，本来是要检查条件是否满足的，如果这时候被抢占，假如没有PREEMPT_ACTIVE标志位，那么抢占过程中调用的<code>__schedule</code>函数就会将进程从运行队列中移除。如果本来condition条件满足了，那就错过了唤醒的机会，也许就会永远休眠了。正确的做法是，继续保留在运行队列中，后面还有机会被调度到继续运行，恢复运行后继续判断条件是否满足。上面讨论了抢占的情况，如果进程不处于TASK_RUNNING的状态，并且PREEMPT_ACTIVE并没有置位，那么就有可能会调用<code>deactivate_task</code>函数将其从运行队列中移除。这里说可能是因为，该进程可能存在尚未处理的信号，如果是这种情况它并不会被移除出运行队列，相反会被再次设置成TASK_RUNNING的状态，获得再次被调度到的机会。</p>
<p><code>__schdule</code>函数的基本流程如图所示。流程图中带有背景色的部分都是调度框架里的hook点。内核的进程调度是模块化的，实现一个新的调度算法，只需要实现一组框架需要的钩子函数即可，内核将会在合适的时机调用这些函数。不妨以<code>deactivate_task</code>为例，来看下调度框架与具体调度算法中的函数之间的关系。<code>deactivate_task</code>函数的职责可以顾名思义，即进程不再处于TASK_RUNNING的状态，需要将其从对应的运行队列中移除。因此其实现为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deactivate_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (task_contributes_to_load(p))</span><br><span class="line">        rq-&gt;nr_uninterruptible++;</span><br><span class="line">    dequeue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dequeue_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    update_rq_clock(rq);</span><br><span class="line">    sched_info_dequeued(p);</span><br><span class="line">    p-&gt;sched_class-&gt;dequeue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>内核会调用进程所属调度类的<code>dequeue_task</code>函数，至于调度类的<code>dequeue_task</code>函数具体做了哪些事情，完全由具体的调度类来决定。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_141.jpg"
                      alt="epub_831302_141"
                ></p>
<p>调用schedule函数时，当前进程可能仍然处于可运行的状态（主动让出CPU或被其他进程抢占），因此选择下一个占用CPU的进程之前，需要调用<code>put_prev_task</code>函数。该函数的目的是，当前进程被调度出去之前，留给具体调度算法一个时机来更新内部的状态。和<code>deactivate_task</code>函数一样，根据当前进程所属的调度类，调用具体的<code>put_prev_task</code>函数。</p>
<p>Linux内核实现了如下4种调度类：</p>
<ul>
<li>stop_sched_class：停止类</li>
<li>rt_sched_class：实时类</li>
<li>fair_sched_class：完全公平调度类</li>
<li>idle_sched_class：空闲类</li>
</ul>
<p>这4种调度类是按照优先级顺序排列的，停止类（stop_sched_class）具有最高的调度优先级，与之对应的，空闲类（idle_sched_class）具有最低的调度优先级。进程调度器挑选下一个执行的进程时，会首先从停止类中挑选进程，如果停止类中没有挑选到可运行的进程，再从实时类中挑选进程，依此类推。</p>
<p><code>pick_next_task</code>函数负责挑选下一个运行的进程，从其实现逻辑中可以看出，系统是按照优先级顺序从调度类中挑选进程的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *</span><br><span class="line"><span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">/*此处是优化，若所有任务都属于公平类，则直接从公平类中挑选下一个类*/</span></span><br><span class="line">    <span class="keyword">if</span> (likely(rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class="line">        p = fair_sched_class.pick_next_task(rq);</span><br><span class="line">        <span class="keyword">if</span> (likely(p))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*按照调度类的优先级，从高到低挑选下一个进程，直到挑选到为止*/</span></span><br><span class="line">    for_each_class(class) &#123;</span><br><span class="line">        p = class-&gt;pick_next_task(rq);</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_142.jpg"
                      alt="epub_831302_142"
                ></p>
<p>优先级最高的停止类进程，主要用于多个CPU之间的负载均衡和CPU的热插拔，它所做的事情就是停止正在运行的CPU，以进行任务的迁移或插拔CPU。优先级最低的空闲类，负责将CPU置于停机状态，直到有中断将其唤醒。<code>idle_sched_class</code>类的空闲任务只有在没有其他任务的时候才能被执行。每一个CPU只有一个停止任务和一个空闲任务。从上面的职责描述也可以看出，这两种调度类属于诸神之战，和应用层的关系并不大。应用层无法将进程设置成停止类进程或空闲类进程。和应用层关系比较密切的两种调度类是实时类和完全公平调度类，尤其是完全公平调度类。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>事实上，除非将Linux用在特定的领域，否则在大部分时间里所有可运行的进程都属于完全公平调度类。从内核代码pick_next_task函数（该函数负责挑选下一个进程放到CPU上执行）中所做的优化可见一斑。Linux是多任务系统，在存在多个可运行进程的情况下，系统不能放任当前进程始终占着CPU。每个进程运行多长时间，是任何一个调度算法都不能回避的问题。传统的调度算法面临着一种困境，那就是时间片到底多大才合适？如果时间片太大，进程执行前需要等待的时间就会变长，当CPU运行队列上可运行进程的个数比较多的时候尤为明显，用户可能会感觉到明显的延迟。如果时间片太短，进程调度的频率就会增加，考虑到上下文切换也需要花费时间，可以想见，大量的时间都浪费到了进程调度上。</p>
<p>完全公平调度，使用了一种动态时间片的算法。它给每个进程分配了使用CPU的时间比例。进程调度设计上，有一个很重要的指标是调度延迟，即保证每一个可运行的进程都至少运行一次的时间间隔。比如调度延迟是20毫秒，如果运行队列上只有2个同等优先级的进程，那么可以允许每个进程执行10毫秒，如果运行队列上是4个同等优先级的进程，那么，每个进程可以运行5毫秒。如果可运行的进程比较少，采用这种算法则没有问题。可是如果运行队列上有200个同等优先级的进程怎么办？每个进程运行0.1毫秒？这可不是个好主意。因为时间片太小，进程调度过于频繁，上下文切换的开销就不能忽视了。为了应对这种情况，完全公平调度提供了另一种控制方法：调度最小粒度。调度最小粒度指的是任一进程所运行的时间长度的基准值。任何一个进程，只要分配到了CPU资源，都至少会执行调度最小粒度的时间，除非进程在执行过程中执行了阻塞型的系统调用或主动让出CPU资源（通过<code>sched_yield</code>调用）。在Linux操作系统中，调度延迟被称为<code>sysctl_sched_latency</code>，记录在<code>/proc/sys/kernel/sched_latency_ns</code>中，而调度最小粒度被称为<code>sysctl_sched_min_granularity</code>，记录在<code>/proc/sys/kernel/sched_min_granularity_ns</code>中，两者的单位都是纳秒。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/sched_latency_ns</span><br><span class="line"><span class="number">12000000</span></span><br><span class="line">cat /proc/sys/kernel/sched_min_granularity_ns</span><br><span class="line"><span class="number">1500000</span></span><br></pre></td></tr></table></figure></div>

<p>调度延迟和调度最小粒度综合起来看是比较有意思的，它反映了在调度延迟内允许的最大活动进程数目。这个值被称为sched_nr_latency。如果运行队列上可运行状态的进程太多，超出了该值，调度最小粒度和调度延迟两个目标则不可能被同时实现。内核并没有提供参数来指定sched_nr_latency，它的值完全是由调度延迟和调度最小粒度来决定的。计算公式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_143.jpg"
                      alt="epub_831302_143"
                ></p>
<p>因此调度延迟是一个尽力而为的目标。当可运行的进程个数小于sched_nr_latency的时候，调度周期总是等于调度延迟（sysctl_sched_latency）。但是如果可运行的进程个数超过了sched_nr_latency，系统就会放弃调度延迟的承诺，转而保证调度最小粒度。在这种情况下调度周期等于最小粒度乘以可运行进程的个数，代码如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u64 __sched_period(<span class="type">unsigned</span> <span class="type">long</span> nr_running)</span><br><span class="line">&#123;</span><br><span class="line">    u64 period = sysctl_sched_latency;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_latency = sched_nr_latency;<span class="comment">/*进程个数过多，无法保证调度延迟，只能保证调度最小粒度*/</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nr_running &gt; nr_latency)) &#123;</span><br><span class="line">        period = sysctl_sched_min_granularity;</span><br><span class="line">        period *= nr_running;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> period;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述函数并不难理解：</p>
<ul>
<li>若运行队列中进程个数小于或等于sched_nr_latency，那么调度周期等于调度延迟。</li>
<li>若运行队列中进程个数大于sched_nr_latency，那么调度周期则等于可运行进程个数与调度最小粒度的乘积。</li>
</ul>
<p>有了调度周期，我们就可以计算，分配给进程的运行时间了：</p>
<p><strong>分配给进程的运行时间＝调度周期*1&#x2F;运行队列上进程个数</strong></p>
<p>到目前为止，所有的讨论都是基于运行队列上所有的进程都有相同的优先级这个假设。但真实情况并非如此，有些任务优先级比较高，理应获得更多的运行时间。考虑到这种情况，完全公平调度又引入了优先级的概念。完全公平调度通过引入调度权重来实现优先级，进程之间按照权重的比例，分配CPU时间。引入权重后，调度周期内分配给进程的运行时间的计算公式如下：</p>
<p><strong>分配给进程的运行时间＝调度周期*进程权重&#x2F;运行队列所有进程权重之和</strong></p>
<p>Linux下每一个进程都有一个nice值，该值的取值范围是[-20，19]，其中nice值越高，表示优先级越低。默认的优先级是0。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"><span class="comment">/* -20 */</span>      <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这个数组基本是通过如下公式来获得的：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weight = <span class="number">1024</span> / (<span class="number">1.25</span> ^ nice_value)</span><br></pre></td></tr></table></figure></div>

<p>其中普通进程的nice值等于0，其权重为基准的1024。nice值为0的进程权重被称为NICE_0_LOAD。当nice值为1时，权重等于1024&#x2F;1.25，约等于820，当nice值为2时，权重等于1024&#x2F;（1.25^2）。</p>
<p>Linux提供了如下函数来获取和修改进程的nice值：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">int</span> who)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">int</span> who, <span class="type">int</span> prio)</span>;</span><br></pre></td></tr></table></figure></div>

<p>两个系统调用的头两个参数都是which和who，这两个参数用于标识需要读取和修改优先级的进程。who参数如何解释，取决于which参数的值，具体如下：</p>
<ul>
<li>PRIO_PROCESS：操作进程ID为who的进程，如果who为0，那么使用调用者的进程ID。</li>
<li>PRIO_PGRP：操作进程组ID为who的进程组的所有成员。如果who等于0，那么使用调用者的进程组ID。</li>
<li>PRIO_USER：操作所有真实用户ID为who的进程。如果who等于0，使用调用者的真实用户ID。</li>
</ul>
<p>getpriority函数返回which和who指定进程的nice值。如果存在多个进程符合指定的标准，那么返回优先级最高的那个nice值（即nice值最小的那个）。因为进程优先级的范围为[-20，19]，所以成功的时候，返回值也可能是-1。因此，不能用返回值是不是-1来判断调用是成功还是失败。正确的方法是，调用前将errno设置成0，然后调用getpriority函数。如果返回值是-1，并且errno不是0，才能确定调用失败。否则，调用成功。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>；</span><br><span class="line">prio = getpriority(which,who);</span><br><span class="line"><span class="keyword">if</span>(prio == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*error handle*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>setpriority函数的返回值并不存在getpriority函数的困境。其成功时返回0，失败时返回-1，并置errno。常见的errno见表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_146.jpg"
                      alt="epub_831302_146"
                ></p>
<p>对于其中的EACCESS错误码，这里仔细说明一下。在早期版本的Linux中非特权进程不能提升优先级，只能降低优先级。但在现在的Linux中，非特权进程也能适当地提升进程的优先级了。Linux提供了RLIMIT_NICE资源限制。如果一个进程的RLIMIT_NICE限制为25，那么其nice值可以提升到20-25＝-5。详情可以查看getrlimit函数的手册。调整进程的优先级会有什么影响？完全公平调度算法里，优先级比较高（nice值比较低）的进程会获得更多的CPU时间。比如，有两个进程位于CPU的运行队列上，一个nice值是0（权重是1024），另外一个nice值是5（权重是335），按照前面的权重可以推算出，nice值为0的进程获得CPU的时间应该是nice值为5的3倍。可以通过一个简单的测试来验证这个结论：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">heavy_work</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + <span class="built_in">sin</span>(i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> <span class="built_in">set</span> ;</span><br><span class="line">    CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">    CPU_SET(<span class="number">0</span>,&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="type">int</span> ret  = sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>),&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;failed to bind the process to cpu 0 (%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = fork();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        ret = setpriority(PRIO_PROCESS,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[%d] failed to change nice value (%s)\n&quot;</span>, getpid(),strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heavy_work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的程序设置了进程的CPU亲和力，父子进程都将运行在CPU 0上，不过，子进程首先调用setpriority函数将自己的nice值设置成了5，而父进程的nice值是默认值0。父子进程都是CPU bound型的程序，始终处于可运行状态。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ ps -C nice_test -o pid,ppid,cmd,etime,<span class="built_in">nice</span>,pri,psr</span><br><span class="line">   PID   PPID CMD                             ELAPSED  NI PRI PSR</span><br><span class="line">  3885   2695 ./nice_test                       35:02   0  19   0</span><br><span class="line">  3886   3885 ./nice_test                       35:02   5  14   0</span><br></pre></td></tr></table></figure></div>

<p>通过NI这一列可以看出，父进程的nice值是0，而子进程的nice值是5。父进程占用的CPU时间应该是子进程的三倍左右。通过<code>/proc/PID/sched</code>可以查看这些调度的信息，其中se_sum_exec_runtime的含义是累计运行的物理时间。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">se.sum_exec_runtime                     :       1584276.837760 父进程	</span><br><span class="line">se.sum_exec_runtime                     :       518296.243156  子进程</span><br></pre></td></tr></table></figure></div>

<p>那么我们比较一下：1024÷335≈3.05671584276.837760÷518296.243156≈3.0567从执行时间上可以看出，执行时间几乎完美地符合权重比。原因就是决定每个进程运行时间片的时候，是根据权重来计算的。有意思的是，如果CPU运行队列上的两个进程的nice值分别是10和15，那么两者占用的CPU时间的比例依然约等于3：1。原因是绝对的nice值并不影响调度决策，而是运行队列上进程间的优先级相对值，影响了CPU时间的分配。</p>
<h2 id="完全公平调度"><a href="#完全公平调度" class="headerlink" title="完全公平调度"></a>完全公平调度</h2><h3 id="时间片和虚拟运行时间"><a href="#时间片和虚拟运行时间" class="headerlink" title="时间片和虚拟运行时间"></a>时间片和虚拟运行时间</h3><p>在进程优先级都相等的情况下，时间记账是一个非常好的方法，但是优先级的存在，给时间记账带来了一定的麻烦。有些进程优先级比较高，理应获得更多的CPU时间，这种情况下如何进行时间记账？Linux引入了虚拟运行时间来解决这个记账的问题。假设CPU运行队列上有两个进程需要调度，nice值分别为0和5，两者的权重比是3：1，调度周期为20毫秒。那么按照公式，第一个进程应该运行15毫秒，接着第二个进程运行5毫秒。尽管两个进程在调度周期内的实际运行时间不同，但是我们希望第一个进程的15毫秒和第二个进程的5毫秒，时间记账是相等的。即：第一个进程15毫秒的记账值＝第二个进程的5毫秒的记账值这样两个进程就能根据时间记账值的大小交替执行了。这种时间加权记账的思想就是完全公平调度的核心了。</p>
<p>Linux内核定义了调度实体结构体，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>  <span class="title">load</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>      <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">group_node</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        on_rq;</span><br><span class="line">    u64         exec_start;</span><br><span class="line">    u64         sum_exec_runtime;</span><br><span class="line">    u64         vruntime;</span><br><span class="line">    u64         prev_sum_exec_runtime;</span><br><span class="line">    u64         nr_migrations;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述结构中，sum_exec_runtime维护的是真实时间记账信息。而vruntime维护的则是加权过的时间记账，即虚拟运行时间。如何根据真实的时间计算出虚拟的运行时间，作为加权过的时间记账？公式如下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_148.jpg"
                      alt="epub_831302_148"
                ></p>
<p>在该公式中，<code>NICE_0_LOAD</code>的值是nice值为0的进程的权重，即1024。前面的例子中，nice值为0的进程运行了15毫秒，因为其权重为1024，故其虚拟运行时间也为15毫秒；nice值为5的进程运行时间为5毫秒，因为其权重为335，所以记账时其虚拟运行时间为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_149.jpg"
                      alt="epub_831302_149"
                ></p>
<p>内核的<code>sched_slice</code>函数负责计算进程在本轮调度周期应分得的真实运行时间，其实现代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u64 <span class="title function_">sched_slice</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本轮调度周期的时间长度*/</span></span><br><span class="line">    u64 slice = __sched_period(cfs_rq-&gt;nr_running + !se-&gt;on_rq);</span><br><span class="line">    <span class="comment">/*Linux支持组调度，所以此处有一个循环，*如果不考虑组调度，将调度实体简化成进程，会更好理解*/</span></span><br><span class="line">    for_each_sched_entity(se) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> *<span class="title">load</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">lw</span>;</span></span><br><span class="line">        cfs_rq = cfs_rq_of(se);</span><br><span class="line">        load = &amp;cfs_rq-&gt;load;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!se-&gt;on_rq)) &#123;</span><br><span class="line">            lw = cfs_rq-&gt;load;</span><br><span class="line">            update_load_add(&amp;lw, se-&gt;load.weight);</span><br><span class="line">            load = &amp;lw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*根据调度实体所占的权重，分配时间片的大小*/</span></span><br><span class="line">        slice = calc_delta_mine(slice, se-&gt;load.weight, load);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个函数中，<code>calc_delta_mine</code>函数就是用来计算分配这个调度实体的时间片长度：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配给进程的运行时间=调度周期 * 进程权重 / 所有进程权重之和</span></span><br><span class="line">slice = calc_delta_mine(slice, se-&gt;load.weight, load);</span><br></pre></td></tr></table></figure></div>

<p>在下一节中可以看到，内核会周期性地检查进程是不是已经耗完了自己的时间片，检查的方法就是判断进程本轮运行时间是否已经超过了<code>sched_slice</code>计算出来的时间片。如果超过，则表示运行时间足够久了，应该发生一次抢占。更新进程虚拟运行时间的逻辑位于内核的<code>__update_curr</code>函数，该函数里更新了当前进程的真实运行时间和虚拟运行时间，同时也更新了CFS运行队列的最小虚拟运行时间。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__update_curr(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr,</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">long</span> delta_exec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> delta_exec_weighted;</span><br><span class="line">    schedstat_set(curr-&gt;statistics.exec_max, max((u64)delta_exec, curr-&gt;statistics.exec_max));</span><br><span class="line">    <span class="comment">/*更新进程的真实运行时间*/</span></span><br><span class="line">    curr-&gt;sum_exec_runtime += delta_exec;</span><br><span class="line">    schedstat_add(cfs_rq, exec_clock, delta_exec);</span><br><span class="line">    <span class="comment">/*calc_delta_fair用来计算加权后的运行时间*/</span></span><br><span class="line">    delta_exec_weighted = calc_delta_fair(delta_exec, curr);</span><br><span class="line">    <span class="comment">/*更新进程的虚拟运行时间*/</span></span><br><span class="line">    curr-&gt;vruntime += delta_exec_weighted;</span><br><span class="line">    <span class="comment">/*更新运行队列的最小虚拟运行时间*/</span></span><br><span class="line">    update_min_vruntime(cfs_rq);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_SMP &amp;&amp; defined CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    cfs_rq-&gt;load_unacc_exec_time += delta_exec;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行队列上存在多个进程，随着时间的流逝，每个进程的虚拟时间各不相同，内核会将所有进程中虚拟运行时间的最小值记录到运行队列的最小虚拟运行时间（<code>vruntime</code>）中。当然运行队列的最小虚拟运行时间是奔流向前的，只会单调增大，绝不会减小。为什么要维护这个值？CFS算法可确保队列上的所有进程步调一致地轮流运行，虚拟运行时间不断增大，大部分进程的虚拟运行时间相差也不会太远。但是记录下队列虚拟运行时间的最小值仍然是有意义的。比如新加入一个进程，应该给它的虚拟运行时间赋初始值，初始值应是多少？再比如进程陷入了漫长的休眠，醒来时已经沧海桑田，相对其他进程，它的虚拟运行时间已经大幅落后。内核应该将该进程的虚拟运行时间调整成何值？又比如内核不得不将某个进程从一个CPU的运行队列拉到另一个CPU的运行队列中，该进程的虚拟运行时间该如何调整？此时，维护运行队列的最小虚拟运行时间的意义就彰显出来了。运行队列的最小虚拟运行时间给了我们一个基准，根据这个基准值可以知道，该CPU运行队列上的大部分进程的虚拟运行时间就在该值附近，且大于该值。在后面分析新创建的进程和唤醒休眠进程时，会分析内核如何调整这些进程的虚拟运行时间。</p>
<p>进程有了虚拟运行时间，完全公平调度器挑选下一个运行程序时就变得非常简单了，只需要挑选具有最小虚拟运行时间（vruntime）的进程投入运行即可。这就是完全公平调度算法的核心所在。内核为了加速挑选具有最小虚拟运行时间的进程，使用了红黑树数据结构。运行队列上的所有调度实体都是红黑树的节点。红黑树是平衡二叉树的一种，调度实体的虚拟运行时间是红黑树的键值。虚拟运行时间最小的调度实体，位于红黑树的最左端。因此挑选下一个运行程序，就简化成了从红黑树上取出最左端的节点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_150.jpg"
                      alt="epub_831302_150"
                ></p>
<p>维护进程的虚拟运行时间就成了调度算法的关键。问题是何时会更新进程的虚拟运行时间呢？可以查看内核代码中所有调用<code>update_curr</code>的函数。内核会周期性地更新进程的虚拟运行时间，也会在某些合适的时间点调用<code>update_curr</code>更新。我们暂时强忍好奇，继续探索。在探索的过程中，会多次遇到调用<code>update_curr</code>的函数。</p>
<h3 id="周期性调度任务"><a href="#周期性调度任务" class="headerlink" title="周期性调度任务"></a>周期性调度任务</h3><p>周期性调度任务是调度框架中很重要的一个部分。因为Linux是抢占式多任务，系统需要周期性地检查，当前运行的进程是不是已经耗尽了它的时间片，是不是应该发起一次抢占了。这就是周期性调度任务的职责。当时钟发生中断时，首先调用的是tick_handle_peroid函数。该函数会调用scheduler_tick函数，而scheduler_tick函数是进程调度框架中的重要函数，负责处理进程调度相关的周期性任务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_152.jpg"
                      alt="epub_831302_152"
                ></p>
<p>在<code>scheduler_tick</code>函数中一个非常重要的调用是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p>在Linux的实现中调度器采用了模块化的实现，任何一个调度类，都要实现<code>task_tick</code>这个函数。那这个<code>task_tick</code>函数要完成哪些使命呢？主要的工作是更新当前运行进程调度相关的统计信息，以及判断是否需要发生调度。对于完全公平的调度而言，<code>task_tick</code>函数为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.task_tick      = task_tick_fair,</span><br><span class="line"><span class="comment">// 在task_tick_fair函数中，内核更新了正在运行的进程的时间统计，包括真实运行时间和虚拟运行时间，</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> task_tick_fair(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *curr, <span class="type">int</span> queued)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> cfs_rq *cfs_rq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se;</span><br><span class="line">    <span class="comment">/*为了支持组调度，引入了调度实体的概念*/</span></span><br><span class="line">    for_each_sched_entity(se) &#123;</span><br><span class="line">        cfs_rq = cfs_rq_of(se);</span><br><span class="line">        entity_tick(cfs_rq, se, queued);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">entity_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*更新正在运行进程的统计信息*/</span></span><br><span class="line">    update_curr(cfs_rq);</span><br><span class="line">    update_entity_shares_tick(cfs_rq);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*如果可运行状态的进程个数大于1，检查是否可以抢占当前进程*/</span></span><br><span class="line">    <span class="keyword">if</span> (cfs_rq-&gt;nr_running &gt; <span class="number">1</span>)</span><br><span class="line">        check_preempt_tick(cfs_rq, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在我们探索的第一站就遇到了更新<code>updat_curr</code>的地方。时钟中断触发了周期性的调度任务，其中一项重要的任务就是通过<code>updat_curr</code>函数更新调度的统计信息。它随着时钟中断处理函数周期性地执行，更新进程的虚拟运行时间、真实运行时间和运行队列的最小虚拟运行时间等。内核需要知道在什么时候调用schedule函数，而不能仅仅依靠用户程序显式地调用schedule函数。如果将schedule函数的发起完全委托给用户程序，那么用户程序可能会无止尽地执行下去，而导致其他进程饿死。内核提供了一个<code>need_resched</code>标志位来表明是否需要重新执行一次调度。很明显，伴随着时钟中断发生的周期性调度任务是一个非常好的时机来判断当前进程是否应该被抢占（另一个时机是进程从睡眠状态醒来时，<code>try_to_wake_up</code>函数也会判断是否需要设置<code>need_resched</code>标志位来抢占当前的进程）。当运行队列上处于可运行状态的进程不止一个时，内核会调用<code>check_preempt_tick</code>函数来检查是否应该发生抢占。该函数确保了当前进程使用完自己的时间片后，可以及时地让出CPU，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_preempt_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ideal_runtime, delta_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span>;</span></span><br><span class="line">    s64 delta;</span><br><span class="line">    <span class="comment">/*ideal_runtime记录进程应该运行的时间*/</span></span><br><span class="line">    ideal_runtime = sched_slice(cfs_rq, curr);</span><br><span class="line">    <span class="comment">/* delta_exec记录进程真实运行的时间 */</span></span><br><span class="line">    delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;</span><br><span class="line">    <span class="comment">/*如果实际运行时间超过了应该运行的时间，则需要调度出去，被抢占*/</span></span><br><span class="line">    <span class="keyword">if</span> (delta_exec &gt; ideal_runtime) &#123;</span><br><span class="line">        <span class="comment">/*resched_task 会负责设置need_resched标志位*/</span></span><br><span class="line">        resched_task(rq_of(cfs_rq)-&gt;curr);</span><br><span class="line">        clear_buddies(cfs_rq, curr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 如果当前进程运行时间低于调度的最小粒度，则不允许发生抢占 */</span></span><br><span class="line">    <span class="keyword">if</span> (delta_exec &lt; sysctl_sched_min_granularity)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在<code>check_preempt_tick</code>中可以看出，进程有自己的完美运行时间，即本轮调度周期应得的时间片。如果本轮执行时间已经超出了时间片，就会执行<code>resched_task</code>函数，在该函数中会通过<code>set_tsk_need_resched</code>函数来设置<code>need_resched</code>标志位，告诉内核请尽快调用schedule函数。如果进程的本轮运行时间小于调度最小粒度，那么不允许发生抢占。<code>resched_task</code>函数仅仅是设置标志位，并没有真正地执行进程切换。进程调度发生的时机之一是发生在中断返回时，<code>check_preempt_tick</code>函数是<code>scheduler_tick</code>函数的一部分，而<code>scheduler_tick</code>函数是中断处理程序的一部分。执行完中断处理，会检查<code>need_resched</code>标志位是否置位，如果置位，那就自然会调用schedule函数来执行切换。</p>
<h3 id="新进程的加入"><a href="#新进程的加入" class="headerlink" title="新进程的加入"></a>新进程的加入</h3><p>首先分析一下sched_fork的内核代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched_fork</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> cpu = get_cpu();</span><br><span class="line">    <span class="comment">/*初始化调度相关的值，如调度实体、运行时间、虚拟运行时间等*/</span></span><br><span class="line">    __sched_fork(p);</span><br><span class="line">    <span class="comment">/*设置成TASK_RUNNING,其实新创建的进程并没有真正地在CPU上执行，*此举的目的是防止外部信号和时间将其唤醒，之后插入运行队列*/</span></span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line">    p-&gt;prio = current-&gt;normal_prio;</span><br><span class="line">    <span class="comment">/*如果设置了sched_reset_on_fork标志位，后面会讨论*/</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(p-&gt;sched_reset_on_fork)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task_has_rt_policy(p)) &#123;</span><br><span class="line">            p-&gt;policy = SCHED_NORMAL;</span><br><span class="line">            p-&gt;static_prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line">            p-&gt;rt_priority = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PRIO_TO_NICE(p-&gt;static_prio) &lt; <span class="number">0</span>)</span><br><span class="line">            p-&gt;static_prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line">        p-&gt;prio = p-&gt;normal_prio = __normal_prio(p);</span><br><span class="line">        set_load_weight(p);</span><br><span class="line">        p-&gt;sched_reset_on_fork = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果不是实时进程，则调度类为完全公平调度类*/</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_prio(p-&gt;prio))</span><br><span class="line">        p-&gt;sched_class = &amp;fair_sched_class;</span><br><span class="line">    <span class="comment">/*如果调度类实现了task_fork函数，则调用该函数*/</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sched_class-&gt;task_fork)</span><br><span class="line">        p-&gt;sched_class-&gt;task_fork(p);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_154.jpg"
                      alt="epub_831302_154"
                ></p>
<p>sched_fork函数的主要工作是初始化进程的与调度相关的变量，确定进程所属的调度类及优先级设置。根据进程所属的调度类，执行与调度类相关的函数。调度类需要实现task_fork这个hook函数。该函数用于处理与新创建的进程相关的初始化事宜。对于完全公平调度类，该函数的实现为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.task_fork      = task_fork_fair,</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> task_fork_fair(<span class="keyword">struct</span> task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> cfs_rq *cfs_rq = task_cfs_rq(current);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;p-&gt;se, *curr = cfs_rq-&gt;curr;</span><br><span class="line">    <span class="type">int</span> this_cpu = smp_processor_id();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> this_rq();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span><br><span class="line">    update_rq_clock(rq);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(task_cpu(p) != this_cpu)) &#123;</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        __set_task_cpu(p, this_cpu);</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*更新CFS调度类的队列,包括执行__update_curr更新当前进程统计 */</span></span><br><span class="line">    update_curr(cfs_rq);</span><br><span class="line">    <span class="comment">/*新创建进程的vruntime初始化成父进程的vruntime，</span></span><br><span class="line"><span class="comment">    *紧随其后的place_entity函数会负责调整新创建进程的vruntime*/</span></span><br><span class="line">    <span class="keyword">if</span> (curr)</span><br><span class="line">        se-&gt;vruntime = curr-&gt;vruntime;</span><br><span class="line">    place_entity(cfs_rq, se, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*如果设置了子进程先运行，并且父进程的vruntime小于子进程，则交换彼此的vruntime，确保子进程先执行*/</span></span><br><span class="line">    <span class="keyword">if</span> (sysctl_sched_child_runs_first &amp;&amp; curr &amp;&amp; entity_before(curr, se)) &#123;</span><br><span class="line">        swap(curr-&gt;vruntime, se-&gt;vruntime);</span><br><span class="line">        resched_task(rq-&gt;curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*此处减去当前运行队列的最小虚拟运行时间，</span></span><br><span class="line"><span class="comment">    *真正进入运行队列，即执行enqueue_entity时，</span></span><br><span class="line"><span class="comment">    *进程的vruntime会加上cfs_rq-&gt;vruntime*/</span></span><br><span class="line">    se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>新创建进程的虚拟运行时间初始值</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curr)</span><br><span class="line">    se-&gt;vruntime = curr-&gt;vruntime;</span><br><span class="line">place_entity(cfs_rq, se, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>

<p>从上面的函数中可以看出，新创建子进程的虚拟运行时间首先被初始化成父进程的虚拟运行时间，接下来会调用了<code>place_entity</code>函数，而<code>place_entity</code>函数会调整新创建进程的虚拟运行时间。“place_entity”，直白的翻译就是放置调度实体的意思，即把调度实体放置到合适的位置。如何才能决定调度实体的位置呢？毫无疑问，只能通过调整调度实体的虚拟运行时间来实现。place_entity函数用来处理两种比较特殊的情况：</p>
<ul>
<li>调整新创建进程的虚拟运行时间。</li>
<li>调整从休眠中唤醒进程的虚拟运行时间。</li>
</ul>
<p>这两种情况根据该函数的第三个参数initial来区分。initial等于1则表示调整新创建进程的虚拟运行时间。下面来看看place_entity函数是如何调整新创建进程的虚拟运行时间的，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">place_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se, <span class="type">int</span> initial)</span></span><br><span class="line">&#123;</span><br><span class="line">    u64 vruntime = cfs_rq-&gt;min_vruntime;</span><br><span class="line">    <span class="keyword">if</span> (initial &amp;&amp; sched_feat(START_DEBIT))</span><br><span class="line">        vruntime += sched_vslice(cfs_rq, se);…vruntime = max_vruntime(se-&gt;vruntime, vruntime);se-&gt;vruntime = vruntime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">sched_vslice</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> calc_delta_fair(sched_slice(cfs_rq, se), se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>完全公平调度类的运行队列cfs_rq中维护有成员变量<code>min_vruntime</code>，该变量存放的是此运行队列中的最小虚拟运行时间。就像前面所说的，它提供了一个基准值，通过它我们无须遍历队列上所有进程的虚拟运行时间，就可以得知该运行队列的整体情况了。大多数进程的虚拟值在该值附近，且略大于该值。内核提供了很多调度的特性，记录在<code>/sys/kernel/debug/sched_features</code>中，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/sched_features</span><br><span class="line">GENTLE_FAIR_SLEEPERS START_DEBIT NO_NEXT_BUDDY LAST_BUDDY CACHE_HOT_BUDDY WAKEUP_</span><br><span class="line">    PREEMPTION ARCH_POWER NO_HRTICK NO_DOUBLE_TICK LB_BIAS NONTASK_POWER TTWU_</span><br><span class="line">    QUEUE NO_FORCE_SD_OVERLAP RT_RUNTIME_SHARE NO_LB_MIN NUMA NUMA_FAVOUR_HIGHER </span><br><span class="line">    NO_NUMA_RESIST_LOWER</span><br></pre></td></tr></table></figure></div>

<p>其中START_DEBIT特性是用来给新创建的进程略加惩罚的。如果没有START_DEBIT选项，子进程的虚拟运行时间为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(父进程的虚拟运行时间，CFS运行队列的最小运行时间)</span><br></pre></td></tr></table></figure></div>

<p>这个值通常比较小，这就意味着子进程很快就能获得调度的机会，因此也就给了恶意进程可乘之机。因为恶意进程可以通过不停地fork来获得更多的CPU时间。如果设置了START_DEBIT选项，会通过增大子进程的虚拟运行时间来惩罚新创建的进程，使新创建的进程晚一点才能获得被调度的机会。那么虚拟运行时间增大多少呢？看看下面的语句：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime += sched_vslice(cfs_rq, se);</span><br></pre></td></tr></table></figure></div>

<p>前面介绍过<code>sched_slice</code>函数是用来计算进程的时间片的，那么<code>sched_vslice</code>函数又是何意呢？</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u64 <span class="title function_">sched_vslice</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> calc_delta_fair(sched_slice(cfs_rq, se), se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>sched_vslice</code>函数是根据时间片的值，来计算对应的虚拟时间片的值。即根据进程的优先级来调整。调整的算法前面已经提到过了。打开了<code>START_DEBIT</code>特性，子进程的虚拟运行时间就会被初始化成：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(父进程的虚拟运行时间，CFS运行队列的最小运行时间+进程虚拟时间片)</span><br></pre></td></tr></table></figure></div>

<p><strong>父子进程谁先执行</strong></p>
<p><code>task_fork_fair</code>函数中有以下代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sysctl_sched_child_runs_first &amp;&amp; curr &amp;&amp; entity_before(curr, se)) &#123;</span><br><span class="line">    swap(curr-&gt;vruntime, se-&gt;vruntime);</span><br><span class="line">    resched_task(rq-&gt;curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果要设置子进程优先获得调度，则会通过entity_before函数来比较父子进程的vruntime，如果父进程的vruntime小，则需要和子进程互换vruntime以确保子进程优先获得调度。</p>
<p>继续分析<code>task_fork_fair</code>函数。在该函数中有一条语句非常奇怪，该语句代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br></pre></td></tr></table></figure></div>

<p>为何要减掉运行队列的最小虚拟运行时间？继续向下看就可以恍然大悟了。因为在do_fork的末尾会调用wake_up_new_task函数。事实上在对称多处理器结构上，新创建的进程和父进程不一定在同一个CPU上运行。进程刚刚创建好，尚未运行，这是多个CPU之间负载均衡的一个良机。Linux也是这么做的，在<code>wake_up_new_task</code>函数中会首先调用如下语句，选择一个合适的CPU：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_task_cpu(p, select_task_rq(p, SD_BALANCE_FORK, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_157.jpg"
                      alt="epub_831302_157"
                ></p>
<p>很不幸的是，不同的CPU之间负载并不完全相同，有的CPU更忙一些，而且每个CPU都有自己的运行队列cfs_rq，不同的CPU运行队列的最小虚拟运行时间<code>min_vruntime</code>并不相同。如果新创建的进程从一个CPU的运行队列迁移到另外一个CPU的运行队列，就可能会产生问题。比如新创建的进程从<code>min_vruntime</code>小的CPU A跳到<code>min_vruntime</code>非常大的CPU B，它就会占便宜，因为它的虚拟运行时间会在相当长的时间范围内都是最小的，从而产生调度的不公平。解决的方法非常简单：</p>
<p>迁移前：进程的虚拟运行时间–&#x3D; 迁移前所在CPU运行队列的最小虚拟运行时间</p>
<p>迁移后：进程的虚拟运行时间 +&#x3D; 迁移后所在CPU 运行队列的最小虚拟运行时间</p>
<p><code>enqueue_task</code>也是调度类的hook函数，每一个调度类都要实现该函数，对于完全公平的调度而言：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.enqueue_task       = enqueue_task_fair,</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> task_fork_fair(<span class="keyword">struct</span> task_struct *p)</span><br><span class="line">&#123;se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">enqueue_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="keyword">if</span> (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_WAKING))</span><br><span class="line">         se-&gt;vruntime += cfs_rq-&gt;min_vruntime;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>事实上该解决方案不仅仅只是用于新创建的进程这一个场景。Linux支持CPU之间的负载均衡，可以将进程从一个CPU迁移到另外一个CPU，为了防止不公平的产生，也采用了上述的解决方案。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dequeue_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DEQUEUE_SLEEP))</span><br><span class="line">         se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">enqueue_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_WAKING))</span><br><span class="line">         se-&gt;vruntime += cfs_rq-&gt;min_vruntime;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="睡眠进程醒来"><a href="#睡眠进程醒来" class="headerlink" title="睡眠进程醒来"></a>睡眠进程醒来</h3><p>如何对待睡眠进程也是调度器需要解决的问题。因为交互型的进程会不断陷入休眠状态中，并等待用户的输入。虽然这类进程对CPU的整体消耗并不大，但是要求响应必须及时，否则用户会感觉到系统卡顿，用户体验就会很糟糕。</p>
<p>对CFS之前的O（1）调度器来说，交互型进程堪称其阿喀琉斯之踵。该调度算法的交互进程识别启发式算法异常复杂，该启发式算法融入了睡眠时间作为考量的标准，但是对于一些特殊的情况，经常判断不准，而且经常是改完一种情况又发现另一种特殊情况。CFS调度算法并没有刻意地区分交互型进程和批处理型进程，依然漂亮地满足了交互型进程需要及时响应的需求。CFS算法是如何做到的呢，对于从休眠中醒来的进程，CFS进行了哪些处理呢？</p>
<p>当进程被内核唤醒时，内核通常会执行<code>try_to_wake_up</code>函数。概括地讲，<code>try_to_wake_up</code>函数的职责是：</p>
<ul>
<li>把从休眠中醒来的进程放到合适的运行队列。</li>
<li>将进程的状态设置为<code>TASK_RUN-NING</code>。</li>
<li>判断醒来的进程是否应该抢占当前正在运行的进程，如果是，则设置<code>need_resched</code>标志位。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_159.jpg"
                      alt="epub_831302_159"
                ></p>
<p>前面提到的<code>try_to_wake_up</code>负责的三件事，分别由以下函数负责完成。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_160.jpg"
                      alt="epub_831302_160"
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ttwu_activate</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> en_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    activate_task(rq, p, en_flags);</span><br><span class="line">    p-&gt;on_rq = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* if a worker is waking up, notify workqueue */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;flags &amp; PF_WQ_WORKER)</span><br><span class="line">        wq_worker_waking_up(p, cpu_of(rq));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">activate_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (task_contributes_to_load(p))</span><br><span class="line">        rq-&gt;nr_uninterruptible--;</span><br><span class="line">    <span class="comment">/*将进程插入运行队列，enqueue_task是调度类hook函数*/</span></span><br><span class="line">    enqueue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">enqueue_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    update_rq_clock(rq);</span><br><span class="line">    sched_info_queued(p);</span><br><span class="line">    <span class="comment">/*根据进程所属的调度类，执行相应的enqueue_task函数*/</span></span><br><span class="line">    p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_161.jpg"
                      alt="epub_831302_161"
                ></p>
<p><code>activate_task</code>函数和<code>deactivate_task</code>函数一样，都是调度框架内的重要函数，并且两者是一对，就好像<code>wake_up</code>和<code>wait_event</code>是一对一样。当进程调用<code>wait_event</code>时，进程从可运行状态变成睡眠状态，因此需要通过<code>deactivate_task</code>函数将进程从运行队列中移除，与此对应的，当内核调用<code>wake_up</code>函数把进程从休眠状态唤醒时，内核需要通过<code>activate_task</code>函数将进程放入运行队列中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_162.jpg"
                      alt="epub_831302_162"
                ></p>
<p>其中enqueue_task函数是调度类的hook函数，每个调度类都需要实现该函数。其含义顾名思义，即将进程放入运行队列。对于完全公平调度类而言，该函数指针指向的是enqueue_task_fair。</p>
<p>enqueue_task_fair很大部分的工作是更新调度相关的统计，其中有一支代码路径非常有意思。这条路径之所以很重要，是因为它决定了休眠进程醒来后的虚拟运行时间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_163-1739157516356-14.jpg"
                      alt="epub_831302_163"
                ></p>
<p>休眠进程的虚拟运行时间会保持不变吗？答案是否定的。很多进程可能会长时间地休眠，在这个过程中，如果虚拟运行时间vruntime保持不变，一旦该进程醒来，它的vruntime就会比运行队列上的其他进程小很多，因为会长时间保持调度的优势。这显然是不合理的。对于这种情况，完全公平调度的做法是，以运行队列的<code>min_vruntime</code>为基础，给予一定的补偿。补偿多少？这就又要去看看我们的老朋友place_entity函数了。在创建新进程时，曾经走到过该函数，那时该函数负责决定新进程的虚拟运行时间。下面来看看对于被唤醒的休眠进程，该函数是如何决定进程的虚拟运行时间的：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">place_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se, <span class="type">int</span> initial)</span></span><br><span class="line">&#123;</span><br><span class="line">    u64 vruntime = cfs_rq-&gt;min_vruntime;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*从休眠中醒来*/</span></span><br><span class="line">    <span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">        <span class="comment">/*补偿一个调度周期*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> thresh = sysctl_sched_latency;</span><br><span class="line">        <span class="comment">/*如果设置了GENTLE_FAIR_SLEEPERS,则补偿半个调度周期*/</span></span><br><span class="line">        <span class="keyword">if</span> (sched_feat(GENTLE_FAIR_SLEEPERS))</span><br><span class="line">            thresh &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        vruntime -= thresh;</span><br><span class="line">    &#125;</span><br><span class="line">    vruntime = max_vruntime(se-&gt;vruntime, vruntime);</span><br><span class="line">    se-&gt;vruntime = vruntime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当initial等于0时，表示正在处理从休眠中醒来的进程。如果没有设置<code>GENTLE_FAIR_SLEEPERS</code>特性，那么在队列最小虚拟运行时间的基础上，补偿1个调度延迟，如果设置了<code>GENTLE_FAIR_SLEEPERS</code>，那么补偿减半，即补偿半个调度延迟。默认情况下，<code>GENTLE_FAIR_SLEEPER</code>的特性是打开的。但休眠进程醒来后的虚拟运行时间并非只是简单粗暴地设置成队列的最小运行时间减掉补偿值。影响因素还有进程原本的虚拟运行时间，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime = max_vruntime(se-&gt;vruntime, vruntime);</span><br></pre></td></tr></table></figure></div>

<p>如果休眠进程的睡眠时间非常短，很有可能进程原本的虚拟运行时间要大于上述计算得到的值，此时，休眠进程的虚拟运行时间不变，即为睡眠前的值。如果休眠进程的睡眠时间特别久，醒来时已经沧海桑田，那么就将虚拟运行时间设置为所在运行队列的最小虚拟运行时间减去补偿量。从上面的代码可以看出，从长时间休眠中醒来的进程，因为其虚拟运行时间较小（比队列的最小虚拟运行时间还小），所以会获得优先的调度，从而使交互型进程得到及时的响应。</p>
<blockquote>
<p>这种对休眠进程进行奖励的做法，在进程调度设计领域存在一定的争议。内核进程调度领域的大牛Con Kolivas就坚持认为，调度器只需要向前看，而不应该考虑一个进程的过去。在早期的CFS调度算法（版本2.6.23）中，CFS会负责记录进程的sleep time，2.6.24版本之后的内核，就不再考虑进程过去的睡眠时间了。但是CFS做得并不彻底，在place_entity函数中，对休眠进程进行了补偿。在CFS早期的版本中，sleeper fairness的特性会导致在一些情况下出现严重的调度延迟。在Jens Axboe的测试中，甚至会出现10秒的延迟，也有客户报告在编译内核时，音频视频会有严重的停顿。上面代码中的GENTLE_FAIR_SLEEPER特性就是作者Ingo给出的Patch，这个特性解决了10秒的延迟和其他鼠标滞后、视频停顿等交互性的问题。</p>
</blockquote>
<h3 id="唤醒抢占"><a href="#唤醒抢占" class="headerlink" title="唤醒抢占"></a>唤醒抢占</h3><p>无论是<code>try_to_wake_up</code>唤醒睡眠的进程还是<code>wake_up_new_task</code>唤醒新创建的进程，内核都会使用<code>check_preempt_curr</code>函数来检查新唤醒的进程或新创建进程是否可以抢占当前运行的进程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_167.jpg"
                      alt="epub_831302_167"
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_preempt_curr</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class) &#123;</span><br><span class="line">        rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">/*for_each_class，从高优先级的调度类到低优先级的调度类*/</span></span><br><span class="line">        for_each_class(class) &#123;</span><br><span class="line">        <span class="comment">/*如果候选进程的调度类低于当前进程所属的调度类，就直接跳出。不许低优先级的调度类抢占高优先级的调度类*/</span></span><br><span class="line">            <span class="keyword">if</span> (class == rq-&gt;curr-&gt;sched_class)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/*如果候选进程所属的调度类优先级高于当前进程的调度类，则通过执行resched_task函数，设置need_resched标志位*/</span></span><br><span class="line">            <span class="keyword">if</span> (class == p-&gt;sched_class) &#123;</span><br><span class="line">                resched_task(rq-&gt;curr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rq-&gt;curr-&gt;on_rq &amp;&amp; test_tsk_need_resched(rq-&gt;curr))</span><br><span class="line">        rq-&gt;skip_clock_update = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>判断能否发生抢占的逻辑异常简单，也是符合正常人思维的：</p>
<ul>
<li>如果候选进程和正在运行的进程属于同一个调度类，那么调度类内部提供方法解决。</li>
<li>如果候选进程和正在运行的进程属于不同的调度类，候选进程所属调度类的优先级高于正在运行进程的调度类的优先级，则可以抢占，否则不可以。</li>
</ul>
<p>注意新唤醒的进程不一定是普通进程，也可能是实时进程。如果唤醒的进程是实时进程而当前运行的进程为普通进程，则会设置<code>need_resched</code>标志位，因为实时进程总是会抢占CFS调度域的普通进程。每一种调度类都应该实现自己的<code>check_preempt_curr</code>函数来判断是否需要发生抢占，对于完全公平调度类，<code>check_preempt_curr</code>的实现为<code>check_preempt_wakeup</code>函数。</p>
<p>如果被唤醒的进程的睡眠时间非常久（上百毫秒、几百毫秒、几秒甚至更久），前面的place_entity函数会将睡眠进程的虚拟运行时间设置为队列的最小虚拟运行时间减掉补偿的半个调度周期，这会使睡眠进程的虚拟运行时间非常的小，醒来时几乎总是会抢占当前的进程，这种行为也是期待的行为，因为它可以保证交互型进程的响应时间。但是也有很多进程的睡眠时间非常短暂（比如只有几毫秒甚至更短），醒来之后通过place_entity函数计算得出的虚拟运行时间值仍然是自己本来的虚拟运行时间值。如果仅仅比较醒来的进程和当前运行进程的虚拟运行时间来决定是否抢占，那么很可能会使得抢占过于频繁。因此Linux引入了唤醒抢占粒度<code>sched_wakeup_granularity_ns</code>，可以通过如下方法来查看系统的唤醒抢占粒度<code>sched_wakeup_granularity_ns</code>的值：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/sched_wakeup_granularity_ns</span><br><span class="line"><span class="number">2000000</span></span><br></pre></td></tr></table></figure></div>

<p>引入该最小粒度后，唤醒进程抢占当前进程的条件是：只有当唤醒进程的vruntime小，并且两者的差值vdiff大于<code>sched_wakeup_granularity_ns</code>时，才能抢占。具体的算法实现如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">wakeup_preempt_entity</span><span class="params">(<span class="keyword">struct</span> sched_entity *curr, <span class="keyword">struct</span> sched_entity *se)</span></span><br><span class="line">&#123;</span><br><span class="line">    s64 gran, vdiff = curr-&gt;vruntime - se-&gt;vruntime;</span><br><span class="line">    <span class="keyword">if</span> (vdiff &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gran = wakeup_gran(curr, se);</span><br><span class="line">    <span class="keyword">if</span> (vdiff &gt; gran)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">wakeup_gran</span><span class="params">(<span class="keyword">struct</span> sched_entity *curr, <span class="keyword">struct</span> sched_entity *se)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> gran = sysctl_sched_wakeup_granularity;</span><br><span class="line">    <span class="keyword">return</span> calc_delta_fair(gran, se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果系统的唤醒抢占太过频繁，大量的上下文切换会影响系统的整体性能。这种情况下可以通过调整<code>sched_wakeup_granularity_ns</code>的值来解决，<code>sched_wakeup_granularity_ns</code>的值越大，发生唤醒抢占就越不容易。注意<code>sched_wakeup_granularity_ns</code>的值不要超过调度周期<code>sched_latency_ns</code>的一半，否则的话，就相当于禁止唤醒抢占了。</p>
<h2 id="普通进程的组调度"><a href="#普通进程的组调度" class="headerlink" title="普通进程的组调度"></a>普通进程的组调度</h2><p>完全公平调度算法会尽力在进程之间保证公平。如果有50个优先级相同的进程，CFS会努力让每个进程获得的CPU时间为2%，以确保公平。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_169.jpg"
                      alt="epub_831302_169"
                ></p>
<p>考虑上图情景，表面看每个进程都被进程调度器公平对待了，即4个进程每个都获得了25%的CPU时间。但是其中的用户B并没有得到公平的对待。我们将情况考虑得再极端一点：系统上存在50个进程，其中49个都属于用户A，而用户B只有1个进程。那么对于用户B而言，它只能使用2%的CPU资源，这显然是不公平的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_170.jpg"
                      alt="epub_831302_170"
                ></p>
<p>比较合理的做法是，首先确保组间的公平，然后才是组内进程之间的公平。</p>
<p>Linux内核实现了cgroups（control groups的缩写）功能，该功能用来限制、记录和隔离一个进程组群所使用的物理资源（如CPU、内存、磁盘IO、网络等）。为了管理不同的资源，cgroups提供了一系列子系统，本节将要介绍的cpu和后面CPU亲和力一节介绍的cpuset都属于cgroups的子系统。cpu子系统只用于限制进程的CPU使用率。</p>
<h2 id="实时进程"><a href="#实时进程" class="headerlink" title="实时进程"></a>实时进程</h2><p>对于普通进程来说，完全公平调度已经能够提供足够好的性能和响应体验了。但是某些进程对实时性的要求更高。严格说来实时系统可以分成两类：硬实时进程和软实时进程。硬实时进程对响应时间的要求非常严格，必须保证在一定的时间内完成，超过时间限制就会失败，而且后果非常严重。这类应用典型的例子有军用武器系统、航空航天系统、交通导航系统、医疗设备等。硬实时的关键特征是任务必须在可保证的时间范围内得到处理。当然这并不意味所要求的时间范围特别短，而是系统必须保证绝不会超过某一时间范围，无论当时系统的负载如何。主流内核的Linux并不支持硬实时进程，当然有些修改版本提供了该特性。软实时进程是硬实时的一种弱化形式。尽管软实时进程仍然需要快速响应和要在规定的时间内完成，但是超过了时间的范围也不会有什么灾难性的后果。比较典型的例子是视频处理应用，如果超过了操作时限，则会影响用户体验，但是少量的丢帧还是可以忍受的。</p>
<h3 id="实时调度策略和优先级"><a href="#实时调度策略和优先级" class="headerlink" title="实时调度策略和优先级"></a>实时调度策略和优先级</h3><p>Linux提供了两种实时调度的策略：先进先出（SCHED_FIFO）策略和时间片轮转（SCHED_RR）策略。无论进程使用哪种实时策略，其优先级都会高于前面介绍的采用完全公平调度的普通进程。实时进程也有一个优先级的范围。SUSv3要求至少要为实时策略实现32个离散的优先级。Linux中为实时进程提供了99个实时优先级。从内核层面看，从0到99范围内的优先级属于实时调度范围，从100到139共40个等级属于前面讨论过的完全公平调度的优先级。其中创建普通进程的时候，其优先级的值为完全公平调度中的中间值120。从整体来看，优先级的值越低，其优先级就越高。事实上每个CPU都有实时运行队列。根据99种离散的优先级可知，共有99个队列。具有相同优先级的实时进程都保存在一个队列之中。这使得在实时调度类中选择下一个运行的进程也就比较简单了，按照优先级从高到低的顺序，选择存在可运行进程的最高优先级队列中的第一个进程即可。事实上内核中还维护有位图来表征哪个优先级的运行队列有可运行的进程，相关结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> &#123;</span></span><br><span class="line">       DECLARE_BITMAP(bitmap, MAX_RT_PRIO+<span class="number">1</span>); <span class="comment">/* include 1 bit for delimiter */</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_RT_PRIO</span>];</span></span><br><span class="line">   &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> <span class="title">active</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_176.jpg"
                      alt="epub_831302_176"
                ></p>
<blockquote>
<p>对于实时进程而言，内核态的优先级和用户进程通过sched_setscheduler或sched_setparam系统调用设置的优先级并不相同：对于内核态而言，优先级的值越小，优先级就越高，而用户进程通过系统调用设置的优先级正好相反，优先级的值越大，优先级越高。</p>
<p>两者的换算关系是：内核态优先级＝MAX_RT_PRIO－1－用户态优先级</p>
<p>其中MAX_RT_PRIO的值为100。</p>
</blockquote>
<p><strong>SCHED_FIFO策略</strong></p>
<p>SCHED_FIFO策略是一种比较简单的策略，即先进先出，它没有时间片的概念，只要没有更高优先级的进程就绪，使用该调度策略的进程就会一直执行。一旦一个调度策略为SCHED_FIFO的进程获得了CPU控制权，它就会始终占有CPU资源直到下面的某种情况发生：</p>
<ul>
<li>自动放弃CPU资源，如执行了一个阻塞型的系统调用或调用了sched_yield系统调用，进程不再处于可执行状态。</li>
<li>进程终止了。</li>
<li>被一个优先级更高的进程抢占。</li>
</ul>
<p>如果FIFO类型的进程通过sched_yield系统调用主动让出了CPU，那么内核会将该进程放到对应队列的尾部；如果进程被更高优先级的进程抢占，那么该进程在队列中的位置不变，一旦高优先级的进程停止执行，被抢占的FIFO类型的进程会继续执行。</p>
<p><strong>SCHED_RR策略</strong></p>
<p>在时间片轮转的策略中，具有相同优先级的进程轮流执行，进程每次使用CPU的时间为一个固定长度的时间片。使用SCHED_RR策略的实施进程一旦被调度器选中，就会一直占有CPU资源，直到下面的某种情况发生：</p>
<ul>
<li>时间片耗尽。</li>
<li>进程自动放弃CPU：或者执行了阻塞式的系统调用，或者主动执行sched_yield函数让出CPU资源。</li>
<li>进程终止了。</li>
<li>被更高优先级的进程抢占。</li>
</ul>
<p>前两种情况下，SCHED_RR策略的进程会被放到其优先级运行队列的队尾。最后一种情况下，被抢占的SCHED_RR策略的实施进程仍然位于其运行队列的头部，在更高优先级的进程运行结束后，被抢占的进程会继续执行，直到其时间片的剩余部分耗光为止。在时间片轮转策略中，时间片的长度是一个关键的参数。POSIX定义了接口来查询SCHED_RR策略的时间片长度：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_rr_get_interval</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> timespec * tp)</span>;</span><br></pre></td></tr></table></figure></div>

<p>默认情况下，SCHED_RR类型进程的时间片总是100毫秒。如果内核版本不低于3.9，时间片的大小可以通过调整<code>/proc/sys/kernel/sched_rr_timeslice_ms</code>的值来调整。伴随着时钟中断处理程序，scheduler_tick函数会根据当前进程的调度类执行对应的task_tick函数，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//实时调度类的task_tick函数为task_tick_rt</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_tick_rt</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct*p, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">    update_curr_rt(rq);</span><br><span class="line">    watchdog(rq, p);</span><br><span class="line">    <span class="comment">/*FIFO类型没有时间片的概念，不会因为执行时间足够长而被抢占*/</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;policy != SCHED_RR)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/*如果时间片还没到，就直接返回*/</span></span><br><span class="line">    <span class="keyword">if</span> (--p-&gt;rt.time_slice)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">/*时间片已经耗尽，先将进程的时间片重新初始化为默认时间片*/</span></span><br><span class="line">    p-&gt;rt.time_slice = DEF_TIMESLICE;</span><br><span class="line">    <span class="comment">/*如果队列上存在其他进程，则将自身移到队列的尾部，</span></span><br><span class="line"><span class="comment">         *并且设置need_resched标志位*/</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rt.run_list.prev != p-&gt;rt.run_list.next) &#123;</span><br><span class="line">        requeue_task_rt(rq, p, <span class="number">0</span>);</span><br><span class="line">        set_tsk_need_resched(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从上面的代码不难看出，采用SCHED_RR调度策略的实时进程，时间片大小为时钟滴答的整数倍。如果系统CONFIG_HZ为250，那么每4毫秒一个时钟滴答，即时间片大小总是4毫秒的整数倍。</p>
<p><strong>SCHED_OTHER策略</strong></p>
<p>SCHED_OTHER策略不属于实时调度的范畴。SCHED_OTHER和下面要讨论的SCHED_BATCH、SCHED_IDLE策略同属于完全公平调度的范畴。事实上，我们遇到的大多数进程都是属于SCHED_OTHER的调度策略。前面讨论的是nice值在-20~19范围内的进程，都是属于SCHED_OTHER的调度策略。在这种调度策略下，不同的nice值，意味着不同的时间片权重。优先级越高的普通进程，将获得越多的CPU时间。</p>
<p><strong>SCHED_BATCH策略</strong></p>
<p>尽管可以通过POSIX实时调度的API设置进程的策略为SCHED_BATCH，但是SCHED_BATCH策略并不属于实时调度的策略。SCHED_BATCH策略是在Linux 2.6.16的内核中加入的。最初引入这个策略的目的是告知内核，指定这个策略的进程并非交互型的进程，不需要根据休眠时间更改优先级。这个策略主要用于早期的O（1）调度器，对于完全公平的调度，SCHED_BATCH策略和SCHED_OTHER策略几乎一样。</p>
<p><strong>SCHED_IDLE策略</strong></p>
<p>SCHED_IDLE策略也隶属于完全公平调度的范畴。采取SCHED_IDLE调度策略的进程拥有非常低的优先级，比nice值为19的进程的优先级还要低（nice值是19的进程，其权重是15，采用SCHED_IDLE调度策略的进程其权重是3）。一般来说，该策略用于运行优先级非常低的进程，通常在系统中没有其他任务需要使用CPU时这些任务才会运行。</p>
<p>完全公平调度类中负责检查是否应该唤醒抢占的check_preempt_wakeup函数中有如下的语句：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(curr-&gt;policy == SCHED_IDLE) &amp;&amp;</span><br><span class="line">    likely(p-&gt;policy != SCHED_IDLE))</span><br><span class="line">    <span class="keyword">goto</span> preempt;</span><br></pre></td></tr></table></figure></div>

<p>这段代码表明，在CFS调度域内，如果醒来的候选进程采用的不是SCHED_IDLE策略，而当前运行的进程采用的调度策略是SCHED_IDLE，那么抢占总是会发生。</p>
<h3 id="实时调度相关API"><a href="#实时调度相关API" class="headerlink" title="实时调度相关API"></a>实时调度相关API</h3><p>Linux下可以通过sched_setscheduler函数来修改进程的调度策略及优先级，其接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setscheduler</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> policy,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line">     <span class="type">int</span> sched_priority;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该接口用于修改pid对应进程的调度策略和优先级。当pid等于0时，修改函数调用进程的调度策略和优先级。策略和优先级的有效值如表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_181.jpg"
                      alt="epub_831302_181"
                ></p>
<p>sched_setscheduler函数调用成功时返回0，失败时返回-1，并设置errno。设置进程调度策略和优先级的方法如下面的代码所示。下面的代码将进程的调度策略设置成了SCHED_RR，并且其优先级为99，即实时进程中的最低优先级。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span> =</span> &#123; .sched_priority = <span class="number">99</span> &#125;;</span><br><span class="line">ret = sched_setscheduler(<span class="number">0</span>, SCHED_RR, &amp;sp);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*error handler*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过fork创建的子进程会保持父进程的调度策略和优先级。有些时候，不希望子进程继承父进程的调度策略和优先级，尤其是父进程是实时进程或nice值是负值的时候。Linux自2.6.32版本开始，提供了SCHED_RESET_ON_FORK选项，一旦设置了该选项，子进程就不会继承父进程的调度策略或nice值了。可通过如下代码设置该标志位：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = sched_setscheduler(<span class="number">0</span>, SCHED_RR |SCHED_RESET_ON_FORK, &amp;sp);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果调用进程的调度策略是SCHED_FIFO或SCHED_RR，那么将fork创建出来的子进程调度策略重设成SCHED_OTHER。</li>
<li>如果调用进程的nice值是负值，那么将fork创建出来的进程的nice值重新设置成0。</li>
</ul>
<p>如何查看进程的调度策略及调度参数？可使用如下语句：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">sched_getscheduler</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">sched_getparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="comment">// sched_getscheduler函数可以返回进程的调度策略，但是无法返回进程的调度参数。</span></span><br><span class="line"><span class="type">int</span> policy  = sched_getscheduler(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">switch</span>(policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> SCHED_OTHER:     <span class="comment">/**/</span></span><br><span class="line">    <span class="keyword">case</span> SCHED_FIFO:</span><br><span class="line">         <span class="comment">/**/</span></span><br><span class="line">    <span class="keyword">case</span> SCHED_RR:</span><br><span class="line">         <span class="comment">/**/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于实时进程，可以调用sched_getparam函数来获得其优先级，代码如下所示：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>；</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">ret</span> ；</span></span><br><span class="line"><span class="class"><span class="title">ret</span> =</span> sched_getparam(<span class="number">0</span>,&amp;sp);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*error handle here*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(“process priority is %d\n”,sp.sched_priority);</span><br><span class="line"><span class="comment">// sched_setscheduler函数用来同时设置调度策略和调度参数。</span></span><br><span class="line"><span class="comment">// 除了该接口外，Linux还提供了一个功能弱化的函数即sched_setparam，该函数可以用来调整进程的调度参数，定义如下：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span> ;</span></span><br><span class="line">sp.sched_priority = <span class="number">15</span>;</span><br><span class="line">ret = sched_setparam(<span class="number">0</span>,&amp;sp);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*error handler*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>除了ps命令外，util-linux包中提供了chrt工具，可以查看和修改进程的调度策略和优先级。</p>
<p>查看进程的调度策略和优先级的方法如下：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ chrt -p 7125</span><br><span class="line">pid 7125<span class="string">&#x27;s current scheduling policy: SCHED_RR</span></span><br><span class="line"><span class="string">pid 7125&#x27;</span>s current scheduling priority: 77</span><br><span class="line">manu@manu-rush:~$ chrt -p 1</span><br><span class="line">pid 1<span class="string">&#x27;s current scheduling policy: SCHED_OTHER</span></span><br><span class="line"><span class="string">pid 1&#x27;</span>s current scheduling priority: 0</span><br></pre></td></tr></table></figure></div>

<p>修改进程的调度策略和优先级的方法如下：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*7135进程最初是普通进程，调度策略为SCHED_OTHER*/</span><br><span class="line">root@manu-rush:~<span class="comment"># chrt -p 7135</span></span><br><span class="line">pid 7135<span class="string">&#x27;s current scheduling policy: SCHED_OTHER</span></span><br><span class="line"><span class="string">pid 7135&#x27;</span>s current scheduling priority: 0</span><br><span class="line">/*-r表示修改调度策略为SCHED_RR，40表示修改优先级为40*/</span><br><span class="line">root@manu-rush:~<span class="comment"># chrt -p -r 40 7135</span></span><br><span class="line">root@manu-rush:~<span class="comment"># chrt -p 7135</span></span><br><span class="line">pid 7135<span class="string">&#x27;s current scheduling policy: SCHED_RR</span></span><br><span class="line"><span class="string">pid 7135&#x27;</span>s current scheduling priority: 40</span><br><span class="line">/*-f表示修改调度策略为SCHED_FIFO，20表示修改优先级为20*/</span><br><span class="line">root@manu-rush:~<span class="comment"># chrt -p -f 20 7135</span></span><br><span class="line">root@manu-rush:~<span class="comment"># chrt -p 7135</span></span><br><span class="line">pid 7135<span class="string">&#x27;s current scheduling policy: SCHED_FIFO</span></span><br><span class="line"><span class="string">pid 7135&#x27;</span>s current scheduling priority: 20</span><br></pre></td></tr></table></figure></div>

<h3 id="限制实时进程运行时间"><a href="#限制实时进程运行时间" class="headerlink" title="限制实时进程运行时间"></a>限制实时进程运行时间</h3><p>实时进程的优先级高于普通进程，如果实时进程处于可执行的状态，那么普通进程无法获得CPU资源。如果使用实时调度策略的进程出现了bug，始终处于可运行的状态，系统将不会调度其他普通进程。这种情况是非常危险的，系统很可能会失去控制，而用户甚至超级用户也无能为力。为了防止出现这种情况，系统做了改进，纵然始终存在可以运行的实时进程，仍然允许普通进程获得一定的CPU时间。系统提供了控制选项来控制单位时间内最多分配多少CPU时间给实时进程。在Linux中，这两个控制参数为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl -n kernel.sched_rt_period_us</span><br><span class="line"><span class="number">1000000</span></span><br><span class="line">sysctl -n kernel.sched_rt_runtime_us</span><br><span class="line"><span class="number">950000</span></span><br></pre></td></tr></table></figure></div>

<p>这两个参数的含义是在以<code>sched_rt_period_us</code>为一个周期的时间内，所有实时进程运行的时间总和不超过<code>sched_rt_runtime_us</code>。这两个配置项的默认值为1秒和0.95秒，表示每秒钟为一个周期，所有实时进程运行的总时间不超过0.95秒，剩下的0.05秒留给普通进程。有了这个机制，哪怕始终有实时进程处于TASK_RUNNING状态，普通进程也能获得运行的机会。如果在一个周期的时间内，实时进程对CPU的需求不足0.95秒，那么剩余的时间都会分配给普通的进程。而如果实时进程对CPU的需求大于0.95秒，它也只能够运行0.95秒，剩下的0.05秒留给其他普通进程。但是如果0.05秒内并没有任何普通进程处于可运行状态，实时进程能否运行超过0.95秒吗？答案还是不能，内核宁可让CPU闲着，也不给实时进程使用。</p>
<p>但是前面讨论的场景都是单CPU的场景，如果存在N个CPU，那么所有CPU上的所有实时进程占有CPU的上限应该为<code>N*sched_rt_runtime_us/sched_rt_period_us</code>。有的CPU上实时进程对CPU的需求超过<code>sched_rt_runtime_us</code>，而有的CPU上实时进程对CPU的需求不足<code>sched_rt_runtime_us</code>，因此内核允许CPU之间互相拆借。若实时进程在CPU上占用的时间超过了<code>sched_rt_runtime_us</code>，则该实时进程会尝试去其他CPU上借时间，将其他CPU剩余的时间借过来。这样做的好处是避免了进程在CPU之间迁移导致的上下文切换、缓存失效等开销。这部分逻辑出现在<code>kernel/sched_rt.c</code>中的<code>sched_rt_runtime_exceeded</code>函数，该函数会通过<code>balance_runtime</code>函数向其他CPU借用时间</p>
<p>事实上，实时进程也支持组调度，可以控制一组实时进程（task_group）占用的CPU时间，将CPU占用的管理分配得更加细致。</p>
<h2 id="CPU的亲和力"><a href="#CPU的亲和力" class="headerlink" title="CPU的亲和力"></a>CPU的亲和力</h2><p>在对称多处理器（SMP）环境中，一个进程被重新调度时，不一定是在上次执行的CPU上运行。同一个进程在不同CPU之间迁移会带来性能的损失，损失的主要原因在于缓存。在进程迁移到新的处理器上后写入新数据到内存时，原有处理器的缓存就过期了。当进程在不同处理器之间迁移时，会带来两方面的性能损失：</p>
<ul>
<li>进程不能访问老的缓存数据；</li>
<li>原处理器中缓存中的数据必须标记为无效。</li>
</ul>
<p>如何查看进程当前运行在哪个CPU上？可以通过ps命令的PSR字段来查看进程当前执行或上一次执行时所在的CPU编号。因为进程调度并不保证进程总是固定在某个CPU上，所以多次查看进程的PSR，其值可能会发生变化。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@manu-rush:~<span class="meta"># ps -p 7214 -o pid,cmd,psr</span></span><br><span class="line">   PID CMD                         PSR</span><br><span class="line">  <span class="number">7214</span> sleep <span class="number">1000</span>                    <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<p>有时候需要把进程绑定到某个或某几个CPU上运行。这就需要设置进程的CPU硬亲和力了。Linux提供了非标准的系统调用来获取和修改进程的硬亲和力：即sched_setaffinity函数和sched_getaffinity函数。sched_setaffinity函数用来设置pid指定进程的CPU亲和力，如果pid的值为0，那么该函数用来修改调用进程的CPU亲和力。函数接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize, <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"><span class="comment">// cpu_set_t数据结构是位掩码，但是不应该直接操作cpu_set_t类型的变量。Linux提供了一组宏来操作cpu_set_t类型的变量：</span></span><br><span class="line"><span class="comment">/*将set初始化为空*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_ZERO</span><span class="params">(<span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*将cpu指定的CPU添加到set中*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">CPU_SET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*从set中删除CPU cpu*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">CPU_CLR</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*判断CPU cpu是否set中的成员*/</span></span><br><span class="line"> <span class="type">int</span>  <span class="title function_">CPU_ISSET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* CPU集合中的编号从0开始。一般在调用CPU_XXX系列函数之前，需要对系统中的CPU核数了然于胸，才能有的放矢。</span></span><br><span class="line"><span class="comment">* 指定cpu的值比系统中的最大CPU编号还大是没有意义的。nproc命令和lscpu命令都可以获取系统的CPU核数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">manu@manu-rush:~$ nproc</span><br><span class="line"><span class="number">2</span></span><br><span class="line">manu@manu-rush:~$ lscpu</span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        <span class="number">32</span>-bit, <span class="number">64</span>-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line"><span class="title function_">CPU</span><span class="params">(s)</span>:                2</span><br><span class="line">On-line <span class="title function_">CPU</span><span class="params">(s)</span> <span class="built_in">list</span>:   0,1</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过proc文件系统的/proc/cpuinfo也可以获取CPU的核数。可以通过下面的代码将某进程迁移到CPU 1上：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Linux提供了sched_getaffinity接口来查看进程的CPU亲和力：</span></span><br><span class="line"><span class="type">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line"><span class="comment">/*必须首先调用CPU_ZERO清空，不可想当然地认为是空*/</span></span><br><span class="line">CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(<span class="number">1</span>,&amp;<span class="built_in">set</span>);</span><br><span class="line">sched_setaffinity(pid,<span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>),&amp;<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure></div>

<p>调用<code>sched_getaffinity</code>之前，需要先调用<code>CPU_ZERO</code>将set清空。函数调用成功时，会将结果记录在set中，但是不要直接操作set来判断哪些CPU在集合中，而是应该用<code>CPU_ISSET</code>来判断。内核如何保证进程只会在某些CPU上执行？内核中的进程对应的进程描述符中有个<code>cpumask_t</code>类型的成员变量<code>cpus_allowed</code>，该成员变量会记住进程允许的CPU。内核在调度的时候会通过<code>select_task_rq</code>来选择CPU，只会选择出允许的CPU。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_task_rq</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> sd_flags, <span class="type">int</span> wake_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cpu = p-&gt;sched_class-&gt;select_task_rq(p, sd_flags, wake_flags);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) ||</span><br><span class="line">             !cpu_online(cpu)))</span><br><span class="line">        cpu = select_fallback_rq(task_cpu(p), p);</span><br><span class="line">    <span class="keyword">return</span> cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>有个很有意思的话题是内核调用select_task_rq的时机：当新的进程创建出来时，当进程调用exec时，当进程从睡眠中醒来时，都是调用select_task_rq的好时机。可以通过这些时机来实现各个CPU之间的负载均衡。</p>
<p>除了编程接口可以获取和修改进程的亲和力以外，Linux的util-linux包中还提供了tasket工具以命令行的方式做同样的事情。它查询进程的CPU亲和力的方法如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ taskset -p <span class="number">1</span></span><br><span class="line">pid <span class="number">1&#x27;</span>s current affinity mask: <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_185.jpg"
                      alt="epub_831302_185"
                ></p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p>在 Linux 和类 Unix 系统中，<code>pid_t</code> 是一个用于表示进程 ID 的数据类型。它通常是一个有符号整数类型，用于标识系统中的进程。以下是关于 <code>pid_t</code> 类型以及相关函数 <code>getpid()</code> 和 <code>getppid()</code> 的详细信息：</p>
<h2 id="pid-t-类型"><a href="#pid-t-类型" class="headerlink" title="pid_t 类型"></a><code>pid_t</code> 类型</h2><ul>
<li><code>pid_t</code> 是一个数据类型，用于表示进程 ID。它通常定义在头文件 <code>&lt;sys/types.h&gt;</code> 中。一般为<code>int</code>类型。</li>
<li>进程 ID 是一个唯一的整数，用于标识系统中的每个进程。</li>
</ul>
<h2 id="getpid-函数"><a href="#getpid-函数" class="headerlink" title="getpid() 函数"></a><code>getpid()</code> 函数</h2><ul>
<li><strong>头文件</strong>: <code>&lt;unistd.h&gt;</code></li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>功能</strong>: <code>getpid()</code> 函数用于获取调用进程的进程 ID。</li>
<li><strong>返回值</strong>: 返回调用进程的进程 ID。</li>
<li><strong>示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current process ID: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="getppid-函数"><a href="#getppid-函数" class="headerlink" title="getppid() 函数"></a><code>getppid()</code> 函数</h2><ul>
<li><strong>头文件</strong>: <code>&lt;unistd.h&gt;</code></li>
<li><strong>原型</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>功能</strong>: <code>getppid()</code> 函数用于获取调用进程的父进程 ID。</li>
<li><strong>返回值</strong>: 返回调用进程的父进程 ID。</li>
<li><strong>示例</strong>:<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ppid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent process ID: %d\n&quot;</span>, ppid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Linux环境编程与内核之进程</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2024-02-01 11:01:40</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-03-16 15:26:00
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2024/02/01/Linux环境编程与内核之进程/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/02/14/FUZZ%E4%B8%93%E9%A2%98/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">FUZZ专题</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Linux内核分析之进程管理</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Linux环境编程与内核之进程</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="nav-text">进程环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="nav-text">程序的开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-exit"><span class="nav-text">关于 exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-atexit"><span class="nav-text">关于 atexit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-text">动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-text">编译生成和使用动态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8D%87%E7%BA%A7"><span class="nav-text">动态升级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-text">内存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C"><span class="nav-text">内存越界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5"><span class="nav-text">内存检查</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%95%BF%E8%B7%B3%E8%BD%AC"><span class="nav-text">长跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#setjmp%E4%B8%8Elongjmp"><span class="nav-text">setjmp与longjmp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E8%B7%B3%E8%BD%AC%E6%9C%BA%E5%88%B6"><span class="nav-text">长跳转机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E8%B7%B3%E8%BD%AC%E9%99%B7%E9%98%B1"><span class="nav-text">长跳转陷阱</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-text">进程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-ID"><span class="nav-text">进程 ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%B1%82%E6%AC%A1"><span class="nav-text">进程层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-text">会话</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fork"><span class="nav-text">fork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vfork"><span class="nav-text">vfork</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Daemon%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">Daemon进程的创建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-text">进程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#exit"><span class="nav-text">_exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exit-1"><span class="nav-text">exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#return"><span class="nav-text">return</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">等待子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait"><span class="nav-text">wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#waitpid"><span class="nav-text">waitpid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%E5%80%BC"><span class="nav-text">等待状态值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#waitid"><span class="nav-text">waitid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%92%8C%E7%AD%89%E5%BE%85%E7%9A%84%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">进程退出和等待的内核实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#exec-%E6%97%8F"><span class="nav-text">exec 族</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#execve"><span class="nav-text">execve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#execve-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">execve 系统调用的内核实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exec%E4%B8%8E%E4%BF%A1%E5%8F%B7"><span class="nav-text">exec与信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Cexec%E4%B9%8B%E5%90%8E%E8%BF%9B%E7%A8%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">执行exec之后进程继承的属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#system"><span class="nav-text">system</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-text">函数接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#system%E4%B8%8E%E4%BF%A1%E5%8F%B7"><span class="nav-text">system与信号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">进程优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6"><span class="nav-text">完全公平调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E5%92%8C%E8%99%9A%E6%8B%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="nav-text">时间片和虚拟运行时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E6%80%A7%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1"><span class="nav-text">周期性调度任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8A%A0%E5%85%A5"><span class="nav-text">新进程的加入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0%E8%BF%9B%E7%A8%8B%E9%86%92%E6%9D%A5"><span class="nav-text">睡眠进程醒来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%A4%E9%86%92%E6%8A%A2%E5%8D%A0"><span class="nav-text">唤醒抢占</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E8%B0%83%E5%BA%A6"><span class="nav-text">普通进程的组调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B"><span class="nav-text">实时进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">实时调度策略和优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3API"><span class="nav-text">实时调度相关API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="nav-text">限制实时进程运行时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E7%9A%84%E4%BA%B2%E5%92%8C%E5%8A%9B"><span class="nav-text">CPU的亲和力</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pid-t-%E7%B1%BB%E5%9E%8B"><span class="nav-text">pid_t 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getpid-%E5%87%BD%E6%95%B0"><span class="nav-text">getpid() 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getppid-%E5%87%BD%E6%95%B0"><span class="nav-text">getppid() 函数</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        121 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>