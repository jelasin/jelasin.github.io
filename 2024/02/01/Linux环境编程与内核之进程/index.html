<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2024/02/01/linux环境编程与内核之进程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="进程环境程序的开始12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; source#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;static void __attribute__ ((constructor)) before_main(void)&amp;#123;    print">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux环境编程与内核之进程">
<meta property="og:url" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="进程环境程序的开始12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; source#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;static void __attribute__ ((constructor)) before_main(void)&amp;#123;    print">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_71.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_73.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_75.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_76.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_79.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_80.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_81.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_84.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_87.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_88.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_90.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_93.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_95.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_99.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_102.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_103.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_104.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_105.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_106.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_110.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_111.jpg">
<meta property="article:published_time" content="2024-02-01T03:01:40.000Z">
<meta property="article:modified_time" content="2025-01-25T10:46:07.263Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Linux_kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_71.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            Linux环境编程与内核之进程 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">42</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">19</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">79</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Linux环境编程与内核之进程</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-02-01 11:01:40</span>
        <span class="mobile">2024-02-01 11:01:40</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-01-25 18:46:07</span>
            <span class="mobile">2025-01-25 18:46:07</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/Linux-kernel/">Linux kernel</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Linux-kernel/">Linux_kernel</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h1><h2 id="程序的开始"><a href="#程序的开始" class="headerlink" title="程序的开始"></a>程序的开始</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__ ((constructor)) before_main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before main...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// complier</span></span><br><span class="line">$ gcc -v first.c -o first</span><br><span class="line">[...]</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;...&quot;</span> search starts here:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span> search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search <span class="built_in">list</span>.</span><br><span class="line">[...]</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;first&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> as -v -<span class="number">-64</span> -o /tmp/cckaqfwB.o /tmp/cc6KuP5q.s</span><br><span class="line">GNU assembler version <span class="number">2.38</span> (x86_64-linux-gnu) using BFD version (GNU Binutils <span class="keyword">for</span> Ubuntu) <span class="number">2.38</span></span><br><span class="line">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/:/usr/lib/gcc/x86_64-linux-gnu/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;first&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span> <span class="string">&#x27;-dumpdir&#x27;</span> <span class="string">&#x27;first.&#x27;</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/lto-wrapper -plugin-opt=-fresolution=/tmp/ccL3y8nT.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> -pie -z now -z relro -o first /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span> -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../.. /tmp/cckaqfwB.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">11</span>/../../../x86_64-linux-gnu/crtn.o</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;first&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span> <span class="string">&#x27;-dumpdir&#x27;</span> <span class="string">&#x27;first.&#x27;</span></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Before main...</span><br><span class="line">Main!</span><br></pre></td></tr></table></figure></div>

<p>在链接生成最后的可执行文件时，有大量的C库二进制文件参与进来，如crt1.o、crti.o等。可见最终的可执行文件，除了我们编写的这个简单的C代码以外，还有大量的C库文件参与了链接，并包含在最终的可执行文件中。这个“组装”的过程，是由链接器ld的链接脚本来决定的。在没有指定链接脚本的情况下，会使用ld的默认脚本，可以通过ld–verbose来查看，</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">❯ ld -verbose</span><br><span class="line">[...]</span><br><span class="line"><span class="comment">// 这里定义了输出的文件格式、目标机器的类型，以及重要的信息和程序的入口ENTRY（_start）​。</span></span><br><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf64-x86-64&quot;</span>, <span class="string">&quot;elf64-x86-64&quot;</span>,</span><br><span class="line">	      <span class="string">&quot;elf64-x86-64&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(i386:x86<span class="number">-64</span>)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/local/lib/x86_64-linux-gnu&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/lib/x86_64-linux-gnu&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/lib/x86_64-linux-gnu&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/lib/x86_64-linux-gnu64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/local/lib64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/lib64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/lib64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/local/lib&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/lib&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/lib&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/x86_64-linux-gnu/lib64&quot;</span>); SEARCH_DIR(<span class="string">&quot;=/usr/x86_64-linux-gnu/lib&quot;</span>);</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 这里定义了.ctors section，而我们的例子中before_main函数使用的gcc扩展属性__attribute__（​（constructor）​）</span></span><br><span class="line"><span class="comment">  * 就是将函数对应的指令归属于.ctors section中。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  .ctors          :</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* gcc uses crtbegin.o to find the start of</span></span><br><span class="line"><span class="comment">       the constructors, so we make sure it is</span></span><br><span class="line"><span class="comment">       first.  Because this is a wildcard, it</span></span><br><span class="line"><span class="comment">       doesn&#x27;t matter if the user does not</span></span><br><span class="line"><span class="comment">       actually link against crtbegin.o; the</span></span><br><span class="line"><span class="comment">       linker won&#x27;t look for a file to match a</span></span><br><span class="line"><span class="comment">       wildcard.  The wildcard also means that it</span></span><br><span class="line"><span class="comment">       doesn&#x27;t matter which directory crtbegin.o</span></span><br><span class="line"><span class="comment">       is in.  */</span></span><br><span class="line">    KEEP (*crtbegin.o(.ctors))</span><br><span class="line">    KEEP (*crtbegin?.o(.ctors))</span><br><span class="line">    <span class="comment">/* We don&#x27;t want to include the .ctor section from</span></span><br><span class="line"><span class="comment">       the crtend.o file until after the sorted ctors.</span></span><br><span class="line"><span class="comment">       The .ctor section from the crtend file contains the</span></span><br><span class="line"><span class="comment">       end of ctors marker and it must be last */</span></span><br><span class="line">    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))</span><br><span class="line">    KEEP (*(SORT(.ctors.*)))</span><br><span class="line">    KEEP (*(.ctors))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 这里定义了.dtors section，是main函数结束调用的代码。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  .dtors          :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP (*crtbegin.o(.dtors))</span><br><span class="line">    KEEP (*crtbegin?.o(.dtors))</span><br><span class="line">    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))</span><br><span class="line">    KEEP (*(SORT(.dtors.*)))</span><br><span class="line">    KEEP (*(.dtors))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面我们来追溯一下Linux可执行程序完整的启动过程。前面的链接脚本明确了入口为<code>_start</code>。在32位的x86平台中，<code>_start</code>位于<code>sysdeps/i386/start.S</code>中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .globl _start</span><br><span class="line">    .type _start,@function</span><br><span class="line">_start:</span><br><span class="line">    <span class="comment">/* Clear the frame pointer.  The ABI suggests this be done, to mark</span></span><br><span class="line"><span class="comment">       the outermost frame obviously.  */</span></span><br><span class="line">    xorl %ebp, %ebp</span><br><span class="line">    <span class="comment">/* Extract the arguments as encoded on the stack and set up</span></span><br><span class="line"><span class="comment">       the arguments for `main&#x27;: argc, argv.  envp will be determined</span></span><br><span class="line"><span class="comment">       later in __libc_start_main.  */</span></span><br><span class="line">    popl %esi       <span class="comment">/* Pop the argument count.  */</span></span><br><span class="line">    movl %esp, %ecx     <span class="comment">/* argv starts just at the current stack top.*/</span></span><br><span class="line">    <span class="comment">/* Before pushing the arguments align the stack to a 16-byte</span></span><br><span class="line"><span class="comment">    (SSE needs 16-byte alignment) boundary to avoid penalties from</span></span><br><span class="line"><span class="comment">    misaligned accesses.  Thanks to Edward Seidl &lt;seidl@janed.com&gt;</span></span><br><span class="line"><span class="comment">    for pointing this out.  */</span></span><br><span class="line">    andl $<span class="number">0xfffffff0</span>, %esp</span><br><span class="line">    pushl %eax      <span class="comment">/* Push garbage because we allocate</span></span><br><span class="line"><span class="comment">                   28 more bytes.  */</span></span><br><span class="line">    <span class="comment">/* Provide the highest stack address to the user code (for stacks</span></span><br><span class="line"><span class="comment">       which grow downwards).  */</span></span><br><span class="line">    pushl %esp</span><br><span class="line">    pushl %edx      <span class="comment">/* Push address of the shared library</span></span><br><span class="line"><span class="comment">                   termination function.  */</span></span><br><span class="line">    <span class="comment">/* Push address of our own entry points to .fini and .init.  */</span></span><br><span class="line">    pushl $__libc_csu_fini</span><br><span class="line">    pushl $__libc_csu_init</span><br><span class="line">    pushl %ecx      <span class="comment">/* Push second argument: argv.  */</span></span><br><span class="line">    pushl %esi      <span class="comment">/* Push first argument: argc.  */</span></span><br><span class="line">    pushl $BP_SYM (main)</span><br><span class="line">    <span class="comment">/* Call the user&#x27;s main function, and exit with its value.</span></span><br><span class="line"><span class="comment">       But let the libc call main.    */</span></span><br><span class="line">    call <span class="title function_">BP_SYM</span> <span class="params">(__libc_start_main)</span></span><br></pre></td></tr></table></figure></div>

<p>上面列出的虽然是汇编代码，但是每一行都有清楚的注释，这段代码主要是为程序的运行创建好运行环境，其中需要注意的是，<code>__libc_csu_fini</code>和<code>__libc_csu_init</code>都被作为参数传给了<code>__libc_start_main</code>。从这两个函数的名字上可以推测它们是用来处理退出和初始化阶段的函数，那么<code>.ctors section</code>中的函数很可能就是由<code>__libc_csu_init</code>来调用的。我们先来关注<code>__libc_csu_init</code>是在何时被调用的，然后再分析其实现。上面的汇编代码将这两个函数作为参数传递给了<code>__libc_start_main</code>，然后又调用了<code>generic_start_main</code>函数。这个函数初始化了C库所需要的环境，如环境变量、函数栈、多线程环境等，最后调用main函数——进入普通应用程序的真正入口。而在此之前，以下代码先被执行：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line"><span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line">    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br></pre></td></tr></table></figure></div>

<p>init即为<code>__libc_csu_init</code>，上面的代码保证了<code>__libc_csu_init</code>在main之前被调用。<code>.ctors</code>的函数调用流程：<code>__libc_csu_init-&gt;_init-&gt;__libc_global_ctors</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_global_ctors (<span class="type">void</span>)</span><br><span class="line">&#123;<span class="comment">/* Call constructor functions.  */</span></span><br><span class="line">    run_hooks (__CTOR_LIST__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">run_hooks</span> <span class="params">(<span class="type">void</span> (*<span class="type">const</span> <span class="built_in">list</span>[]) (<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (*++<span class="built_in">list</span>)</span><br><span class="line">        (**<span class="built_in">list</span>) ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*<span class="type">const</span> __CTOR_LIST__[<span class="number">1</span>])</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">  __<span class="title function_">attribute__</span> <span class="params">((used, section (<span class="string">&quot;.ctors&quot;</span>)))</span></span><br><span class="line">  = &#123; (<span class="type">void</span> (*) (<span class="type">void</span>)) <span class="number">-1</span> &#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>__CTOR_LIST__</code>是一个函数指针数组，数组的大小为1。该数组使用gcc的扩展属性，使<code>__CTOR_LIST__</code>位于<code>.ctors section</code>中。因此，在上面的代码中，<code>__libc_global_ctors</code>将<code>__CTOR_LIST__</code>传递给了<code>run_hooks</code>，实际上就是将<code>.ctors section</code>的起始地址传递给了<code>run_hooks</code>。而<code>__CTOR_LIST__</code>位于<code>.ctors</code>的第一个位置，其本身并不是一个真正的<code>.ctors</code>属性函数，因此<code>run_hooks</code>的<code>while（*++list）</code>先执行自增操作，即跳过了<code>__CTOR_LIST__</code>。</p>
<p>可以通过 <code>r2</code> 反汇编查看二进制的可执行程序来验证：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">080483e4 &lt;before_main&gt;:</span><br><span class="line">80483e4:       55                      push   %ebp</span><br><span class="line">80483e5:       89 e5                   mov    %esp,%ebp</span><br><span class="line">80483e7:       83 ec 18                sub    $0x18,%esp</span><br><span class="line">80483ea:       c7 04 24 e0 84 04 08    movl   $0x80484e0,(%esp)</span><br><span class="line">80483f1:       e8 22 ff ff ff          call   8048318 &lt;puts@plt&gt;</span><br><span class="line">80483f6:       c9                      leave</span><br><span class="line">80483f7:       c3                      ret</span><br></pre></td></tr></table></figure></div>

<p>可以看到，函数<code>before_main</code>的地址为<code>0x080483e4</code>。然后使用<code>objdump</code>来查看<code>.ctors section：</code></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objdump -s -j .ctors a.out</span><br><span class="line">a.out:     file format elf32-i386</span><br><span class="line">Contents of section .ctors:</span><br><span class="line">8049f08 ffffffff e4830408 00000000           ……</span><br></pre></td></tr></table></figure></div>

<p>可以看到，<code>.ctors section</code>的第一个元素即上文中的<code>__CTOR_LIST__</code>，第二个元素为<code>before_main</code>——由于x86是小端CPU，因此0xe4830408实际上表示的地址值为0x080483e4。</p>
<p>需要注意的是，在新版本的gcc中，.ctors属性的函数并不会位于<code>.ctors section</code>中，而是被gcc合并到了<code>.init_array section</code>中，<code>.dtors section</code>也被合并到了<code>.fini_array section</code>中。下面来看一下这种情况下的objdump输出：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到，在.ctors section中，没有任何有效的.ctors函数，</span></span><br><span class="line">[fgao@fgao chapter3]<span class="comment">#objdump -s -j .ctors a.out</span></span><br><span class="line">a.out:     file format elf32-i386</span><br><span class="line">Contents of section .ctors:</span><br><span class="line">8049600 ffffffff 00000000</span><br><span class="line"><span class="comment"># 保存在.init_array section中的函数调用机制与之前分析的.ctors section机制类似的。</span></span><br><span class="line">[fgao@fgao chapter3]<span class="comment">#objdump -s -j .init_array a.out</span></span><br><span class="line">a.out:     file format elf32-i386</span><br><span class="line">Contents of section .init_array:</span><br><span class="line">80495fc b4830408</span><br></pre></td></tr></table></figure></div>

<h2 id="关于-exit"><a href="#关于-exit" class="headerlink" title="关于 exit"></a>关于 exit</h2><p>在刚刚学习C语言的时候，我们就被告知分配内存以后，如果不使用free来释放内存，就会造成内存的泄漏。同样，打开文件以后，如果忘记close也会造成资源的泄漏。那么，在进程退出以后，这些资源是否真的泄漏了呢？</p>
<p>当进程正常退出时，会调用C库的exit；而当进程崩溃或被kill掉时，C库的exit则不会被调用，只会执行内核退出进程的操作。</p>
<p>首先，我们来分析C库的退出函数exit，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>C库的exit主要用来执行所有注册的退出函数，比如使用atexit或on_exit注册的函数。执行完注册的退出函数后，<code>__run_exit_handlers</code>会调用<code>_exit</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_exit (status)</span><br><span class="line">     <span class="type">int</span> status;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NR_exit_group</span></span><br><span class="line">      INLINE_SYSCALL (exit_group, <span class="number">1</span>, status);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      INLINE_SYSCALL (<span class="built_in">exit</span>, <span class="number">1</span>, status);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ABORT_INSTRUCTION</span></span><br><span class="line">      ABORT_INSTRUCTION;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码很简单，当平台有<code>exit_group</code>时，就调用<code>exit_group</code>，否则就调用exit。从Linux内核2.5.35版本以后，为了支持线程，就有了<code>exit_group</code>。这个系统调用不仅仅是用于退出当前线程，还会让所有线程组的线程全部退出。下面来看看系统调用<code>exit_group</code>的实现：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(exit_group, <span class="type">int</span>, error_code)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* do_group_exit做真正的工作 */</span></span><br><span class="line">    do_group_exit((error_code &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="comment">/* NOTREACHED */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">NORET_TYPE <span class="type">void</span></span><br><span class="line"><span class="title function_">do_group_exit</span><span class="params">(<span class="type">int</span> exit_code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span> =</span> current-&gt;signal;</span><br><span class="line">    BUG_ON(exit_code &amp; <span class="number">0x80</span>); <span class="comment">/* core dumps don&#x27;t get here */</span></span><br><span class="line">    <span class="comment">/* 检查该线程组是否正在退出，如果条件为真，则不需要设置线程组退出的条件，直接执行本线程task退出流程do_exit即可 */</span></span><br><span class="line">    <span class="keyword">if</span> (signal_group_exit(sig))</span><br><span class="line">        exit_code = sig-&gt;group_exit_code;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!thread_group_empty(current)) &#123; <span class="comment">/* 线程组不为空 */</span></span><br><span class="line">        <span class="keyword">struct</span> sighand_struct *<span class="type">const</span> sighand = current-&gt;sighand;</span><br><span class="line">        spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">        <span class="comment">/* 标准的双重条件检查机制。因为第一次检查signal_group_exit时为假，</span></span><br><span class="line"><span class="comment">        *  但是另外一个线程已经拿到锁，并设置了状态。当拿到锁的时候，需要再次检查</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (signal_group_exit(sig)) &#123;</span><br><span class="line">            <span class="comment">/* Another thread got here before we took the lock.  */</span></span><br><span class="line">            exit_code = sig-&gt;group_exit_code;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 设置线程组的退出值和退出状态 */</span></span><br><span class="line">            sig-&gt;group_exit_code = exit_code;</span><br><span class="line">            sig-&gt;flags = SIGNAL_GROUP_EXIT;</span><br><span class="line">            <span class="comment">/* 使用SIGKILL“干掉”线程组的其他线程 */</span></span><br><span class="line">            zap_other_threads(current);</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 真正的退出动作，退出当前线程task */</span></span><br><span class="line">    do_exit(exit_code);</span><br><span class="line">    <span class="comment">/* NOTREACHED */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面来看看<code>do_exit</code>的实现：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">NORET_TYPE <span class="type">void</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> group_dead;</span><br><span class="line">    profile_task_exit(tsk);</span><br><span class="line">    WARN_ON(blk_needs_flush_plug(tsk));</span><br><span class="line">    <span class="comment">/* 中断上下文不能使用退出，因为没有进程上下文 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(in_interrupt()))</span><br><span class="line">        panic(<span class="string">&quot;Aiee, killing interrupt handler!&quot;</span>);</span><br><span class="line">    <span class="comment">/* pid为0，即内核的idle进程。这个task也是不应该退出的 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!tsk-&gt;pid))</span><br><span class="line">        panic(<span class="string">&quot;Attempted to kill the idle task!&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If do_exit is called because this processes oopsed, it&#x27;s possible</span></span><br><span class="line"><span class="comment">     * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before</span></span><br><span class="line"><span class="comment">     * continuing. Amongst other possible reasons, this is to prevent</span></span><br><span class="line"><span class="comment">     * mm_release()-&gt;clear_child_tid() from writing to a user-controlled</span></span><br><span class="line"><span class="comment">     * kernel address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    set_fs(USER_DS);</span><br><span class="line">    <span class="comment">/* 如果task正在被跟踪如gdb，则发送ptrace事件 */</span></span><br><span class="line">    ptrace_event(PTRACE_EVENT_EXIT, code);</span><br><span class="line">    validate_creds_for_do_exit(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;re taking recursive faults here in do_exit. Safest is to just</span></span><br><span class="line"><span class="comment">     * leave this task alone and wait for reboot.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 当task退出的时候，会被设置上PF_EXITING标志。如果发现此时flags已经设置了该标志，则说明发生了错误。此时就要按照注释所说的，最安全的方法是什么都不做，通知并等待重启 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tsk-&gt;flags &amp; PF_EXITING)) &#123;</span><br><span class="line">        printk(KERN_ALERT</span><br><span class="line">            <span class="string">&quot;Fixing recursive fault but reboot is needed!\n&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We can do this unlocked here. The futex code uses</span></span><br><span class="line"><span class="comment">         * this flag just to verify whether the pi state</span></span><br><span class="line"><span class="comment">         * cleanup has been done or not. In the worst case it</span></span><br><span class="line"><span class="comment">         * loops once more. We pretend that the cleanup was</span></span><br><span class="line"><span class="comment">         * done as there is no way to return. Either the</span></span><br><span class="line"><span class="comment">         * OWNER_DIED bit is set by now or we push the blocked</span></span><br><span class="line"><span class="comment">         * task into the wait for ever nirwana as well.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">        <span class="comment">/* 将当前task设置为不可中断的状态，然后放弃CPU。 */</span></span><br><span class="line">        set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果当前task是中断线程，即每个CPU中断由一个线程来处理，则设置对应的中断停止来唤醒本线程。</span></span><br><span class="line"><span class="comment">    * 这是一个编译选项，默认情况下是关闭的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    exit_irq_thread();</span><br><span class="line">    <span class="comment">/* 给task设置退出标志PF_EXITING */</span></span><br><span class="line">    exit_signals(tsk);  <span class="comment">/* sets PF_EXITING */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * tsk-&gt;flags are checked in the futex code to protect against</span></span><br><span class="line"><span class="comment">     * an exiting task cleaning up the robust pi futexes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    raw_spin_unlock_wait(&amp;tsk-&gt;pi_lock);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(in_atomic()))</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;note: %s[%d] exited with preempt_count %d\n&quot;</span>,</span><br><span class="line">                current-&gt;comm, task_pid_nr(current),</span><br><span class="line">                preempt_count());</span><br><span class="line">    acct_update_integrals(tsk);</span><br><span class="line">    <span class="comment">/* sync mm&#x27;s RSS info before statistics gathering */</span></span><br><span class="line">    <span class="comment">/* 该task有自己的内存空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;mm)</span><br><span class="line">        sync_mm_rss(tsk, tsk-&gt;mm); <span class="comment">//更新内存统计计数</span></span><br><span class="line">    <span class="comment">/* 判断整个线程组是否都已经退出。*/</span></span><br><span class="line">    group_dead = atomic_dec_and_test(&amp;tsk-&gt;signal-&gt;live);</span><br><span class="line">    <span class="keyword">if</span> (group_dead) &#123;</span><br><span class="line">        <span class="comment">/* 取消高精度定时器 */</span></span><br><span class="line">        hrtimer_cancel(&amp;tsk-&gt;signal-&gt;real_timer);</span><br><span class="line">        <span class="comment">/* 删除task的内部定时器，对应系统调用getitimer和setitimer */</span></span><br><span class="line">        exit_itimers(tsk-&gt;signal);</span><br><span class="line">        <span class="keyword">if</span> (tsk-&gt;mm)</span><br><span class="line">            setmax_mm_hiwater_rss(&amp;tsk-&gt;signal-&gt;maxrss, tsk-&gt;mm);</span><br><span class="line">    &#125;</span><br><span class="line">    acct_collect(code, group_dead);</span><br><span class="line">    <span class="comment">/* 如果整个线程组都已经退出，则释放授权资源 */</span></span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        tty_audit_exit();</span><br><span class="line">    <span class="keyword">if</span> (unlikely(tsk-&gt;audit_context))</span><br><span class="line">        audit_free(tsk);</span><br><span class="line">    <span class="comment">/* 设置task的退出值 */</span></span><br><span class="line">    tsk-&gt;exit_code = code;</span><br><span class="line">    <span class="comment">/* 释放任务统计资源 */</span></span><br><span class="line">    taskstats_exit(tsk, group_dead);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    释放task的内存空间。task使用的所有内存页都由内核来维护。对于用户程序，如果忘记释放申请的内存，则只会造成用户程序无法再使用该内存，因为内核认为该内存仍然在被用户程序使用。当task退出时，内核会负责释放所有的内存地址。因此当进程退出时，所有申请的内存都会被释放，不会有任何的内存泄漏。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    exit_mm(tsk);</span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        acct_process();</span><br><span class="line">    trace_sched_process_exit(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    检查是否释放了semphore资源，如没有释放则执行semphore的undo操作。这点用于保证在进程意外退出时，能恢复semphore的正确状态，也可以用于预防错误的程序逻辑所导致的semphore释放操作遗漏。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    exit_sem(tsk);</span><br><span class="line">    <span class="comment">/* 释放共享内存 */</span></span><br><span class="line">    exit_shm(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果文件资源没有被共享，则释放所有的文件资源。即使用户程序有文件泄漏也不必担心，一旦task退出，文件资源都会得到正确的释放—因为内核维护了所有的、打开的文件。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    exit_files(tsk);</span><br><span class="line">    <span class="comment">/* 释放task的文件系统资源，如当前目录、根目录等*/</span></span><br><span class="line">    exit_fs(tsk);</span><br><span class="line">    check_stack_usage();</span><br><span class="line">    <span class="comment">/* 释放task资源，如TSS段等 */</span></span><br><span class="line">    exit_thread();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Flush inherited counters to the parent - before the parent</span></span><br><span class="line"><span class="comment">     * gets woken up by child-exit notifications.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">     * because of cgroup mode, must be called before cgroup_exit()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    perf_event_exit_task(tsk);</span><br><span class="line">    <span class="comment">/* 从控制组退出，并释放相关资源 */</span></span><br><span class="line">    cgroup_exit(tsk, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 如果线程组都已经退出，则断开控制终端即tty */</span></span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        disassociate_ctty(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 后面仍然是一些task退出的清理工作，因与本节关系不大，所以在此不再一一列出了 */</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从<code>exit</code>的源码可以得知，即使应用程序在应用层有内存泄漏或文件句柄泄漏也不必担心，当进程退出时，内核的<code>exit_group</code>调用将会默默地在后面做着清理工作，释放所有内存，关闭所有文件，以及其他资源——当然，前提条件是这些资源是该进程独享的。</p>
<h2 id="关于-atexit"><a href="#关于-atexit" class="headerlink" title="关于 atexit"></a>关于 atexit</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">callback1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">callback2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">callback3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    atexit(callback1);</span><br><span class="line">    atexit(callback2);</span><br><span class="line">    atexit(callback3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">main <span class="built_in">exit</span></span><br><span class="line">callback3</span><br><span class="line">callback2</span><br><span class="line">callback1</span><br></pre></td></tr></table></figure></div>

<p>从上面的代码输出可以看出，我们顺序地注册callback1、callback2和callback3，当进程退出时，其调用顺序为callback3、callback2和callback1。</p>
<p>使用atexit注册的退出函数是在进程正常退出时，才会被调用。这里的正常退出是指，使用exit退出或使用main中最后的return语句退出。若是因为收到信号而导致程序退出，atexit注册的退出函数则不会被调用。下面我们通过一个测试程序来验证这一观点：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">callback1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    atexit(callback1);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// terminal</span></span><br><span class="line">&gt;                                | &gt; ./atexit_signal;</span><br><span class="line">&gt; killall atexit_signal  		 |  </span><br><span class="line">&gt;    							 |    Terminated</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们会发现atexit注册的退出函数并没有被调用，下面我们来看一下其在 glibc 中的源码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> atexit</span></span><br><span class="line">attribute_hidden</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">atexit (<span class="type">void</span> (*func) (<span class="type">void</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* __dso_handle是动态共享对象的句柄，此处可以略过 */</span></span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) func, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">__cxa_atexit (<span class="type">void</span> (*func) (<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* __exit_funcs为退出函数的链表 */</span></span><br><span class="line">    <span class="keyword">return</span> __internal_atexit (func, arg, d, &amp;__exit_funcs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__internal_atexit (<span class="type">void</span> (*func) (<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d,</span><br><span class="line">          <span class="keyword">struct</span> exit_function_list **listp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 在退出函数链表中，得到一个新的节点 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">new</span> =</span> __new_exitfn (listp);</span><br><span class="line">  <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">  PTR_MANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* 初始化这个节点，将函数及其参数赋给这个节点 */</span></span><br><span class="line">  new-&gt;func.cxa.fn = (<span class="type">void</span> (*) (<span class="type">void</span> *, <span class="type">int</span>)) func;</span><br><span class="line">  new-&gt;func.cxa.arg = arg;</span><br><span class="line">  new-&gt;func.cxa.dso_handle = d;</span><br><span class="line">  atomic_write_barrier ();</span><br><span class="line">  new-&gt;flavor = ef_cxa;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码揭示了atexit是如何把函数注册到退出函数链表中的。那么，这些函数又是何时被调用的呢？回忆atexit的介绍，退出注册函数只有在程序正常退出或调用exit时才会被执行。程序正常退出时，系统就会调用exit。因此，问题的关键就在于exit函数了：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这里，<code>__run_exit_handlers</code>会遍历<code>__exit_funcs</code>，一一调用注册的退出函数，在此就不再罗列其代码了。从atexit的实现机制上进行分析，我们可以得出atexit的实现是依赖于C库的代码的。当进程收到信号时，如果没有注册对应的信号处理函数，那么内核就会执行信号的默认动作，一般是直接终止进程。这时，进程的退出完全由内核来完成，自然不会调用到C库的exit函数，也就无法调用注册的退出函数了。</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>Linux环境下，程序在启动的时候都会从shell环境下继承当前的环境变量，如<code>PATH、HOME、TZ</code>等。我们也可以通过C库的接口来增加、修改或删除当前进程的环境变量，<code>putenv</code>用于增加或修改当前的环境变量。<code>string</code>的格式为“名字&#x3D;值”。如果当前环境变量没有该名称的环境变量，则增加这个新的环境变量；如果已经存在，则使用新值。看似功能很简单，但实际上使用这个接口时，却很容易犯错。请看下面的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_env_string</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> test_env[] = <span class="string">&quot;test_env=test&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != putenv(test_env)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to putenv\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1. The test_evn string is %s\n&quot;</span>, getenv(<span class="string">&quot;test_env&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_env_string</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2. The test_env string is %s\n&quot;</span>, getenv(<span class="string">&quot;test_env&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    set_env_string();</span><br><span class="line">    show_env_string();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">1.</span> The test_evn <span class="built_in">string</span> is test</span><br><span class="line"><span class="number">2.</span> The test_env <span class="built_in">string</span> <span class="title function_">is</span> <span class="params">(null)</span></span><br></pre></td></tr></table></figure></div>

<p>使用putenv添加环境变量时，参数直接被当作环境变量的一部分了。对于本例而言，<code>set_env_string</code>中的<code>test_env</code>数组直接被环境变量引用了。而<code>test_env</code>是一个局部变量，在执行<code>set_env_string</code>的时候，<code>test_env</code>已经不存在了，对应栈上的内存会在后面的函数调用中使用，并存入其他值。因此，在进入<code>show_env_string</code>的时候，就无法得到正确的值了。</p>
<blockquote>
<p>笔者曾经修改过一个因为putenv引起的bug，当时也是费了很大一番力气才找到根本原因，所以颇为气愤当时的开发人员为什么在使用putenv的时候，不认真阅读该接口的说明。Martin Golding曾说过一句话“编程的时候，要总是想着那个维护你代码的人会是一个知道你住在哪儿的、有暴力倾向的精神病患者”。</p>
</blockquote>
<p>如果非要用putenv来设置环境变量，就必须要保证参数是一个长期存在的内容。因此，只能选择全局变量、常量或动态内存等。为了避免犯错，我们应该尽量使用另外一个接口<code>setenv</code>，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* @name：要加入的环境变量名称。</span></span><br><span class="line"><span class="comment">*  @value：该环境变量的值。</span></span><br><span class="line"><span class="comment">*  @overwrite：用于指示是否覆盖已存在的重名环境变量。0不覆盖，非0则覆盖。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_env_string</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setenv(<span class="string">&quot;test_env&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1. The test_evn string is %s\n&quot;</span>, getenv(<span class="string">&quot;test_env&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_env_string</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2. The test_env string is %s\n&quot;</span>, getenv(<span class="string">&quot;test_env&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    set_env_string();</span><br><span class="line">    show_env_string();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">1.</span> The test_evn <span class="built_in">string</span> is test</span><br><span class="line"><span class="number">2.</span> The test_env <span class="built_in">string</span> is test</span><br></pre></td></tr></table></figure></div>

<h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><h2 id="编译生成和使用动态库"><a href="#编译生成和使用动态库" class="headerlink" title="编译生成和使用动态库"></a>编译生成和使用动态库</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="number">4</span>_5_2_dlib.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dynamic_lib_call</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dynamic lib call\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ gcc -Wall -shared <span class="number">4</span>_5_2_dlib.c -o libdlib.so</span><br><span class="line">$ cat <span class="number">4</span>_5_2_main.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">dynamic_lib_call</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    dynamic_lib_call();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ gcc -Wall <span class="number">4</span>_5_2_main.c -o test_dlib -L ./-ldlib</span><br><span class="line">$ ./test_dlib</span><br><span class="line">./test_dlib: error <span class="keyword">while</span> loading shared libraries: libdlib.so: cannot open shared object file: No such file or directory</span><br><span class="line"></span><br><span class="line">$ ldd test_dlib</span><br><span class="line">        linux-gate.so<span class="number">.1</span> =&gt;  (<span class="number">0xb7785000</span>)</span><br><span class="line">        libdlib.so =&gt; not found</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/i386-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0xb75ce000</span>)</span><br><span class="line">        /lib/ld-linux.so<span class="number">.2</span> (<span class="number">0xb7786000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>显示无法找到<code>libdlib.so</code>。原因在于-L只是在gcc编译的过程中指示库的位置，而在程序运行的时候，动态库的加载路径默认为<code>/lib</code>和<code>/usr/lib</code>。在Linux环境下，还可以通过<code>/etc/ld.so.conf</code>配置文件和环境变量<code>LD_LIBRARY_PATH</code>指示额外的动态库路径，或者使用<code>patch_elf</code>修改动态库路径。为简单起见，我们在这里将<code>libdlib.so</code>复制到<code>/usr/lib</code>目录下，再运行test_dlib试试：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> /home/fgao/works/my_git_codes/my_books/understanding_apue/sample_codes/chapter3/libdlib.so .</span><br><span class="line">$ ./test_dlib</span><br><span class="line">dynamic lib call</span><br></pre></td></tr></table></figure></div>

<p>上面的例子中，动态库是由系统自动加载的，所以需要将动态库放在指定的目录下。然而，C库还提供了dlopen等接口来支持手工加载动态库的功能，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *dlib = dlopen(<span class="string">&quot;./libdlib.so&quot;</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (!dlib) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dlopen failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> (*dfunc) (<span class="type">void</span>) = dlsym(dlib, <span class="string">&quot;dynamic_lib_call&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dfunc) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dlsym failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfunc();</span><br><span class="line">    dlclose(dlib);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">$ gcc -Wall <span class="number">4</span>_5_2_main_mlib.c -ldl -o test_mlib</span><br><span class="line">$ ./test_dlib</span><br><span class="line">dynamic lib call </span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程。</span></span><br><span class="line"><span class="comment">// flag中必须设置以下的mode：</span></span><br><span class="line"><span class="comment">// RTLD_LAZY 暂缓决定，等有需要时再解出符号 </span></span><br><span class="line"><span class="comment">// RTLD_NOW 立即决定，返回前解除所有未决定的符号。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当动态链接库操作函数执行失败时，可以返回出错信息，返回值为NULL时，表示没有错误信息。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle是由dlopen打开动态链接库后返回的指针，symbol就是要求获取的函数的名称，函数返回值是void*,指向函数的地址，供调用使用。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将该.so的引用计数减一，当引用计数为0时，将它从系统中卸载。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="动态升级"><a href="#动态升级" class="headerlink" title="动态升级"></a>动态升级</h2><p>动态库的一个重要优点就是，可执行程序并不包含动态库中的任何指令，而是在运行时加载动态库并完成调用。这就给我们提供了升级动态库的机会。只要保证接口不变，使用新版本的动态库替换原来的动态库，就完成了动态库的升级。</p>
<p>更新完库文件以后启动的可执行程序都会使用新的动态库。这样的更新方法只能够影响更新以后启动的程序，对于正在运行的程序则无法产生效果，因为程序在运行时，旧的动态库文件已经加载到内存中了。我们只能更新位于磁盘上的动态库的物理文件，而不能影响已经位于内存中的库了。</p>
<p>对于服务程序来说，重启会付出很大的代价并带来糟糕的用户体验。但可以使用前面介绍的手工加载动态库的方法。下面的伪代码将给出一个比较简单的解决方案。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) 使用一个结构体来管理动态库的接口：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlib_manager</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *dlib_handle; <span class="comment">//保存动态库的句柄</span></span><br><span class="line">    <span class="type">int</span> (service_func) (<span class="type">void</span> *);</span><br><span class="line">    <span class="type">int</span> (service_func2) (<span class="type">void</span> *);</span><br><span class="line">&#125; g_dlib_manager;</span><br><span class="line"><span class="comment">/* g_dlib_manager作为动态库接口的全局变量 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlib_manager</span> *<span class="title">g_dlib_manager</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2)c利用dlopen、dlsym等来加载动态库，更新接口。重新申请新的内存，来保存新的动态库接口：</span></span><br><span class="line"><span class="comment">/* 更新动态库接口 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlib_manager</span> *<span class="title">new_manager</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new_manager));</span><br><span class="line">new_manager-&gt;dlib_handle = dlopen(<span class="string">&quot;libupgrade.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">new_manager-&gt;service_func = dlsym(g_dlib_handle, <span class="string">&quot;service_call&quot;</span>);</span><br><span class="line">new_manager-&gt;service_func2 = dlsym(g_dlib_handle, <span class="string">&quot;service_call2&quot;</span>);</span><br><span class="line"><span class="comment">/* 在多核环境下，使用内存屏障，以保证在交换new_manager和g_dlib_manager时，new_manager已经完成了赋值 */</span></span><br><span class="line">wmb();</span><br><span class="line"><span class="comment">// 交换新指针与当前正在使用的接口指针，因为目前，无论是新指针还是旧指针都是有效的接口，所以并不会对业务产生影响</span></span><br><span class="line">swap(new_manager, g_dlib_manager);</span><br><span class="line"><span class="comment">// 交换完成以后，新的请求都会交由新接口来处理。由于当前旧接口仍然可能正在使用中，所以要使用推迟释放或是等待正在服务的接口完成</span></span><br><span class="line">delay_free(new_manager);</span><br><span class="line"><span class="comment">// (3) 在调用服务接口时，要利用局部变量保存服务接口：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 之所以这里使用局部变量来进行接口调用，是为了避免在调用了一部分接口后，g_dlib_manager才发生更新，</span></span><br><span class="line"><span class="comment">* 从而导致前后的服务接口属于不同的动态库，造成不可预料的问题。通过临时变量来保存服务接口，能确保所有接口的一致性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlib_manager</span> *<span class="title">local_dlib_manager</span> =</span> g_dlib_manager;</span><br><span class="line">local_dlib_manager-&gt;service_func1(data);</span><br><span class="line">local_dlib_manager-&gt;service_func2(data);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 释放旧接口的关键在于，要保证没有旧接口正在被使用。根据自己的业务，找到一个时间点——在这个时间点上，</span></span><br><span class="line"><span class="comment">* 所有的线程（准确地说是请求流程）都已经服务过一次。这时，新来的请求就会使用新的接口，</span></span><br><span class="line"><span class="comment">* 于是我们也就可以安全地释放旧接口了。其实整个实现方案是借鉴了Linux内核的RCU实现方式。</span></span><br><span class="line"><span class="comment">* 通过这种方法，可以进行“平滑无缝”的升级，而不影响运行状态下的业务功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<h1 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于良好的代码风格，有一项很重要的要求是一个函数只专注于做一件事情。如果该函数像瑞士军刀一样能实现多个功能，那基本上可以断言这不是一个设计良好的函数。C库中的realloc函数就是一个典型的反面教材：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数ptr为NULL，而size不为0，则等同于malloc（size）。</span></span><br><span class="line"><span class="comment">* 参数ptr不为NULL，而size为0，则等同于free（ptr）。</span></span><br><span class="line"><span class="comment">* 参数ptr和size均不为0，其行为类似于free（ptr）；malloc（size）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这里就会因为realloc的第三种行为引入一个bug。当realloc分配内存失败的时候，ptr会返回NULL。</span></span><br><span class="line"><span class="comment">* 但是这时ptr原来指向的内存并没有被释放，而ptr却已经被赋值为NULL了，这就造成了ptr原有内存泄漏。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> * ptr = <span class="built_in">realloc</span>(ptr, new_size);</span><br><span class="line"><span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* realloc只有在分配内存成功的情况下，才会让ptr等于new_ptr。</span></span><br><span class="line"><span class="comment">* 这样，在分配内存失败的情况下，ptr指向的内存并不会丢失。</span></span><br><span class="line"><span class="comment">* realloc使用不当还会引发其他几种bug，在此就不一一罗列了。</span></span><br><span class="line"><span class="comment">* 需要吸取的教训就是，慎用realloc，甚至最好不用realloc。如果真的需要使用realloc，</span></span><br><span class="line"><span class="comment">* 一定要确保在realloc的三种行为下代码都可以正常工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> * new_ptr = <span class="built_in">realloc</span>(ptr, new_size);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br><span class="line">ptr = new_ptr</span><br></pre></td></tr></table></figure></div>

<h2 id="内存越界"><a href="#内存越界" class="headerlink" title="内存越界"></a>内存越界</h2><p>通过良好的编程习惯基本上是可以避免内存越界问题的。防范的根本思想在于在对缓冲区（一般为数组）进行拷贝前，要保证复制的长度不要超过缓冲区的空间大小。比如在memcpy前，要检查目的地址是否有足够的空间。使用宏或sizeof可保证缓冲长度的一致性；</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当缓冲大小改变为32的时候，需要改动两处代码。一旦忘记修改memcpy处的拷贝长度，就会造成内存越界。</span></span><br><span class="line"><span class="comment">// bad code</span></span><br><span class="line"><span class="type">char</span> dst_buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dst_buf, src_buf,<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就可以做到缓存大小和复制长度的同步修改。</span></span><br><span class="line"><span class="comment">// good code</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE    64</span></span><br><span class="line"><span class="type">char</span> dst_buf[BUF_SIZE];</span><br><span class="line"><span class="built_in">memcpy</span>(dst_buf, src_buf, BUF_SIZE);</span><br><span class="line"><span class="comment">// good code</span></span><br><span class="line"><span class="type">char</span> dst_buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dst_buf, src_buf, <span class="keyword">sizeof</span>(dst_buf));</span><br></pre></td></tr></table></figure></div>

<p>使用安全的库函数也可以保证复制的长度不超过缓冲区的空间，下面来介绍4种库函数。</p>
<p>1）使用strncat代替strcat，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<p>从src中最多追加n个字符到dest字符串的后面。需要注意的是，当src包含n个以上的字符时，dest的空间至少为<code>strlen（dest）+n+1</code>，因为该函数还会追加字符串结束符<code>&#39;\0&#39;</code>到dest后面。</p>
<p>2）使用strncpy代替strcpy，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<p>从src中最多复制n个字符到dest字符串中。与strncat相同的是，当src包含n个以上的字符时，dest的空间需要为<code>n+1</code>，因为该函数还会再复制一个字符串结束符<code>&#39;\0&#39;</code>。</p>
<p>3）使用snprintf代替sprintf，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>snprintf比前面两个函数strncat和strncpy更为友好，在往str中写数据时，最多会写入n字节，其中已包括字符串结束符’\0’。</p>
<p>4）使用fgets代替gets，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure></div>

<p>危险的gets函数从来不检查缓冲区的大小，并且还是从标准输入中读取数据，这是极其危险的行为。再大的缓存空间也无法满足永无终止的标准输入，因此一定要使用fgets代替。fgets最多会复制<code>size-1</code>字节到缓存s中，并且会在最后一个字符后面追加<code>&#39;\0&#39;</code>。</p>
<blockquote>
<p>由于历史原因，标准C库中还存在其他不安全的接口，不过后来C库中也发展了相应的安全接口。在日常的编程中，除非特殊情况，都要使用安全函数来替代非安全函数的调用。</p>
</blockquote>
<h2 id="内存检查"><a href="#内存检查" class="headerlink" title="内存检查"></a>内存检查</h2><p>工欲善其事，必先利其器。valgrind作为一个免费且优秀的工具包，提供了很多有用的功能，其中最有名的就是对内存问题的检测和定位。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_leak1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_leak2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_overrun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    *(<span class="type">short</span>*)p = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_overrun2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="built_in">array</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_double_free</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_free_wild_pointer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    mem_leak1();</span><br><span class="line">    mem_leak2();</span><br><span class="line">    mem_overrun1();</span><br><span class="line">    mem_overrun2();</span><br><span class="line">    mem_double_free();</span><br><span class="line">    mem_free_wild_pointer();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码中包含了六种常见的内存问题：</p>
<ul>
<li>动态内存泄漏；</li>
<li>资源泄漏，代码中以文件描述符为例；</li>
<li>动态内存越界；</li>
<li>数组越界；</li>
<li>动态内存double free；</li>
<li>使用野指针。</li>
</ul>
<p>下面来看看怎样执行valgrind来检测内存错误：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --track-fds=yes --leak-check=full --undef-value-errors=yes ./mem_test</span><br><span class="line">==<span class="number">2326</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">2326</span>== Copyright (C) <span class="number">2002</span><span class="number">-2009</span>, and GNU GP<span class="string">L&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==2326== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==2326== Command: ./mem_test</span></span><br><span class="line"><span class="string">==2326==</span></span><br><span class="line"><span class="string">/* 此处检测到了动态内存的越界，提示Invalid write*/</span></span><br><span class="line"><span class="string">==2326== Invalid write of size 2</span></span><br><span class="line"><span class="string">==2326== at 0x80484B4: mem_overrun1 (in /home/fgao/works/test/a.out)</span></span><br><span class="line"><span class="string">==2326== by 0x8048553: main (in /home/fgao/works/test/a.out)</span></span><br><span class="line"><span class="string">==2326== Address 0x40211f0 is 0 bytes inside a block of size 1 alloc&#x27;</span>d</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x4005BDC</span>: <span class="built_in">malloc</span> (vg_replace_malloc.c:<span class="number">195</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x80484AD</span>: mem_overrun1 (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048553</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"> <span class="comment">/* 此处检测到了double free的问题，提示Invalid Free */</span></span><br><span class="line">==<span class="number">2326</span>== Invalid <span class="built_in">free</span>() / delete / delete[]</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057F6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048514</span>: mem_double_free (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804855D</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== Address <span class="number">0x4021228</span> is <span class="number">0</span> bytes inside a block of size <span class="number">1</span> <span class="built_in">free</span><span class="number">&#x27;</span>d</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057F6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048509</span>: mem_double_free (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804855D</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/* 此处检测到了未初始化变量的问题 */</span></span><br><span class="line">==<span class="number">2326</span>== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057B6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804853C</span>: mem_free_wild_pointer (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048562</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"> <span class="comment">/* 此处检测到了非法使用野指针 */</span></span><br><span class="line">==<span class="number">2326</span>== Invalid <span class="built_in">free</span>() / delete / delete[]</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057F6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804853C</span>: mem_free_wild_pointer (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048562</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== Address <span class="number">0x4021228</span> is <span class="number">0</span> bytes inside a block of size <span class="number">1</span> <span class="built_in">free</span><span class="number">&#x27;</span>d</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x40057F6</span>: <span class="built_in">free</span> (vg_replace_malloc.c:<span class="number">325</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048509</span>: mem_double_free (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804855D</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/*此处检测到了文件指针资源的泄漏，下面提示说有4个文件描述符在退出时仍是打开的描述符0、1、2无须关心，通过报告，可以发现程序中自己明确打开的文件描述符没有关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">==<span class="number">2326</span>== FILE DESCRIPTORS: <span class="number">4</span> open at <span class="built_in">exit</span>.</span><br><span class="line">==<span class="number">2326</span>== Open file descriptor <span class="number">3</span>: test.txt</span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x68D613</span>: __open_nocancel (in /lib/libc<span class="number">-2.12</span>.so)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x61F8EC</span>: __fopen_internal (in /lib/libc<span class="number">-2.12</span>.so)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x61F94B</span>: fopen@@GLIBC_2<span class="number">.1</span> (in /lib/libc<span class="number">-2.12</span>.so)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048496</span>: mem_leak2 (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x804854E</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>== Open file descriptor <span class="number">2</span>: /dev/pts/<span class="number">4</span></span><br><span class="line">==<span class="number">2326</span>== &lt;inherited from parent&gt;</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>== Open file descriptor <span class="number">1</span>: /dev/pts/<span class="number">4</span></span><br><span class="line">==<span class="number">2326</span>== &lt;inherited from parent&gt;</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>== Open file descriptor <span class="number">0</span>: /dev/pts/<span class="number">4</span></span><br><span class="line">==<span class="number">2326</span>== &lt;inherited from parent&gt;</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/* 堆信息的总结：一共调用了4次alloc，4次free。之所以正好相等，是因为上面有一个函数少了free，有一个函数正好又多了一个free */</span></span><br><span class="line">==<span class="number">2326</span>== HEAP SUMMARY:</span><br><span class="line">==<span class="number">2326</span>== in use at <span class="built_in">exit</span>: <span class="number">353</span> bytes in <span class="number">2</span> blocks</span><br><span class="line">==<span class="number">2326</span>== total heap usage: <span class="number">4</span> allocs, <span class="number">4</span> frees, <span class="number">355</span> bytes allocated</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/* 检测到一字节的内存泄漏 */</span></span><br><span class="line">==<span class="number">2326</span>== <span class="number">1</span> bytes in <span class="number">1</span> blocks are definitely lost in loss record <span class="number">1</span> of <span class="number">2</span></span><br><span class="line">==<span class="number">2326</span>== at <span class="number">0x4005BDC</span>: <span class="built_in">malloc</span> (vg_replace_malloc.c:<span class="number">195</span>)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048475</span>: mem_leak1 (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>== by <span class="number">0x8048549</span>: main (in /home/fgao/works/test/a.out)</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line"><span class="comment">/* 内存泄漏的总结 */</span></span><br><span class="line">==<span class="number">2326</span>== LEAK SUMMARY:</span><br><span class="line">==<span class="number">2326</span>== definitely lost: <span class="number">1</span> bytes in <span class="number">1</span> blocks</span><br><span class="line">==<span class="number">2326</span>== indirectly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">2326</span>== possibly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">2326</span>== still reachable: <span class="number">352</span> bytes in <span class="number">1</span> blocks</span><br><span class="line">==<span class="number">2326</span>== suppressed: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">2326</span>== Reachable blocks (those to which a pointer was found) are not shown.</span><br><span class="line">==<span class="number">2326</span>== To see them, rerun with: --leak-check=full --show-reachable=yes</span><br><span class="line">==<span class="number">2326</span>==</span><br><span class="line">==<span class="number">2326</span>== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==<span class="number">2326</span>== Use --track-origins=yes to see where uninitialised values come from</span><br><span class="line">==<span class="number">2326</span>== ERROR SUMMARY: <span class="number">5</span> errors from <span class="number">5</span> contexts (suppressed: <span class="number">12</span> from <span class="number">8</span>)</span><br></pre></td></tr></table></figure></div>

<p>这只是一个简单的示例程序，即使没有valgrind，我们也可以很轻易地发现问题。但是在真实的项目中，当代码量达到万行、十万行甚至百万行时，由于申请的内存可能不是在一个地方被使用，它不可避免地会被传来传去。这时，如果只是靠review代码来检查问题，可能很难找到根本原因，而使用valgrind则可以很容易地发现问题所在。</p>
<p>当然，valgrind也不是万能的。笔者就遇到过valgrind无法找到问题，最后是通过不断地检查代码才找到症结所在的情况。发现问题，再解决问题，毕竟是末流。最好的方法，就是从一开始就不引入问题，防微杜渐。这点可以通过良好的代码风格和设计来实现。写代码不是一件容易的事情，要用心，把代码当作自己的作品，真心地去写好它。这样，自然而然的就会把代码写好。</p>
<h1 id="长跳转"><a href="#长跳转" class="headerlink" title="长跳转"></a>长跳转</h1><h2 id="setjmp与longjmp"><a href="#setjmp与longjmp" class="headerlink" title="setjmp与longjmp"></a>setjmp与longjmp</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* setjmp用于保存当前栈的上下文，将其保存到参数env中。</span></span><br><span class="line"><span class="comment">* 若返回0值，则为setjmp直接返回的结果；若返回非0值，则为从longjmp恢复栈空间时返回的结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* longjmp用于将上下文恢复至env保存的状态，参数val用于作为恢复点setjmp的返回值。</span></span><br><span class="line"><span class="comment">* 一般情况下，保存的jmp_buf env为全局变量。跳转一次后，保存的env上下文环境就会失效。请看下面的示例：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> jmp_buf g_stack_env;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == setjmp(g_stack_env)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Normal flow\n&quot;</span>);</span><br><span class="line">        func1();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Longjump flow\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter func1\n&quot;</span>);</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter func2\n&quot;</span>);</span><br><span class="line">    longjmp(g_stack_env, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Leave func2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Normal flow</span><br><span class="line">Enter func1</span><br><span class="line">Enter func2</span><br><span class="line">Longjump flow</span><br></pre></td></tr></table></figure></div>

<p>在main函数中，使用setjmp将当前的栈环境保存到<code>g_stack_env</code>中，然后调用<code>func1-&gt;func2</code>，在func2中，使用longjmp来恢复保存的栈环境<code>g_stack_env</code>，从而完成“长跳转”。</p>
<h2 id="长跳转机制"><a href="#长跳转机制" class="headerlink" title="长跳转机制"></a>长跳转机制</h2><p>etjmp和longjmp分别用于保存和恢复栈的上下文，来实现长跳转。而栈的实现肯定是与平台相关的，因此setjmp和longjmp的实现也是与平台相关的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calling environment, plus possibly a saved signal mask.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">jmp_buf_tag</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> The machine-dependent definitions of `__sigsetjmp&#x27;</span></span><br><span class="line"><span class="comment">       assume that a `jmp_buf&#x27; begins with a `__jmp_buf&#x27; and that `__mask_was_saved&#x27; follows it.  Do not move these members or add others before it.  */</span></span><br><span class="line">    __jmp_buf __jmpbuf;     <span class="comment">/* Calling environment.  */</span></span><br><span class="line">    <span class="type">int</span> __mask_was_saved;   <span class="comment">/* Saved the signal mask?  */</span></span><br><span class="line">    <span class="type">__sigset_t</span> __saved_mask;    <span class="comment">/* Saved signal mask.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">jmp_buf_tag</span> <span class="title">jmp_buf</span>[1];</span></span><br></pre></td></tr></table></figure></div>

<p>x86平台的__jmp_buf的定义为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __jmp_buf[<span class="number">8</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> defined  __x86_64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __jmp_buf[<span class="number">8</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> __jmp_buf[<span class="number">6</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>x86平台的setjmp和longjmp的实现均位于<code>glibc-2.17/sysdeps/i386/setjmp.S</code>中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ENTRY (BP_SYM (__sigsetjmp))</span><br><span class="line">    ENTER</span><br><span class="line">    <span class="comment">/* 将jmpbuf的地址赋给eax */</span></span><br><span class="line">    movl <span class="title function_">JMPBUF</span><span class="params">(%esp)</span>, %eax</span><br><span class="line">    <span class="title function_">CHECK_BOUNDS_BOTH_WIDE</span> <span class="params">(%eax, JMPBUF(%esp), $JB_SIZE)</span></span><br><span class="line">    <span class="comment">/* 保存寄存器 */</span></span><br><span class="line">    movl %ebx, <span class="params">(JB_BX*<span class="number">4</span>)</span><span class="params">(%eax)</span></span><br><span class="line">    movl %esi, <span class="params">(JB_SI*<span class="number">4</span>)</span><span class="params">(%eax)</span></span><br><span class="line">    movl %edi, <span class="params">(JB_DI*<span class="number">4</span>)</span><span class="params">(%eax)</span></span><br><span class="line">    leal <span class="title function_">JMPBUF</span><span class="params">(%esp)</span>, %ecx <span class="comment">/* Save SP as it will be after we return.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">    <span class="title function_">PTR_MANGLE</span> <span class="params">(%ecx)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    movl %ecx, <span class="params">(JB_SP*<span class="number">4</span>)</span><span class="params">(%eax)</span></span><br><span class="line">    movl <span class="title function_">PCOFF</span><span class="params">(%esp)</span>, %ecx  <span class="comment">/* Save PC we are returning to now.  */</span></span><br><span class="line">    <span class="title function_">LIBC_PROBE</span> <span class="params">(setjmp, <span class="number">3</span>, <span class="number">4</span>@%eax, <span class="number">-4</span>@SIGMSK(%esp), <span class="number">4</span>@%ecx)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">    <span class="title function_">PTR_MANGLE</span> <span class="params">(%ecx)</span></span><br><span class="line"><span class="meta">#endifmovl %ecx, (JB_PC*4)(%eax)</span></span><br><span class="line">    LEAVE <span class="comment">/* pop frame pointer to prepare for tail-call.  */</span></span><br><span class="line">    movl %ebp, <span class="params">(JB_BP*<span class="number">4</span>)</span><span class="params">(%eax)</span> <span class="comment">/* Save caller&#x27;s frame pointer.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined NOT_IN_libc &amp;&amp; defined IS_IN_rtld</span></span><br><span class="line">    <span class="comment">/* In ld.so we never save the signal mask.  */</span></span><br><span class="line">    xorl %eax, %eax</span><br><span class="line">    ret</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Make a tail call to __sigjmp_save; it takes the same args.  */</span></span><br><span class="line">    jmp __sigjmp_save</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="title function_">END</span> <span class="params">(BP_SYM (__sigsetjmp))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>上面的汇编代码，主要是将寄存器EBX、ESI、EDI、ESP、PC和EBP寄存器保存到jmp_buf中。回想前面<code>__jmp_buf</code>的定义，它在x86_32位平台上是大小为6的int型数组，正好用于保存这6个寄存器。</p>
<p>看完了<code>__sigsetjmp</code>的实现，自然就轮到longjmp了：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ENTRY (__longjmp)</span><br><span class="line">    movl <span class="number">4</span>(%esp), %ecx  <span class="comment">/* User&#x27;s jmp_buf in %ecx.  */</span></span><br><span class="line">    movl <span class="number">8</span>(%esp), %eax  <span class="comment">/* Second argument is return value.  */</span></span><br><span class="line">    <span class="comment">/* Save the return address now.  */</span></span><br><span class="line">    movl (JB_PC*<span class="number">4</span>)(%ecx), %edx</span><br><span class="line">    <span class="title function_">LIBC_PROBE</span> <span class="params">(longjmp, <span class="number">3</span>, <span class="number">4</span>@%ecx, <span class="number">-4</span>@%eax, <span class="number">4</span>@%edx)</span></span><br><span class="line">    <span class="comment">/* 恢复保存的寄存器  */</span></span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_BX*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %ebx</span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_SI*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %esi</span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_DI*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %edi</span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_BP*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %ebp</span><br><span class="line">    <span class="title function_">movl</span> <span class="params">(JB_SP*<span class="number">4</span>)</span><span class="params">(%ecx)</span>, %esp</span><br><span class="line">    <span class="title function_">LIBC_PROBE</span> <span class="params">(longjmp_target, <span class="number">3</span>, <span class="number">4</span>@%ecx, <span class="number">-4</span>@%ecx, <span class="number">4</span>@%edx)</span></span><br><span class="line">    <span class="comment">/* Jump to saved PC.  */</span></span><br><span class="line">    jmp *%edx</span><br><span class="line"><span class="title function_">END</span> <span class="params">(__longjmp)</span></span><br></pre></td></tr></table></figure></div>

<p><code>setjmp</code>保存寄存器的内容，longjmp自然是恢复寄存器的内容。上面的代码很简单，把寄存器<code>PC、EBX、ESI、EDI、EBP</code>和ESP的内容恢复后，将第二个参数val保存到EAX中，最后跳转到恢复的PC寄存器处——也就是<code>setjmp</code>的下一条指令的位置。</p>
<h2 id="长跳转陷阱"><a href="#长跳转陷阱" class="headerlink" title="长跳转陷阱"></a>长跳转陷阱</h2><p>longjmp的man手册给出了如下说明：</p>
<p>当满足以下条件时，局部变量的值是不能确定的：</p>
<ul>
<li>它们是调用setjmp所在函数的局部变量。</li>
<li>其值在setjmp和longjmp之间有变化。</li>
<li>它们没有被声明为volatile变量。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> jmp_buf g_stack_env;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> ret = setjmp(g_stack_env);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Normal flow\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">        func1(&amp;a, &amp;b, &amp;c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Longjump flow\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c);&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter func1\n&quot;</span>);</span><br><span class="line">    ++(*a);</span><br><span class="line">    ++(*b);</span><br><span class="line">    ++(*c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1: a = %d, b = %d, c = %d\n&quot;</span>, *a, *b, *c);</span><br><span class="line">    longjmp(g_stack_env, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Leave func1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从结果上看，变量a、b、c的值均没有被恢复。这点符合我们的预期，毕竟longjmp只是恢复了6个寄存器的内容。</span></span><br><span class="line"><span class="meta"># gcc 4_7_3_longjmp_var.c -Wall</span></span><br><span class="line"># ./a.out</span><br><span class="line">Normal flow</span><br><span class="line">a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">Enter func1</span><br><span class="line">func1: a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">4</span></span><br><span class="line">Longjump flow</span><br><span class="line">a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">4</span></span><br><span class="line"><span class="comment">// 然而当我们加上编译选项-O2以后，结果就完全不同了。在longjmp跳转以后，a、b和c的值仍然是原来的值。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 -O2 优化级别下，编译器会执行大量的优化，例如：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    消除重复计算（Common Subexpression Elimination）</span></span><br><span class="line"><span class="comment">    死代码消除（Dead Code Elimination）</span></span><br><span class="line"><span class="comment">    循环优化（Loop Optimization）</span></span><br><span class="line"><span class="comment">    寄存器分配优化</span></span><br><span class="line"><span class="comment">    函数内联（Inline Functions）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[fgao@ubuntu chapter3]<span class="meta">#gcc 4_7_3_longjmp_var.c -Wall -O2</span></span><br><span class="line">[fgao@ubuntu chapter3]#./a.out</span><br><span class="line">Normal flow</span><br><span class="line">a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">Enter func1</span><br><span class="line">func1: a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">4</span></span><br><span class="line">Longjump flow</span><br><span class="line">a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<p>除了上面这个缺陷以外，如果我们的思维再开阔些，还能发现由longjmp实现原理引发的其他缺陷。比如因为它不能处理局部变量的问题，因此在C++中局部变量的析构肯定也是有问题的。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> jmp_buf g_stack_env;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">setjmp</span>(g_stack_env);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Normal flow&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Longjump flow&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="meta"># g++ 4_7_3_longjmp_destructor.cpp -Wall</span></span><br><span class="line"># ./a.out</span><br><span class="line">Normal flow</span><br><span class="line">Enter func1</span><br><span class="line">Constructor</span><br><span class="line">Longjump flow</span><br></pre></td></tr></table></figure></div>

<h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>进程是操作系统的一个核心概念。每个进程都有自己唯一的标识：进程ID，也有自己的生命周期。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_71.jpg"
                      alt="epub_831302_71"
                ></p>
<h2 id="进程-ID"><a href="#进程-ID" class="headerlink" title="进程 ID"></a>进程 ID</h2><p>Linux下每个进程都会有一个非负整数表示的唯一进程ID，简称pid。Linux提供了getpid函数来获取进程的pid，同时还提供了getppid函数来获取父进程的pid，相关接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>每个进程都有自己的父进程，父进程又会有自己的父进程，最终都会追溯到1号进程即init进程。这就决定了操作系统上所有的进程必然会组成树状结构，就像一个家族的家谱一样。可以通过pstree的命令来查看进程的家族树。</p>
<p>procfs文件系统会在&#x2F;proc下为每个进程创建一个目录，名字是该进程的pid。目录下有很多文件，用于记录进程的运行情况和统计信息等，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ll /proc总用量 <span class="number">0</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">1</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">10</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">100</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">101</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">102</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">103</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">1039</span></span><br><span class="line">dr-xr-xr-x  <span class="number">9</span> root       root          <span class="number">0</span>  <span class="number">4</span>月  <span class="number">1</span> <span class="number">06</span>:<span class="number">56</span> <span class="number">104</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>

<p>因为进程有创建，也有终止，所以&#x2F;proc&#x2F;下记录进程信息的目录（以及目录下的文件）也会发生变化。操作系统必须保证在任意时刻都不能出现两个进程有相同pid的情况。虽然进程ID是唯一的，但是进程ID可以重用。进程退出以后，其进程ID还可以再次分配给其他的进程使用。</p>
<p>Linux分配进程ID的算法不同于给进程分配文件描述符的最小可用算法，它采用了延迟重用的算法，即分配给新创建进程的ID尽量不与最近终止进程的ID重复，这样就可以防止将新创建的进程误判为使用相同进程ID的已经退出的进程。</p>
<p>那么如何实现延迟重用呢？内核采用的方法如下：</p>
<p>1）位图记录进程ID的分配情况（0为可用，1为已占用）。</p>
<p>2）将上次分配的进程ID记录到last_pid中，分配进程ID时，从last_pid+1开始找起，从位图中寻找可用的ID。</p>
<p>3）如果找到位图集合的最后一位仍不可用，则回滚到位图集合的起始位置，从头开始找。</p>
<p>既然是位图记录进程ID的分配情况，那么位图的大小就必须要考虑周全。位图的大小直接决定了系统允许同时存在的进程的最大个数，这个最大个数在系统中称为pid_max。上面的第3步提到，回绕到位图集合的起始位置，从头寻找可用的进程ID。事实上，严格说来，这种说法并不正确，回绕时并不是从0开始找起，而是从300开始找起。内核在kernel&#x2F;pid.c文件中定义了RESERVED_PIDS，其值是300，300以下的pid会被系统占用，而不能分配给用户进程：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define RESERVED_PIDS       <span class="number">300</span></span><br><span class="line"><span class="type">int</span> pid_max = PID_MAX_DEFAULT;</span><br></pre></td></tr></table></figure></div>

<p>Linux系统下可以通过procfs或sysctl命令来查看pid_max的值：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-rush:~$ <span class="built_in">cat</span> /proc/sys/kernel/pid_max</span><br><span class="line">131072</span><br><span class="line">manu@manu-rush:~$ sysctl kernel.pid_max</span><br><span class="line">kernel.pid_max = 131072</span><br><span class="line"><span class="comment"># 其实，此上限值是可以调整的，系统管理员可以通过如下方法来修改此上限值：</span></span><br><span class="line">root@manu-rush:~<span class="comment"># sysctl -w kernel.pid_max=4194304</span></span><br><span class="line">kernel.pid_max = 4194304</span><br><span class="line"><span class="comment"># 但是内核自己也设置了硬上限，如果尝试将pid_max的值设成一个大于硬上限的值就会失败。</span></span><br><span class="line">root@manu-rush:~<span class="comment"># sysctl -w kernel.pid_max=4194305</span></span><br><span class="line">error: <span class="string">&quot;Invalid argument&quot;</span> setting key <span class="string">&quot;kernel.pid_max&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>从上面的操作可以看出，Linux系统将系统进程数的硬上限设置为4194304（4M）。内核又是如何决定系统进程个数的硬上限的呢？对此，内核定义了如下的宏：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PID_MAX_LIMIT (CONFIG_BASE_SMALL ? PAGE_SIZE * 8 : \</span></span><br><span class="line"><span class="meta">    (sizeof(long) &gt; 4 ? 4 * 1024 * 1024 :PID_MAX_DEFAULT))</span></span><br></pre></td></tr></table></figure></div>

<p>从上面代码中可以看出决定系统进程个数硬上限的逻辑为：</p>
<ul>
<li>如果选择了CONFIG_BASE_SMALL编译选项，则为页面（PAGE_SIZE）的位数。</li>
<li>如果选择了CONFIG_BASE_FULL编译选项，那么：<ul>
<li>对于32位系统，系统进程个数硬上限为32768（即32K）。</li>
<li>对于64位系统，系统进程个数硬上限为4194304（即4M）。</li>
</ul>
</li>
</ul>
<p>通过上面的讨论可以看出，在64位系统中，系统容许创建的进程的个数超过了400万，这个数字是相当庞大的，足够应用层使用。对于单线程的程序，进程ID比较好理解，就是唯一标识进程的数字。对于多线程的程序，每一个线程调用getpid函数，其返回值都是一样的，即进程的ID。</p>
<h2 id="进程层次"><a href="#进程层次" class="headerlink" title="进程层次"></a>进程层次</h2><p>每个进程都有父进程，父进程也有父进程，这就形成了一个以init进程为根的家族树。除此以外，进程还有其他层次关系：进程、进程组和会话。进程组和会话在进程之间形成了两级的层次：进程组是一组相关进程的集合，会话是一组相关进程组的集合。</p>
<p>这样说来，一个进程会有如下ID：</p>
<ul>
<li>PID：进程的唯一标识。对于多线程的进程而言，所有线程调用getpid函数会返回相同的值。</li>
<li>PGID：进程组ID。每个进程都会有进程组ID，表示该进程所属的进程组。默认情况下新创建的进程会继承父进程的进程组ID。</li>
<li>SID：会话ID。每个进程也都有会话ID。默认情况下，新创建的进程会继承父进程的会话ID。</li>
</ul>
<p>可以调用如下指令来查看所有进程的层次关系：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ejH</span><br><span class="line">$ ps axjf</span><br></pre></td></tr></table></figure></div>

<p>对于进程而言，可以通过如下函数调用来获取其进程组ID和会话ID。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure></div>

<p>前面提到过，新进程默认继承父进程的进程组ID和会话ID，如果都是默认情况的话，那么追根溯源可知，所有的进程应该有共同的进程组ID和会话ID。但是调用ps axjf可以看到，实际情况并非如此，系统中存在很多不同的会话，每个会话下也有不同的进程组。</p>
<p>进程组和会话是为了支持shell作业控制而引入的概念。当有新的用户登录Linux时，登录进程会为这个用户创建一个会话。用户的登录shell就是会话的首进程。会话的首进程ID会作为整个会话的ID。会话是一个或多个进程组的集合，囊括了登录用户的所有活动。</p>
<p>在登录shell时，用户可能会使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组。当用户通过SSH客户端工具连入Linux时，与上述登录的情景是类似的。</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>修改进程组ID的接口如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这个函数的含义是，找到进程ID为pid的进程，将其进程组ID修改为pgid，</span></span><br><span class="line"><span class="comment">* 如果pid的值为0，则表示要修改调用进程的进程组ID。该接口一般用来创建一个新的进程组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 下面三个接口含义一致，都是创立新的进程组，并且指定的进程会成为进程组的首进程。</span></span><br><span class="line"><span class="comment">* 如果参数pid和pgid的值不匹配，那么setpgid函数会将一个进程从原来所属的进程组迁移到pgid对应的进程组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">setpgid(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">setpgid(getpid(),<span class="number">0</span>)</span><br><span class="line">setpgid(getpid(),getpid())</span><br></pre></td></tr></table></figure></div>

<p>setpgid函数有很多限制：</p>
<ul>
<li>pid参数必须指定为调用setpgid函数的进程或其子进程，不能随意修改不相关进程的进程组ID，如果违反这条规则，则返回-1，并置errno为ESRCH。</li>
<li>pid参数可以指定调用进程的子进程，但是子进程如果已经执行了exec函数，则不能修改子进程的进程组ID。如果违反这条规则，则返回-1，并置errno为EACCESS。</li>
<li>在进程组间移动，调用进程，pid指定的进程及目标进程组必须在同一个会话之内。如果违反这条规则，则返回-1，并置errno为EPERM。</li>
<li>pid指定的进程，不能是会话首进程。如果违反这条规则，则返回-1，并置errno为EPERM。</li>
</ul>
<p>有了创建进程组的接口，新创建的进程组就不必继承父进程的进程组ID了。最常见的创建进程组的场景就是在shell中执行管道命令，代码如下：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd1 | cmd2 | cmd3</span><br></pre></td></tr></table></figure></div>

<p>下面用一个最简单的命令来说明，其进程之间的关系如图:</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ax|grep nfsd</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_73.jpg"
                      alt="epub_831302_73"
                ></p>
<p>ps进程和grep进程都是bash创建的子进程，两者通过管道协同完成一项工作，它们隶属于同一个进程组，其中ps进程是进程组的组长。</p>
<p>引入了进程组的概念，可以更方便地管理这一组进程了。比如这项工作放弃了，不必向每个进程一一发送信号，可以直接将信号发送给进程组，进程组内的所有进程都会收到该信号。</p>
<blockquote>
<p>前文曾提到过，子进程一旦执行exec，父进程就无法调用setpgid函数来设置子进程的进程组ID了，这条规则会影响shell的作业控制。出于保险的考虑，一般父进程在调用fork创建子进程后，会调用setpgid函数设置子进程的进程组ID，同时子进程也要调用setpgid函数来设置自身的进程组ID。这两次调用有一次是多余的，但是这样做能够保证无论是父进程先执行，还是子进程先执行，子进程一定已经进入了指定的进程组中。由于fork之后，父子进程的执行顺序是不确定的，因此如果不这样做，就会造成在一定的时间窗口内，无法确定子进程是否进入了相应的进程组。</p>
</blockquote>
<p>可以通过跟踪bash进程的系统调用来证明这一点，下面的2258进程是bash，我们在该bash上执行sleep 200，在执行之前，在另一个终端用strace跟踪bash的系统调用，可以看到，父进程和子进程都执行了一遍setpgid函数，代码如下所示：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:~$ sudo strace -f -p 2258</span><br><span class="line">Process 2258 attached</span><br><span class="line">    ．．．</span><br><span class="line">/*父进程调用setpgid函数*/</span><br><span class="line">[pid  2258] setpgid(2509, 2509 &lt;unfinished ...&gt;．．．</span><br><span class="line">/*子进程调用setpgid函数*/</span><br><span class="line">[pid  2509] setpgid(2509, 2509 &lt;unfinished ...&gt;．．．</span><br><span class="line">/*子进程执行execve*/</span><br><span class="line">[pid  2509] execve(<span class="string">&quot;/bin/sleep&quot;</span>, [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;200&quot;</span>], [/* 31 vars */]) = 0．．．</span><br></pre></td></tr></table></figure></div>

<p>用户在shell中可以同时执行多个命令。对于耗时很久的命令（如编译大型工程），用户不必傻傻等待命令运行完毕才执行下一个命令。用户在执行命令时，可以在命令的结尾添加<code>“&amp;”</code>符号，表示将命令放入后台执行。这样该命令对应的进程组即为后台进程组。在任意时刻，可能同时存在多个后台进程组，但是不管什么时候都只能有一个前台进程组。只有在前台进程组中进程才能在控制终端读取输入。当用户在终端输入信号生成终端字符（如<code>ctrl+c、ctrl+z、ctr+\</code>等）时，对应的信号只会发送给前台进程组。</p>
<p>shell中可以存在多个进程组，无论是前台进程组还是后台进程组，它们或多或少存在一定的联系，为了更好地控制这些进程组（或者称为作业），系统引入了会话的概念。会话的意义在于将很多的工作囊括在一个终端，选取其中一个作为前台来直接接收终端的输入及信号，其他的工作则放在后台执行。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话是一个或多个进程组的集合，以用户登录系统为例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_75.jpg"
                      alt="epub_831302_75"
                ></p>
<p>系统提供setsid函数来创建会话，其接口定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果这个函数的调用进程不是进程组组长，那么调用该函数会发生以下事情：</p>
<p>1）创建一个新会话，会话ID等于进程ID，调用进程成为会话的首进程。</p>
<p>2）创建一个进程组，进程组ID等于进程ID，调用进程成为进程组的组长。</p>
<p>3）该进程没有控制终端，如果调用setsid前，该进程有控制终端，这种联系就会断掉。</p>
<p>调用setsid函数的进程不能是进程组的组长，否则调用会失败，返回-1，并置errno为EPERM。这个限制是比较合理的。如果允许进程组组长迁移到新的会话，而进程组的其他成员仍然在老的会话中，那么，就会出现同一个进程组的进程分属不同的会话之中的情况，这就破坏了进程组和会话的严格的层次关系了。Linux提供了setsid命令，可以在新的会话中执行命令，通过该命令可以很容易地验证上面提到的三点：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ setsid <span class="built_in">sleep</span> 100</span><br><span class="line">$ ps ajxf</span><br><span class="line">PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND…</span><br><span class="line">1     4469  4469  4469 ?           -1   Ss   1000   0:00 <span class="built_in">sleep</span> 100</span><br></pre></td></tr></table></figure></div>

<p>从输出中可以看出，系统创建了新的会话4469，新的会话下又创建了新的进程组，会话ID和进程组ID都等于进程ID，而该进程已经不再拥有任何控制终端了（TTY对应的值为“？”表示进程没有控制终端）。常用的调用setsid函数的场景是login和shell。除此以外创建daemon进程也要调用setsid函数。</p>
<h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Linux系统下，进程可以调用fork函数来创建新的进程。调用进程为父进程，被创建的进程为子进程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>与普通函数不同，fork函数会返回两次。一般说来，创建两个完全相同的进程并没有太多的价值。大部分情况下，父子进程会执行不同的代码分支。fork函数的返回值就成了区分父子进程的关键。fork函数向子进程返回0，并将子进程的进程ID返给父进程。当然了，如果fork失败，该函数则返回-1，并设置errno。</p>
<p>常见的出错情景如表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_76.jpg"
                      alt="epub_831302_76"
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ret = fork();</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    …<span class="comment">//此处是子进程的代码分支</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    …<span class="comment">//此处是父进程的代码分支</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     …<span class="comment">// fork失败，执行error handle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>fork可能失败。检查返回值进行正确的出错处理，是一个非常重要的习惯。设想如果fork返回-1，而程序没有判断返回值，直接将-1当成子进程的进程号，那么后面的代码执行kill（child_pid，9）就相当于执行kill（-1，9）。这会发生什么？后果是惨重的，它将杀死除了init以外的所有进程，只要它有权限。</p>
</blockquote>
<p>从内核2.6.32开始，在默认情况下，父进程将成为fork之后优先调度的对象。采取这种策略的原因是：fork之后，父进程在CPU中处于活跃的状态，并且其内存管理信息也被置于硬件内存管理单元的转译后备缓冲器（TLB），所以先调度父进程能提升性能。从2.6.24起，Linux采用完全公平调度（Completely Fair Scheduler，CFS）。用户创建的普通进程，都采用CFS调度策略。对于CFS调度策略，procfs提供了如下控制选项：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/kernel/sched_child_runs_first</span><br></pre></td></tr></table></figure></div>

<p>该值默认是0，表示父进程优先获得调度。如果将该值改成1，那么子进程会优先获得调度。POSIX标准和Linux都没有保证会优先调度父进程。因此在应用中，决不能对父子进程的执行顺序做任何的假设。如果确实需要某一特定执行的顺序，那么需要使用进程间同步的手段。</p>
<blockquote>
<p><strong>从 Linux 内核版本 5.9 开始，<code>kernel.sched_child_runs_first</code> 参数被移除了</strong>。在移除该参数后，内核默认的行为是 <strong>父进程在 <code>fork()</code> 后优先运行</strong>，并且无法通过参数进行更改。</p>
</blockquote>
<p>fork之后的子进程完全拷贝了父进程的地址空间，包括栈、堆、代码段等。通过下面的示例代码，我们一起来查看父子进程的内存关系：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> g_int = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> local_int = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *malloc_int = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *malloc_int = <span class="number">1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        local_int = <span class="number">0</span>;</span><br><span class="line">        g_int = <span class="number">0</span>;</span><br><span class="line">        *malloc_int = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[CHILD ] child change local global malloc value to 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(malloc_int);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[CHILD ] child exit\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork failed (%s)&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[PARENT] wait child exit\n&quot;</span>);</span><br><span class="line">    waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;[PARENT] child have exit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[PARENT] g_int = %d\n&quot;</span>,g_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[PARENT] local_int = %d\n&quot;</span>,local_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[PARENT] malloc_int = %d\n&quot;</span>,local_int);</span><br><span class="line">    <span class="built_in">free</span>(malloc_int);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">[PARENT] wait child <span class="built_in">exit</span></span><br><span class="line">[CHILD ] child change local global <span class="built_in">malloc</span> value to <span class="number">0</span></span><br><span class="line">[CHILD ] child <span class="built_in">exit</span></span><br><span class="line">[PARENT] child have <span class="built_in">exit</span></span><br><span class="line">[PARENT] g_int = <span class="number">1</span></span><br><span class="line">[PARENT] local_int = <span class="number">1</span></span><br><span class="line">[PARENT] malloc_int = <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p>这里刻意定义了三个变量，一个是位于数据段的全局变量，一个是位于栈上的局部变量，还有一个是通过malloc动态分配位于堆上的变量，三者的初始值都是1。然后调用fork创建子进程，子进程将三个变量的值都改成了0。按照fork的语义，子进程完全拷贝了父进程的数据段、栈和堆上的内存，如果父子进程对相应的数据进行修改，那么两个进程是并行不悖、互不影响的。因此，在上面示例代码中，尽管子进程将三个变量的值都改成了0，对父进程而言这三个值都没有变化，仍然是1，代码的输出也证实了这一点。</p>
<p>前文提到过，子进程和父进程执行一模一样的代码的情形比较少见。Linux提供了execve系统调用，构建在该系统调用之上，glibc提供了exec系列函数。这个系列函数会丢弃现存的程序代码段，并构建新的数据段、栈及堆。调用fork之后，子进程几乎总是通过调用exec系列函数，来执行新的程序。在这种背景下，fork时子进程完全拷贝父进程的数据段、栈和堆的做法是不明智的，因为接下来的exec系列函数会毫不留情地抛弃刚刚辛苦拷贝的内存。为了解决这个问题，Linux引入了写时拷贝（copy-on-write）的技术。</p>
<p>写时拷贝是指子进程的页表项指向与父进程相同的物理内存页，这样只拷贝父进程的页表项就可以了，当然要把这些页面标记成只读。如果父子进程都不修改内存的内容，大家便相安无事，共用一份物理内存页。但是一旦父子进程中有任何一方尝试修改，就会引发缺页异常（page fault）。此时，内核会尝试为该页面创建一个新的物理页面，并将内容真正地复制到新的物理页面中，让父子进程真正地各自拥有自己的物理内存页，然后将页表中相应的表项标记为可写。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_79.jpg"
                      alt="epub_831302_79"
                ></p>
<p>从上面的描述可以看出，对于没有修改的页面，内核并没有真正地复制物理内存页，仅仅是复制了父进程的页表。这种机制的引入提升了fork的性能，从而使内核可以快速地创建一个新的进程。</p>
<p>Linux的内存管理使用的是四级页表，如图4-6所示，看了四级页表的名字，也就不难推测图中那些函数的作用了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_80.jpg"
                      alt="epub_831302_80"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_81.jpg"
                      alt="epub_831302_81"
                ></p>
<p>在最后的<code>copy_one_pte</code>函数中有如下代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果是写时拷贝，那么无论是初始页表，还是拷贝的页表，都设置了写保护</span></span><br><span class="line"><span class="comment"> *后面无论父子进程，修改页表对应位置的内存时，都会触发page fault</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">if</span> (is_cow_mapping(vm_flags)) &#123;</span><br><span class="line">     ptep_set_wrprotect(src_mm, addr, src_pte);</span><br><span class="line">     pte = pte_wrprotect(pte);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>该代码将页表设置成写保护，父子进程中任意一个进程尝试修改写保护的页面时，都会引发缺页中断，内核会走向do_wp_page函数，该函数会负责创建副本，即真正的拷贝。写时拷贝技术极大地提升了fork的性能，在一定程度上让vfork成为了鸡肋。</p>
<hr>
<p>执行fork函数，内核会复制父进程所有的文件描述符。对于父进程打开的所有文件，子进程也是可以操作的。那么父子进程同时操作同一个文件是并行不悖的，还是互相影响的呢？</p>
<p>下面通过对一个例子的讨论来说明这个问题。read函数并没有将偏移量作为参数传入，但是每次调用read函数或write函数时，却能够接着上次读写的位置继续读写。原因是内核已经将偏移量的信息记录在与文件描述符相关的数据结构里了。那么问题来了，父子进程是共用一个文件偏移量还是各有各的文件偏移量呢？</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFILE <span class="string">&quot;./in.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTFILE <span class="string">&quot;./out.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE  S_IRUSR |S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd_in,fd_out;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    fd_in = open(INFILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd_in &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;failed to open %s, reason(%s)\n&quot;</span>, INFILE,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_out = open(OUTFILE,O_WRONLY|O_CREAT|O_TRUNC,MODE);</span><br><span class="line">    <span class="keyword">if</span>(fd_out &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;failed to open %s, reason(%s)\n&quot;</span>, OUTFILE,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fork();<span class="comment">/*此处忽略错误检查*/</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd_in, buf, <span class="number">2</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s&quot;</span>,getpid(),buf);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d Hello,World!\n&quot;</span>,getpid());</span><br><span class="line">        write(fd_out,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>INFILE的内容是：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure></div>

<p>上面的程序中，父子进程都会去读INFILE，如果父子进程各维护各的文件偏移量，那么父子进程都会打印出1~6。事实如何呢？请看输出内容：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./fork_file</span><br><span class="line">6610: 1</span><br><span class="line">6611: 2</span><br><span class="line">6610: 3</span><br><span class="line">6611: 4</span><br><span class="line">6610: 5</span><br><span class="line">6611: 5</span><br><span class="line">6610: 6</span><br></pre></td></tr></table></figure></div>

<p>如果父子进程各自维护自己的文件偏移量，那么一定是打印出两套1~6，但是事实并非如此。无论父进程还是子进程调用read函数导致文件偏移量后移都会被对方获知，这表明父子进程共用了一套文件偏移量。对于第二个输出，为什么父子进程都打印5呢？这是因为我的机器是多核的，父子进程同时执行，发现当前文件偏移量是4*2，然后各自去读了第8和第9字节，也就是“5\n”。写文件也是一样，如果fork之前打开了某文件，之后父子进程写入同一个文件描述符而又不采取任何同步的手段，那么就会因为共享文件偏移量而使输出相互混合，不可阅读。</p>
<p>文件描述符还有一个文件描述符标志（file descriptor flag）。目前只定义了一个标志位：FD_CLOSEXEC，这是close_on_exec标志位。细心阅读open函数手册也会发现，open函数也有一个类似的标志位，即O_CLOSEXEC，该标志位也是用于设置文件描述符标志的。那么这个标志位到底有什么作用呢？如果文件描述符中将这个标志位置位，那么调用exec时会自动关闭对应的文件。可是为什么需要这个标志位呢？主要是出于安全的考虑。对于fork之后子进程执行exec这种场景，如果子进程可以操作父进程打开的文件，就会带来严重的安全隐患。一般来讲，调用exec的子进程时，因为它会另起炉灶，因此父进程打开的文件描述符也应该一并关闭，但事实上内核并没有主动这样做。试想如下场景，Webserver首先以root权限启动，打开只有拥有root权限才能打开的端口和日志等文件，再降到普通用户，fork出一些worker进程，在进程中进行解析脚本、写日志、输出结果等操作。由于子进程完全可以操作父进程打开的文件，因此子进程中的脚本只要继续操作这些文件描述符，就能越权操作root用户才能操作的文件。</p>
<p>为了解决这个问题，Linux引入了close on exec机制。设置了FD_CLOSEXEC标志位的文件，在子进程调用exec家族函数时会将相应的文件关闭。</p>
<p>而设置该标志位的方法有两种：</p>
<ul>
<li>open时，带上O_CLOSEXEC标志位。</li>
<li>open时如果未设置，那就在后面调用fcntl函数的F_SETFD操作来设置。</li>
</ul>
<p>建议使用第一种方法。原因是第二种方法在某些时序条件下并不那么绝对的安全。</p>
<p>考虑以下的场景：Thread 1还没来得及将FD_CLOSEXEC置位，由于Thread 2已经执行过fork，这时候fork出来的子进程就不会关闭相应的文件。尽管Thread1后来调用了fcntl的F_SETFD操作，但是为时已晚，文件已经泄露了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_84.jpg"
                      alt="epub_831302_84"
                ></p>
<blockquote>
<p>多线程程序执行了fork，仅仅是为了示意，实际中并不鼓励这种做法。正相反，这种做法是十分危险的。多线程程序不应该调用fork来创建子进程。</p>
</blockquote>
<p>前面提到，执行fork时，子进程会获取父进程所有文件描述符的副本，但是测试结果表明，父子进程共享了文件的很多属性。这到底是怎么回事？让我们深入内核一探究竟。</p>
<p>在内核的进程描述符task_struct结构体中，与打开文件相关的变量如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用fork时，内核会在copy_files函数中处理拷贝父进程打开的文件的相关事宜：</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_files</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">oldf</span>, *<span class="title">newf</span>;</span></span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    oldf = current-&gt;files;</span><br><span class="line">    <span class="keyword">if</span> (!oldf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"> <span class="comment">/*创建线程和vfork，都不用复制父进程的文件描述符，增加引用计数即可*/</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_FILES) &#123;</span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;oldf-&gt;count);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*对于fork而言，需要复制父进程的文件描述符*/</span></span><br><span class="line">    newf = dup_fd(oldf, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (!newf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    tsk-&gt;files = newf;</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>CLONE_FILES标志位用来控制是否共享父进程的文件描述符。如果该标志位置位，则表示不必费劲复制一份父进程的文件描述符了，增加引用计数，直接共用一份就可以了。对于vfork函数和创建线程的pthread_create函数来说都是如此。但是fork函数却不同，调用fork函数时，该标志位为0，表示需要为子进程拷贝一份父进程的文件描述符。文件描述符的拷贝是通过内核的dup_fd函数来完成的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> files_struct *<span class="title function_">dup_fd</span><span class="params">(<span class="keyword">struct</span> files_struct *oldf, <span class="type">int</span> *errorp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">newf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> **<span class="title">old_fds</span>, **<span class="title">new_fds</span>;</span></span><br><span class="line">    <span class="type">int</span> open_files, size, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">old_fdt</span>, *<span class="title">new_fdt</span>;</span></span><br><span class="line">    *errorp = -ENOMEM;</span><br><span class="line">    newf = kmem_cache_alloc(files_cachep, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!newf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure></div>

<p><code>dup_fd</code>函数首先会给子进程分配一个<code>file_struct</code>结构体，然后做一些赋值操作。这个结构体是进程描述符中与打开文件相关的数据结构，每一个打开的文件都会记录在该结构体中。其定义代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="type">int</span> next_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">close_on_exec_init</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">open_fds_init</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line">    fd_set *close_on_exec;</span><br><span class="line">    fd_set *open_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fds_bits[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>初看之下struct fdtable的内容与struct files_struct的内容有颇多重复之处，包括close_on_exec文件描述符位图、打开文件描述符位图及file指针数组等，但事实上并非如此。struct files_struct中的成员是相应数据结构的实例，而struct fdtable中的成员是相应的指针。</p>
<p>Linux系统假设大多数的进程打开的文件不会太多。于是Linux选择了一个long类型的位数（32位系统下为32位，64位系统下为64位）作为经验值。以64位系统为例，file_struct结构体自带了可以容纳64个struct file类型指针的数组fd_array，也自带了两个大小为64的位图，其中open_fds_init位图用于记录文件的打开情况，close_on_exec_init位图用于记录文件描述符的FD_CLOSEXCE标志位是否置位。只要进程打开的文件个数小于64，file_struct结构体自带的指针数组和两个位图就足以满足需要。因此在分配了file_struct结构体后，内核会初始化file_struct自带的fdtable，代码如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_set</span>(&amp;newf-&gt;count, <span class="number">1</span>);</span><br><span class="line">spin_lock_init(&amp;newf-&gt;file_lock);</span><br><span class="line">newf-&gt;next_fd = <span class="number">0</span>;</span><br><span class="line">new_fdt = &amp;newf-&gt;fdtab;</span><br><span class="line">new_fdt-&gt;max_fds = NR_OPEN_DEFAULT;</span><br><span class="line">new_fdt-&gt;close_on_exec = (fd_set *)&amp;newf-&gt;close_on_exec_init;</span><br><span class="line">new_fdt-&gt;open_fds = (fd_set *)&amp;newf-&gt;open_fds_init;</span><br><span class="line">new_fdt-&gt;fd = &amp;newf-&gt;fd_array[<span class="number">0</span>];</span><br><span class="line">new_fdt-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></div>

<p>初始化之后，子进程的file_struct的情况如图所示。注意，此时file_struct结构体中的fdt指针并未指向file_struct自带的struct fdtable类型的fdtab变量。原因很简单，因为此时内核还没有检查父进程打开文件的个数，因此并不确定自带的结构体能否满足需要。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_87.jpg"
                      alt="epub_831302_87"
                ></p>
<p>接下来，内核会检查父进程打开文件的个数。如果父进程打开的文件超过了64个，struct files_struct中自带的数组和位图就不能满足需要了。这种情况下内核会分配一个新的struct fdtable，代妈如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> spin_lock(&amp;oldf-&gt;file_lock);</span><br><span class="line"> old_fdt = files_fdtable(oldf);</span><br><span class="line"> open_files = count_open_files(old_fdt);</span><br><span class="line"><span class="comment">/*如果父进程打开文件的个数超过NR_OPEN_DEFAULT*/</span></span><br><span class="line"> <span class="keyword">while</span> (unlikely(open_files &gt; new_fdt-&gt;max_fds)) &#123;</span><br><span class="line">     spin_unlock(&amp;oldf-&gt;file_lock);  <span class="comment">/* 如果不是自带的fdtable而是曾经分配的fdtable，则需要先释放*/</span></span><br><span class="line">     <span class="keyword">if</span> (new_fdt != &amp;newf-&gt;fdtab)</span><br><span class="line">     __free_fdtable(new_fdt);</span><br><span class="line">    <span class="comment">/*创建新的fdtable*/</span></span><br><span class="line">     new_fdt = alloc_fdtable(open_files - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (!new_fdt) &#123;</span><br><span class="line">     *errorp = -ENOMEM;</span><br><span class="line">     <span class="keyword">goto</span> out_release;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*如果超出了系统限制，则返回EMFILE*/</span></span><br><span class="line">     <span class="keyword">if</span> (unlikely(new_fdt-&gt;max_fds &lt; open_files)) &#123;</span><br><span class="line">     __free_fdtable(new_fdt);</span><br><span class="line">     *errorp = -EMFILE;</span><br><span class="line">     <span class="keyword">goto</span> out_release;</span><br><span class="line">     &#125;</span><br><span class="line">     spin_lock(&amp;oldf-&gt;file_lock);</span><br><span class="line">     old_fdt = files_fdtable(oldf);</span><br><span class="line">     open_files = count_open_files(old_fdt);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>alloc_fdtable所做的事情，不过是分配fdtable结构体本身，以及分配一个指针数组和两个位图。分配之前会根据父进程打开文件的数目，计算出一个合理的值nr，以确保分配的数组和位图能够满足需要。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_88.jpg"
                      alt="epub_831302_88"
                ></p>
<p>无论是使用file_struct结构体自带的fdtable，还是使用alloc_fdtable分配的fdtable，接下来要做的事情都一样，即将父进程的两个位图信息和打开文件的struct file类型指针拷贝到子进程的对应数据结构中，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    old_fds = old_fdt-&gt;fd;  <span class="comment">/*父进程的struct file 指针数组*/</span></span><br><span class="line">    new_fds = new_fdt-&gt;fd;  <span class="comment">/*子进程的struct file 指针数组*/</span></span><br><span class="line">    <span class="comment">/* 拷贝打开文件位图 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_fdt-&gt;open_fds-&gt;fds_bits,old_fdt-&gt;open_fds-&gt;fds_bits, open_files/<span class="number">8</span>);</span><br><span class="line">    <span class="comment">/* 拷贝 close_on_exec位图 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_fdt-&gt;close_on_exec-&gt;fds_bits,old_fdt-&gt;close_on_exec-&gt;fds_bits, open_files/<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = open_files; i != <span class="number">0</span>; i--) </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> *old_fds++;</span><br><span class="line">        <span class="keyword">if</span> (f) &#123;        </span><br><span class="line">            get_file(f); <span class="comment">/* f对应的文件的引用计数加1 */</span>    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">            FD_CLR(open_files - i, new_fdt-&gt;open_fds);    </span><br><span class="line">        &#125;<span class="comment">/* 子进程的struct file类型指针，*指向和父进程相同的struct file 结构体*/</span>    </span><br><span class="line">        rcu_assign_pointer(*new_fds++, f);   </span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;oldf-&gt;file_lock);<span class="comment">/* compute the remainder to be cleared */</span></span><br><span class="line">    size = (new_fdt-&gt;max_fds - open_files) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="comment">/*将尚未分配到的struct file结构的指针清零*/</span></span><br><span class="line">    <span class="built_in">memset</span>(new_fds, <span class="number">0</span>, size);<span class="comment">/*将尚未分配到的位图区域清零*/</span></span><br><span class="line">    <span class="keyword">if</span> (new_fdt-&gt;max_fds &gt; open_files) &#123;    </span><br><span class="line">        <span class="type">int</span> left = (new_fdt-&gt;max_fds-open_files)/<span class="number">8</span>;    </span><br><span class="line">        <span class="type">int</span> start = open_files / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>));    </span><br><span class="line">        <span class="built_in">memset</span>(&amp;new_fdt-&gt;open_fds-&gt;fds_bits[start], <span class="number">0</span>, left);    </span><br><span class="line">        <span class="built_in">memset</span>(&amp;new_fdt-&gt;close_on_exec-&gt;fds_bits[start], <span class="number">0</span>, left);</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_assign_pointer(newf-&gt;fdt, new_fdt);</span><br><span class="line">    <span class="keyword">return</span> newf;</span><br><span class="line">out_release:</span><br><span class="line">    kmem_cache_free(files_cachep, newf);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>procfs的&#x2F;proc&#x2F;PID&#x2F;status中的FDSize，记录了当前fdtable的大小：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/1/status </span><br><span class="line">FDSize: 128</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>当然了，FDSize记录的是目前fdtable能容纳的struct file指针，而不是已经打开的文件个数，已经打开的文件记录在&#x2F;proc&#x2F;PID&#x2F;fd中。通过对上述流程的梳理，不难看出，父子进程之间拷贝的是struct file的指针，而不是struct file的实例，父子进程的struct file类型指针，都指向同一个struct file实例。fork之后，父子进程的文件描述符关系如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_90.jpg"
                      alt="epub_831302_90"
                ></p>
<p>下面来看看struct file成员变量：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    f_flags</span><br><span class="line">    <span class="type">fmode_t</span>         f_mode</span><br><span class="line">    <span class="type">loff_t</span>          f_pos;<span class="comment">/*文件位置指针的当前值，即文件偏移量*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看到此处，就不难理解父子进程是如何共享文件偏移量的了，那是因为父子进程的指针都指向了同一个struct file结构体。</p>
<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h2><p>在早期的实现中，fork没有实现写时拷贝机制，而是直接对父进程的数据段、堆和栈进行完全拷贝，效率十分低下。很多程序在fork一个子进程后，会紧接着执行exec家族函数，这更是一种浪费。所以BSD引入了vfork。既然fork之后会执行exec函数，拷贝父进程的内存数据就变成了一种无意义的行为，所以引入的vfork压根就不会拷贝父进程的内存数据，而是直接共享。再后来Linux引入了写时拷贝的机制，其效率提高了很多，这样一来，vfork其实就可以退出历史舞台了。除了一些需要将性能优化到极致的场景，大部分情况下不需要再使用vfork函数了。</p>
<p>vfork会创建一个子进程，该子进程会共享父进程的内存数据，而且系统将保证子进程先于父进程获得调度。子进程也会共享父进程的地址空间，而父进程将被一直挂起，直到子进程退出或执行exec。注意，vfork之后，子进程如果返回，则不要调用return，而应该使用<code>_exit</code>函数。如果使用return，就会出现诡异的错误。请看下面的示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> glob = <span class="number">88</span> ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = vfork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vfork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* 子进程 */</span></span><br><span class="line">        var++;</span><br><span class="line">        glob++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d, glob=%d, var=%d\n&quot;</span>,getpid(), glob, var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用子进程，如果使用return返回，就意味着main函数返回了，因为栈是父子进程共享的，所以程序的函数栈发生了变化。main函数return之后，通常会调用exit系的函数，父进程收到子进程的exit之后，就会开始从vfork返回，但是这时整个main函数的栈都已经不复存在了，所以父进程压根无法执行。于是会返回一个诡异的栈地址，对于在某些内核版本中，进程会直接报栈错误然后退出，但是在某些内核版本中，有可能就会再次进出main，于是进入一个无限循环，直到vfork返回错误。笔者的Ubuntu版本就是后者。一般来说，vfork创建的子进程会执行exec，执行完exec后应该调用<code>_exit</code>返回。注意是<code>_exit</code>而不是exit。因为exit会导致父进程stdio缓冲区的冲刷和关闭。我们会在后面讲述exit和<code>_exit</code>的区别。</p>
<blockquote>
<p>高版本内核修复了这个问题。</p>
</blockquote>
<h1 id="Daemon进程的创建"><a href="#Daemon进程的创建" class="headerlink" title="Daemon进程的创建"></a>Daemon进程的创建</h1><p>daemon进程又被称为守护进程，一般来说它有以下两个特点：</p>
<ul>
<li>生命周期很长，一旦启动，正常情况下不会终止，一直运行到系统退出。但凡事无绝对：daemon进程其实也是可以停止的，如很多daemon提供了stop命令，执行stop命令就可以终止daemon，或者通过发送信号将其杀死，又或者因为daemon进程代码存在bug而异常退出。这些退出一般都是由手工操作或因异常引发的。</li>
<li>在后台执行，并且不与任何控制终端相关联。即使daemon进程是从终端命令行启动的，终端相关的信号如SIGINT、SIGQUIT和SIGTSTP，以及关闭终端，都不会影响到daemon进程的继续执行。</li>
</ul>
<p>习惯上daemon进程的名字通常以d结尾，如sshd、rsyslogd等。但这仅仅是习惯，并非一定要如此。如何使一个进程变成daemon进程，或者说编写daemon进程，需要遵循哪些规则或步骤呢？一般来讲，创建一个daemon进程的步骤被概括地称为double-fork magic。细细说来，需要以下步骤：</p>
<p>（1）<strong>执行fork（）函数，父进程退出，子进程继续执行这一步。</strong></p>
<p>原因有二：</p>
<ul>
<li>父进程有可能是进程组的组长（在命令行启动的情况下），从而不能够执行后面要执行的setsid函数，子进程继承了父进程的进程组ID，并且拥有自己的进程ID，一定不会是进程组的组长，所以子进程一定可以执行后面要执行的setsid函数。</li>
<li>如果daemon是从终端命令行启动的，那么父进程退出会被shell检测到，shell会显示shell提示符，让子进程在后台执行。</li>
</ul>
<p>（2）<strong>子进程执行如下三个步骤，以摆脱与环境的关系。</strong></p>
<ul>
<li><p><strong>修改进程的当前目录为根目录（&#x2F;）</strong>。这样做是有原因的，因为daemon一直在运行，如果当前工作路径上包含有根文件系统以外的其他文件系统，那么这些文件系统将无法卸载。因此，常规是将当前工作目录切换成根目录，当然也可以是其他目录，只要确保该目录所在的文件系统不会被卸载即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>调用setsid函数。这个函数的目的是切断与控制终端的所有关系，并且创建一个新的会话。</strong>这一步比较关键，因为这一步确保了子进程不再归属于控制终端所关联的会话。因此无论终端是否发送SIGINT、SIGQUIT或SIGTSTP信号，也无论终端是否断开，都与要创建的daemon进程无关，不会影响到daemon进程的继续执行。</p>
</li>
<li><p><strong>设置文件模式创建掩码为0。</strong>这一步的目的是让daemon进程创建文件的权限属性与shell脱离关系。因为默认情况下，进程的umask来源于父进程shell的umask。如果不执行umask（0），那么父进程shell的umask就会影响到daemon进程的umask。如果用户改变了shell的umask，那么也就相当于改变了daemon的umask，就会造成daemon进程每次执行的umask信息可能会不一致。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>（3）<strong>再次执行fork，父进程退出，子进程继续。</strong></p>
<p>执行完前面两步之后，可以说已经比较圆满了：新建会话，进程是会话的首进程，也是进程组的首进程。进程ID、进程组ID和会话ID，三者的值相同，进程和终端无关联。那么这里为何还要再执行一次fork函数呢？原因是，daemon进程有可能会打开一个终端设备，即daemon进程可能会根据需要，执行类似如下的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/console&quot;</span>, O_RDWR);</span><br></pre></td></tr></table></figure></div>

<p>这个打开的终端设备是否会成为daemon进程的控制终端，取决于两点：</p>
<ul>
<li>daemon进程是不是会话的首进程。</li>
<li>系统实现。（BSD风格的实现不会成为daemon进程的控制终端，但是POSIX标准说这由具体实现来决定）。</li>
</ul>
<p>既然如此，为了确保万无一失，只有确保daemon进程不是会话的首进程，才能保证打开的终端设备不会自动成为控制终端。因此，不得不执行第二次fork，fork之后，父进程退出，子进程继续。这时，子进程不再是会话的首进程，也不是进程组的首进程了。</p>
<p>（4）<strong>关闭标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。</strong></p>
<p>因为文件描述符0、1和2指向的就是控制终端。daemon进程已经不再与任意控制终端相关联，因此这三者都没有意义。一般来讲，关闭了之后，会打开&#x2F;dev&#x2F;null，并执行dup2函数，将0、1和2重定向到&#x2F;dev&#x2F;null。这个重定向是有意义的，防止了后面的程序在文件描述符0、1和2上执行I&#x2F;O库函数而导致报错。</p>
<p>至此，即完成了daemon进程的创建，进程可以开始自己真正的工作了。</p>
<p>上述步骤比较繁琐，对于C语言而言，glibc提供了daemon函数，从而帮我们将程序转化成daemon进程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  @nochdir: 用来控制是否将当前工作目录切换到根目录。</span></span><br><span class="line"><span class="comment">*           0：将当前工作目录切换到/。</span></span><br><span class="line"><span class="comment">*           1：保持当前工作目录不变。</span></span><br><span class="line"><span class="comment">*  @noclose: 用来控制是否将标准输入、标准输出和标准错误重定向到/dev/null。</span></span><br><span class="line"><span class="comment">*           0：将标准输入、标准输出和标准错误重定向到/dev/null。</span></span><br><span class="line"><span class="comment">*           1：保持标准输入、标准输出和标准错误不变。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon</span><span class="params">(<span class="type">int</span> nochdir, <span class="type">int</span> noclose)</span>;</span><br><span class="line"><span class="comment">// 一般情况下，这两个入参都要为0。</span></span><br><span class="line">ret = daemon(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 成功时，daemon函数返回0；失败时，返回-1，并置errno。</span></span><br><span class="line"><span class="comment">* 因为daemon函数内部会调用fork函数和setsid函数，所以出错时errno可以查看fork函数和setsid函数的出错情形。</span></span><br><span class="line"><span class="comment">* glibc的daemon函数做的事情，和前面讨论的大体一致，但是做得并不彻底，没有执行第二次的fork。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (daemon(<span class="number">0</span>, <span class="number">0</span>)) &#123;<span class="comment">//调用glibc库函数daemon,创建daemon守护进程</span></span><br><span class="line">        perror(<span class="string">&quot;daemon&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon</span><span class="params">( <span class="type">int</span> nochdir, <span class="type">int</span> noclose )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">if</span> ( !nochdir &amp;&amp; chdir(<span class="string">&quot;/&quot;</span>) != <span class="number">0</span> )   <span class="comment">//如果nochdir=0,那么改变到&quot;/&quot;根目录</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> ( !noclose )                      <span class="comment">//如果没有noclose=0，那么开始输入,输出以及错误输出重定向到/dev/null </span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);<span class="comment">//打开神奇的黑洞文件.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//每个进程都拥有自己fds文件描述符表，</span></span><br><span class="line"><span class="comment">//fdt-&gt;fd[0],fdt-&gt;fd[1],fdt-&gt;fd[2],</span></span><br><span class="line"><span class="comment">//表中fd[0],fd[1],和fd[2]文件句柄位置对应的fops文件操作函数集,分别与标准输入,标准输出,标准错误输出相关联</span></span><br><span class="line"><span class="comment">//所以用户应用程序调用open函数打开文件时,默认都是以3索引为开始句柄,也就是fd[3]，故当前open返回的文件句柄最小值为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dup2(unsigned int oldfd, unsigned int newfd)系统调用就是用oldfd的fops操作文件集file,复制到newfd所在处</span></span><br><span class="line"><span class="comment">//即：fdt-&gt;fd[newfd] = fdt-&gt;fd[oldfd];</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ( dup2( fd, <span class="number">0</span> ) &lt; <span class="number">0</span> || <span class="comment">//使用字符设备/dev/null的fops函数操作集,替换0句柄对应的文件操作集.</span></span><br><span class="line">     dup2( fd, <span class="number">1</span> ) &lt; <span class="number">0</span> ||      <span class="comment">//使用字符设备/dev/null的fops函数操作集,替换1句柄对应的文件操作集.</span></span><br><span class="line">          dup2( fd, <span class="number">2</span> ) &lt; <span class="number">0</span> )  <span class="comment">//使用字符设备/dev/null的fops函数操作集,替换2句柄对应的文件操作集.</span></span><br><span class="line">     &#123;</span><br><span class="line">       close(fd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果替换成功,那么键盘的任何操作将不会对该进程产生任何影响,因为0,1,2句柄所在处的fops文件操作集已经都变成了,</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//被重定向为&quot;/dev/null&quot;空洞设备的fops.所以对0,1,2句柄的读写操作,也就是在对/dev/null设备作读写操作.</span></span><br><span class="line">     close(fd); <span class="comment">//关闭打开的/dev/null</span></span><br><span class="line">  &#125;</span><br><span class="line">   pid = fork();<span class="comment">//创建子进程.</span></span><br><span class="line">   <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);  <span class="comment">//返回执行的是父进程,那么父进程退出,让子进程变成真正的孤儿进程.</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//ok,我们期望的daemon子进程执行到这里了.</span></span><br><span class="line">   <span class="keyword">if</span> ( setsid() &lt; <span class="number">0</span> ) <span class="comment">//设置session id.</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//成功创建daemon子进程[luther.gliethttp].</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h1><p>在不考虑线程的情况下，进程的退出有以下5种方式。</p>
<p>正常退出有3种：</p>
<ul>
<li>从main函数return返回</li>
<li>调用<code>exit</code></li>
<li>调用<code>_exit</code></li>
</ul>
<p>异常退出有两种：</p>
<ul>
<li>调用abort</li>
<li>接收到信号，由信号终止</li>
</ul>
<h2 id="exit"><a href="#exit" class="headerlink" title="_exit"></a><code>_exit</code></h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure></div>

<p><code>_exit</code> 函数中status参数定义了进程的终止状态，父进程可以通过<code>wait（）</code>来获取该状态值。需要注意的是返回值，虽然status是int型，但是仅有低8位可以被父进程所用。所以写<code>_exit（-1）</code>结束进程时，在终端执行<code>“$？”</code>会发现返回值是255。如果是shell相关的编程，shell可能需要获取进程的退出值，那么退出值最好不要大于128。如果退出值大于128，会给shell带来困扰。POSIX标准规定了退出状态及其含义如表4-2所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_93.jpg"
                      alt="epub_831302_93"
                ></p>
<p>下面的命令被SIGINT信号（signo&#x3D;2）中断，返回了130。如程序通过exit返回130，与其配合工作的shell就可能会误判为收到信号而退出。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sleep</span> 10000</span><br><span class="line">^C</span><br><span class="line">$ $?</span><br><span class="line">130：未找到命令</span><br></pre></td></tr></table></figure></div>

<p>用户调用<code>_exit</code>函数，本质上是调用<code>exit_group</code>系统调用。这点在前面已经详细介绍过，在此就不再赘述了。</p>
<h2 id="exit-1"><a href="#exit-1" class="headerlink" title="exit"></a>exit</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure></div>

<p>exit（）函数的最后也会调用<code>_exit（）</code>函数，但是exit在调用<code>_exit</code>之前，还做了其他工作：</p>
<p>1）执行用户通过调用<code>atexit</code>函数或<code>on_exit</code>定义的清理函数。</p>
<p>2）关闭所有打开的流（stream），所有缓冲的数据均被写入（flush），通过tmpfile创建的临时文件都会被删除。</p>
<p>3）调用_exit。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_95.jpg"
                      alt="epub_831302_95"
                ></p>
<p>下面介绍<code>exit</code>函数和<code>_exit</code>函数的不同之处。</p>
<p>首先是<code>exit</code>函数会执行用户注册的清理函数。用户可以通过调用<code>atexit（）</code>函数或<code>on_exit（）</code>函数来定义清理函数。这些清理函数在调用<code>return</code>或调用<code>exit</code>时会被执行。执行顺序与函数注册的顺序相反。当进程收到致命信号而退出时，注册的清理函数不会被执行；当进程调用<code>_exit</code>退出时，注册的清理函数不会被执行；当执行到某个清理函数时，若收到致命信号或清理函数调用了<code>_exit（）</code>函数，那么该清理函数不会返回，从而导致排在后面的需要执行的清理函数都会被丢弃。</p>
<p>其次是exit函数会冲刷（flush）标准I&#x2F;O库的缓冲并关闭流。glibc提供的很多与I&#x2F;O相关的函数都提供了缓冲区，用于缓存大块数据。缓冲有三种方式：<code>无缓冲（_IONBF）、行缓冲（_IOLBF）和全缓冲（_IOFBF）</code>。</p>
<ul>
<li>无缓冲：就是没有缓冲区，每次调用stdio库函数都会立刻调用<code>read/write</code>系统调用。</li>
<li>行缓冲：对于输出流，收到换行符之前，一律缓冲数据，除非缓冲区满了。对于输入流，每次读取一行数据。</li>
<li>全缓冲：就是缓冲区满之前，不会调用<code>read/write</code>系统调用来进行读写操作。</li>
</ul>
<p>对于后两种缓冲，可能会出现这种情况：进程退出时，缓冲区里面可能还有未冲刷的数据。如果不冲刷缓冲区，缓冲区的数据就会丢失。比如行缓冲迟迟没有等到换行符，又或者全缓冲没有等到缓冲区满。尤其是后者，很容易出现，因为glibc的缓冲区默认是8192字节。exit函数在关闭流之前，会冲刷缓冲区的数据，确保缓冲区里的数据不会丢失。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;foo says bye.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;bar says bye.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    atexit(foo);</span><br><span class="line">    atexit(bar);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;Oops ... forgot a newline!&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;_exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意上面的示例代码，fprintf打印的字符串是没有换行符的，对于标准输出流stdout，采用的是行缓冲，收到换行符之前是不会有输出的。输出情况如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$ ./test <span class="built_in">exit</span></span><br><span class="line">bar says bye.</span><br><span class="line">foo says bye.</span><br><span class="line">Oops ... forgot a newline!manu@manu-hacks:<span class="built_in">exit</span>$</span><br><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$</span><br><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$ ./test</span><br><span class="line">bar says bye.</span><br><span class="line">foo says bye.</span><br><span class="line">Oops ... forgot a newline!manu@manu-hacks:<span class="built_in">exit</span>$</span><br><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$</span><br><span class="line">manu@manu-hacks:<span class="built_in">exit</span>$ ./test _exit</span><br><span class="line">manu@manu-hacks:~/code/self/c/<span class="built_in">exit</span>$</span><br></pre></td></tr></table></figure></div>

<p>尽管缓冲区里的数据没有等到换行符，但是无论是调用return返回还是调用exit返回，缓冲区里的数据都会被冲刷，<code>“Oops...forgot a newline！”</code>都会被输出。因为<code>exit（）</code>函数会负责此事。从测试代码的输出也可以看出，<code>exit（）</code>函数首先执行的是用户注册的清理函数，然后才执行了缓冲区的冲刷。第三，存在临时文件，exit函数会负责将临时文件删除，这点在第3章中已经介绍过，此处就不再赘述了。<code>exit</code>函数的最后调用了<code>_exit（）</code>函数，最终殊途同归，走向内核清理。</p>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>return是一种更常见的终止进程的方法。执行return（n）等同于执行exit（n），因为调用main（）的运行时函数会将main的返回值当作exit的参数。</p>
<h1 id="等待子进程"><a href="#等待子进程" class="headerlink" title="等待子进程"></a>等待子进程</h1><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>进程就像一个生命体，通过<code>fork（）</code>函数，子进程呱呱坠地。有的子进程子承父业，继续执行与父进程一样的程序（相同的代码段，尽管可能是不同的程序分支），有的子进程则比较叛逆，通过exec离家出走，走向与父进程完全不同的道路。</p>
<p>令人悲伤的是，如同所有的生命体一样，进程也会消亡。进程退出时会进行内核清理，基本就是释放进程所有的资源，这些资源包括内存资源、文件资源、信号量资源、共享内存资源，或者引用计数减一，或者彻底释放。不过，进程的退出其实并没有将所有的资源完全释放，仍保留了少量的资源，比如进程的PID依然被占用着，不可被系统分配。此时的进程不可运行，事实上也没有地址空间让其运行，进程进入僵尸状态。</p>
<p>为什么进程退出之后不将所有的资源释放，从此灰飞烟灭，一了百了，反而非要保留少量资源，进入僵尸状态呢？看看僵尸进程依然占有的系统资源，我们就能获得答案。僵尸进程依然保留的资源有进程控制块task_struct、内核栈等。这些资源不释放是为了提供一些重要的信息，比如进程为何退出，是收到信号退出还是正常退出，进程退出码是多少，进程一共消耗了多少系统CPU时间，多少用户CPU时间，收到了多少信号，发生了多少次上下文切换，最大内存驻留集是多少，产生多少缺页中断？等等。这些信息，就像墓志铭，总结了进程的一生。如果没有这个僵尸状态，进程的这些信息也会随之流逝，系统也将再也没有机会获知该进程的相关信息了。因此进程退出后，会保留少量的资源，等待父进程前来收集这些信息。一旦父进程收集了这些信息之后（通过调用下面提到的wait&#x2F;waitpid等函数），这些残存的资源完成了它的使命，就可以释放了，进程就脱离僵尸状态，彻底消失了。</p>
<p>从上面的讨论可以看出，制造一个僵尸进程是一件很容易的事情，只要父进程调用fork创建子进程，子进程退出后，父进程如果不调用wait或waitpid来获取子进程的退出信息，子进程就会沦为僵尸进程。示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果出错 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error occurred!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        sleep(<span class="number">300</span>);  <span class="comment">/* 休眠300秒 */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">/* 获取僵尸进程的退出信息 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的例子中父进程休眠300秒后才会调用wait来获取子进程的退出信息。而子进程退出之后会变成僵尸状态，苦苦等待父进程来获取退出信息。在这300秒左右的时间里，子进程就是一个僵尸进程。</p>
<p>如何查看一个进程是否处于僵尸状态呢？ps命令输出的进程状态Z，就表示进程处于僵尸状态，另外procfs提供的status信息中的State给出的值是Z（zombie），也表明进程处于僵尸状态。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ps ax</span><br><span class="line">......</span><br><span class="line"><span class="number">3940</span> pts/<span class="number">10</span>   S      <span class="number">0</span>:<span class="number">00</span> ./zombie</span><br><span class="line"><span class="number">3941</span> pts/<span class="number">10</span>   Z      <span class="number">0</span>:<span class="number">00</span> [zombie] &lt;defunct&gt;</span><br><span class="line">cat /proc/<span class="number">3941</span>/status</span><br><span class="line">Name:    zombie</span><br><span class="line">State:    Z (zombie)</span><br><span class="line">Tgid:    <span class="number">3941</span></span><br><span class="line">Ngid:    <span class="number">0</span></span><br><span class="line">Pid:    <span class="number">3941</span></span><br><span class="line">PPid:    <span class="number">3940</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure></div>

<p>进程一旦进入僵尸状态，就进入了一种刀枪不入的状态，“杀人不眨眼”的kill-9也无能为力，因为谁也没有办法杀死一个已经死去的进程。</p>
<p>清除僵尸进程有以下两种方法：</p>
<ul>
<li>父进程调用wait函数，为子进程“收尸”。</li>
<li>父进程退出，init进程会为子进程“收尸”。</li>
</ul>
<p>一般而言，系统不希望大量进程长期处于僵尸状态，因为会浪费系统资源。除了少量的内存资源外，比较重要的是进程ID。僵尸进程并没有将自己的进程ID归还给系统，而是依然占有这个进程ID，因此系统不能将该ID分配给其他进程。</p>
<p>对于编程来说，如何防范僵尸进程的产生呢？答案是具体情况具体分析。如果我们不关心子进程的退出状态，就应该将父进程对SIGCHLD的处理函数设置为SIG_IGN，或者在调用sigaction函数时设置SA_NOCLDWAIT标志位。这两者都会明确告诉子进程，父进程很“绝情”，不会为子进程“收尸”。子进程退出的时候，内核会检查父进程的SIGCHLD信号处理结构体是否设置了SA_NOCLDWAIT标志位，或者是否将信号处理函数显式地设为SIG_IGN。如果是，则autoreap为true，子进程发现autoreap为true也就“死心”了，不会进入僵尸状态，而是调用release_task函数“自行了断”了。如果父进程关心子进程的退出信息，则应该在流程上妥善设计，能够及时地调用wait，使子进程处于僵尸状态的时间不会太久。对于创建了很多子进程的应用来说，知道子进程的返回值是有意义的。比如说父进程维护一个进程池，通过进程池里的子进程来提供服务。当子进程退出的时候，父进程需要了解子进程的返回值来确定子进程的“死因”，从而采取更有针对性的措施。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;sys/wait.h&gt;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure></div>

<p>成功时，返回已退出子进程的进程ID；失败时，则返回-1并设置errno，常见的errno及说明见表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_99.jpg"
                      alt="epub_831302_99"
                ></p>
<p>注意父子进程是两个进程，子进程退出和父进程调用wait（）函数来获取子进程的退出状态在时间上是独立的事件，因此会出现以下两种情况：</p>
<ul>
<li><p>子进程先退出，父进程后调用wait（）函数。</p>
<p>对于这种情况，子进程几乎已经销毁了自己所有的资源，只留下少量的信息，苦苦等待父进程来“收尸”。当父进程调用wait（）函数的时候，苦守寒窑十八载的子进程终于等到了父进程来“收尸”，这种情况下，父进程获取到子进程的状态信息，wait函数立刻返回。</p>
</li>
<li><p>父进程先调用wait（）函数，子进程后退出。</p>
<p>对于第二种情况，父进程先调用wait（）函数，调用时并无子进程退出，该函数调用就会陷入阻塞状态，直到某个子进程退出。</p>
</li>
</ul>
<p>wait（）函数等待的是任意一个子进程，任何一个子进程退出，都可以让其返回。当多个子进程都处于僵尸状态，wait（）函数获取到其中一个子进程的信息后立刻返回。由于wait（）函数不会接受pid_t类型的入参，所以它无法明确地等待特定的子进程。</p>
<p>一个进程如何等待所有的子进程退出呢？wait（）函数返回有三种可能性：</p>
<ul>
<li>等到了子进程退出，获取其退出信息，返回子进程的进程ID。</li>
<li>等待过程中，收到了信号，信号打断了系统调用，并且注册信号处理函数时并没有设置SA_RESTART标志位，系统调用不会被重启，wait（）函数返回-1，并且将errno设置为EINTR。</li>
<li>已经成功地等待了所有子进程，没有子进程的退出信息需要接收，在这种情况下，wait（）函数返回-1，errno为ECHILD。</li>
</ul>
<blockquote>
<p>《Linux&#x2F;Unix系统编程手册》给出下面的代码来等待所有子进程的退出：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((childPid = wait(<span class="literal">NULL</span>)) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(errno !=ECHILD)</span><br><span class="line">    errExit(<span class="string">&quot;wait&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这种方法并不完全，因为这里忽略了wait（）函数被信号中断这种情况，如果wait（）函数被信号中断，上面的代码并不能成功地等待所有子进程退出。若将上面的wait（）函数封装一下，使其在信号中断后，自动重启wait就完备了。代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">r_wait</span><span class="params">(<span class="type">int</span> *stat_loc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">while</span>(((retval = wait(stat_loc)) == <span class="number">-1</span> &amp;&amp; (errno == EINTR));</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>((childPid = r_wait(<span class="literal">NULL</span>)) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">If(errno != ECHILD)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*some error happened*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>如果父进程调用wait（）函数时，已经有多个子进程退出且都处于僵尸状态，那么哪一个子进程会被先处理是不一定的（标准并未规定处理的顺序）。</p>
<p>通过上面的讨论，可以看出wait（）函数存在一定的局限性：</p>
<ul>
<li>不能等待特定的子进程。如果进程存在多个子进程，而它只想获取某个子进程的退出状态，并不关心其他子进程的退出状态，此时wait（）只能一一等待，通过查看返回值来判断是否为关心的子进程。</li>
<li>如果不存在子进程退出，wait（）只能阻塞。有些时候，仅仅是想尝试获取退出子进程的退出状态，如果不存在子进程退出就立刻返回，不需要阻塞等待，类似于trywait的概念。wait（）函数没有提供trywait的接口。</li>
<li>wait（）函数只能发现子进程的终止事件，如果子进程因某信号而停止，或者停止的子进程收到SIGCONT信号又恢复执行，这些事件wait（）函数是无法获知的。换言之，wait（）能够探知子进程的死亡，却不能探知子进程的昏迷（暂停），也无法探知子进程从昏迷中苏醒（恢复执行）。由于上述三个缺点的存在，所以Linux又引入了waitpid（）函数。</li>
</ul>
<h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure></div>

<p>先说说waitpid（）与wait（）函数相同的地方：</p>
<ul>
<li>返回值的含义相同，都是终止子进程或因信号停止或因信号恢复而执行的子进程的进程ID。</li>
<li>status的含义相同，都是用来记录子进程的相关事件，后面一节将会详细介绍。</li>
</ul>
<p>接下来介绍waitpid（）函数特有的功能。其第一个参数是pid_t类型，有了此值，不难看出waitpid函数肯定具备了精确打击的能力。waitpid函数可以明确指定要等待哪一个子进程的退出（以及停止和恢复执行）。事实上，扩展的功能不仅仅如此：</p>
<ul>
<li>pid＞0：表示等待进程ID为pid的子进程，也就是上文提到的精确打击的对象。</li>
<li>pid＝0：表示等待与调用进程同一个进程组的任意子进程；因为子进程可以设置自己的进程组，所以某些子进程不一定和父进程归属于同一个进程组，这样的子进程，waitpid函数就毫不关心了。</li>
<li>pid＝-1：表示等待任意子进程，同wait类似。waitpid（-1，&amp;status，0）与wait（&amp;status）完全等价。</li>
<li>pid＜-1：等待所有子进程中，进程组ID与pid绝对值相等的所有子进程。</li>
</ul>
<p>内核之中，wait函数和waitpid函数调用的都是wait4系统调用。下面是wait4系统调用的实现。函数的中间部分，根据pid的正负或是否为0和-1来定义<code>wait_opts</code>类型的变量wo，后面会根据wo来控制到底关心哪些进程的事件。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(wait4, <span class="type">pid_t</span>, upid, <span class="type">int</span> __user *, stat_addr, <span class="type">int</span> options, <span class="keyword">struct</span> rusage __user *, ru)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wait_opts</span> <span class="title">wo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pid_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; ~(WNOHANG|WUNTRACED|WCONTINUED|</span><br><span class="line">            __WNOTHREAD|__WCLONE|__WALL))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (upid == <span class="number">-1</span>)</span><br><span class="line">        type = PIDTYPE_MAX;   <span class="comment">/*任意子进程*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (upid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        type = PIDTYPE_PGID;</span><br><span class="line">        pid = find_get_pid(-upid);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (upid == <span class="number">0</span>) &#123;</span><br><span class="line">        type = PIDTYPE_PGID;</span><br><span class="line">        pid = get_task_pid(current, PIDTYPE_PGID);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">/* upid &gt; 0 */</span> &#123;</span><br><span class="line">        type = PIDTYPE_PID;</span><br><span class="line">        pid = find_get_pid(upid);</span><br><span class="line">    &#125;</span><br><span class="line">    wo.wo_type    = type;</span><br><span class="line">    wo.wo_pid    = pid;</span><br><span class="line">    wo.wo_flags    = options | WEXITED;</span><br><span class="line">    wo.wo_info    = <span class="literal">NULL</span>;</span><br><span class="line">    wo.wo_stat    = stat_addr;</span><br><span class="line">    wo.wo_rusage    = ru;</span><br><span class="line">    ret = do_wait(&amp;wo);</span><br><span class="line">    put_pid(pid);</span><br><span class="line">    <span class="comment">/* avoid REGPARM breakage on x86: */</span></span><br><span class="line">    asmlinkage_protect(<span class="number">4</span>, ret, upid, stat_addr, options, ru);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到，内核的<code>do_wait</code>函数会根据<code>wait_opts</code>类型的wo变量来控制到底在等待哪些子进程的状态。当前进程中的每一个线程（在内核层面，线程就是进程，每个线程都有独立的task_struct），都会遍历其子进程。在内核中，<code>task_struct</code>中的<code>children</code>成员变量是个链表头，该进程的所有子进程都会链入该链表，遍历起来比较方便。代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_wait_thread</span><span class="params">(<span class="keyword">struct</span> wait_opts *wo, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">       list_for_each_entry(p, &amp;tsk-&gt;children, sibling) &#123;</span><br><span class="line">           <span class="comment">/*遍历进程所有的子进程*/</span></span><br><span class="line">        <span class="type">int</span> ret = wait_consider_task(wo, <span class="number">0</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是我们并不一定关心所有的子进程。当wait（）函数或waitpid（）函数的第一个参数pid等于-1的时候，表示任意子进程我们都关心。但是如果是waitpid（）函数的其他情况，则表示我们只关心其中的某些子进程或某个子进程。内核需要对所有的子进程进行过滤，找到关心的子进程。这个过滤的环节是在内核的<code>eligible_pid</code>函数中完成的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当waitpid的第一个参数为-1时，wo-&gt;wo_type 赋值为PIDTYPE_MAX</span></span><br><span class="line"><span class="comment">* 其他三种情况task_pid_type(p, wo-&gt;wo_type)== wo-&gt;wo_pid检验</span></span><br><span class="line"><span class="comment">* 或者检查pid是否相等，或者检查进程组ID是否等于指定值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eligible_pid</span><span class="params">(<span class="keyword">struct</span> wait_opts *wo, <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> wo-&gt;wo_type == PIDTYPE_MAX || task_pid_type(p, wo-&gt;wo_type) == wo-&gt;wo_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>waitpid函数的第三个参数options是一个位掩码（bit mask），可以同时存在多个标志。当options没有设置任何标志位时，其行为与wait类似，即阻塞等待与pid匹配的子进程退出。options的标志位可以是如下标志位的组合：</p>
<ul>
<li>WUNTRACE：除了关心终止子进程的信息，也关心那些因信号而停止的子进程信息。</li>
<li>WCONTINUED：除了关心终止子进程的信息，也关心那些因收到信号而恢复执行的子进程的状态信息。</li>
<li>WNOHANG：指定的子进程并未发生状态变化，立刻返回，不会阻塞。这种情况下返回值是0。如果调用进程并没有与pid匹配的子进程，则返回-1，并设置errno为ECHILD，根据返回值和errno可以区分这两种情况。</li>
</ul>
<p>传统的wait函数只关注子进程的终止，而waitpid函数则可以通过前两个标志位来检测子进程的停止和从停止中恢复这两个事件。讲到这里，需要解释一下什么是“使进程停止”，什么是“使进程继续”，以及为什么需要这些。设想如下的场景，正在某机器上编译一个大型项目，编译过程需要消耗很多CPU资源和磁盘I&#x2F;O资源，并且耗时很久。如果我暂时需要用机器做其他事情，虽然可能只需要占用几分钟时间。但这会使这几分钟内的用户体验非常糟糕，那怎么办？当然，杀掉编译进程是一个选择，但是这个方案并不好。因为编译耗时很久，贸然杀死进程，你将不得不从头编译起。这时候，我们需要的仅仅是让编译大型工程的进程停下来，把CPU资源和I&#x2F;O资源让给我，让我从容地做自己想做的事情，几分钟后，我用完了，让编译的进程继续工作就行了。</p>
<p>Linux提供了SIGSTOP（信号值19）和SIGCONT（信号值18）两个信号，来完成暂停和恢复的动作，可以通过执行kill-SIGSTOP或kill-19来暂停一个进程的执行，通过执行kill-SIGCONT或kill-18来让一个暂停的进程恢复执行。waitpid（）函数可以通过WUNTRACE标志位关注停止的事件，如果有子进程收到信号处于暂停状态，waitpid就可以返回。同样的道理，通过WCONTINUED标志位可以关注恢复执行的事件，如果有子进程收到SIGCONT信号而恢复执行，waitpid就可以返回。但是上述两个事件和子进程的终止事件是并列的关系，waitpid成功返回的时候，可能是等到了子进程的终止事件，也可能是等到了暂停或恢复执行的事件。这需要通过status的值来区分。那么，现在应该分析status的值了。</p>
<h2 id="等待状态值"><a href="#等待状态值" class="headerlink" title="等待状态值"></a>等待状态值</h2><p>无论是wait（）函数还是waitpid（）函数，都有一个status变量。这个变量是一个int型指针。可以传递NULL，表示不关心子进程的状态信息。如果不为空，则根据填充的status值，可以获取到子进程的很多信息，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_102.jpg"
                      alt="epub_831302_102"
                ></p>
<p>上图可知，直接根据status值可以获得进程的退出方式，但是为了保证可移植性，不应该直接解析status值来获取退出状态。因此系统提供了相应的宏（macro），用来解析返回值。下面分别介绍各种情况。</p>
<ul>
<li>进程是正常退出的</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_103.jpg"
                      alt="epub_831302_103"
                ></p>
<p>所谓截取退出状态8~15位的值，也就是<code>exit_group</code>系统调用用户传入的int型的值。当然只有最低的8位：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    __WEXITSTATUS(status)    (((status) &amp; 0xff00) &gt;&gt; 8)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>进程收到信号，导致退出</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_104.jpg"
                      alt="epub_831302_104"
                ></p>
<ul>
<li>进程收到信号，被停止</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_105.jpg"
                      alt="epub_831302_105"
                ></p>
<ul>
<li>子进程恢复执行</li>
</ul>
<p>有一个宏与这种情况相关。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_106.jpg"
                      alt="epub_831302_106"
                ></p>
<p>为何没有返回使子进程恢复的信号值的宏？原因是只有SIGCONT信号能够使子进程从停止状态中恢复过来。如果子进程恢复执行，只可能是收到了SIGCONT信号，所以不需要宏来取信号的值。下面给出了判断子进程终止的示例代码。等待子进程暂停或恢复执行的情况，可以根据下面的示例代码自行实现。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_wait_exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;status = %d\n&quot;</span>,status);</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;normal termination,exit status = %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abnormal termination,signal number =%d%s\n&quot;</span>,WTERMSIG(status),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">                WCOREDUMP(status)?<span class="string">&quot;core file generated&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>尽管waitpid函数对wait函数做了很多的扩展，但waitpid函数还是存在不足之处：waitpid固然通过WUNTRACE和WCONTINUED标志位，增加了对子进程停止事件和子进程恢复执行事件的支持，但是这种支持并不完美，这两种事件都和子进程的终止事件混在一起了。wait和waitpid函数都会调用wait4系统调用，无论用户传递的参数为何，总会添上WEXITED事件，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wo.wo_flags         = options | WEXITED;</span><br></pre></td></tr></table></figure></div>

<p>如果用户不关心子进程的终止事件，只关心子进程的停止事件，能否使用waitpid（）明确做到？答案是不行。当waitpid返回时，可能是因为子进程终止，也可能是因为子进程停止。这是waitpid和wait的致命缺陷。为了解决这个缺陷，wait家族的最重要成员，waitid（）函数就要闪亮登场了。</p>
<h2 id="waitid"><a href="#waitid" class="headerlink" title="waitid"></a>waitid</h2><p>前面提到过，waitpid函数是wait函数的超集，wait函数能干的事情，waitpid函数都能做到。但是waitpid函数的控制还是不太精确，无论用户是否关心相关子进程的终止事件，终止事件都可能会返回给用户。因此Linux提供了waitid系统调用。glibc封装了waitid系统调用从而实现了waitid函数。尽管目前普遍使用的是wait和waitpid两个函数，但是waitid函数的设计显然更加合理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  @ @ 该函数的第一个入参idtype和第二个入参id用于选择用户关心的子进程。</span></span><br><span class="line"><span class="comment">      idtype==P_PID：精确打击，等待进程ID等于id的进程。</span></span><br><span class="line"><span class="comment">      idtype==P_PGID：在所有子进程中等待进程组ID等于id的进程。</span></span><br><span class="line"><span class="comment">      idtype==P_ALL：等待任意子进程，第二个参数id被忽略。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @ 第三个参数infop本质是个返回值，系统调用负责将子进程的相关信息填充到infop指向的结构体中。</span></span><br><span class="line"><span class="comment">      如果成功获取到信息，下面的字段将会被填充：</span></span><br><span class="line"><span class="comment">      si_pid：子进程的进程ID，相当于wait和waitpid成功时的返回值。</span></span><br><span class="line"><span class="comment">      si_uid：子进程真正的用户ID。</span></span><br><span class="line"><span class="comment">      si_signo：该字段总被填成SIGCHLD。</span></span><br><span class="line"><span class="comment">      si_code：指示子进程发生的事件，该字段可能的取值是：</span></span><br><span class="line"><span class="comment">      		   CLD_EXIT（子进程正常退出）</span></span><br><span class="line"><span class="comment">      		   CLD_KILLED（子进程被信号杀死）</span></span><br><span class="line"><span class="comment">      		   CLD_DUMPED（子进程被信号杀死，并且产生了core dump）</span></span><br><span class="line"><span class="comment">      		   CLD_STOPPED（子进程被信号暂停）</span></span><br><span class="line"><span class="comment">      		   CLD_CONTINUED（子进程被SIGCONT信号恢复执行）</span></span><br><span class="line"><span class="comment">      		   CLD_TRAPPED（子进程被跟踪）</span></span><br><span class="line"><span class="comment">      si_status：status值的语义与wait函数及waitpid函数一致，对于返回值，在两种情况下会返回0：</span></span><br><span class="line"><span class="comment">                成功等到子进程的变化，并取回相应的信息。</span></span><br><span class="line"><span class="comment">                设置了WNOHANG标志位，并且子进程状态无变化。</span></span><br><span class="line"><span class="comment">           如何区分这两种情况呢？解决的方法就是判断返回的siginfo_t结构体中的si_pid，</span></span><br><span class="line"><span class="comment">           如果是因为子进程的状态变化而导致的返回，则si_pid必不等于0，而是等于子进程的进程ID；</span></span><br><span class="line"><span class="comment">           若子进程状态没有变化，则si_pid等于0。</span></span><br><span class="line"><span class="comment">           但是标准并没有规定，waitid函数负责将siginfo_t结构体的内容清零，</span></span><br><span class="line"><span class="comment">           所以为了正确区分这两种情况，唯一安全的做法就是首先将siginfo_t结构体清零，</span></span><br><span class="line"><span class="comment">           返回后，通过判断si_pid是否为0来分辨这两种情况。示例代码如 (1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @ 该函数的改进在于第四个参数options。options参数是下面标志位的按位或：</span></span><br><span class="line"><span class="comment">      WEXITED：等待子进程的终止事件。</span></span><br><span class="line"><span class="comment">      WSTOPPED：等待被信号暂停的子进程事件。</span></span><br><span class="line"><span class="comment">      WCONTINUED：等待先前被暂停，但是被SIGCONT信号恢复执行的子进程。</span></span><br><span class="line"><span class="comment">      WNOHANG：这个标志位语义与waitpid一致，与id匹配的子进程若并无状态信息需要返回，则不阻塞，立刻返回，返回值是0。</span></span><br><span class="line"><span class="comment">      如果调用进程并无子进程与id匹配，则返回-1，并且设置errno为ECHILD。</span></span><br><span class="line"><span class="comment">      WNOWAIT：该标志位指示内核，只负责获取信息，不要改变子进程的状态(僵尸状态)。</span></span><br><span class="line"><span class="comment">      带有WNOWAIT标志位调用waitid函数，稍后还可以调用wait或waitpid或waitid再次获得同样的信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// (1) </span></span><br><span class="line"><span class="type">siginfo_t</span> info ;</span><br><span class="line"><span class="built_in">memset</span>(&amp;info,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">siginfo_t</span>));</span><br><span class="line"><span class="keyword">if</span>(waited(idtype,id,&amp;info,options | WNOHANG) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*发生错误*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(info.si_pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*子进程没有发生变化*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*若有子进程状态发生变化，则进一步处理之*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="进程退出和等待的内核实现"><a href="#进程退出和等待的内核实现" class="headerlink" title="进程退出和等待的内核实现"></a>进程退出和等待的内核实现</h2><p>Linux引入多线程之后，为了支持进程的所有线程能够整体退出，内核引入了<code>exit_group</code>系统调用。对于进程而言，无论是调用exit（）函数、<code>_exit（）</code>函数还是在main函数中return，最终都会调用<code>exit_group</code>系统调用。</p>
<p>对于单线程的进程，从<code>do_exit_group</code>直接调用<code>do_exit</code>就退出了。但是对于多线程的进程，如果某一个线程调用了<code>exit_group</code>系统调用，那么该线程在调用<code>do_exit</code>之前，会通过<code>zap_other_threads</code>函数，给每一个兄弟线程挂上一个<code>SIGKILL</code>信号。内核在尝试递送信号给兄弟进程时（通过<code>get_signal_to_deliver</code>函数），会在挂起信号中发现<code>SIGKILL</code>信号。内核会直接调用<code>do_group_exit</code>函数让该线程也退出（如图4-13所示）。这个过程在第3章中已经详细分析过了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_110.jpg"
                      alt="epub_831302_110"
                ></p>
<p>在do_exit函数中，进程会释放几乎所有的资源（文件、共享内存、信号量等）。该进程并不甘心，因为它还有两桩心愿未了：</p>
<ul>
<li>作为父进程，它可能还有子进程，进程退出以后，将来谁为它的子进程“收尸”。</li>
<li>作为子进程，它需要通知它的父进程来为自己“收尸”。</li>
</ul>
<p>这两件事情是由<code>exit_notify</code>来负责完成的，具体来说<code>forget_original_parent</code>函数和<code>do_notify_parent</code>函数各自负责一件事，如表所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/01/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/epub_831302_111.jpg"
                      alt="epub_831302_111"
                ></p>
<p><code>forget_original_parent（）</code>，多么“悲伤”的函数名。顾名思义，该函数用来给自己的子进程安排新的父进程。给自己的子进程安排新的父进程，细分下来，是两件事情：</p>
<p>1）为子进程寻找新的父进程。</p>
<p>2）将子进程的父进程设置为第1）步中找到的新的父亲。</p>
<p>为子进程寻找父进程，是由<code>find_new_reaper（）</code>函数完成的。如果退出的进程是多线程进程，则可以将子进程托付给自己的兄弟线程。如果没有这样的线程，就“托孤”给init进程。</p>
<p>为自己的子进程找到新的父亲之后，内核会遍历退出进程的所有子进程，将新的父亲设置为子进程的父亲。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">forget_original_parent</span><span class="params">(<span class="keyword">struct</span> task_struct *father)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, *<span class="title">n</span>, *<span class="title">reaper</span>;</span></span><br><span class="line">    LIST_HEAD(dead_children);</span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note that exit_ptrace() and find_new_reaper() might</span></span><br><span class="line"><span class="comment">     * drop tasklist_lock and reacquire it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    exit_ptrace(father);</span><br><span class="line">    reaper = find_new_reaper(father);</span><br><span class="line">    list_for_each_entry_safe(p, n, &amp;father-&gt;children, sibling) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span> =</span> p;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            t-&gt;real_parent = reaper;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;parent == father) &#123;</span><br><span class="line">                BUG_ON(t-&gt;ptrace);</span><br><span class="line">                t-&gt;parent = t-&gt;real_parent;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">/*内核提供了机制，允许父进程退出时向子进程发送信号*/</span></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;pdeath_signal)</span><br><span class="line">                group_send_sig_info(t-&gt;pdeath_signal,</span><br><span class="line">                       SEND_SIG_NOINFO, t);</span><br><span class="line">        &#125; while_each_thread(p, t);</span><br><span class="line">        reparent_leader(father, p, &amp;dead_children);</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    BUG_ON(!list_empty(&amp;father-&gt;children));</span><br><span class="line">    list_for_each_entry_safe(p, n, &amp;dead_children, sibling) &#123;</span><br><span class="line">        list_del_init(&amp;p-&gt;sibling);</span><br><span class="line">        release_task(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分代码比较容易引起困扰的是下面这行，我们都知道，子进程“死”的时候，会向父进程发送信号SIGCHLD，Linux也提供了一种机制，允许父进程“死”的时候向子进程发送信号。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;pdeath_signal)</span><br><span class="line">    group_send_sig_info(t-&gt;pdeath_signal,</span><br><span class="line">           SEND_SIG_NOINFO, t);</span><br></pre></td></tr></table></figure></div>

<p>读者可以通过man prctl，查看<code>PR_SET_PDEATHSIG</code>标志位部分。如果应用程序通过prctl函数设置了父进程“死”时要向子进程发送信号，就会执行到这部分内核代码，以通知其子进程。</p>
<p>接下来是第二桩未了的心愿：想办法通知父进程为自己“收尸”。对于单线程的程序来说完成这桩心愿比较简单，但是多线程的情况就复杂些。只有线程组的主线程才有资格通知父进程，线程组的其他线程终止的时候，不需要通知父进程，也没必要保留最后的资源并陷入僵尸态，直接调用release_task函数释放所有资源就好。为什么要这样设计？细细想来，这么做是合理的。父进程创建子进程时，只有子进程的主线程是父进程亲自创建出来的，是父进程的亲生儿子，父进程也只关心它，至于子进程调用pthread_create产生的其他线程，父进程压根就不关心。</p>
<p>由于父进程只认子进程的主线程，所以在线程组中，主线程一定要挺住。在用户层面，可以调用pthread_exit让主线程先“死”，但是在内核态中，主线程的task_struct一定要挺住，哪怕变成僵尸，也不能释放资源。生命在于“折腾”，如果主线程率先退出了，而其他线程还在正常工作，内核又将如何处理？</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (thread_group_leader(tsk)) &#123;</span><br><span class="line">   <span class="comment">/*线程组组长只有在全部线程都已退出的情况下，</span></span><br><span class="line"><span class="comment">    *才能调用do_notify_parent通知父进程*/</span></span><br><span class="line">    autoreap = thread_group_empty(tsk) &amp;&amp;</span><br><span class="line">    do_notify_parent(tsk, tsk-&gt;exit_signal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*如果是线程组的非组长线程，可以立即调用release_task，</span></span><br><span class="line"><span class="comment">    *释放残余的资源，因为通知父进程这件事和它没有关系*/</span></span><br><span class="line">    autoreap = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码给出了答案，如果退出的进程是线程组的主线程，但是线程组中还有其他线程尚未终止（thread_group_empty函数返回false），那么autoreaper就等于false，也就不会调用do_notify_parent向父进程发送信号了。因为子进程的线程组中有其他线程还活着，因此子进程的主线程退出时不能通知父进程，错过了调用do_notify_parent的机会，那么父进程如何才能知晓子进程已经退出了呢？答案会在最后一个线程退出时揭晓。此答案就藏在内核的release_task函数中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leader = p-&gt;group_leader;</span><br><span class="line"><span class="keyword">if</span> (leader != p &amp;&amp; thread_group_empty(leader) &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE) &#123;</span><br><span class="line">     zap_leader = do_notify_parent(leader, leader-&gt;exit_signal);</span><br><span class="line">     <span class="keyword">if</span> (zap_leader)</span><br><span class="line">         leader-&gt;exit_state = EXIT_DEAD;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>当线程组的最后一个线程退出时，如果发现：</p>
<ul>
<li>该线程不是线程组的主线程。</li>
<li>线程组的主线程已经退出，且处于僵尸状态。</li>
<li>自己是最后一个线程。</li>
</ul>
<p>同时满足这三个条件的时候，该子进程就需要冒充线程组的组长，即以子进程的主线程的身份来通知父进程。 </p>
<p>上面讨论了一种比较少见又比较折腾的场景，正常的多线程编程应该不会如此安排。对于多线程的进程，一般情况下会等所有其他线程退出后，主线程才退出。这时，主线程会在exit_notify函数中发现自己是组长，线程组里所有成员均已退出，然后它调用do_notify_parent函数来通知父进程。无论怎样，子进程都走到了do_notify_parent函数这一步。该函数是完成父子进程之间互动的主要函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">do_notify_parent</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">psig</span>;</span></span><br><span class="line">    <span class="type">bool</span> autoreap = <span class="literal">false</span>;</span><br><span class="line">    BUG_ON(sig == <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">/* do_notify_parent_cldstop should have been called instead.  */</span></span><br><span class="line">    BUG_ON(task_is_stopped_or_traced(tsk));</span><br><span class="line">    BUG_ON(!tsk-&gt;ptrace &amp;&amp;</span><br><span class="line">            (tsk-&gt;group_leader != tsk || !thread_group_empty(tsk)));</span><br><span class="line">    <span class="keyword">if</span> (sig != SIGCHLD) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This is only possible if parent == real_parent.</span></span><br><span class="line"><span class="comment">         * Check if it has changed security domain.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (tsk-&gt;parent_exec_id != tsk-&gt;parent-&gt;self_exec_id)</span><br><span class="line">            sig = SIGCHLD;</span><br><span class="line">    &#125;</span><br><span class="line">    info.si_signo = sig;</span><br><span class="line">    info.si_errno = <span class="number">0</span>;</span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    info.si_pid = task_pid_nr_ns(tsk, tsk-&gt;parent-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">    info.si_uid = __task_cred(tsk)-&gt;uid;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    info.si_utime = <span class="type">cputime_to_clock_t</span>(cputime_add(tsk-&gt;utime,</span><br><span class="line">                tsk-&gt;signal-&gt;utime));</span><br><span class="line">    info.si_stime = <span class="type">cputime_to_clock_t</span>(cputime_add(tsk-&gt;stime,</span><br><span class="line">                tsk-&gt;signal-&gt;stime));</span><br><span class="line">    info.si_status = tsk-&gt;exit_code &amp; <span class="number">0x7f</span>;</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;exit_code &amp; <span class="number">0x80</span>)</span><br><span class="line">        info.si_code = CLD_DUMPED;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;exit_code &amp; <span class="number">0x7f</span>)</span><br><span class="line">        info.si_code = CLD_KILLED;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        info.si_code = CLD_EXITED;</span><br><span class="line">        info.si_status = tsk-&gt;exit_code &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    psig = tsk-&gt;parent-&gt;sighand;</span><br><span class="line">    spin_lock_irqsave(&amp;psig-&gt;siglock, flags);</span><br><span class="line">    <span class="keyword">if</span> (!tsk-&gt;ptrace &amp;&amp; sig == SIGCHLD &amp;&amp;</span><br><span class="line">            (psig-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_handler == SIG_IGN ||</span><br><span class="line">             (psig-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_flags &amp; SA_NOCLDWAIT))) &#123;</span><br><span class="line">        autoreap = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (psig-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_handler == SIG_IGN)</span><br><span class="line">            sig = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*子进程向父进程发送信号*/</span></span><br><span class="line">    <span class="keyword">if</span> (valid_signal(sig) &amp;&amp; sig)</span><br><span class="line">        __group_send_sig_info(sig, &amp;info, tsk-&gt;parent);</span><br><span class="line">    <span class="comment">/* 子进程尝试唤醒父进程，如果父进程正在等待其终止 */</span>__wake_up_parent(tsk, tsk-&gt;parent);</span><br><span class="line">    spin_unlock_irqrestore(&amp;psig-&gt;siglock, flags);</span><br><span class="line">    <span class="keyword">return</span> autoreap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>父子进程之间的互动有两种方式：</p>
<p><strong>子进程向父进程发送信号SIGCHLD。</strong></p>
<p>父进程可能并不知道子进程是何时退出的，如果调用wait函数等待子进程退出，又会导致父进程陷入阻塞，无法执行其他任务。那有没有一种办法，让子进程退出的时候，异步通知到父进程呢？答案是肯定的。当子进程退出时，会向父进程发送SIGCHLD信号。父进程收到该信号，默认行为是置之不理。在这种情况下，子进程就会陷入僵尸状态，而这又会浪费系统资源，该状态会维持到父进程退出，子进程被init进程接管，init进程会等待僵尸进程，使僵尸进程释放资源。如果父进程不太关心子进程的退出事件，听之任之可不是好办法，可以采取以下办法：</p>
<ul>
<li><p>父进程调用signal函数或sigaction函数，将SIGCHLD信号的处理函数设置为SIG_IGN。</p>
</li>
<li><p>父进程调用sigaction函数，设置标志位时置上SA_NOCLDWAIT位（如果不关心子进程的暂停和恢复执行，则置上SA_NOCLDSTOP位）。</p>
</li>
</ul>
<p>从内核代码来看，如果父进程的SIGCHLD的信号处理函数为SIG_IGN或sa_flags中被置上了SA_NOCLDWAIT位，子进程运行到此处时就知道了，父进程并不关心自己的退出信息，do_notify_parent函数就会返回true。在外层的exit_notify函数发现返回值是true，就会调用release_task函数，释放残余的资源，自行了断，子进程也就不会进入僵尸状态了。如果父进程关心子进程的退出，情况就不同了。父进程除了调用wait函数之外，还有了另外的选择，即注册SIGCHLD信号处理函数，在信号处理函数中处理子进程的退出事件。</p>
<p>为SIGCHLD写信号处理函数并不简单，原因是SIGCHLD是传统的不可靠信号。信号处理函数执行期间，会将引发调用的信号暂时阻塞（除非显式地指定了SA_NODEFER标志位），在这期间收到的SIGCHLD之类的传统信号，都不会排队。因此，如果在处理SIGCHLD信号时，有多个子进程退出，产生了多个SIGCHLD信号，但父进程只能收到一个。如果在信号处理函数中，只调用一次wait或waitpid，则会造成某些僵尸进程成为漏网之鱼。</p>
<p>正确的写法是，信号处理函数内，带着NOHANG标志位循环调用waitpid。如果返回值大于0，则表示不断等待子进程退出，返回0则表示，当前没有僵尸子进程，返回-1则表示出错，最大的可能就是errno等于ECHLD，表示所有子进程都已退出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(waitpid(<span class="number">-1</span>,&amp;status,WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">/*此处处理返回信息*/</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>信号处理函数中的waitpid可能会失败，从而改变全局的errno的值，当主程序检查errno时，就有可能发生冲突，所以进入信号处理函数前要现保存errno到本地变量，信号处理函数退出前，再恢复errno。</p>
<p><strong>子进程唤醒父进程</strong></p>
<p>上一种方法可以称之为信号通知。另一种情况是父进程调用wait主动等待。如果父进程调用wait陷入阻塞，那么子进程退出时，又该如何及时唤醒父进程呢？前面提到了，子进程会调用<code>__wake_up_parent</code>函数，来及时唤醒父进程。事实上，前提条件是父进程确实在等待子进程的退出。如果父进程并没有调用wait系列函数等待子进程的退出，那么，等待队列为空，子进程的<code>__wake_up_parent</code>对父进程并无任何影响。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __wake_up_parent(<span class="keyword">struct</span> task_struct *p, <span class="keyword">struct</span> task_struct *parent)</span><br><span class="line">&#123;</span><br><span class="line">    __wake_up_sync_key(&amp;parent-&gt;signal-&gt;wait_chldexit,</span><br><span class="line">            TASK_INTERRUPTIBLE, <span class="number">1</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>父进程的进程描述符的signal结构体中有wait_childexit变量，这个变量是等待队列头。父进程调用wait系列函数时，会创建一个<code>wait_opts</code>结构体，并把该结构体挂入等待队列中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_wait</span><span class="params">(<span class="keyword">struct</span> wait_opts *wo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    trace_sched_process_wait(wo-&gt;wo_pid);</span><br><span class="line">    <span class="comment">/*挂入等待队列*/</span></span><br><span class="line">    init_waitqueue_func_entry(&amp;wo-&gt;child_wait, child_wait_callback);</span><br><span class="line">    wo-&gt;child_wait.private = current;</span><br><span class="line">    add_wait_queue(&amp;current-&gt;signal-&gt;wait_chldexit, &amp;wo-&gt;child_wait);</span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    wo-&gt;notask_error = -ECHILD;</span><br><span class="line">    <span class="keyword">if</span> ((wo-&gt;wo_type &lt; PIDTYPE_MAX) &amp;&amp;</span><br><span class="line">            (!wo-&gt;wo_pid || hlist_empty(&amp;wo-&gt;wo_pid-&gt;tasks[wo-&gt;wo_type])))</span><br><span class="line">        <span class="keyword">goto</span> notask;</span><br><span class="line">    set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">    read_lock(&amp;tasklist_lock);</span><br><span class="line">    tsk = current;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        retval = do_wait_thread(wo, tsk);</span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        retval = ptrace_do_wait(wo, tsk);</span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        <span class="keyword">if</span> (wo-&gt;wo_flags &amp; __WNOTHREAD)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; while_each_thread(current, tsk);</span><br><span class="line">    read_unlock(&amp;tasklist_lock);</span><br><span class="line"><span class="comment">/*找了一圈，没有找到满足等待条件的的子进程，下一步的行为将取决于WNOHANG标志位</span></span><br><span class="line"><span class="comment">*如果将WNOHANG标志位置位，则表示不等了，直接退出，</span></span><br><span class="line"><span class="comment">*如果没有置位，则让出CPU，醒来后继续再找一圈*/</span></span><br><span class="line">notask:</span><br><span class="line">    retval = wo-&gt;notask_error;</span><br><span class="line">    <span class="keyword">if</span> (!retval &amp;&amp; !(wo-&gt;wo_flags &amp; WNOHANG)) &#123;</span><br><span class="line">        retval = -ERESTARTSYS;</span><br><span class="line">        <span class="keyword">if</span> (!signal_pending(current)) &#123;</span><br><span class="line">            schedule();</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">end:</span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">    remove_wait_queue(&amp;current-&gt;signal-&gt;wait_chldexit, &amp;wo-&gt;child_wait);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>父进程先把自己设置成<code>TASK_INTERRUPTIBLE</code>状态，然后开始寻找满足等待条件的子进程。如果找到了，则将自己重置成<code>TASK_RUNNING</code>状态，欢乐返回；如果没找到，就要根据WNOHANG标志位来决定等不等待子进程。如果没有WNOHANG标志位，那么，父进程就会让出CPU资源，等待别人将它唤醒。回到另一头，子进程退出的时候，会调用<code>__wake_up_parent</code>，唤醒父进程，父进程醒来以后，回到repeat，再次扫描。这样做，子进程的退出就能及时通知到父进程，从而使父进程的wait系列函数可以及时返回。</p>
<h1 id="exec-族"><a href="#exec-族" class="headerlink" title="exec 族"></a>exec 族</h1><p>整个exec家族有6个函数，这些函数都是构建在execve系统调用之上的。该系统调用的作用是，将新程序加载到进程的地址空间，丢弃旧有的程序，进程的栈、数据段、堆栈等会被新程序替换。</p>
<h2 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></div>







<h1 id="（未完待续）"><a href="#（未完待续）" class="headerlink" title="（未完待续）"></a>（未完待续）</h1>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Linux环境编程与内核之进程</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2024-02-01 11:01:40</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-01-25 18:46:07
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2024/02/01/Linux环境编程与内核之进程/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/Linux-kernel/">#Linux_kernel</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/02/14/FUZZ%E4%B8%93%E9%A2%98/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">FUZZ专题</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Linux内核分析之进程</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Linux环境编程与内核之进程</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="nav-text">进程环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="nav-text">程序的开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-exit"><span class="nav-text">关于 exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-atexit"><span class="nav-text">关于 atexit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-text">动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-text">编译生成和使用动态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8D%87%E7%BA%A7"><span class="nav-text">动态升级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-text">内存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C"><span class="nav-text">内存越界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5"><span class="nav-text">内存检查</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%95%BF%E8%B7%B3%E8%BD%AC"><span class="nav-text">长跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#setjmp%E4%B8%8Elongjmp"><span class="nav-text">setjmp与longjmp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E8%B7%B3%E8%BD%AC%E6%9C%BA%E5%88%B6"><span class="nav-text">长跳转机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E8%B7%B3%E8%BD%AC%E9%99%B7%E9%98%B1"><span class="nav-text">长跳转陷阱</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-text">进程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-ID"><span class="nav-text">进程 ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%B1%82%E6%AC%A1"><span class="nav-text">进程层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-text">会话</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fork"><span class="nav-text">fork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vfork"><span class="nav-text">vfork</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Daemon%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">Daemon进程的创建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-text">进程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#exit"><span class="nav-text">_exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exit-1"><span class="nav-text">exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#return"><span class="nav-text">return</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">等待子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait"><span class="nav-text">wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#waitpid"><span class="nav-text">waitpid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%E5%80%BC"><span class="nav-text">等待状态值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#waitid"><span class="nav-text">waitid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%92%8C%E7%AD%89%E5%BE%85%E7%9A%84%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">进程退出和等待的内核实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#exec-%E6%97%8F"><span class="nav-text">exec 族</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#execve"><span class="nav-text">execve</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%EF%BC%88%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%EF%BC%89"><span class="nav-text">（未完待续）</span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        79 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>