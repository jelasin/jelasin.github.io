<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2024/01/29/linux内核分析之进程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="进程原理及系统调用参考链接-Linux中国  进程四要素 要有一段程序供该进程运行 进程专用的系统堆栈空间 进程控制块 (PCB)，具体实现是task_struct结构 有独立的存储空间  只具备前三点可称之为线程，完全没有用户地址空间的被称为内核线程，共享用户地址空间的被称为用户线程。 进程一般分为两大类：实时进程和普通进程。实时进程与普通进程的根本不同之处：如果系统中有一个实时进程且可运行，那">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核分析之进程">
<meta property="og:url" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="进程原理及系统调用参考链接-Linux中国  进程四要素 要有一段程序供该进程运行 进程专用的系统堆栈空间 进程控制块 (PCB)，具体实现是task_struct结构 有独立的存储空间  只具备前三点可称之为线程，完全没有用户地址空间的被称为内核线程，共享用户地址空间的被称为用户线程。 进程一般分为两大类：实时进程和普通进程。实时进程与普通进程的根本不同之处：如果系统中有一个实时进程且可运行，那">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/prio.jpg">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/kernel_fork.png">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/ddqandcl.webp">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/ddst.webp">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/diaoducelv.png">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/dl_sched_class.png">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/uma.png">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/numa.png">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/mpp.png">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/2120938-20210531162259502-679485193.png">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/6-1.png">
<meta property="og:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/uma.png">
<meta property="article:published_time" content="2024-01-29T14:11:49.000Z">
<meta property="article:modified_time" content="2024-03-03T03:43:05.544Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Linux_kernel进程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/prio.jpg">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            Linux内核分析之进程 -
        
        Jelasin
    </title>

    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/anime.min.js"></script>
    <h1 class="ml13">
        Jelasin
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/assets/build/styles.css">
    

    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fonts/fonts.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fonts/Satoshi/satoshi.css">
    <!--- Font Part-->
    
    
    
    


    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"5rem","h2":"4rem","h3":"2.8rem","h4":"2.5rem","h5":"2.2rem","h6":"2rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/favicon.ico">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">26</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">31</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">Linux内核分析之进程</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/touxiang.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-01-29 22:11:49</span>
        <span class="mobile">2024-01-29 22:11:49</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-03-03 11:43:05</span>
            <span class="mobile">2024-03-03 11:43:05</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/Linux-kernel/">Linux kernel</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Linux-kernel%E8%BF%9B%E7%A8%8B/">Linux_kernel进程</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <h1 id="进程原理及系统调用"><a href="#进程原理及系统调用" class="headerlink" title="进程原理及系统调用"></a>进程原理及系统调用</h1><p><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112203100#:~:text=%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%A9%E4%BD%A0%E4%BA%86%E8%A7%A3Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%201%201%E3%80%81%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%201.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%B0%83%E5%BA%A6%E5%99%A8%20%E9%80%9A%E5%B8%B8%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%8F%AF%E7%94%A8%E8%B5%84%E6%BA%90%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AA%92%E4%BB%8B%E3%80%82%20%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%9C%89%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E3%80%82%20...,%281%29O%20%281%29%E8%B0%83%E5%BA%A6%E5%99%A8%20...%204%204%E3%80%81Linux%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E8%AE%BE%E8%AE%A1%204.1%20linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%A1%86%E6%9E%B6%20" >参考链接-Linux中国 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="进程四要素"><a href="#进程四要素" class="headerlink" title="进程四要素"></a>进程四要素</h2><ul>
<li>要有一段程序供该进程运行</li>
<li>进程专用的系统堆栈空间</li>
<li>进程控制块 (PCB)，具体实现是task_struct结构</li>
<li>有独立的存储空间</li>
</ul>
<p>只具备前三点可称之为线程，完全没有用户地址空间的被称为内核线程，共享用户地址空间的被称为用户线程。</p>
<p>进程一般分为两大类：实时进程和普通进程。实时进程与普通进程的根本不同之处：如果系统中有一个实时进程且可运行，那么调度器总是会选择它，除非另有一个优先级更高的实时进程。</p>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核线程是直接由内核本身启动的进程。内核线程实际上是将内核函数委托给独立的进程，与系统中其他进程“并行”执行（实际上，也并行于内核自身的执行）。内核线程经常称之为（内核）守护进程（Daemon）。它们用于执行下列任务。</p>
<ul>
<li>周期性地将修改的内存页与页来源块设备同步（例如，使用mmap的文件映射）。</li>
<li>如果内存页很少使用，则写入交换区。</li>
<li>管理延时动作（deferred action）。</li>
<li>实现文件系统的事务日志。</li>
</ul>
<h2 id="Linux内核提供的进程API"><a href="#Linux内核提供的进程API" class="headerlink" title="Linux内核提供的进程API"></a>Linux内核提供的进程API</h2><p>其定义在<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.6.14/source/include/linux/sched.h#L76" >&#x2F;include&#x2F;linux&#x2F;sched.h <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中，下面介绍几个常用的：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING				0x0000 <span class="comment">// 可运行或可就绪状态。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE			0x0001 <span class="comment">// 浅睡眠，可中断睡眠状态。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE		0x0002 <span class="comment">// 深睡眠，不可中断睡眠状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED				0x0004 <span class="comment">// 终止状态</span></span></span><br><span class="line">define EXIT_ZOMBIE					<span class="number">0x0020</span> <span class="comment">// 僵尸状态</span></span><br></pre></td></tr></table></figure></div>

<h2 id="task-struct-结构体分析"><a href="#task-struct-结构体分析" class="headerlink" title="task_struct 结构体分析"></a>task_struct 结构体分析</h2><p><code>task_struct</code> 为进程描述符，Linux内核涉及进程和程序的所有算法都离不开这个结构体，源码在<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.6.14/source/include/linux/sched.h#L629" >&#x2F;include&#x2F;linux&#x2F;sched.h <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，其内容过多，这里挑核心成员进行讲解：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For reasons of header soup (see current_thread_info()), this</span></span><br><span class="line"><span class="comment">	 * must be the first element of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>		<span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 就绪态: -1, 运行态: 0, 终止态: &gt;0 */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">long</span>			state;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This begins the randomizable portion of task_struct. Only</span></span><br><span class="line"><span class="comment">	 * scheduling-critical items should be added above here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	randomized_struct_fields_start</span><br><span class="line">	<span class="comment">/* 指向内核栈 */</span></span><br><span class="line">	<span class="type">void</span>				*<span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">/* 有几个进程在使用此结构体 */</span></span><br><span class="line">	<span class="type">refcount_t</span>			usage;</span><br><span class="line">	<span class="comment">/* 标记 Per task flags (PF_*), defined further below: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			flags;</span><br><span class="line">    <span class="comment">/* ptrace系统调用, 常被用于追踪调试 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ptrace;</span><br><span class="line"><span class="comment">// 条件编译，多处理器用到</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>		<span class="title">wake_entry</span>;</span></span><br><span class="line">	<span class="type">int</span>				on_cpu;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/* Current CPU: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			cpu;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			wakee_flips;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			wakee_flip_decay_ts;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">last_wakee</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * recent_used_cpu is initially set as the last CPU used by a task</span></span><br><span class="line"><span class="comment">	 * that wakes affine another task. Waker/wakee relationships can</span></span><br><span class="line"><span class="comment">	 * push tasks around a CPU where each wakeup moves to the next one.</span></span><br><span class="line"><span class="comment">	 * Tracking a recently used CPU allows a quick search for a recently</span></span><br><span class="line"><span class="comment">	 * used CPU that may be idle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>				recent_used_cpu;</span><br><span class="line">	<span class="type">int</span>				wake_cpu;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 运行队列 */</span></span><br><span class="line">	<span class="type">int</span>				on_rq;</span><br><span class="line">	<span class="comment">/* 进程调度策略和优先级 */</span></span><br><span class="line">	<span class="type">int</span>				prio; 				 <span class="comment">// 调度优先级</span></span><br><span class="line">	<span class="type">int</span>				static_prio; 		 <span class="comment">// 静态优先级</span></span><br><span class="line">	<span class="type">int</span>				normal_prio; 		 <span class="comment">// 正常优先级</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			rt_priority; <span class="comment">// 实时优先级</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span>	*<span class="title">sched_class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>		<span class="title">se</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>		<span class="title">rt</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span>		*<span class="title">sched_task_group</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span>		<span class="title">dl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	<span class="comment">/* Clamp values requested for a scheduling entity */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span>		<span class="title">uclamp_req</span>[<span class="title">UCLAMP_CNT</span>];</span></span><br><span class="line">	<span class="comment">/* Effective clamp values used for a scheduling entity */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span>		<span class="title">uclamp</span>[<span class="title">UCLAMP_CNT</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	<span class="comment">/* List of struct preempt_notifier: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>		<span class="title">preempt_notifiers</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			btrace_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 进程调试策略相关字段</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			policy;</span><br><span class="line">	<span class="type">int</span>				nr_cpus_allowed;</span><br><span class="line">	<span class="type">const</span> <span class="type">cpumask_t</span>			*cpus_ptr; <span class="comment">// 允许进程在哪个cpu运行</span></span><br><span class="line">	<span class="type">cpumask_t</span>			cpus_mask;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_RCU</span></span><br><span class="line">	<span class="type">int</span>				rcu_read_lock_nesting;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">rcu_special</span>		<span class="title">rcu_read_unlock_special</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rcu_node_entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_node</span>			*<span class="title">rcu_blocked_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_PREEMPT_RCU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASKS_RCU</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			rcu_tasks_nvcsw;</span><br><span class="line">	u8				rcu_tasks_holdout;</span><br><span class="line">	u8				rcu_tasks_idx;</span><br><span class="line">	<span class="type">int</span>				rcu_tasks_idle_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rcu_tasks_holdout_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_TASKS_RCU */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>		<span class="title">sched_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">plist_node</span>		<span class="title">pushable_tasks</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>			<span class="title">pushable_dl_tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 下面两个指向内存描述符，一般指向同一个内存描述符</span></span><br><span class="line">    <span class="comment">// 内核线程 mm-&gt;null, active_mm 指向从进程借用的内存描述符（前一个进程的active_mm），</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">active_mm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-thread vma caching: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vmacache</span>			<span class="title">vmacache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SPLIT_RSS_COUNTING</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_rss_stat</span>		<span class="title">rss_stat</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 进程状态参数</span></span><br><span class="line">	<span class="type">int</span>				exit_state;</span><br><span class="line">	<span class="type">int</span>				exit_code;</span><br><span class="line">	<span class="type">int</span>				exit_signal;</span><br><span class="line">	<span class="comment">/* The signal sent when the parent dies: */</span></span><br><span class="line">	<span class="type">int</span>				pdeath_signal;</span><br><span class="line">	<span class="comment">/* JOBCTL_*, siglock protected: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			jobctl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Used for emulating ABI behavior of previous Linux versions: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			personality;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Scheduler bits, serialized by scheduler locks: */</span></span><br><span class="line">	<span class="type">unsigned</span>			sched_reset_on_fork:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>			sched_contributes_to_load:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>			sched_migrated:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>			sched_remote_wakeup:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PSI</span></span><br><span class="line">	<span class="type">unsigned</span>			sched_psi_wake_requeue:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Force alignment to the next boundary: */</span></span><br><span class="line">	<span class="type">unsigned</span>			:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unserialized, strictly &#x27;current&#x27; */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bit to tell LSMs we&#x27;re in execve(): */</span></span><br><span class="line">	<span class="type">unsigned</span>			in_execve:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>			in_iowait:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIF_RESTORE_SIGMASK</span></span><br><span class="line">	<span class="type">unsigned</span>			restore_sigmask:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="type">unsigned</span>			in_user_fault:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line">	<span class="type">unsigned</span>			brk_randomized:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* disallow userland-initiated cgroup migration */</span></span><br><span class="line">	<span class="type">unsigned</span>			no_cgroup_migration:<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* task is frozen/stopped (used by the cgroup freezer) */</span></span><br><span class="line">	<span class="type">unsigned</span>			frozen:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">	<span class="comment">/* to be used once the psi infrastructure lands upstream. */</span></span><br><span class="line">	<span class="type">unsigned</span>			use_memdelay:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			<span class="type">atomic_flags</span>; <span class="comment">/* Flags requiring atomic access. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>		<span class="title">restart_block</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">pid_t</span>				pid;  <span class="comment">// 全局的进程号</span></span><br><span class="line">	<span class="type">pid_t</span>				tgid; <span class="comment">// 全局线程组标识符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_STACKPROTECTOR</span></span><br><span class="line">	<span class="comment">/* Canary value for the -fstack-protector GCC feature: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			stack_canary;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pointers to the (original) parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment">	 * older sibling, respectively.  (p-&gt;father can be replaced with</span></span><br><span class="line"><span class="comment">	 * p-&gt;real_parent-&gt;pid)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Real parent process: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">real_parent</span>;</span> <span class="comment">// 指向真实父进程</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Recipient of SIGCHLD, wait4() reports: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">parent</span>;</span> <span class="comment">// 指向父进程，ptrace会用到</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Children/sibling form the list of natural children:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">children</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">sibling</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">group_leader</span>;</span> <span class="comment">// 指向线程组组长</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * &#x27;ptraced&#x27; is the list of tasks this task is using ptrace() on.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This includes both natural children and PTRACE_ATTACH targets.</span></span><br><span class="line"><span class="comment">	 * &#x27;ptrace_entry&#x27; is this task&#x27;s link on the p-&gt;parent-&gt;ptraced list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">ptraced</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">ptrace_entry</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PID/PID hash table linkage. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span>			*<span class="title">thread_pid</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>		<span class="title">pid_links</span>[<span class="title">PIDTYPE_MAX</span>];</span> <span class="comment">/* pid_link指向了和该task_struct结构体相关的pid结构体。</span></span><br><span class="line"><span class="comment">                                                     * 进程号 进程组标识符，全局会话标识符</span></span><br><span class="line"><span class="comment">                                                     */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">thread_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">thread_node</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>		*<span class="title">vfork_done</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CLONE_CHILD_SETTID: */</span></span><br><span class="line">	<span class="type">int</span> __user			*set_child_tid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CLONE_CHILD_CLEARTID: */</span></span><br><span class="line">	<span class="type">int</span> __user			*clear_child_tid;</span><br><span class="line"></span><br><span class="line">	u64				utime;</span><br><span class="line">	u64				stime;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_SCALED_CPUTIME</span></span><br><span class="line">	u64				utimescaled;</span><br><span class="line">	u64				stimescaled;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	u64				gtime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prev_cputime</span>		<span class="title">prev_cputime</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vtime</span>			<span class="title">vtime</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line">	<span class="type">atomic_t</span>			tick_dep_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Context switch counts: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			nvcsw;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			nivcsw;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Monotonic time in nsecs: */</span></span><br><span class="line">	u64				start_time;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Boot based time in nsecs: */</span></span><br><span class="line">	u64				start_boottime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			min_flt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			maj_flt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Empty if CONFIG_POSIX_CPUTIMERS=n */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_cputimers</span>		<span class="title">posix_cputimers</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span> <span class="comment">// 初始凭证</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span> <span class="comment">// 有效凭证</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="comment">/* Cached requested key. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>			*<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * executable name, excluding path.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">	 * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">	 * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span>				comm[TASK_COMM_LEN]; <span class="comment">// 进程名称</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>		*<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个分别是 unix 信号量和共享内存</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span>			<span class="title">sysvsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span>			<span class="title">sysvshm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			last_switch_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			last_switch_time;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Filesystem information: */</span></span><br><span class="line">    <span class="comment">/* 指向文件系统，主要是进程根目录，和工作目录 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>		*<span class="title">fs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Open file information: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>		*<span class="title">files</span>;</span> <span class="comment">// 打开文件表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Namespaces: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>			*<span class="title">nsproxy</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于信号处理</span></span><br><span class="line">	<span class="comment">/* Signal handlers: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>		*<span class="title">signal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> __<span class="title">rcu</span>		*<span class="title">sighand</span>;</span></span><br><span class="line">	<span class="type">sigset_t</span>			blocked;</span><br><span class="line">	<span class="type">sigset_t</span>			real_blocked;</span><br><span class="line">	<span class="comment">/* Restored if set_restore_sigmask() was used: */</span></span><br><span class="line">	<span class="type">sigset_t</span>			saved_sigmask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>		<span class="title">pending</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			sas_ss_sp;</span><br><span class="line">	<span class="type">size_t</span>				sas_ss_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			sas_ss_flags;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span>		*<span class="title">task_works</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUDIT</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUDITSYSCALL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span>		*<span class="title">audit_context</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>				loginuid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			sessionid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp</span>			<span class="title">seccomp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Thread group tracking: */</span></span><br><span class="line">	u64				parent_exec_id;</span><br><span class="line">	u64				self_exec_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protection against (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, mempolicy: */</span></span><br><span class="line">	<span class="type">spinlock_t</span>			alloc_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protection of the PI data structures: */</span></span><br><span class="line">	<span class="type">raw_spinlock_t</span>			pi_lock;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span>		<span class="title">wake_q</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RT_MUTEXES</span></span><br><span class="line">	<span class="comment">/* PI waiters blocked on a rt_mutex held by this task: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>		<span class="title">pi_waiters</span>;</span></span><br><span class="line">	<span class="comment">/* Updated under owner&#x27;s pi_lock and rq lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">pi_top_task</span>;</span></span><br><span class="line">	<span class="comment">/* Deadlock detection and priority inheritance handling: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex_waiter</span>		*<span class="title">pi_blocked_on</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">	<span class="comment">/* Mutex deadlock detection: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span>		*<span class="title">blocked_on</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line">	<span class="type">int</span>				non_block_count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			irq_events;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			hardirq_enable_ip;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			hardirq_disable_ip;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			hardirq_enable_event;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			hardirq_disable_event;</span><br><span class="line">	<span class="type">int</span>				hardirqs_enabled;</span><br><span class="line">	<span class="type">int</span>				hardirq_context;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			softirq_disable_ip;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			softirq_enable_ip;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			softirq_disable_event;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			softirq_enable_event;</span><br><span class="line">	<span class="type">int</span>				softirqs_enabled;</span><br><span class="line">	<span class="type">int</span>				softirq_context;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_LOCK_DEPTH			48UL</span></span><br><span class="line">	u64				curr_chain_key;</span><br><span class="line">	<span class="type">int</span>				lockdep_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			lockdep_recursion;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">held_lock</span>		<span class="title">held_locks</span>[<span class="title">MAX_LOCK_DEPTH</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UBSAN</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			in_ubsan;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Journalling filesystem info: */</span></span><br><span class="line">	<span class="type">void</span>				*journal_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stacked block device info: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_list</span>			*<span class="title">bio_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLOCK</span></span><br><span class="line">	<span class="comment">/* Stack plugging: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_plug</span>			*<span class="title">plug</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* VM state: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span>		*<span class="title">reclaim_state</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span>		*<span class="title">backing_dev_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_context</span>		*<span class="title">io_context</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span>		*<span class="title">capture_control</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Ptrace state: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			ptrace_message;</span><br><span class="line">	<span class="type">kernel_siginfo_t</span>		*last_siginfo;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_io_accounting</span>	<span class="title">ioac</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PSI</span></span><br><span class="line">	<span class="comment">/* Pressure stall state */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			psi_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASK_XACCT</span></span><br><span class="line">	<span class="comment">/* Accumulated RSS usage: */</span></span><br><span class="line">	u64				acct_rss_mem1;</span><br><span class="line">	<span class="comment">/* Accumulated virtual memory usage: */</span></span><br><span class="line">	u64				acct_vm_mem1;</span><br><span class="line">	<span class="comment">/* stime + utime since last update: */</span></span><br><span class="line">	u64				acct_timexpd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPUSETS</span></span><br><span class="line">	<span class="comment">/* Protected by -&gt;alloc_lock: */</span></span><br><span class="line">	<span class="type">nodemask_t</span>			mems_allowed;</span><br><span class="line">	<span class="comment">/* Seqence number to catch updates: */</span></span><br><span class="line">	<span class="type">seqcount_t</span>			mems_allowed_seq;</span><br><span class="line">	<span class="type">int</span>				cpuset_mem_spread_rotor;</span><br><span class="line">	<span class="type">int</span>				cpuset_slab_spread_rotor;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span>		*<span class="title">cgroups</span>;</span></span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_CPU_RESCTRL</span></span><br><span class="line">	u32				closid;</span><br><span class="line">	u32				rmid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">robust_list_head</span> __<span class="title">user</span>	*<span class="title">robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_robust_list_head</span> __<span class="title">user</span> *<span class="title">compat_robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">pi_state_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">futex_pi_state</span>		*<span class="title">pi_state_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>			<span class="title">futex_exit_mutex</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			futex_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span>	*<span class="title">perf_event_ctxp</span>[<span class="title">perf_nr_task_contexts</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>			<span class="title">perf_event_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">perf_event_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			preempt_disable_ip;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/* Protected by alloc_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span>		*<span class="title">mempolicy</span>;</span></span><br><span class="line">	<span class="type">short</span>				il_prev;</span><br><span class="line">	<span class="type">short</span>				pref_node_fork;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="type">int</span>				numa_scan_seq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			numa_scan_period;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			numa_scan_period_max;</span><br><span class="line">	<span class="type">int</span>				numa_preferred_nid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			numa_migrate_retry;</span><br><span class="line">	<span class="comment">/* Migration stamp: */</span></span><br><span class="line">	u64				node_stamp;</span><br><span class="line">	u64				last_task_numa_placement;</span><br><span class="line">	u64				last_sum_exec_runtime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span>		<span class="title">numa_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This pointer is only modified for current in syscall and</span></span><br><span class="line"><span class="comment">	 * pagefault context (and for tasks being destroyed), so it can be read</span></span><br><span class="line"><span class="comment">	 * from any of the following contexts:</span></span><br><span class="line"><span class="comment">	 *  - RCU read-side critical section</span></span><br><span class="line"><span class="comment">	 *  - current-&gt;numa_group from everywhere</span></span><br><span class="line"><span class="comment">	 *  - task&#x27;s runqueue locked, task not running</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">numa_group</span> __<span class="title">rcu</span>		*<span class="title">numa_group</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * numa_faults is an array split into four regions:</span></span><br><span class="line"><span class="comment">	 * faults_memory, faults_cpu, faults_memory_buffer, faults_cpu_buffer</span></span><br><span class="line"><span class="comment">	 * in this precise order.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * faults_memory: Exponential decaying average of faults on a per-node</span></span><br><span class="line"><span class="comment">	 * basis. Scheduling placement decisions are made based on these</span></span><br><span class="line"><span class="comment">	 * counts. The values remain static for the duration of a PTE scan.</span></span><br><span class="line"><span class="comment">	 * faults_cpu: Track the nodes the process was running on when a NUMA</span></span><br><span class="line"><span class="comment">	 * hinting fault was incurred.</span></span><br><span class="line"><span class="comment">	 * faults_memory_buffer and faults_cpu_buffer: Record faults per node</span></span><br><span class="line"><span class="comment">	 * during the current scan window. When the scan completes, the counts</span></span><br><span class="line"><span class="comment">	 * in faults_memory and faults_cpu decay and these values are copied.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			*numa_faults;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			total_numa_faults;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * numa_faults_locality tracks if faults recorded during the last</span></span><br><span class="line"><span class="comment">	 * scan window were remote/local or failed to migrate. The task scan</span></span><br><span class="line"><span class="comment">	 * period is adapted based on the locality of the faults with different</span></span><br><span class="line"><span class="comment">	 * weights depending on whether they were shared or private faults</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			numa_faults_locality[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			numa_pages_migrated;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA_BALANCING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RSEQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rseq</span> __<span class="title">user</span> *<span class="title">rseq</span>;</span></span><br><span class="line">	u32 rseq_sig;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * RmW on rseq_event_mask must be performed atomically</span></span><br><span class="line"><span class="comment">	 * with respect to preemption.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rseq_event_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tlbflush_unmap_batch</span>	<span class="title">tlb_ubc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">refcount_t</span>		rcu_users;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cache last used pipe for splice(): */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>		*<span class="title">splice_pipe</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_frag</span>		<span class="title">task_frag</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASK_DELAY_ACCT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_delay_info</span>		*<span class="title">delays</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAULT_INJECTION</span></span><br><span class="line">	<span class="type">int</span>				make_it_fail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			fail_nth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When (nr_dirtied &gt;= nr_dirtied_pause), it&#x27;s time to call</span></span><br><span class="line"><span class="comment">	 * balance_dirty_pages() for a dirty throttling pause:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>				nr_dirtied;</span><br><span class="line">	<span class="type">int</span>				nr_dirtied_pause;</span><br><span class="line">	<span class="comment">/* Start of a write-and-pause period: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			dirty_paused_when;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LATENCYTOP</span></span><br><span class="line">	<span class="type">int</span>				latency_record_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">latency_record</span>		<span class="title">latency_record</span>[<span class="title">LT_SAVECOUNT</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Time slack values; these are used to round up poll() and</span></span><br><span class="line"><span class="comment">	 * select() etc timeout values. These are in nanoseconds.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64				timer_slack_ns;</span><br><span class="line">	u64				default_timer_slack_ns;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			kasan_depth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FUNCTION_GRAPH_TRACER</span></span><br><span class="line">	<span class="comment">/* Index of current stored address in ret_stack: */</span></span><br><span class="line">	<span class="type">int</span>				curr_ret_stack;</span><br><span class="line">	<span class="type">int</span>				curr_ret_depth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stack of return addresses for return function tracing: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ret_stack</span>		*<span class="title">ret_stack</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Timestamp for last schedule: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>		ftrace_timestamp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of functions that haven&#x27;t been traced</span></span><br><span class="line"><span class="comment">	 * because of depth overrun:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span>			trace_overrun;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pause tracing: */</span></span><br><span class="line">	<span class="type">atomic_t</span>			tracing_graph_pause;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACING</span></span><br><span class="line">	<span class="comment">/* State flags for use by tracers: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			trace;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bitmask and counter of trace recursion: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			trace_recursion;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_TRACING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KCOV</span></span><br><span class="line">	<span class="comment">/* See kernel/kcov.c for more details. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Coverage collection mode enabled for this task (0 if disabled): */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			kcov_mode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Size of the kcov_area: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			kcov_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Buffer for coverage collection: */</span></span><br><span class="line">	<span class="type">void</span>				*kcov_area;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KCOV descriptor wired with this task or NULL: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kcov</span>			*<span class="title">kcov</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KCOV common handle for remote coverage collection: */</span></span><br><span class="line">	u64				kcov_handle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KCOV sequence number: */</span></span><br><span class="line">	<span class="type">int</span>				kcov_sequence;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span>		*<span class="title">memcg_in_oom</span>;</span></span><br><span class="line">	<span class="type">gfp_t</span>				memcg_oom_gfp_mask;</span><br><span class="line">	<span class="type">int</span>				memcg_oom_order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of pages to reclaim on returning to userland: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			memcg_nr_pages_over_high;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Used by memcontrol for targeted memcg charge: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span>		*<span class="title">active_memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span>		*<span class="title">throttle_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UPROBES</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uprobe_task</span>		*<span class="title">utask</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BCACHE) || defined(CONFIG_BCACHE_MODULE)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			sequential_io;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			sequential_io_avg;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			task_state_change;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span>				pagefault_disabled;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">oom_reaper_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_VMAP_STACK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span>		*<span class="title">stack_vm_area</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/* A live task holds one reference: */</span></span><br><span class="line">	<span class="type">refcount_t</span>			stack_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LIVEPATCH</span></span><br><span class="line">	<span class="type">int</span> patch_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="comment">/* Used by LSM modules for access restriction: */</span></span><br><span class="line">	<span class="type">void</span>				*security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GCC_PLUGIN_STACKLEAK</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			lowest_stack;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			prev_lowest_stack;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * New fields for task_struct should be added above here, so that</span></span><br><span class="line"><span class="comment">	 * they are included in the randomized portion of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	randomized_struct_fields_end</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CPU-specific state of this task: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span>		<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * WARNING: on x86, &#x27;thread_struct&#x27; contains a variable-sized</span></span><br><span class="line"><span class="comment">	 * structure.  It *MUST* be at the end of &#x27;task_struct&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Do not put anything below here!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>Linux 进程 分为 3 种类型 , “ 限期进程 “ , “ 实时进程 “ , “ 普通进程 “ ; 从 “ 进程优先级 “ 角度对比 , 优先级从高到低分别是 : 限期进程 &gt; 实时进程 &gt; 普通进程 ;</p>
<ul>
<li><strong>限期进程：</strong> 优先级为 -1</li>
<li><strong>实时进程：</strong>动态优先级为0-99的进程，采用实时调度算法调度。</li>
<li><strong>普通进程：</strong>动态优先级为100-139的进程，采用完全公平调度算法调度。</li>
<li><strong>nice值：</strong>是用于调整普通进程优先级的参数。范围：-20-19。</li>
</ul>
<p>一般来说优先级顺序，限期进程 &gt; 实时进程 &gt; 普通进程。</p>
<h3 id="查看进程优先级"><a href="#查看进程优先级" class="headerlink" title="查看进程优先级"></a>查看进程优先级</h3><p>执行 ps -elf 命令查看进程优先级，PRI：进程优先级，数值越小，优先级越高。（并非动态优先级）NI：nice值。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">❯ ps -elf</span><br><span class="line">F S UID          PID    PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line">4 S root           1       0  6  80   0 - 25316 -      15:12 ?        00:00:01 /sbin/init auto nopro</span><br><span class="line">1 S root           2       0  0  80   0 -     0 -      15:12 ?        00:00:00 [kthreadd]</span><br><span class="line">1 I root           3       2  0  60 -20 -     0 -      15:12 ?        00:00:00 [rcu_gp]</span><br><span class="line">1 I root           4       2  0  60 -20 -     0 -      15:12 ?        00:00:00 [rcu_par_gp]</span><br><span class="line">1 I root           5       2  0  60 -20 -     0 -      15:12 ?        00:00:00 [slub_flushwq]</span><br><span class="line">1 I root           6       2  0  60 -20 -     0 -      15:12 ?        00:00:00 [netns]</span><br><span class="line">1 I root           7       2  0  80   0 -     0 -      15:12 ?        00:00:00 [kworker/0:0-events]</span><br><span class="line">1 I root           8       2  0  60 -20 -     0 -      15:12 ?        00:00:00 [kworker/0:0H-events_</span><br><span class="line">5 I root           9       2  0  80   0 -     0 -      15:12 ?        00:00:00 [kworker/0:1-events]</span><br><span class="line">5 I root          10       2  4  80   0 -     0 -      15:12 ?        00:00:01 [kworker/u256:0-event</span><br><span class="line">1 I root          11       2  0  60 -20 -     0 -      15:12 ?        00:00:00 [mm_percpu_wq]</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>

<h3 id="进程优先级策略"><a href="#进程优先级策略" class="headerlink" title="进程优先级策略"></a>进程优先级策略</h3><ul>
<li><strong>prio</strong>（动态优先级）</li>
</ul>
<p>动态优先级，有效优先级，调度器最终使用的优先级数值，范围0-139，值越小，优先级越高。用于保存静态优先级, 是进程启动时分配的优先级, 可以通过nice和sched_setscheduler系统调用来进行修改, 否则在进程运行期间会一直保持恒定</p>
<ul>
<li><strong>static_prio</strong>（静态优先级）</li>
</ul>
<p>静态优先级，采用<code>SCHED_NORMAL</code>和<code>SCHED_BATCH</code>调度策略的进程（即普通进程）用于计算动态优先级的，范围100-139。进程的动态优先级, 这个有显示才是调度器重点考虑的进程优先级</p>
<p><code>prio = static_prio = nice + DEFAULT_PRIO = nice + 120</code>。</p>
<ul>
<li><strong>normal_prio</strong>（归一化优先级）</li>
</ul>
<p>用于计算prio的中间变量，不需要太关心。普通进程的静态优先级static_prio和调度策略计算出的优先级. 因此即使普通进程和实时进程具有相同的静态优先级, 其普通优先级也是不同的, 进程分叉(fork)时, 子进程会继承父进程的普通优先级, 可以通过normal_prio来计算(非实时进程用static_prIo计算, 实时进程用rt_priority计算)</p>
<ul>
<li><strong>rt_priority</strong>（实时优先级）</li>
</ul>
<p>实时优先级，采用<code>SCHED_FIFO</code>和<code>SCHED_RR</code>调度策略进程（即实时进程）用于计算动态优先级，范围0-99。实时优先级数值越大，得到的动态优先级数值越小，优先级越高。</p>
<p><code>prio = MAX_RT_PRIO - 1 - rt_prio = 100 - 1 - rt_priority</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/prio.jpg"
                      alt="prio"
                ></p>
<h2 id="一些进程相关系统调用"><a href="#一些进程相关系统调用" class="headerlink" title="一些进程相关系统调用"></a>一些进程相关系统调用</h2><p><code>fork(), vfork(), clone()</code> 函数实际上就是系统调用。</p>
<table>
<thead>
<tr>
<th align="left">调用</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">clone</td>
<td align="left">创建轻量级进程（也就是线程），pthread库基于此实现</td>
</tr>
<tr>
<td align="left">vfork</td>
<td align="left">父子进程共享资源，子进程先于父进程执行</td>
</tr>
<tr>
<td align="left">fork</td>
<td align="left">创建父进程的完整副本</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/kernel_fork.png"
                      alt="kernel_fork"
                ></p>
<h2 id="退出进程"><a href="#退出进程" class="headerlink" title="退出进程"></a>退出进程</h2><p><strong>正常退出</strong></p>
<ul>
<li>从main函数返回return</li>
<li>调用exit</li>
<li>调用_exit</li>
</ul>
<p><strong>异常退出</strong></p>
<ul>
<li>调用abort</li>
<li>由信号终止</li>
</ul>
<h1 id="调度器简述"><a href="#调度器简述" class="headerlink" title="调度器简述"></a>调度器简述</h1><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><ul>
<li>调度：就是按照某种调度的算法设计，从进程的就绪队列中选择进程分配CPU，主要是协调进程对CPU等相关资源的使用。</li>
<li>调度的目的：最大限度的使用CPU时间。</li>
</ul>
<p>​        Linux内核中用来安排调度进程执行的模块称为调度器（Scheduler），它可以切换进程状态（执行、睡眠、退出等）。调度器相当于CPU的管理员，主要完成两件事：</p>
<ol>
<li>选择某些就绪进程来执行</li>
<li>打断某些执行的进程让他们变为就绪态</li>
</ol>
<p>​        操作系统还负责“上下文切换”，即保存切换前的寄存器内容等进程的状态，以便稍后恢复。如果调度器支持就绪状态切换到执行状态，同时支持执行状态切换为就绪状态，就称该调度器为抢占式调度器。</p>
<h2 id="调度类结构体"><a href="#调度类结构体" class="headerlink" title="调度类结构体"></a>调度类结构体</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">/* OS中有多个调度类,按照调度优先级排成一个链表 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	<span class="type">int</span> uclamp_enabled;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 将进程加入到执行队列中,即将调度实体存放到红黑树中，并将nr_running变量+1 */</span></span><br><span class="line">	<span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="comment">/* 从执行队列删除进程,并将nr_running变量-1*/</span></span><br><span class="line">	<span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="comment">/* 放弃CPU的执行权限，实际上此函数执行先出队后入队，这种情况下它直接将调度实体存放在红黑树的最右端 */</span></span><br><span class="line">	<span class="type">void</span> (*yield_task)   (<span class="keyword">struct</span> rq *rq);</span><br><span class="line">	<span class="type">bool</span> (*yield_to_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">bool</span> preempt);</span><br><span class="line">	<span class="comment">/* 专门用于检查当前进程是否可被新进程抢占 */</span></span><br><span class="line">	<span class="type">void</span> (*check_preempt_curr)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">	<span class="comment">/* 选择下一个要运行的进程 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *(*<span class="title">pick_next_task</span>)(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line">	<span class="comment">/* 将进程加到运行队列中 */</span></span><br><span class="line">	<span class="type">void</span> (*put_prev_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line">	<span class="type">void</span> (*set_next_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">bool</span> first);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">int</span> (*balance)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> rq_flags *rf);</span><br><span class="line">	<span class="type">int</span>  (*select_task_rq)(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> task_cpu, <span class="type">int</span> sd_flag, <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">void</span> (*migrate_task_rq)(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> new_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*task_woken)(<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*set_cpus_allowed)(<span class="keyword">struct</span> task_struct *p,</span><br><span class="line">				 <span class="type">const</span> <span class="keyword">struct</span> cpumask *newmask);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*rq_online)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line">	<span class="type">void</span> (*rq_offline)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*task_tick)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> queued);</span><br><span class="line">	<span class="type">void</span> (*task_fork)(<span class="keyword">struct</span> task_struct *p);</span><br><span class="line">	<span class="type">void</span> (*task_dead)(<span class="keyword">struct</span> task_struct *p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The switched_from() call is allowed to drop rq-&gt;lock, therefore we</span></span><br><span class="line"><span class="comment">	 * cannot assume the switched_from/switched_to pair is serliazed by</span></span><br><span class="line"><span class="comment">	 * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*switched_from)(<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">	<span class="type">void</span> (*switched_to)  (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">	<span class="type">void</span> (*prio_changed) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">			      <span class="type">int</span> oldprio);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_rr_interval)</span><span class="params">(<span class="keyword">struct</span> rq *rq,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> task_struct *task)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*update_curr)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SET_GROUP		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_MOVE_GROUP		1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="type">void</span> (*task_change_group)(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> type);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="调度器分类"><a href="#调度器分类" class="headerlink" title="调度器分类"></a>调度器分类</h2><p>调度器可分为五种，对应不同的调度策略：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">stop_sched_class</span>;</span> <span class="comment">// 停机调度类</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">dl_sched_class</span>;</span>   <span class="comment">// 期限调度类 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">rt_sched_class</span>;</span>   <span class="comment">// 实时调度类</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span>;</span> <span class="comment">// 公平调度类/cfs</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">idle_sched_class</span>;</span> <span class="comment">// 空闲调度类</span></span><br></pre></td></tr></table></figure></div>

<p>这五种调度类优先级从高到低依次为：停机调度类&gt;限期调度类&gt;实时调度类&gt;公平调度类&gt;空闲调度类</p>
<ul>
<li><strong>停机调度类</strong></li>
</ul>
<p>​        优先级最高的调度类，停机进程是优先级最高的进程，可以抢占所有其他进程，其他进程不可能抢占停机进程，停机的意思是使处理器停下来，做更紧急的事情。</p>
<ul>
<li><strong>限期调度类</strong></li>
</ul>
<p>​        最早使用优先算法。使用红黑树把进程按照绝对截止限期从小到达排序，每次调度时选择绝对截止期限最小的进程。如果限期进程用完了它的运行时间，它将让出处理器，并且把它从运行队列中删除。在下一个周期开始，重新把它添加到运行队列中。</p>
<ul>
<li><strong>实时调度类</strong></li>
</ul>
<p>​        为每个调度优先级维护一个队列。SCHED_FIFO实现了一种简单的、先进先出的调度算法。它不使用时间片。处于可运行状态的SCHED_FIFO级的进程会比任何SCHED_NORMAL级的进程都先得到调度。一旦一个SCHED_FIFO级进程处于可运行状态，就会一直执行，直到它自己受阻塞或显式地释放处理器为止。 它不基于时间片，可以一直执行下去。只有更高优先级的SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO任务。如果有两个或者更多的同优先级的SCHED_FIFO级进程，它们会轮流执行，但是依然只有在它们愿意让出处理器时才会退出。只有有SCHED_FIFO级进程在执行，其他级别较低的进程就只能等待它变为不可运行后才有机会执行。</p>
<ul>
<li><strong>实时调度类</strong></li>
</ul>
<p>​          SCHED_RR与SCHED_FIFO大体相同，只是SCHED_RR级的进程在耗尽事先分配给它的时间后就不能再继续执行了。也就是说，SCHED_RR是带有时间片的SCHED_FIFO——这是一种实时轮流调度算法。                  </p>
<ul>
<li><strong>公平调度类</strong></li>
</ul>
<p>​        使用完全公平调度算法。完全公平调度算法引入虚拟运行时间的相关概念：虚拟运行时间 &#x3D; 实际运行时间 * nice0对应的权重 &#x2F; 进程的权重</p>
<ul>
<li><strong>空闲调度类</strong></li>
</ul>
<p>​        每个CPU上都有一个空闲线程，即0号线程，空闲调度类优先级别最低，当没有其他进程可以调度的时候，才会调度空闲线程。</p>
<h2 id="就绪队列结构体"><a href="#就绪队列结构体" class="headerlink" title="就绪队列结构体"></a>就绪队列结构体</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">	<span class="comment">/* runqueue lock: */</span></span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * nr_running and cpu_load should be in the same cacheline because</span></span><br><span class="line"><span class="comment">	 * remote CPUs use both these fields when doing load calculation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_running;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_numa_running;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_preferred_running;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		numa_migrate_on;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_load_update_tick;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_blocked_load_update_tick;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		has_blocked_load;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nohz_tick_stopped;</span><br><span class="line">	<span class="type">atomic_t</span> nohz_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NO_HZ_COMMON */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_load_updates;</span><br><span class="line">	u64			nr_switches;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	<span class="comment">/* Utilization clamp values based on CPU&#x27;s RUNNABLE tasks */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_rq</span>	<span class="title">uclamp</span>[<span class="title">UCLAMP_CNT</span>] ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		uclamp_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCLAMP_FLAG_IDLE 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>		<span class="title">cfs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span>		<span class="title">rt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span>		<span class="title">dl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="comment">/* list of leaf cfs_rq on this CPU: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">leaf_cfs_rq_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	*<span class="title">tmp_alone_branch</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is part of a global counter where only the total sum</span></span><br><span class="line"><span class="comment">	 * over all CPUs matters. A task can increase this counter on</span></span><br><span class="line"><span class="comment">	 * one CPU and if it got migrated afterwards it may decrease</span></span><br><span class="line"><span class="comment">	 * it on another CPU. Always updated under the runqueue lock:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_uninterruptible;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">curr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">idle</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">stop</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		next_balance;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>	*<span class="title">prev_mm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		clock_update_flags;</span><br><span class="line">	u64			clock;</span><br><span class="line">	<span class="comment">/* Ensure that all clocks are in the same cache line */</span></span><br><span class="line">	u64			clock_task ____cacheline_aligned;</span><br><span class="line">	u64			clock_pelt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		lost_idle_time;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_t</span>		nr_iowait;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMBARRIER</span></span><br><span class="line">	<span class="type">int</span> membarrier_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span>		*<span class="title">rd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> __<span class="title">rcu</span>	*<span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		cpu_capacity;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		cpu_capacity_orig;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span>	*<span class="title">balance_callback</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		idle_balance;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		misfit_task_load;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For active balancing */</span></span><br><span class="line">	<span class="type">int</span>			active_balance;</span><br><span class="line">	<span class="type">int</span>			push_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_stop_work</span>	<span class="title">active_balance_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CPU of this runqueue: */</span></span><br><span class="line">	<span class="type">int</span>			cpu;</span><br><span class="line">	<span class="type">int</span>			online;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cfs_tasks</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>	<span class="title">avg_rt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>	<span class="title">avg_dl</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_SCHED_AVG_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>	<span class="title">avg_irq</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	u64			idle_stamp;</span><br><span class="line">	u64			avg_idle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is used to determine avg_idle&#x27;s max value */</span></span><br><span class="line">	u64			max_idle_balance_cost;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_TIME_ACCOUNTING</span></span><br><span class="line">	u64			prev_irq_time;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PARAVIRT</span></span><br><span class="line">	u64			prev_steal_time;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PARAVIRT_TIME_ACCOUNTING</span></span><br><span class="line">	u64			prev_steal_time_rq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* calc_load related fields */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		calc_load_update;</span><br><span class="line">	<span class="type">long</span>			calc_load_active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHED_HRTICK</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">int</span>			hrtick_csd_pending;</span><br><span class="line">	<span class="type">call_single_data_t</span>	hrtick_csd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span>		<span class="title">hrtick_timer</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">	<span class="comment">/* latency stats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>	<span class="title">rq_sched_info</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>	rq_cpu_time;</span><br><span class="line">	<span class="comment">/* could above be rq-&gt;cfs_rq.exec_clock + rq-&gt;rt_rq.rt_runtime ? */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sys_sched_yield() stats */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		yld_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* schedule() stats */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		sched_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		sched_goidle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try_to_wake_up() stats */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		ttwu_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		ttwu_local;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_head</span>	<span class="title">wake_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_IDLE</span></span><br><span class="line">	<span class="comment">/* Must be inspected within a rcu lock section */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpuidle_state</span>	*<span class="title">idle_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>task_struct结构体中采用三个成员表示进程的优先级：prio 和 normal_prio（动态优先级）、static_prio（静态优先级）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_USER_RT_PRIO 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_RT_PRIO     MAX_USER_RT_PRIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PRIO (MAX_RT_PRIO + NICE_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_PRIO (MAX_RT_PRIO + NICE_WIDTH / 2)</span></span><br></pre></td></tr></table></figure></div>

<p>实时进程优先级从 <code>0 ~ MAX_USER_RT_PRIO-1(99)</code>，普通进程优先级从 <code>100 ~ MAX_RT_PRIO-1(139) </code></p>
<h2 id="内核调度策略"><a href="#内核调度策略" class="headerlink" title="内核调度策略"></a>内核调度策略</h2><p>Linux内核提供一些调度策略供用户应用程序来选择调度器。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_NORMAL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_BATCH 3</span></span><br><span class="line"><span class="comment">/* SCHED_ISO: reserved but not implemented yet */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_IDLE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_DEADLINE 6</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>SCHED_NORMAL：</strong>普通进程的调度策略，使task选择CFS调度器来调度运行</li>
<li><strong>SCHED_FIFO：</strong>实时进程的调度策略，先进先出调度，没有时间片，没有更高优先级的状态下，只有等待主动让出CPU（非抢占）</li>
<li><strong>SCHED_RR：</strong>实时进程的调度策略，采用时间片轮转，进程使用完时间片之后会进入优先级对应运行队列的尾部，把CPU让给同等优先级的其他进程</li>
<li><strong>SCHED_BATCH：</strong>普通进程的调度策略，批量处理，使task选择CFS调度器来调度运行</li>
<li><strong>SCHED_IDLE：</strong>普通进程的调度策略，使我们task以最低优先级选择CFS调度器来调度运行</li>
<li><strong>SCHED_DEADLINE：</strong>限期进程调度策略，使我们task选择Deadline调度器来调度运行</li>
</ul>
<blockquote>
<p>stop调度器和Deadline调度器，仅使用于内核，用户没有办法进行选择</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/ddqandcl.webp"
                      alt="ddqandcl"
                ></p>
<h2 id="调度实体"><a href="#调度实体" class="headerlink" title="调度实体"></a>调度实体</h2><p>调度器不限于调度进程, 还可以调度更大的实体, 比如实现组调度: 可用的CPUI时间首先在一半的进程组(比如, 所有进程按照所有者分组)之间分配, 接下来分配的时间再在组内进行二次分配。这种一般性要求调度器不直接操作进程, 而是处理可调度实体, 因此需要一个通用的数据结构描述这个调度实体,即seched_entity结构, 其实际上就代表了一个调度对象，可以为一个进程，也可以为一个进程组。</p>
<p>linux中针对当前可调度的实时和非实时进程, 定义了类型为seched_entity的3个调度实体</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/ddst.webp"
                      alt="ddst"
                ></p>
<h3 id="CFS调度实体-sched-entity"><a href="#CFS调度实体-sched-entity" class="headerlink" title="CFS调度实体 sched_entity"></a>CFS调度实体 sched_entity</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先需要注意的是，调度实体可能是进程和调度组两种，因此结构体中会同时包含这两类实体相关的数据。 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    *  load 表示当前调度实体的权重，这个权重决定了一个调度实体的运行优先级，对进程实体而言，</span></span><br><span class="line"><span class="comment">    *  它是由静态优先级计算得到，对应调度组而言，是组内各实体的 load 之和。</span></span><br><span class="line"><span class="comment">    *  load 和 cpu_load 两个名字取得是有歧义的，虽然都是 load，但是 cpu_load 却是表示负载</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>      <span class="title">load</span>;</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    *  红黑树的数据节点，使用该 rb_node 将当前节点挂到红黑树上面，还是内核中的老套路，</span></span><br><span class="line"><span class="comment">    *  将 rb_node 嵌入 sched_entity 结构，在操作节点时，可以通过 rb_node 反向获取到其父结构。</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>          <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  链表节点，被链接到 percpu 的 rq-&gt;cfs_tasks 上，</span></span><br><span class="line"><span class="comment">    *  在做 CPU 之间的负载均衡时，</span></span><br><span class="line"><span class="comment">    *  就会从该链表上选出 group_node 节点作为迁移进程。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">group_node</span>;</span></span><br><span class="line">    <span class="comment">// 标志位，代表当前调度实体是否在就绪队列上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>            on_rq;</span><br><span class="line">    <span class="comment">// 当前实体上次被调度执行的时间</span></span><br><span class="line">    u64             exec_start;</span><br><span class="line">    <span class="comment">// 当前实体总执行时间</span></span><br><span class="line">    u64             sum_exec_runtime;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    *  截止到上次统计，进程执行的时间，通常，</span></span><br><span class="line"><span class="comment">    *  通过 sum_exec_runtime - prev_sum_exec_runtime 来统计进程本次在 CPU 上执行了多长时间，</span></span><br><span class="line"><span class="comment">    *  以执行某些时间相关的操作 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    u64             prev_sum_exec_runtime;</span><br><span class="line">    <span class="comment">// 当前实体的虚拟时间，调度器就是通过调度实体的虚拟时间进行调度，在选择下一个待执行实体时总是选择虚拟时间最小的。</span></span><br><span class="line">    u64             vruntime;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  实体执行迁移的次数，在多核系统中，CPU 之间会经常性地执行负载均衡操作，</span></span><br><span class="line"><span class="comment">    *  因此调度实体很可能因为负载均衡而迁移到其它 CPU 的就绪队列上。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    u64             nr_migrations;</span><br><span class="line">    <span class="comment">// 进程的属性统计，需要内核配置 CONFIG_SCHEDSTATS，其统计信息包含睡眠统计、等待延迟统计、CPU迁移统计、唤醒统计等。 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_statistics</span>     <span class="title">statistics</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  由于调度实体可能是调度组，调度组中存在嵌套的调度实体，</span></span><br><span class="line"><span class="comment">    *  这个标志表示当前实体处于调度组中的深度，当不属于调度组时， depth 为 0.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span>             depth;</span><br><span class="line">    <span class="comment">// 指向父级调度实体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>     *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">// 当前调度实体属于的 cfs_rq.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>           *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  如果当前调度实体是一个调度组，那么它将拥有自己的 cfs_rq，属于该组内的所有调度实体在该 cfs_rq 上排列，</span></span><br><span class="line"><span class="comment">    *  而且当前 se 也是组内所有调度实体的 parent，子 se 存在一个指针指向 parent，</span></span><br><span class="line"><span class="comment">    *  而父级与子 se 的联系并不直接，而是通过访问 cfs_rq 来找到对应的子 se。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>           *<span class="title">my_q</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  在多核系统中，需要记录 CPU 的负载，其统计方式精确到每一个调度实体，</span></span><br><span class="line"><span class="comment">    *  而这里的 avg 成员就是用来记录当前实体对于 CPU 的负载贡献。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>        <span class="title">avg</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="RT调度实体-sched-rt-entity"><a href="#RT调度实体-sched-rt-entity" class="headerlink" title="RT调度实体 sched_rt_entity"></a>RT调度实体 sched_rt_entity</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">run_list</span>;</span>  <span class="comment">// 用于加入到优先级队列中</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			timeout; <span class="comment">// 设置时间超时</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			watchdog_stamp; <span class="comment">// 用于 记录 jiffies 的值</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			time_slice; <span class="comment">//  表示 时间片</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>			on_rq; <span class="comment">// </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>			on_list;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>		*<span class="title">back</span>;</span> <span class="comment">// 用于由上到下连接 &quot; 实时调度实体 &quot; </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>		*<span class="title">parent</span>;</span> <span class="comment">// 指向父类 &quot; 实时调度实体 &quot; </span></span><br><span class="line">	<span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span>			*<span class="title">rt_rq</span>;</span> <span class="comment">// 表示 &quot;实时调度实体&quot; 所属的 &quot;实时运行队列 &quot;</span></span><br><span class="line">	<span class="comment">/* rq &quot;owned&quot; by this entity/group: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span>			*<span class="title">my_q</span>;</span> <span class="comment">// 表示 &quot;实时调度实体&quot; 所拥有的 &quot;实时运行队列&quot; , 用于管理 &quot; 子任务 &quot; </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>

<h3 id="DL调度实体-sched-dl-entity"><a href="#DL调度实体-sched-dl-entity" class="headerlink" title="DL调度实体 sched_dl_entity"></a>DL调度实体 sched_dl_entity</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>			<span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Original scheduling parameters. Copied here from sched_attr</span></span><br><span class="line"><span class="comment">	 * during sched_setattr(), they will remain the same until</span></span><br><span class="line"><span class="comment">	 * the next sched_setattr().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64				dl_runtime;	<span class="comment">/* Maximum runtime for each instance	*/</span></span><br><span class="line">	u64				dl_deadline;	<span class="comment">/* Relative deadline of each instance	*/</span></span><br><span class="line">	u64				dl_period;	<span class="comment">/* Separation of two instances (period) */</span></span><br><span class="line">	u64				dl_bw;		<span class="comment">/* dl_runtime / dl_period		*/</span></span><br><span class="line">	u64				dl_density;	<span class="comment">/* dl_runtime / dl_deadline		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Actual scheduling parameters. Initialized with the values above,</span></span><br><span class="line"><span class="comment">	 * they are continuously updated during task execution. Note that</span></span><br><span class="line"><span class="comment">	 * the remaining runtime could be &lt; 0 in case we are in overrun.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s64				runtime;	<span class="comment">/* Remaining runtime for this instance	*/</span></span><br><span class="line">	u64				deadline;	<span class="comment">/* Absolute deadline for this instance	*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			flags;		<span class="comment">/* Specifying the scheduler behaviour	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some bool flags:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @dl_throttled tells if we exhausted the runtime. If so, the</span></span><br><span class="line"><span class="comment">	 * task has to wait for a replenishment to be performed at the</span></span><br><span class="line"><span class="comment">	 * next firing of dl_timer.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @dl_boosted tells if we are boosted due to DI. If so we are</span></span><br><span class="line"><span class="comment">	 * outside bandwidth enforcement mechanism (but only until we</span></span><br><span class="line"><span class="comment">	 * exit the critical section);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @dl_yielded tells if task gave up the CPU before consuming</span></span><br><span class="line"><span class="comment">	 * all its available runtime during the last job.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @dl_non_contending tells if the task is inactive while still</span></span><br><span class="line"><span class="comment">	 * contributing to the active utilization. In other words, it</span></span><br><span class="line"><span class="comment">	 * indicates if the inactive timer has been armed and its handler</span></span><br><span class="line"><span class="comment">	 * has not been executed yet. This flag is useful to avoid race</span></span><br><span class="line"><span class="comment">	 * conditions between the inactive timer handler and the wakeup</span></span><br><span class="line"><span class="comment">	 * code.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @dl_overrun tells if the task asked to be informed about runtime</span></span><br><span class="line"><span class="comment">	 * overruns.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			dl_throttled      : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			dl_boosted        : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			dl_yielded        : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			dl_non_contending : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			dl_overrun	  : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bandwidth enforcement timer. Each -deadline task has its</span></span><br><span class="line"><span class="comment">	 * own bandwidth to be enforced, thus we need one timer per task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span>			<span class="title">dl_timer</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Inactive timer, responsible for decreasing the active utilization</span></span><br><span class="line"><span class="comment">	 * at the &quot;0-lag time&quot;. When a -deadline task blocks, it contributes</span></span><br><span class="line"><span class="comment">	 * to GRUB&#x27;s active utilization until the &quot;0-lag time&quot;, hence a</span></span><br><span class="line"><span class="comment">	 * timer is needed to decrease the active utilization at the correct</span></span><br><span class="line"><span class="comment">	 * time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">inactive_timer</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="CFS调度类fair-sched-class"><a href="#CFS调度类fair-sched-class" class="headerlink" title="CFS调度类fair_sched_class"></a>CFS调度类fair_sched_class</h2><p>完全公平调度算法体现在对待每个进程都是公平的，让每个进程都运行一段相同的时间片，这就是基于时间片轮询调度算法。CFS定义一种新调度模型，它给cfs_rq（cfs的run queue）中的每一个进程都设置一个虚拟时钟 - virtual  runtime（vruntime），如果一个进程得以执行，随着执行时间的不断增长，其vruntime也不断增大，没有得到执行的进程vruntime将保持不变。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span> <span class="comment">// 表示该进程所属的调度器类</span></span><br></pre></td></tr></table></figure></div>

<p>CFS：完全公平调度器。实际当中，必然会有进程优先级高或进程优先级低，此时CFS调度器会引入权重，使用该权重代表进程的优先级。各个进程会按照权重的比例来分配CPU时间。</p>
<blockquote>
<p>实际运行时间 &#x3D; 调度周期 * 进程权重 &#x2F; 所有进程权重之和 </p>
<p>虚拟运行时间 &#x3D; 实际运行时间 * NICE_0_LOAD &#x2F; 进程权重 </p>
<p>假设有X和Y两个进程，X权重为1024，Y权重为2048，那么X所获得CPU时间的比例为（1024 &#x2F; （1024 + 2048））* 100%</p>
</blockquote>
<p>​        在一个调度周期里面，所有进程的虚拟运行时间都是不变的，所以在进程调度时，只需要找到虚拟运行时间最小的进程调度运行即可。Linux采用红黑树保存调度实体，按照虚拟时间从小到大存储在红黑树中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/diaoducelv.png"
                      alt="diaoducelv"
                ></p>
<p>主调度器：通过调用schedule()函数来完成进程的选择和切换。</p>
<p>周期性调度器：根据频率自动调用scheduler_tick函数，根据进程运行时间触发调度</p>
<p>上下文切换：主要做两个事情（切换地址空间、切换寄存器和栈空间）</p>
<hr>
<p>CFS调度器的Linux部分内核源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span> =</span> &#123;</span><br><span class="line">	.next			= &amp;idle_sched_class, <span class="comment">// CPU运行队列中的下一个调度类，优先级更低，为空闲调度类</span></span><br><span class="line">	.enqueue_task		= enqueue_task_fair,</span><br><span class="line">	.dequeue_task		= dequeue_task_fair,</span><br><span class="line">	.yield_task		= yield_task_fair,</span><br><span class="line">	.yield_to_task		= yield_to_task_fair,</span><br><span class="line"></span><br><span class="line">	.check_preempt_curr	= check_preempt_wakeup,</span><br><span class="line"></span><br><span class="line">	.pick_next_task		= __pick_next_task_fair,</span><br><span class="line">	.put_prev_task		= put_prev_task_fair,</span><br><span class="line">	.set_next_task          = set_next_task_fair,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	.balance		= balance_fair,</span><br><span class="line">	.select_task_rq		= select_task_rq_fair,</span><br><span class="line">	.migrate_task_rq	= migrate_task_rq_fair,</span><br><span class="line"></span><br><span class="line">	.rq_online		= rq_online_fair,</span><br><span class="line">	.rq_offline		= rq_offline_fair,</span><br><span class="line"></span><br><span class="line">	.task_dead		= task_dead_fair,</span><br><span class="line">	.set_cpus_allowed	= set_cpus_allowed_common,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	.task_tick		= task_tick_fair,</span><br><span class="line">	.task_fork		= task_fork_fair,</span><br><span class="line"></span><br><span class="line">	.prio_changed		= prio_changed_fair,</span><br><span class="line">	.switched_from		= switched_from_fair,</span><br><span class="line">	.switched_to		= switched_to_fair,</span><br><span class="line"></span><br><span class="line">	.get_rr_interval	= get_rr_interval_fair,</span><br><span class="line"></span><br><span class="line">	.update_curr		= update_curr_fair,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	.task_change_group	= task_change_group_fair,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	.uclamp_enabled		= <span class="number">1</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="CFS就绪队列cfs-rq"><a href="#CFS就绪队列cfs-rq" class="headerlink" title="CFS就绪队列cfs_rq"></a>CFS就绪队列cfs_rq</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> &#123;</span></span><br><span class="line">    <span class="comment">// 在上面的 sched_entity 结构中也存在同样的 load 成员，一个 sched_entity(se) 的 load 成员表示单个 se 的 load，</span></span><br><span class="line">    <span class="comment">// 而 cfs_rq 上的 load 表示当前 cfs_rq 上所有实体的 load 总和。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个都是对当前 cfs_rq 上实体的统计，区别在于：nr_running 只表示当前 cfs_rq 上存在的子实体，</span></span><br><span class="line">    <span class="comment">// 如果子实体是调度组，也只算一个。而 h_nr_running 的统计会递归地包含子调度组中的所有实体。</span></span><br><span class="line">    <span class="comment">// 因此可以通过比较这两者是否相等来判断当前 cfs_rq 上是否存在调度组。   </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_running, h_nr_running;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 cfs_rq 上执行的时间 </span></span><br><span class="line">    u64 exec_clock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个非常重要的成员，每个 cfs_rq 都会维护一个最小虚拟时间 min_vruntime，这个虚拟时间是一个基准值，</span></span><br><span class="line">    <span class="comment">// 每个新添加到当前队列的 se 都会被初始化为当前的 min_vruntime 附近的值，</span></span><br><span class="line">    <span class="comment">// 以保证新添加的执行实体和当前队列上已存在的实体拥有差不多的执行机会，至于执行多长时间，</span></span><br><span class="line">    <span class="comment">// 则是由对应实体的 load 决定，该 load 会决定 se-&gt;vruntime 的增长速度。  </span></span><br><span class="line">    u64 min_vruntime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cfs_rq 维护的红黑树结构，其中包含一个根节点以及最左边实体(vruntime最小的实体，对应一个进程)的指针。  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> <span class="title">tasks_timeline</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &#x27;curr&#x27; points to currently running entity on this cfs_rq.</span></span><br><span class="line"><span class="comment">     * It is set to NULL otherwise (i.e when none are currently running).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 记录当前 cfs_rq 上特殊的几个实体指针：</span></span><br><span class="line">    <span class="comment">// curr：cfs_rq 上当前正在运行的实体，如果运行的进程实体不在当前 cfs_rq 上，设置为 NULL。</span></span><br><span class="line">    <span class="comment">// 需要注意的是,在支持组调度的情况下,一个进程 se 运行,被设置为当前 cfs_rq 的 curr,</span></span><br><span class="line">    <span class="comment">// 同时其 parent 也会被设置为同级 cfs_rq 的 curr. </span></span><br><span class="line">    <span class="comment">// next：用户特别指定的需要在下一次调度中执行的进程实体，但是这并不是绝对的，</span></span><br><span class="line">    <span class="comment">// 只有在 next 指定的进程实体快要运行(但可能不是下次)的时候，因为这时候不会造成太大的不公平，</span></span><br><span class="line">    <span class="comment">// 就会运行指定的 next，也是一种临时提高优先级的做法。 </span></span><br><span class="line">    <span class="comment">// last：上次执行过的实体不应该跨越公平性原则执行，比如将 next 设置为 last，这时候就需要仔细斟酌一下了，</span></span><br><span class="line">    <span class="comment">// 也是保证公平性的一种方法。  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span>, *<span class="title">next</span>, *<span class="title">last</span>, *<span class="title">skip</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在多核 CPU 中，对当前 cfs_rq 的负载统计，该统计会精确到每个 se，自然也就会传递到 cfs_rq，</span></span><br><span class="line">    <span class="comment">// 下面的几个成员用于负载统计，目前专注于 cfs 调度的主要实现，负载均衡部分后续再进行分析。  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span> <span class="title">avg</span>;</span></span><br><span class="line">    u64 runnable_load_sum;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> runnable_load_avg;</span><br><span class="line">    <span class="type">atomic_long_t</span> removed_load_avg, removed_util_avg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="comment">// 指向 percpu rq 的指针，在不支持组调度的系统中，runqueue 上只存在一个 cfs_rq，</span></span><br><span class="line">    <span class="comment">// 可以直接结构体的地址偏移反向获取到 rq 的指针，而支持组调度的 cfs_rq 可能是 root cfs_rq 的子级 cfs_rq,</span></span><br><span class="line">    <span class="comment">// 因此需要通过一个指针获取当前 cfs_rq 所在的 rq。  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span>  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一部分是组调度中的带宽控制，在某些应用场景，比如虚拟化或者用户付费使用服务器中，需要对用户的使用带宽或者时长进行限制，</span></span><br><span class="line">    <span class="comment">// 就需要用到 cfs 调度的贷款控制，其实现原理就是在一个周期内，通过某些算法设置用户组应该运行多长时间、</span></span><br><span class="line">    <span class="comment">// 同时计算已经运行了多长时间，如果超时，就将该用户组 throttle，夺取其执行权直到下一个周期。</span></span><br><span class="line">    <span class="comment">// 同样的，cfs 的带宽控制部分我们暂时不深入讨论。 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CFS_BANDWIDTH</span></span><br><span class="line">    <span class="type">int</span> runtime_enabled;</span><br><span class="line">    <span class="type">int</span> expires_seq;</span><br><span class="line">    u64 runtime_expires;</span><br><span class="line">    s64 runtime_remaining;</span><br><span class="line"></span><br><span class="line">    u64 throttled_clock, throttled_clock_task;</span><br><span class="line">    u64 throttled_clock_task_time;</span><br><span class="line">    <span class="type">int</span> throttled, throttle_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">throttled_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_CFS_BANDWIDTH */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>cfs_rq ： 跟踪就绪队列信息以及管理就绪态调度实体，并且维护一棵按照虚拟时间排序的红黑树</p>
<p>tasks_timeline-&gt;rb_root（红黑树的根）</p>
<p>tasks_timeline-&gt;rb_leftmost（指向虚拟时间最小的结点）</p>
<h2 id="RT调度类rt-sched-class"><a href="#RT调度类rt-sched-class" class="headerlink" title="RT调度类rt_sched_class"></a>RT调度类rt_sched_class</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">rt_sched_class</span> =</span> &#123;</span><br><span class="line">    .next            = &amp;fair_sched_class,</span><br><span class="line">    .enqueue_task        = enqueue_task_rt, <span class="comment">// 将一个task放入到就绪队列头或者尾部</span></span><br><span class="line">    .dequeue_task        = dequeue_task_rt, <span class="comment">// 将一个task从就绪队列末尾</span></span><br><span class="line">    .yield_task        = yield_task_rt, <span class="comment">// 主动放弃执行</span></span><br><span class="line"></span><br><span class="line">    .check_preempt_curr    = check_preempt_curr_rt,</span><br><span class="line">	<span class="comment">// 核心调度器选择就绪队列的哪个任务将要被调度，prev是将要被调度出的任务，返回值是将要被调度的任务。</span></span><br><span class="line">    .pick_next_task        = pick_next_task_rt,</span><br><span class="line">    .put_prev_task        = put_prev_task_rt, <span class="comment">// 当一个任务将要被调度出时执行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    .select_task_rq        = select_task_rq_rt, <span class="comment">// 核心调度器给任务选定CPU，用于将任务分发到不同CPU上执行。</span></span><br><span class="line"></span><br><span class="line">    .set_cpus_allowed       = set_cpus_allowed_rt,</span><br><span class="line">    .rq_online              = rq_online_rt,</span><br><span class="line">    .rq_offline             = rq_offline_rt,</span><br><span class="line">    .post_schedule        = post_schedule_rt,</span><br><span class="line">    .task_woken        = task_woken_rt,</span><br><span class="line">    .switched_from        = switched_from_rt,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    .set_curr_task          = set_curr_task_rt, <span class="comment">// 当任务修改其调度类或修改其它任务组时，将调用这个函数。</span></span><br><span class="line">    .task_tick        = task_tick_rt, <span class="comment">// 当时钟中断出发时被调用，主要更新进程运行统计信息以及是否需要调度。</span></span><br><span class="line"></span><br><span class="line">    .get_rr_interval    = get_rr_interval_rt,</span><br><span class="line"></span><br><span class="line">    .prio_changed        = prio_changed_rt,</span><br><span class="line">    .switched_to        = switched_to_rt,</span><br><span class="line"></span><br><span class="line">    .update_curr        = update_curr_rt,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="RT就绪队列struct-rt-rq"><a href="#RT就绪队列struct-rt-rq" class="headerlink" title="RT就绪队列struct rt_rq"></a>RT就绪队列struct rt_rq</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> <span class="title">active</span>;</span> <span class="comment">// 优先级队列</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rt_nr_running;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_SMP || defined CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> curr; <span class="comment">/* highest queued rt task prio 最高实时任务的优先级 */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">        <span class="type">int</span> next; <span class="comment">/* next highest 下一个实时任务最高优先级 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; highest_prio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rt_nr_migratory;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rt_nr_total;</span><br><span class="line">    <span class="type">int</span> overloaded;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">plist_head</span> <span class="title">pushable_tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> rt_queued;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rt_throttled <span class="comment">// 当前队列的实时调度是否受限</span></span><br><span class="line">    u64 rt_time; <span class="comment">// 当前队列的累积运行时间</span></span><br><span class="line">    u64 rt_runtime; <span class="comment">// 当前队列的单个period周期内最大运行时间</span></span><br><span class="line">    <span class="comment">/* Nests inside the rq lock: */</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span> rt_runtime_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rt_nr_boosted;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="DL调度类dl-sched-class"><a href="#DL调度类dl-sched-class" class="headerlink" title="DL调度类dl_sched_class"></a>DL调度类dl_sched_class</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/dl_sched_class.png"
                      alt="dl_sched_class"
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">dl_sched_class</span> =</span> &#123;</span><br><span class="line">	.next			= &amp;rt_sched_class,</span><br><span class="line">	.enqueue_task		= enqueue_task_dl,</span><br><span class="line">	.dequeue_task		= dequeue_task_dl,</span><br><span class="line">	.yield_task		= yield_task_dl,</span><br><span class="line"></span><br><span class="line">	.check_preempt_curr	= check_preempt_curr_dl,</span><br><span class="line"></span><br><span class="line">	.pick_next_task		= pick_next_task_dl,</span><br><span class="line">	.put_prev_task		= put_prev_task_dl,</span><br><span class="line">	.set_next_task		= set_next_task_dl,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	.balance		= balance_dl,</span><br><span class="line">	.select_task_rq		= select_task_rq_dl,</span><br><span class="line">	.migrate_task_rq	= migrate_task_rq_dl,</span><br><span class="line">	.set_cpus_allowed       = set_cpus_allowed_dl,</span><br><span class="line">	.rq_online              = rq_online_dl,</span><br><span class="line">	.rq_offline             = rq_offline_dl,</span><br><span class="line">	.task_woken		= task_woken_dl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	.task_tick		= task_tick_dl,</span><br><span class="line">	.task_fork              = task_fork_dl,</span><br><span class="line"></span><br><span class="line">	.prio_changed           = prio_changed_dl,</span><br><span class="line">	.switched_from		= switched_from_dl,</span><br><span class="line">	.switched_to		= switched_to_dl,</span><br><span class="line"></span><br><span class="line">	.update_curr		= update_curr_dl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="DL就绪队列dl-rq"><a href="#DL就绪队列dl-rq" class="headerlink" title="DL就绪队列dl_rq"></a>DL就绪队列dl_rq</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span> &#123;</span></span><br><span class="line">	<span class="comment">/* runqueue is an rbtree, ordered by deadline */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">root</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		dl_nr_running;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Deadline values of the currently executing and the</span></span><br><span class="line"><span class="comment">	 * earliest ready task on this rq. Caching these facilitates</span></span><br><span class="line"><span class="comment">	 * the decision whether or not a ready but not running task</span></span><br><span class="line"><span class="comment">	 * should migrate somewhere else.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		u64		curr;</span><br><span class="line">		u64		next;</span><br><span class="line">	&#125; earliest_dl;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		dl_nr_migratory;</span><br><span class="line">	<span class="type">int</span>			overloaded;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tasks on this rq that can be pushed away. They are kept in</span></span><br><span class="line"><span class="comment">	 * an rb-tree, ordered by tasks&#x27; deadlines, with caching</span></span><br><span class="line"><span class="comment">	 * of the leftmost (earliest deadline) element.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">pushable_dl_tasks_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_bw</span>		<span class="title">dl_bw</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * &quot;Active utilization&quot; for this runqueue: increased when a</span></span><br><span class="line"><span class="comment">	 * task wakes up (becomes TASK_RUNNING) and decreased when a</span></span><br><span class="line"><span class="comment">	 * task blocks</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64			running_bw;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Utilization of the tasks &quot;assigned&quot; to this runqueue (including</span></span><br><span class="line"><span class="comment">	 * the tasks that are in runqueue and the tasks that executed on this</span></span><br><span class="line"><span class="comment">	 * CPU and blocked). Increased when a task moves to this runqueue, and</span></span><br><span class="line"><span class="comment">	 * decreased when the task moves away (migrates, changes scheduling</span></span><br><span class="line"><span class="comment">	 * policy, or terminates).</span></span><br><span class="line"><span class="comment">	 * This is needed to compute the &quot;inactive utilization&quot; for the</span></span><br><span class="line"><span class="comment">	 * runqueue (inactive utilization = this_bw - running_bw).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64			this_bw;</span><br><span class="line">	u64			extra_bw;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Inverse of the fraction of CPU utilization that can be reclaimed</span></span><br><span class="line"><span class="comment">	 * by the GRUB algorithm.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64			bw_ratio;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p>Symmetrical  Multi-Processing，简称SMP，即对称多处理技术，是指将多CPU汇集在同一总线上，各CPU间进行内存和总线共享的技术。将同一个工作平衡地(run in  parallel)分布到多个CPU上运行，该相同任务在不同CPU上共享着相同的物理内存。在现行的SMP架构中，发展出三种模型：UMA、NUMA和MPP。下面将展开重点讲述前两种模型。</p>
<h2 id="UMA系统架构"><a href="#UMA系统架构" class="headerlink" title="UMA系统架构"></a>UMA系统架构</h2><p>SMP (Symmetric Multi  Processing),对称多处理系统内有许多紧耦合多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I&#x2F;O系统等，操作系统或管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去解决资源争用问题。Access to RAM is serialized; this and cache coherency issues causes performance to lag slightly behind the number of additional processors in the system.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/uma.png"
                      alt="uma"
                ></p>
<p>所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU  共享相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为一致存储器访问结构 (UMA ： Uniform  Memory Access) 。对 SMP 服务器进行扩展的方式包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I&#x2F;O(  槽口数与总线数 ) 以及添加更多的外部设备 ( 通常是磁盘存储 ) 。</p>
<p>SMP  服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I&#x2F;O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP  服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP  服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU  数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU  利用率最好的情况是 2 至 4 个 CPU 。</p>
<h2 id="NUMA系统架构"><a href="#NUMA系统架构" class="headerlink" title="NUMA系统架构"></a>NUMA系统架构</h2><p>由于 SMP 在扩展能力上的限制，人们开始探究如何进行有效地扩展从而构建大型系统的技术， NUMA(Non-Uniform Memory Access) 就是这种努力下的结果之一。利用 NUMA 技术，可以把几十个 CPU( 甚至上百个 CPU) 组合在一个服务器内。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/numa.png"
                      alt="numa"
                ></p>
<p>NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I&#x2F;O 槽口等。由于其节点之间可以通过互联模块 ( 如称为 Crossbar Switch)  进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 ( 这是 NUMA 系统与 MPP 系统的重要差别 )  。显然，访问本地内存的速度将远远高于访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA  的由来。由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的信息交互。</p>
<p>利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持上百个 CPU 。比较典型的 NUMA 服务器的例子包括 HP 的 Superdome 、 SUN15K 、 IBMp690 等。</p>
<p>但 NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。如 HP 公司发布  Superdome 服务器时，曾公布了它与 HP 其它 UNIX 服务器的相对性能值，结果发现， 64 路 CPU 的 Superdome  (NUMA 结构 ) 的相对性能值是 20 ，而 8 路 N4000( 共享的 SMP 结构 ) 的相对性能值是 6.3 。从这个结果可以看到， 8 倍数量的 CPU 换来的只是 3 倍性能的提升。</p>
<h2 id="MPP系统架构"><a href="#MPP系统架构" class="headerlink" title="MPP系统架构"></a>MPP系统架构</h2><p>和 NUMA 不同， MPP 提供了另外一种进行系统扩展的方式，它由多个 SMP  服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 ( 每个  SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 ( 内存、存储等 ) ，是一种完全无共享 (Share  Nothing) 结构，因而扩展能力最好，理论上其扩展无限制，目前的技术可实现 512 个节点互联，数千个 CPU  。目前业界对节点互联网络暂无标准，如 NCR 的 Bynet ， IBM 的 SPSwitch  ，它们都采用了不同的内部实现机制。但节点互联网仅供 MPP 服务器内部使用，对用户而言是透明的。</p>
<p>在 MPP 系统中，每个 SMP 节点也可以运行自己的操作系统、数据库等。但和 NUMA  不同的是，它不存在异地内存访问的问题。换言之，每个节点内的 CPU  不能访问另一个节点的内存。节点之间的信息交互是通过节点互联网络实现的，这个过程一般称为数据重分配 (Data Redistribution) 。</p>
<p>但是 MPP 服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。目前一些基于 MPP 技术的服务器往往通过系统级软件 ( 如数据库 ) 来屏蔽这种复杂性。举例来说， NCR 的 Teradata 就是基于 MPP  技术的一个关系数据库软件，基于此数据库来开发应用时，不管后台服务器由多少个节点组成，开发人员所面对的都是同一个数据库系统，而不需要考虑如何调度其中某几个节点的负载。</p>
<p>MPP (Massively Parallel  Processing)，大规模并行处理系统，这样的系统是由许多松耦合的处理单元组成的，要注意的是这里指的是处理单元而不是处理器。每个单元内的CPU都有自己私有的资源，如总线，内存，硬盘等。在每个单元内都有操作系统和管理数据库的实例复本。这种结构最大的特点在于不共享资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/mpp.png"
                      alt="mpp"
                ></p>
<h1 id="RCU-机制"><a href="#RCU-机制" class="headerlink" title="RCU 机制"></a>RCU 机制</h1><p>Read-copy update (RCU) 是一种 2002 年 10 月被引入到内核当中的同步机制。通过允许在更新的同时读数据，RCU 提高了同步机制的可伸缩性（scalability）。相对于传统的在并发线程间不区分是读者还是写者的简单互斥性锁机制，或者是哪些允许并发读但同时不 允许写的读写锁，RCU 支持同时一个更新线程和多个读线程的并发。RCU  通过保存对象的多个副本来保障读操作的连续性，并保证在预定的读方临界区没有完成之前不会释放这个对象。RCU定义并使用高效、可伸缩的机制来发布并读取 对象的新版本，并延长旧版本们的寿命。这些机制将工作分发到了读和更新路径上，以保证读路径可以极快地运行。在某些场合（非抢占内核），RCU  的读方没有任何性能负担。</p>
<blockquote>
<p>Linux内核源码当中,关于RCU的文档比较齐全，你可以在 <code>Documentation/RCU/</code>  目录下找到这些文件。Paul E. McKenney  是内核中RCU源码的主要实现者，他也写了很多RCU方面的文章。他把这些文章和一些关于RCU的论文的链接整理到了一起：<a class="link"   target="_blank" rel="noopener" href="http://www2.rdrop.com/users/paulmck/RCU/" >http://www2.rdrop.com/users/paulmck/RCU/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="RCU机制解决了什么"><a href="#RCU机制解决了什么" class="headerlink" title="RCU机制解决了什么"></a>RCU机制解决了什么</h2><p>在RCU的实现过程中，我们主要解决以下问题：</p>
<p>1、在读取过程中，另外一个线程删除了一个节点。删除线程可以把这个节点从链表中移除，但它不能直接销毁这个节点，必须等到所有的读取线程读取完成以后，才进行销毁操作。RCU中把这个过程称为宽限期（Grace period）。</p>
<p>2、在读取过程中，另外一个线程插入了一个新节点，而读线程读到了这个节点，那么需要保证读到的这个节点是完整的。这里涉及到了发布-订阅机制（Publish-Subscribe Mechanism）。</p>
<p>3、保证读取链表的完整性。新增或者删除一个节点，不至于导致遍历一个链表从中间断开。但是RCU并不保证一定能读到新增的节点或者不读到要被删除的节点。</p>
<p>RCU(Read-Copy  Update)，顾名思义就是读-拷贝更新，它是基于其原理命名的。对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。那么这个“适当的时机”是怎么确定的呢？这是由内核确定的，也是我们后面讨论的重点。</p>
<h2 id="RCU-原理"><a href="#RCU-原理" class="headerlink" title="RCU 原理"></a>RCU 原理</h2><p>RCU实际上是一种改进的rwlock，读者几乎没有什么同步开销，它不需要锁，不使用原子指令，而且在除alpha的所有架构上也不需要内存栅（Memory  Barrier），因此不会导致锁竞争，内存延迟以及流水线停滞。不需要锁也使得使用更容易，因为死锁问题就不需要考虑了。写者的同步开销比较大，它需要延迟数据结构的释放，复制被修改的数据结构，它也必须使用某种锁机制同步并行的其它写者的修改操作。</p>
<p>读者必须提供一个信号给写者以便写者能够确定数据可以被安全地释放或修改的时机。有一个专门的垃圾收集器来探测读者的信号，一旦所有的读者都已经发送信号告知它们都不在使用被RCU保护的数据结构，垃圾收集器就调用回调函数完成最后的数据释放或修改操作。</p>
<p>RCU 既允许多个读者同时访问被保护的数据，又允许多个读者和多个写者同时访问被保护的数据（注意：是否可以有多个写者并行访问取决于写者之间使用的同步机制），读者没有任何同步开销，而写者的同步开销则取决于使用的写者间同步机制。</p>
<p>读者在访问被RCU保护的共享数据期间不能被阻塞，这是RCU机制得以实现的一个基本前提，也就说当读者在引用被RCU保护的共享数据期间，读者所在的CPU不能发生上下文切换。写者在访问被RCU保护的共享数据时不需要和读者竞争任何锁，只有在有多于一个写者的情况下需要获得某种锁以与其他写者同步。</p>
<h2 id="RCU-核心-API"><a href="#RCU-核心-API" class="headerlink" title="RCU 核心 API"></a>RCU 核心 API</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock()</span><br><span class="line">rcu_read_unlock()</span><br><span class="line"></span><br><span class="line">synchronize_rcu()</span><br><span class="line"></span><br><span class="line">rcu_assign_pointer()</span><br><span class="line">rcu_dereference()</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>rcu_read_lock()</code>和<code>rcu_read_unlock()</code>用来保持一个读者的RCU临界区.在该临界区内不允许发生上下文切换。</p>
<p>为什么不能发生切换呢？因为内核要根据“是否发生过切换”来判断读者是否已结束读操作，我们后面再分析。</p>
<p>而下列的函数用于实现内存屏障的作用。</p>
<ul>
<li><code>rcu_dereference()</code>：读者调用它来获得一个被RCU保护的指针。</li>
<li><code>rcu_assign_pointer()</code>：写者使用该函数来为被RCU保护的指针分配一个新的值。</li>
</ul>
<p>注意，<code>synchronize_rcu()</code>：这是RCU的核心所在，它挂起写者，等待读者都退出后释放老的数据。</p>
<h3 id="增加链表项"><a href="#增加链表项" class="headerlink" title="增加链表项"></a>增加链表项</h3><p>Linux kernel 中利用 RCU 往链表增加项的源码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_next_rcu(list)     (*((struct list_head __rcu **)(&amp;(list)-&gt;next)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add_rcu(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">                <span class="keyword">struct</span> list_head *prev, <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">        new-&gt;next = next;</span><br><span class="line">        new-&gt;prev = prev;</span><br><span class="line">        rcu_assign_pointer(list_next_rcu(prev), new);</span><br><span class="line">        next-&gt;prev = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>list_next_rcu() </code>函数中的 rcu 是一个供代码分析工具 Sparse 使用的编译选项，规定有 rcu   标签的指针不能直接使用，而需要使用 <code>rcu_dereference() </code>返回一个受 RCU   保护的指针才能使用。<code>rcu_dereference() </code>接口的相关知识会在后文介绍，这一节重点关注 <code>rcu_assign_pointer() </code> 接口。首先看一下 <code>rcu_assign_pointer() </code>的源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __rcu_assign_pointer(p, v, space) \</span></span><br><span class="line"><span class="meta">    (&#123; \</span></span><br><span class="line"><span class="meta">        smp_wmb(); \</span></span><br><span class="line"><span class="meta">        (p) = (typeof(*v) __force space *)(v); \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码的最终效果是把 v 的值赋值给 p，关键点在于第 3 行的内存屏障。什么是内存屏障（Memory Barrier）呢？CPU 采用流水线技术执行指令时，只保证有内存依赖关系的指令的执行顺序，例如 p &#x3D; v; a &#x3D; *p;，由于第 2 条指令访问的指针 p   所指向的内存依赖于第 1 条指令，因此 CPU 会保证第 1 条指令在第 2 条指令执行前执行完毕。但对于没有内存依赖的指令，例如上述   <code>__list_add_rcu() </code>接口中，假如把第 8 行写成 <code>prev-&gt;next = new;</code>，由于这个赋值操作并没涉及到对 new  指针指向的内存的访问，因此认为不依赖于 6,7 行对 <code>new-&gt;next</code> 和 <code>new-&gt;prev</code> 的赋值，CPU   有可能实际运行时会先执行 <code>prev-&gt;next = new;</code> 再执行 <code>new-&gt;prev = prev;</code>，这就会造成 new   指针（也就是新加入的链表项）还没完成初始化就被加入了链表中，假如这时刚好有一个读者刚好遍历访问到了该新的链表项（因为 RCU   的一个重要特点就是可随意执行读操作），就会访问到一个未完成初始化的链表项！通过设置内存屏障就能解决该问题，它保证了在内存屏障前边的指令一定会先于内存屏障后边的指令被执行。这就保证了被加入到链表中的项，一定是已经完成了初始化的。</p>
<p>最后提醒一下，这里要注意的是，如果可能存在多个线程同时执行添加链表项的操作，添加链表项的操作需要用其他同步机制（如 spin_lock 等）进行保护。</p>
<h3 id="访问链表项"><a href="#访问链表项" class="headerlink" title="访问链表项"></a>访问链表项</h3><p>Linux kernel 中访问 RCU 链表项常见的代码模式是：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock();</span><br><span class="line">list_for_each_entry_rcu(pos, head, member) &#123;</span><br><span class="line">    <span class="comment">// do something with `pos`</span></span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br></pre></td></tr></table></figure></div>

<p>这里要讲到的 <code>rcu_read_lock()</code> 和 <code>rcu_read_unlock()</code>，是 RCU “随意读”   的关键，它们的效果是声明了一个读端的临界区（read-side critical   sections）。在说读端临界区之前，我们先看看读取链表项的宏函数   list_for_each_entry_rcu。追溯源码，获取一个链表项指针主要调用的是一个名为 <code>rcu_dereference()</code>  的宏函数，而这个宏函数的主要实现如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __rcu_dereference_check(p, c, space) \</span></span><br><span class="line"><span class="meta">    (&#123; \</span></span><br><span class="line"><span class="meta">        typeof(*p) *_________p1 = (typeof(*p)*__force )ACCESS_ONCE(p); \</span></span><br><span class="line"><span class="meta">        rcu_lockdep_assert(c, <span class="string">&quot;suspicious rcu_dereference_check()&quot;</span> \</span></span><br><span class="line"><span class="meta">                      <span class="string">&quot; usage&quot;</span>); \</span></span><br><span class="line"><span class="meta">        rcu_dereference_sparse(p, space); \</span></span><br><span class="line"><span class="meta">        smp_read_barrier_depends(); \</span></span><br><span class="line"><span class="meta">        ((typeof(*p) __force __kernel *)(_________p1)); \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"><span class="comment">// 第 3 行：声明指针 _p1 = p;</span></span><br><span class="line"><span class="comment">// 第 7 行：smp_read_barrier_depends();</span></span><br><span class="line"><span class="comment">// 第 8 行：返回 _p1;</span></span><br></pre></td></tr></table></figure></div>

<p>上述两块代码，实际上可以看作这样一种模式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock();</span><br><span class="line">p1 = rcu_dereference(p);</span><br><span class="line"><span class="keyword">if</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// do something with p1, such as:</span></span><br><span class="line">    printk(<span class="string">&quot;%d\n&quot;</span>, p1-&gt;field);</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br></pre></td></tr></table></figure></div>

<p>根据 <code>rcu_dereference()</code> 的实现，最终效果就是把一个指针赋值给另一个，那如果把上述第 2 行的 <code>rcu_dereference()</code> 直接写成 p1 &#x3D; p 会怎样呢？在一般的处理器架构上是一点问题都没有的。但在 alpha 上，编译器的   value-speculation 优化选项据说可能会“猜测” p1 的值，然后重排指令先取值 p1-&gt;field~ 因此 Linux   kernel 中，smp_read_barrier_depends() 的实现是架构相关的，arm、x86 等架构上是空实现，alpha   上则加了内存屏障，以保证先获得 p 真正的地址再做解引用。因此上一节 “增加链表项” 中提到的 “__rcu” 编译选项强制检查是否使用   rcu_dereference() 访问受 RCU 保护的数据，实际上是为了让代码拥有更好的可移植性。</p>
<p>现在回到读端临界区的问题上来。多个读端临界区不互斥，即多个读者可同时处于读端临界区中，但一块内存数据一旦能够在读端临界区内被获取到指针引用，这块内存块数据的释放必须等到读端临界区结束，等待读端临界区结束的 Linux kernel API   是synchronize_rcu()。读端临界区的检查是全局的，系统中有任何的代码处于读端临界区，synchronize_rcu()   都会阻塞，知道所有读端临界区结束才会返回。为了直观理解这个问题，举以下的代码实例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* `p` 指向一块受 RCU 保护的共享数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* reader */</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">p1 = rcu_dereference(p);</span><br><span class="line"><span class="keyword">if</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    printk(<span class="string">&quot;%d\n&quot;</span>, p1-&gt;field);</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free the memory */</span></span><br><span class="line">p2 = p;</span><br><span class="line"><span class="keyword">if</span> (p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    synchronize_rcu();</span><br><span class="line">    kfree(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用以下图示来表示多个读者与内存释放线程的时序关系：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/2120938-20210531162259502-679485193.png"
                      alt="img"
                ></p>
<p>上图中，每个读者的方块表示获得 p 的引用（第5行代码）到读端临界区结束的时间周期；t1 表示 p &#x3D; NULL 的时间；t2 表示   <code>synchronize_rcu()</code> 调用开始的时间；t3 表示 <code>synchronize_rcu()</code> 返回的时间。我们先看 Reader1,2,3，虽然这 3 个读者的结束时间不一样，但都在 t1 前获得了 p 地址的引用。t2 时调用 <code>synchronize_rcu()</code>，这时 Reader1 的读端临界区已结束，但 Reader2,3 还处于读端临界区，因此必须等到   Reader2,3 的读端临界区都结束，也就是 t3，t3 之后，就可以执行 kfree(p2) 释放内存。synchronize_rcu()  阻塞的这一段时间，有个名字，叫做 Grace period。而 Reader4,5,6，无论与 Grace period   的时间关系如何，由于获取引用的时间在 t1 之后，都无法获得 p 指针的引用，因此不会进入 p1 !&#x3D; NULL 的分支。</p>
<h3 id="删除链表项"><a href="#删除链表项" class="headerlink" title="删除链表项"></a>删除链表项</h3><p>知道了前边说的 Grace period，理解链表项的删除就很容易了。常见的代码模式是：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p = seach_the_entry_to_delete();</span><br><span class="line">list_del_rcu(p-&gt;<span class="built_in">list</span>);</span><br><span class="line">synchronize_rcu();</span><br><span class="line">kfree(p);</span><br><span class="line"><span class="comment">/* 其中 list_del_rcu() 的源码如下，把某一项移出链表：*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* list.h */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rculist.h */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del_rcu</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据上一节“访问链表项”的实例，假如一个读者能够从链表中获得我们正打算删除的链表项，则肯定在<code> synchronize_rcu()</code>之前进入了读端临界区，<code>synchronize_rcu()</code>就会保证读端临界区结束时才会真正释放链表项的内存，而不会释放读者正在访问的链表项。</p>
<h3 id="更新链表项"><a href="#更新链表项" class="headerlink" title="更新链表项"></a>更新链表项</h3><p>前文提到，RCU 的更新机制是 “Copy Update”，RCU 链表项的更新也是这种机制，典型代码模式是：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = search_the_entry_to_update();</span><br><span class="line">q = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">*q = *p;</span><br><span class="line">q-&gt;field = new_value;</span><br><span class="line">list_replace_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;q-&gt;<span class="built_in">list</span>);</span><br><span class="line">synchronize_rcu(); <span class="comment">// 挂起写者，等待读者全部结束</span></span><br><span class="line">kfree(p); <span class="comment">// 释放老数据</span></span><br></pre></td></tr></table></figure></div>

<p>其中第 3,4 行就是复制一份副本，并在副本上完成更新，然后调用 <code>list_replace_rcu()</code> 用新节点替换掉旧节点，最后释放旧节点内存。</p>
<p><code>list_replace_rcu()</code> 源码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_replace_rcu</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> list_head *new)</span></span><br><span class="line">&#123;</span><br><span class="line">    new-&gt;next = old-&gt;next;</span><br><span class="line">    new-&gt;prev = old-&gt;prev;</span><br><span class="line">    rcu_assign_pointer(list_next_rcu(new-&gt;prev), new);</span><br><span class="line">    new-&gt;next-&gt;prev = new;</span><br><span class="line">    old-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="内存屏障与优化屏障"><a href="#内存屏障与优化屏障" class="headerlink" title="内存屏障与优化屏障"></a>内存屏障与优化屏障</h1><p>我们都知道，带有优化的编译器，会尝试重新排序汇编指令，以提高程序的执行速度。但是，当在处理同步问题的时候，重新排序的指令应该被避免。因为重新排序可能会打乱我们之前想要的同步效果。其实，所有的同步原语都可以充当优化和内存屏障。</p>
<h2 id="优化屏障"><a href="#优化屏障" class="headerlink" title="优化屏障"></a>优化屏障</h2><p>编译器编译源代码时，会将源代码进行优化，将源代码的指令进行重排序，以适合于CPU的并行执行。然而，内核同步必须避免指令重新排序，优化屏障（Optimization barrier）避免编译器的重排序优化操作，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。</p>
<p>Linux用宏barrier实现优化屏障，gcc编译器的优化屏障宏定义列出如下（在include&#x2F;linux&#x2F;compiler-gcc.h中）：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</span><br></pre></td></tr></table></figure></div>

<p>上述定义中，“asm”表示插入了汇编语言程序，“volatile”表示阻止编译器对该值进行优化，确保变量使用了用户定义的精确地址，而不是装有同一信息的一些别名。“memory”表示指令修改了内存单元。</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>软件可通过读写屏障强制内存访问次序。读写屏障像一堵墙，所有在设置读写屏障之前发起的内存访问，必须先于在设置屏障之后发起的内存访问之前完成，确保内存访问按程序的顺序完成。</p>
<p>读写屏障通过处理器构架的特殊指令mfence（内存屏障）、lfence（读屏障）和sfence（写屏障）完成。另外，在x86-64处理器中，对硬件进行操作的汇编语言指令是“串行的”，也具有内存屏障的作用，如：对I&#x2F;O端口进行操作的所有指令、带lock前缀的指令以及写控制寄存器、系统寄存器或调试寄存器的所有指令（如：cli和sti）。</p>
<p>内存屏障可用于多处理器和单处理器系统，如果仅用于多处理器系统，就使用smp_xxx函数，在单处理器系统上，它们什么都不要。</p>
<table>
<thead>
<tr>
<th>内存屏障的宏定义</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>mb()</td>
<td>适用于多处理器和单处理器的内存屏障。</td>
</tr>
<tr>
<td>rmb()</td>
<td>适用于多处理器和单处理器的读内存屏障。</td>
</tr>
<tr>
<td>wmb()</td>
<td>适用于多处理器和单处理器的写内存屏障。</td>
</tr>
<tr>
<td>smp_mb()</td>
<td>适用于多处理器的内存屏障。</td>
</tr>
<tr>
<td>smp_rmb()</td>
<td>适用于多处理器的读内存屏障。</td>
</tr>
<tr>
<td>smp_wmb()</td>
<td>适用于多处理器的写内存屏障。</td>
</tr>
</tbody></table>
<p>适合于多处理器和单处理器的内存屏障宏定义列出如下（在include&#x2F;asm-x86&#x2F;system.h中）：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 指令“lock; addl $0,0(%%esp)”表示加锁，把0加到栈顶的内存单元，该指令操作本身无意义，但这些指令起到内存屏障的作用，</span></span><br><span class="line"><span class="comment"> * 让前面的  指令执行完成。具有XMM2特征的CPU已有内存屏障指令，就直接使用该指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mb() alternative(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span>, <span class="string">&quot;mfence&quot;</span>, X86_FEATURE_XMM2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rmb() alternative(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span>, <span class="string">&quot;lfence&quot;</span>, X86_FEATURE_XMM2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wmb() alternative(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span>, <span class="string">&quot;sfence&quot;</span>, X86_FEATURE_XMM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mb() asm volatile(<span class="string">&quot;mfence&quot;</span>:::<span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rmb() asm volatile(<span class="string">&quot;lfence&quot;</span>:::<span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wmb() asm volatile(<span class="string">&quot;sfence&quot;</span> ::: <span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*刷新后面的读所依赖的所有挂起读操作，在x86-64构架上不需要*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> read_barrier_depends() do &#123; &#125; while (0)</span></span><br></pre></td></tr></table></figure></div>

<p>宏定义ead_barrier_depends()刷新后面的读所依赖的所有挂起读操作，后面的读操作依赖于正处理的读操作返回的数据。在x86-64构架上不需要此宏。它表明：在此屏障之前，没有来自内存区域数据所依赖的读曾经重排序。所有的读操作处理此原语，保证在跟随此原语的任何读操作此原语之前访问内存（但不需要其他CPU的cache）。此原语在大多数CPU上有比rmb()更轻的份量。</p>
<p>本地CPU和编译器遵循内存屏障的排序限制，仅内存屏障原语保证排序，即使数据有依赖关系，也不能保证排序。例如：下面代码将强迫排序，因为*q的读操作依赖于p的读操作，并且这两个读操作被read_barrier_depends()分开。在CPU 0和CPU 1上执行的程序语句分别列出如下：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. CPU 0                                      1. CPU 1</span><br><span class="line">2. b = 2;									  2.</span><br><span class="line">3. memory_barrier();						  3.</span><br><span class="line">4. p = &amp;b;                                    4. q = p;</span><br><span class="line">                                              5. read_barrier_depends();</span><br><span class="line">                                              6. d = *q;</span><br></pre></td></tr></table></figure></div>

<p>下面的代码没有强制排序，因为在a和b的读操作之间没有依赖关系，因此，在一些CPU上，如：Alpha，y将设置为3，x设置为0。类似这种没有数据依赖关系的读操作，需要排序应使用rmb()。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. CPU 0                                      1. CPU 1</span><br><span class="line">2. a = 2;									  2.</span><br><span class="line">3. memory_barrier();						  3.</span><br><span class="line">4. b = 3;                                     4. y = b;</span><br><span class="line">                                              5. read_barrier_depends();</span><br><span class="line">                                              6. x = a;</span><br></pre></td></tr></table></figure></div>

<p>适合于多处理器的内存屏障宏定义列出如下（在include&#x2F;asm-x86&#x2F;system.h中）：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smp_mb() mb()</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_PPRO_FENCE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> smp_rmb() rmb()</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> smp_rmb() barrier()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_OOSTORE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> smp_wmb() wmb()</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> smp_wmb() barrier()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smp_read_barrier_depends() read_barrier_depends()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_mb(var, value) do &#123; (void)xchg(&amp;var, value); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smp_mb() barrier()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smp_rmb() barrier()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smp_wmb() barrier()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smp_read_barrier_depends() do &#123; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_mb(var, value) do &#123; var = value; barrier(); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>函数rdtsc_barrier用于加内存屏障阻止RDTSC猜测，当在一个定义的代码区域使用读取时间戳计数器（Read Time-Stamp  Counter，RDTSC）函数（或者函数get_cycles或vread）时，必须加内存屏障阻止RDTSC猜测。其列出如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rdtsc_barrier</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    alternative(ASM_NOP3, <span class="string">&quot;mfence&quot;</span>, X86_FEATURE_MFENCE_RDTSC);</span><br><span class="line">    alternative(ASM_NOP3, <span class="string">&quot;lfence&quot;</span>, X86_FEATURE_LFENCE_RDTSC);</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="内核内存布局"><a href="#内核内存布局" class="headerlink" title="内核内存布局"></a>内核内存布局</h1><p>具体在内存管理分析。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/6-1.png"
                      alt="6-1"
                ></p>
<h1 id="多核调度分析"><a href="#多核调度分析" class="headerlink" title="多核调度分析"></a>多核调度分析</h1><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52622200/article/details/135886010" >参考链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="多核调度"><a href="#多核调度" class="headerlink" title="多核调度"></a>多核调度</h2><p>SMP（Symmetric Multiprocessing，对称多处理）是一种常见的多核处理器架构。它将多个处理器集成到一个计算机系统中，并通过共享系统总线和内存子系统来实现处理器之间的通信。</p>
<p>首先，SMP架构将一组处理器集中在同一个计算机上。这些处理器可以是物理上独立的芯片，也可以是在同一芯片上集成的多个核心。无论是物理上独立的处理器还是集成在同一芯片上的核心，它们都可以同时工作，处理不同的任务。</p>
<p>在SMP架构中，各处理器是对等的，也就是说它们具有相同的权限和地位。每个处理器都可以独立地执行任务，并且可以访问共享的系统总线和内存子系统。这意味着不同的处理器可以同时读取和写入内存，从而实现数据的共享和协同处理。</p>
<p>通过共享系统总线和内存子系统，SMP架构实现了处理器之间的通信和协作。处理器可以通过总线发送和接收数据，从而进行协同工作。例如，一个处理器可以将计算结果存储在内存中，而另一个处理器可以读取该结果并继续后续的计算。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/uma.png"
                      alt="uma"
                ></p>
<p>根据处理器的实际物理属性，CPU可以分为超线程和多核。</p>
<ul>
<li><strong>超线程（SMT，Simultaneous  Multithreading）：</strong></li>
</ul>
<p>Linux内核分类位 <code>CONFIG_SCHED_SMT</code>，超线程是一种技术，允许单个物理处理器核心模拟出多个逻辑处理器核心。这意味着在一个物理处理器核心上可以并行执行多个线程，从而提高处理器的利用率和性能。在Linux内核中，针对超线程技术，可以使用CONFIG_SCHED_SMT进行分类和配置。</p>
<ul>
<li><strong>多核（MC，Multiple Cores）：</strong></li>
</ul>
<p>Linux内核分类位 <code>CONFIG_SCHED_MC</code>，多核处理器是指在一个集成电路芯片上集成了多个独立的物理处理器核心。每个核心都可以独立地执行任务，因此多核处理器可以同时处理多个线程或进程，从而提高系统的并行处理能力和整体性能。在Linux内核中，针对多核处理器，可以使用CONFIG_SCHED_MC进行分类和配置。</p>
<p>Linux内核对CPU管理主要是通过使用bitmap来实现，同时定义了四种状态：possible、online、active、present。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 可能状态（possible）：表示系统中存在但尚未启用的CPU。这意味着该CPU是硬件上存在的，</span></span><br><span class="line"><span class="comment">* 但由于某些原因（例如节能策略或热插拔功能），暂时没有被激活。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> __<span class="title">cpu_possible_mask</span>;</span></span><br><span class="line"><span class="comment">/* 在线状态（online）：表示CPU已经被启用并且处于可用状态。在线状态的CPU可以处理任务和线程，并参与系统的运行。*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> __<span class="title">cpu_online_mask</span>;</span></span><br><span class="line"><span class="comment">/* 活跃状态（active）：表示CPU正在执行任务或线程，即处于活动状态。这是指当前正在被利用的CPU核心。 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> __<span class="title">cpu_present_mask</span>;</span></span><br><span class="line"><span class="comment">/* 存在状态（present）：表示该CPU核心是物理上存在的，即硬件上存在该CPU核心。 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> __<span class="title">cpu_active_mask</span>;</span></span><br><span class="line"><span class="comment">// 系统上有多少个可以执行的cpu核心</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_possible_mask ((const struct cpumask *)&amp;__cpu_possible_mask)</span></span><br><span class="line"><span class="comment">// 系统上有多少个正在运行的cpu核心</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_online_mask   ((const struct cpumask *)&amp;__cpu_online_mask)</span></span><br><span class="line"><span class="comment">// 系统上有多少个具备online条件的cpu核心，有的cpu可能被热拔插</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_present_mask  ((const struct cpumask *)&amp;__cpu_present_mask)</span></span><br><span class="line"><span class="comment">// 系统上有多少个活跃的cpu核心</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_active_mask   ((const struct cpumask *)&amp;__cpu_active_mask)</span></span><br></pre></td></tr></table></figure></div>

<p>在Linux内核中，为了实现对多核处理器的调度和管理，将<strong>同一个级别的CPU核心归纳为一个调度组（scheduling group），然后将同一个级别的调度组组合成一个调度域（scheduling domain）</strong>。</p>
<p><strong>调度组</strong>是一组具有相似特性的CPU核心。比如，它们可能位于同一个物理芯片上、共享同一个高速缓存等。通过将这些核心组织在一起，内核可以更有效地进行资源分配和任务调度。调度组通常由内核自动创建，并根据硬件拓扑关系进行组织。</p>
<p><strong>调度域</strong>是一组调度组的集合，它们具有相同的调度策略和目标。调度域用于确定任务在系统中的调度范围和选择可用的CPU核心。通过将调度组组合在一起，内核可以更好地控制任务的调度和负载均衡。</p>
<p><strong>调度域</strong>的几个常见级别包括：</p>
<ol>
<li>CPU级别调度域：表示同一个物理芯片上的多个调度组。这个级别的调度域被称为cpu_domain。</li>
<li>NUMA级别调度域：表示非一致性内存访问（NUMA）架构中的不同内存节点。这个级别的调度域被称为node_domain。</li>
<li>系统级别调度域：表示整个系统中的所有调度组，也可以包括多个NUMA节点。这个级别的调度域被称为sched_domain。</li>
</ol>
<h2 id="调度域和调度组"><a href="#调度域和调度组" class="headerlink" title="调度域和调度组"></a>调度域和调度组</h2><p>调度域（scheduling domain）和调度组（scheduling group）是Linux内核中用于管理多核处理器调度的重要概念。</p>
<ol>
<li><strong>调度组：</strong>Linux内核将同一个级别的CPU核心归纳为一个调度组。调度组是一组具有相似特性的CPU核心，它们通常位于同一个物理芯片上，或者共享同一个高速缓存。通过将这些核心组织在一起，内核可以更好地进行资源分配和任务调度。每个调度组都有自己的调度队列，内核根据调度策略从不同的调度组中选择适当的CPU核心来运行任务。</li>
<li><strong>调度域：</strong>调度域是一组调度组的集合，它们具有相同的调度策略和目标。调度域用于确定任务在系统中的调度范围和选择可用的CPU核心。调度域的层次结构从低到高包括：硬件线程调度域、核调度域、处理器调度域和NUMA节点调度域。每个调度域都负责管理和调度其下一级调度域中的任务。通过将调度组组合在一起形成调度域，内核可以更好地控制任务的调度和负载均衡。</li>
</ol>
<p>通常来说，在多核处理器中，处理器拓扑结构是由多个层次结构组成的。在最底层是核心层，一个处理器可以包含多个核心，每个核心有独立的一级缓存，所有核心共享二级缓存。在核心层之上是硬件线程层，也称为虚拟处理器或逻辑处理器，一个核心可以包含多个硬件线程，这些线程共享一级缓存和二级缓存。在硬件线程层之上是处理器层，一个处理器由多个核心和硬件线程组成，处理器共享内存和I&#x2F;O资源。最高层是NUMA层，它由多个处理器组成，每个处理器可以包含多个处理器层，每个处理器层可以包含多个核心和硬件线程。</p>
<h2 id="处理器拓扑"><a href="#处理器拓扑" class="headerlink" title="处理器拓扑"></a>处理器拓扑</h2><p>处理器拓扑结构是指处理器内部各个组件之间的连接关系和层次结构。在多核处理器中，常见的两种拓扑结构是NUMA（Non-Uniform Memory Access）和SMP（Symmetric Multiprocessing）。</p>
<ol>
<li>NUMA结构：在NUMA结构中，处理器由多个物理节点组成，每个节点包含一部分处理器核心、内存和I&#x2F;O设备。不同节点之间的访问延迟和带宽不同，因此是“非均匀内存访问”结构。在NUMA结构下，任务调度算法需要考虑到任务在不同节点之间的迁移和负载均衡，以优化系统性能。</li>
<li>SMP结构：在SMP结构中，所有处理器核心都共享同一个物理地址空间，内存访问延迟和带宽相同，因此是“对称多处理”结构。在SMP结构下，任务调度算法可以采用简单的轮转或抢占式算法来实现任务的负载均衡。</li>
</ol>
<p>通常来说，在多核处理器中，处理器拓扑结构是由多个层次结构组成的。在最底层是核心层，一个处理器可以包含多个核心，每个核心有独立的一级缓存，所有核心共享二级缓存。在核心层之上是硬件线程层，也称为虚拟处理器或逻辑处理器，一个核心可以包含多个硬件线程，这些线程共享一级缓存和二级缓存。在硬件线程层之上是处理器层，一个处理器由多个核心和硬件线程组成，处理器共享内存和I&#x2F;O资源。最高层是NUMA层，它由多个处理器组成，每个处理器可以包含多个处理器层，每个处理器层可以包含多个核心和硬件线程。</p>
<p><strong>SMP系统启动流程：</strong></p>
<ol>
<li>引导处理器（BP）先完成自身的初始化，然后从start_kernel()调用smp_init()进行SMP结构初始化。</li>
<li>smp_init()的主体是 smp_prepare_cpus()，它会为每个处理器核心分配并初始化一个cpu结构体，并设置相应的标志位。</li>
<li>BP使用smp_callin_map[]表格记录每个处理器核心的状态，并向每个AP发送一个初始化IPI（Inter-Processor Interrupt），通知AP进入start_secondary()函数进行进一步初始化。</li>
<li>AP接收到IPI后，会执行trampoline.S中的一段跳板程序，在跳板程序中会将AP的状态设置为SMP_CALLIN，并调用startup_32()函数完成一些基本的初始化工作。</li>
<li>在start_secondary()函数中，AP会进行进一步的初始化，并等待全局变量smp_commenced变为1。这个变量是在BP完成所有AP的启动后被设置为1的。</li>
<li>BP调用smp_cpus_done()函数等待所有AP完成初始化，并最终调用smp_commence()函数发出起跑命令。</li>
<li>每个CPU进入cpu_idle()函数，等待调度。在这个函数中，处理器核心会处于空闲状态，并等待操作系统调度器分配任务给它。一旦有任务需要执行，处理器核心就会被唤醒并开始执行任务。</li>
</ol>
<h1 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h1><p><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58087261" >参考链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="Linux内核链表实现"><a href="#Linux内核链表实现" class="headerlink" title="Linux内核链表实现"></a>Linux内核链表实现</h2><p>单向链表和双向链表在实际使用中有一些局限性，如数据区必须是固定数据，而实际需求是多种多样的。这种方法无法构建一套通用的链表，因为每个不同的数据区需要一套链表。为此，Linux内核把所有链表操作方法的共同部分提取出来，把不同的部分留给代码编程者自己去处理。Linux内核实现了一套纯链表的封装，链表节点数据结构只有指针区而没有数据区，另外还封装了各种操作函数，如创建节点函数、插入节点函数、删除节点函数、遍历节点函数等。</p>
<p>Linux内核链表使用struct list_head数据结构来描述。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/types.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>struct list_head数据结构不包含链表节点的数据区，通常是嵌入其他数据结构，如struct page数据结构中嵌入了一个lru链表节点，通常是把page数据结构挂入LRU链表。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/mm_types.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>链表头的初始化有两种方法，一种是静态初始化，另一种动态初始化。把next和prev指针都初始化并指向自己，这样便初始化了一个带头节点的空链表。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/<span class="built_in">list</span>.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态初始化*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">    struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*动态初始化*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>添加节点到一个链表中，内核提供了几个接口函数，如list_add()是把一个节点添加到表头，list_add_tail()是插入表尾。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/<span class="built_in">list</span>.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line"><span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br></pre></td></tr></table></figure></div>

<p>遍历节点的接口函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br></pre></td></tr></table></figure></div>

<p>这个宏只是遍历一个一个节点的当前位置，那么如何获取节点本身的数据结构呢？这里还需要使用list_entry()宏。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line">container_of()宏的定义在kernel.h头文件中。</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;            \</span></span><br><span class="line"><span class="meta">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">    (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure></div>

<p>其中offsetof()宏是通过把0地址转换为type类型的指针，然后去获取该结构体中member成员的指针，也就是获取了member在type结构体中的偏移量。最后用指针ptr减去offset，就得到type结构体的真实地址了。</p>
<p>下面是遍历链表的一个例子。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;drivers/block/osdblk.c&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">class_osdblk_list</span><span class="params">(<span class="keyword">struct</span> class *c,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> class_attribute *attr,</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each(tmp, &amp;osdblkdev_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">osdblk_device</span> *<span class="title">osdev</span>;</span></span><br><span class="line"></span><br><span class="line">        osdev = list_entry(tmp, <span class="keyword">struct</span> osdblk_device, node);</span><br><span class="line"></span><br><span class="line">        n += <span class="built_in">sprintf</span>(data+n, <span class="string">&quot;%d %d %llu %llu %s\n&quot;</span>,</span><br><span class="line">            osdev-&gt;id,</span><br><span class="line">            osdev-&gt;major,</span><br><span class="line">            osdev-&gt;obj.partition,</span><br><span class="line">            osdev-&gt;obj.id,</span><br><span class="line">            osdev-&gt;osd_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><strong>红黑树</strong></h2><p>红黑树（Red Black Tree）被广泛应用在内核的内存管理和进程调度中，用于将排序的元素组织到树中。红黑树被广泛应用在计算机科学的各个领域中，它在速度和实现复杂度之间提供一个很好的平衡。</p>
<p>红黑树是具有以下特征的二叉树。</p>
<p>　每个节点或红或黑。</p>
<ul>
<li>每个叶节点是黑色的。</li>
<li>如果结点都是红色，那么两个子结点都是黑色。</li>
<li>从一个内部结点到叶结点的简单路径上，对所有叶节点来说，黑色结点的数目都是相同的。</li>
</ul>
<p>红黑树的一个优点是，所有重要的操作（例如插入、删除、搜索）都可以在<em>O</em>(log <em>n</em>)时间内完成，<em>n</em>为树中元素的数目。经典的算法教科书都会讲解红黑树的实现，这里只是列出一个内核中使用红黑树的例子，供读者在实际的驱动和内核编程中参考。这个例子可以在内核代码的documentation&#x2F;Rbtree.txt文件中找到。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rbtree.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;figo.zhang&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot; &quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytype</span> &#123;</span> </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line">     <span class="type">int</span> key; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*红黑树根节点*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mytree</span> =</span> RB_ROOT;</span><br><span class="line"><span class="comment">/*根据key来查找节点*/</span></span><br><span class="line"><span class="keyword">struct</span> mytype *<span class="title function_">my_search</span><span class="params">(<span class="keyword">struct</span> rb_root *root, <span class="type">int</span> new)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> root-&gt;rb_node;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (node) &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">mytype</span> *<span class="title">data</span> =</span> container_of(node, <span class="keyword">struct</span> mytype, node);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (data-&gt;key &gt; new)</span><br><span class="line">               node = node-&gt;rb_left;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (data-&gt;key &lt; new)</span><br><span class="line">               node = node-&gt;rb_right;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> data;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入一个元素到红黑树中*/</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">my_insert</span><span class="params">(<span class="keyword">struct</span> rb_root *root, <span class="keyword">struct</span> mytype *data)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">new</span> =</span> &amp;(root-&gt;rb_node), *parent=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 寻找可以添加新节点的地方 */</span></span><br><span class="line">     <span class="keyword">while</span> (*new) &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">mytype</span> *<span class="title">this</span> =</span> container_of(*new, <span class="keyword">struct</span> mytype, node);</span><br><span class="line"></span><br><span class="line">          parent = *new;</span><br><span class="line">          <span class="keyword">if</span> (this-&gt;key &gt; data-&gt;key)</span><br><span class="line">               new = &amp;((*new)-&gt;rb_left);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (this-&gt;key &lt; data-&gt;key) &#123;</span><br><span class="line">               new = &amp;((*new)-&gt;rb_right);</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 添加一个新节点 */</span></span><br><span class="line">     rb_link_node(&amp;data-&gt;node, parent, new);</span><br><span class="line">     rb_insert_color(&amp;data-&gt;node, root);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">mytype</span> *<span class="title">data</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/*插入元素*/</span></span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; <span class="number">20</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">          data = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mytype), GFP_KERNEL);</span><br><span class="line">          data-&gt;key = i;</span><br><span class="line">          my_insert(&amp;mytree, data);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*遍历红黑树，打印所有节点的key值*/</span></span><br><span class="line">      <span class="keyword">for</span> (node = rb_first(&amp;mytree); node; node = rb_next(node)) </span><br><span class="line">          printk(<span class="string">&quot;key=%d\n&quot;</span>, rb_entry(node, <span class="keyword">struct</span> mytype, node)-&gt;key);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">mytype</span> *<span class="title">data</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span>;</span></span><br><span class="line">     <span class="keyword">for</span> (node = rb_first(&amp;mytree); node; node = rb_next(node)) &#123;</span><br><span class="line">          data = rb_entry(node, <span class="keyword">struct</span> mytype, node);</span><br><span class="line">          <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                rb_erase(&amp;data-&gt;node, &amp;mytree);</span><br><span class="line">                kfree(data);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br></pre></td></tr></table></figure></div>

<p>mytree 是红黑树的根节点，my_insert() 实现插入一个元素到红黑树中，my_search() 根据key来查找节点。内核大量使用红黑树，如虚拟地址空间 VMA 的管理。</p>
<h1 id="进程管理常用API"><a href="#进程管理常用API" class="headerlink" title="进程管理常用API"></a>进程管理常用API</h1><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/h549570564/article/details/106819598" >参考链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="struct-pid"><a href="#struct-pid" class="headerlink" title="struct pid"></a>struct pid</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span>                       <span class="comment">//指向pid_namespace的引用个数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pidmap</span> <span class="title">pidmap</span>[<span class="title">PIDMAP_ENTRIES</span>];</span>   <span class="comment">//分配pid的位图</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="type">int</span> last_pid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_hashed;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child_reaper</span>;</span>   <span class="comment">/* 托管进程，如果父进程先于子进程退出，托管进程会对孤儿进程调用wait4</span></span><br><span class="line"><span class="comment">                                         * 每个命名空间都具有的进程，发挥的作用相当于全局的init进程</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">pid_cachep</span>;</span>      <span class="comment">//分配pid的slab地址</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> level;                 <span class="comment">//当前命名空间的级别，父进程 level = n，则子进程 level = n+1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">parent</span>;</span>       <span class="comment">//父命名空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">proc_mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_self</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_thread_self</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_pin</span> *<span class="title">bacct</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">proc_work</span>;</span></span><br><span class="line">	<span class="type">kgid_t</span> pid_gid;</span><br><span class="line">	<span class="type">int</span> hide_pid;</span><br><span class="line">	<span class="type">int</span> reboot;	<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> <span class="title">ns</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pid_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PIDTYPE_PID,</span><br><span class="line">    PIDTYPE_PGID,</span><br><span class="line">    PIDTYPE_SID,</span><br><span class="line">    PIDTYPE_MAX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;                 <span class="comment">// 该pid被不同task_struct引用的次数(不同的命名空间，可以存在相同的pid)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> level;             <span class="comment">// 这个pid结构体的深度, root level = 0, root的子空间为1</span></span><br><span class="line">	<span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span>   <span class="comment">// 指向与该pid相连的task</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span>         <span class="comment">/* 变长数组, 存储upid结构, 数组大小为 level+1</span></span><br><span class="line"><span class="comment">                                     * numbers[0], numbers[1],..., numbers[level]</span></span><br><span class="line"><span class="comment">                                     * 由于同一个pid从下往上会被映射到多个 namespace 中</span></span><br><span class="line"><span class="comment">                                     * 这里会保存每一个 namespace 下的 upid 信息</span></span><br><span class="line"><span class="comment">                                     */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * struct upid is used to get the id of the struct pid, as it is</span></span><br><span class="line"><span class="comment"> * seen in particular namespace. Later the struct pid is found with</span></span><br><span class="line"><span class="comment"> * find_pid_ns() using the int nr and struct pid_namespace *ns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Try to keep pid_chain in the same cacheline as nr for find_vpid */</span></span><br><span class="line">	<span class="type">int</span> nr;                         <span class="comment">// PID具体的值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span>       <span class="comment">// 指向命名空间的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">pid_chain</span>;</span>    <span class="comment">/* pid哈希列表(pid_hash)中的节点，用于快速通过nr和ns查找到upid</span></span><br><span class="line"><span class="comment">	                                 * 在alloc_pid 时将该节点添加到哈希列表中</span></span><br><span class="line"><span class="comment">	                                 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="find-get-pid"><a href="#find-get-pid" class="headerlink" title="find_get_pid()"></a>find_get_pid()</h2><p>根据进程编号，获取进程描述符。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pid *<span class="title function_">find_get_pid</span><span class="params">(<span class="type">pid_t</span> nr)</span> <span class="comment">// nr 进程编号</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock(); <span class="comment">// RCU读加锁</span></span><br><span class="line">	pid = get_pid(find_vpid(nr)); <span class="comment">// 调用 get_pid() 增加引用计数</span></span><br><span class="line">	rcu_read_unlock();<span class="comment">// RCU读解锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(find_get_pid);</span><br></pre></td></tr></table></figure></div>

<h3 id="find-vpid"><a href="#find-vpid" class="headerlink" title="find_vpid()"></a>find_vpid()</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pid *<span class="title function_">find_vpid</span><span class="params">(<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> find_pid_ns(nr, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(find_vpid);</span><br></pre></td></tr></table></figure></div>

<h3 id="get-pid"><a href="#get-pid" class="headerlink" title="get_pid()"></a>get_pid()</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> pid *<span class="title function_">get_pid</span><span class="params">(<span class="keyword">struct</span> pid *pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pid)</span><br><span class="line">		refcount_inc(&amp;pid-&gt;count);</span><br><span class="line">	<span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="pid-task"><a href="#pid-task" class="headerlink" title="pid_task()"></a>pid_task()</h2><p>获取任务描述符相关信息。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数pid: pid类型指针，存储进程描述符相关信息</span></span><br><span class="line"><span class="comment">// 参数type: pid_type类型变量</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">pid_task</span><span class="params">(<span class="keyword">struct</span> pid *pid, <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pid) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">		first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]),</span><br><span class="line">					      lockdep_tasklist_lock_is_held());</span><br><span class="line">		<span class="keyword">if</span> (first)</span><br><span class="line">			result = hlist_entry(first, <span class="keyword">struct</span> task_struct, pid_links[(type)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(pid_task);</span><br></pre></td></tr></table></figure></div>

<h2 id="pid-nr"><a href="#pid-nr" class="headerlink" title="pid_nr()"></a>pid_nr()</h2><p>获取进程全局进程号。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the helpers to get the pid&#x27;s id seen from different namespaces</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pid_nr()    : global id, i.e. the id seen from the init namespace;</span></span><br><span class="line"><span class="comment"> * pid_vnr()   : virtual id, i.e. the id seen from the pid namespace of</span></span><br><span class="line"><span class="comment"> *               current.</span></span><br><span class="line"><span class="comment"> * pid_nr_ns() : id seen from the ns specified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * see also task_xid_nr() etc in include/linux/sched.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pid_t</span> <span class="title function_">pid_nr</span><span class="params">(<span class="keyword">struct</span> pid *pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> nr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pid)</span><br><span class="line">		nr = pid-&gt;numbers[<span class="number">0</span>].nr;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">pid_nr_ns</span><span class="params">(<span class="keyword">struct</span> pid *pid, <span class="keyword">struct</span> pid_namespace *ns)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">pid_vnr</span><span class="params">(<span class="keyword">struct</span> pid *pid)</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="task-pid-nr-ns"><a href="#task-pid-nr-ns" class="headerlink" title="__task_pid_nr_ns()"></a>__task_pid_nr_ns()</h2><p>获取进程编号。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> __task_pid_nr_ns(<span class="keyword">struct</span> task_struct *task, <span class="keyword">enum</span> pid_type type,</span><br><span class="line">			<span class="keyword">struct</span> pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> nr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (!ns)</span><br><span class="line">		ns = task_active_pid_ns(current);</span><br><span class="line">	<span class="keyword">if</span> (likely(pid_alive(task)))</span><br><span class="line">		nr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__task_pid_nr_ns);</span><br></pre></td></tr></table></figure></div>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>pidtest.c</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">pidtest_initfunc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">kernelpid</span> =</span> find_get_pid(current-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;count ==&gt; %d\n&quot;</span>, kernelpid-&gt;count);</span><br><span class="line">	printk(<span class="string">&quot;level ==&gt; %d\n&quot;</span>, kernelpid-&gt;level);</span><br><span class="line">	printk(<span class="string">&quot;numbers ==&gt; %d\n&quot;</span>, kernelpid-&gt;numbers[kernelpid-&gt;level].nr);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iNr = pid_nr(kernelpid);</span><br><span class="line">	printk(<span class="string">&quot;nr ==&gt; %d\n&quot;</span>, iNr);</span><br><span class="line">	printk(<span class="string">&quot;tgid ==&gt; %d\n&quot;</span>, current-&gt;tgid);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">ttask</span> =</span> pid_task(kernelpid, PIDTYPE_PID);</span><br><span class="line">	printk(<span class="string">&quot;state ==&gt;  %ld\n&quot;</span>, ttask-&gt;state);</span><br><span class="line">	printk(<span class="string">&quot;pid ==&gt; %d\n&quot;</span>, ttask-&gt;pid);</span><br><span class="line">	</span><br><span class="line">	<span class="type">pid_t</span> rest = __task_pid_nr_ns(ttask, PIDTYPE_PID, kernelpid-&gt;numbers[kernelpid-&gt;level].ns);</span><br><span class="line">	printk(<span class="string">&quot;rest ==&gt; %d&quot;</span>, rest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">pidtest_exitfunc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;exit...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “核心内核”（大概包括frob_task_by_pid_hard及其同类）中的frob_task_by_pid_hard是GPL的，需要将模块的许可证声明为GPL。</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(pidtest_initfunc);</span><br><span class="line">module_exit(pidtest_exitfunc);</span><br></pre></td></tr></table></figure></div>

<p><strong>makefile</strong></p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">obj-m:=pidtest.o</span></span><br><span class="line">CONFIG_MODULE_SIG=n</span><br><span class="line">CURRENT_PATH:=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">LINUX_KERNEL:=<span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">LINUX_KERNEL_PATH:=/usr/src/linux-headers-<span class="variable">$(LINUX_KERNEL)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.mk .tmp_versions Module.symvers *.mod.c *.o *.ko .*.cmd Module.markers modules.order *.a *.mod</span><br></pre></td></tr></table></figure></div>

<p><strong>dmesg -c</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@kernel:~/pidtest<span class="comment"># dmesg -c</span></span><br><span class="line">[11762.163090] count ==&gt; 3</span><br><span class="line">[11762.163090] level ==&gt; 0</span><br><span class="line">[11762.163091] numbers ==&gt; 40250</span><br><span class="line">[11762.163091] nr ==&gt; 40250</span><br><span class="line">[11762.163091] tgid ==&gt; 40250</span><br><span class="line">[11762.163091] state ==&gt;  0</span><br><span class="line">[11762.163091] pid ==&gt; 40250</span><br></pre></td></tr></table></figure></div>

<h1 id="进程调度常用API"><a href="#进程调度常用API" class="headerlink" title="进程调度常用API"></a>进程调度常用API</h1><h2 id="kthread-create-on-node"><a href="#kthread-create-on-node" class="headerlink" title="kthread_create_on_node()"></a>kthread_create_on_node()</h2><p>指定存储节点创建新内核线程。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 int (*threadfn) (void *data) 是一个函数指针，即它是一个函数，此函数是此进程执行时执行的函数，此函数返回值为int型，</span></span><br><span class="line"><span class="comment">// 		参数是一个void型指针。</span></span><br><span class="line"><span class="comment">// 参数void * data是一个void型指针，是传递给第一个参数所代表函数的参数，即进程执行时函数的参数。</span></span><br><span class="line"><span class="comment">// 参数node为存储节点编号，内核将内存区域进程编号，如果指定编号，则创建的新进程在指定的内存区域，如果不指定，设置为-1，则内核随机</span></span><br><span class="line"><span class="comment">// 		选择内存区域。</span></span><br><span class="line"><span class="comment">// namefmt为进程的输出类型名。</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create_on_node</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">					   <span class="type">void</span> *data, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params">					   <span class="type">const</span> <span class="type">char</span> namefmt[],</span></span><br><span class="line"><span class="params">					   ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	va_list args;</span><br><span class="line"></span><br><span class="line">	va_start(args, namefmt);</span><br><span class="line">	task = __kthread_create_on_node(threadfn, data, node, namefmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kthread_create_on_node);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">kthread_create_on_node</span>(<span class="title">int</span> (*<span class="title">threadfn</span>)(<span class="title">void</span> *<span class="title">data</span>),</span></span><br><span class="line"><span class="class">						    <span class="title">void</span> *<span class="title">data</span>, <span class="title">int</span> <span class="title">node</span>,</span></span><br><span class="line"><span class="class">						    <span class="title">const</span> <span class="title">char</span> <span class="title">namefmt</span>[],</span></span><br><span class="line"><span class="class">						    <span class="title">va_list</span> <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DECLARE_COMPLETION_ONSTACK(done);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*create),</span><br><span class="line">						     GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!create)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	create-&gt;threadfn = threadfn;</span><br><span class="line">	create-&gt;data = data;</span><br><span class="line">	create-&gt;node = node;</span><br><span class="line">	create-&gt;done = &amp;done;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;kthread_create_lock);</span><br><span class="line">	list_add_tail(&amp;create-&gt;<span class="built_in">list</span>, &amp;kthread_create_list);</span><br><span class="line">	spin_unlock(&amp;kthread_create_lock);</span><br><span class="line"></span><br><span class="line">	wake_up_process(kthreadd_task);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wait for completion in killable state, for I might be chosen by</span></span><br><span class="line"><span class="comment">	 * the OOM killer while kthreadd is trying to allocate memory for</span></span><br><span class="line"><span class="comment">	 * new kernel thread.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(wait_for_completion_killable(&amp;done))) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If I was SIGKILLed before kthreadd (or new kernel thread)</span></span><br><span class="line"><span class="comment">		 * calls complete(), leave the cleanup of this structure to</span></span><br><span class="line"><span class="comment">		 * that thread.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (xchg(&amp;create-&gt;done, <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-EINTR);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * kthreadd (or new kernel thread) will call complete()</span></span><br><span class="line"><span class="comment">		 * shortly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		wait_for_completion(&amp;done);</span><br><span class="line">	&#125;</span><br><span class="line">	task = create-&gt;result;</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(task)) &#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123; .sched_priority = <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="type">char</span> name[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * task is already visible to other tasks, so updating</span></span><br><span class="line"><span class="comment">		 * COMM must be protected.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		vsnprintf(name, <span class="keyword">sizeof</span>(name), namefmt, args);</span><br><span class="line">		set_task_comm(task, name);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * root may have changed our (kthreadd&#x27;s) priority or CPU mask.</span></span><br><span class="line"><span class="comment">		 * The kernel thread should not inherit these properties.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sched_setscheduler_nocheck(task, SCHED_NORMAL, &amp;param);</span><br><span class="line">		set_cpus_allowed_ptr(task, cpu_all_mask);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(create);</span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="wake-up-process"><a href="#wake-up-process" class="headerlink" title="wake_up_process()"></a>wake_up_process()</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回0：当前进程处于RUNNING状态或唤醒失败。</span></span><br><span class="line"><span class="comment">// 返回1：当前进程不处于RUNNING状态，唤醒成功。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wake_up_process</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(p, TASK_NORMAL, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">try_to_wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">unsigned</span> <span class="type">int</span> state, <span class="type">int</span> wake_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> cpu, success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="keyword">if</span> (p == current) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We&#x27;re waking current, this means &#x27;p-&gt;on_rq&#x27; and &#x27;task_cpu(p)</span></span><br><span class="line"><span class="comment">		 * == smp_processor_id()&#x27;. Together this means we can special</span></span><br><span class="line"><span class="comment">		 * case the whole &#x27;p-&gt;on_rq &amp;&amp; ttwu_remote()&#x27; case below</span></span><br><span class="line"><span class="comment">		 * without taking any locks.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * In particular:</span></span><br><span class="line"><span class="comment">		 *  - we rely on Program-Order guarantees for all the ordering,</span></span><br><span class="line"><span class="comment">		 *  - we&#x27;re serialized against set_special_state() by virtue of</span></span><br><span class="line"><span class="comment">		 *    it disabling IRQs (this allows not taking -&gt;pi_lock).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(p-&gt;state &amp; state))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		success = <span class="number">1</span>;</span><br><span class="line">		cpu = task_cpu(p);</span><br><span class="line">		trace_sched_waking(p);</span><br><span class="line">		p-&gt;state = TASK_RUNNING;</span><br><span class="line">		trace_sched_wakeup(p);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are going to wake up a thread waiting for CONDITION we</span></span><br><span class="line"><span class="comment">	 * need to ensure that CONDITION=1 done by the caller can not be</span></span><br><span class="line"><span class="comment">	 * reordered with p-&gt;state check below. This pairs with mb() in</span></span><br><span class="line"><span class="comment">	 * set_current_state() the waiting thread does.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	smp_mb__after_spinlock();</span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;state &amp; state))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	trace_sched_waking(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We&#x27;re going to change -&gt;state: */</span></span><br><span class="line">	success = <span class="number">1</span>;</span><br><span class="line">	cpu = task_cpu(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure we load p-&gt;on_rq _after_ p-&gt;state, otherwise it would</span></span><br><span class="line"><span class="comment">	 * be possible to, falsely, observe p-&gt;on_rq == 0 and get stuck</span></span><br><span class="line"><span class="comment">	 * in smp_cond_load_acquire() below.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sched_ttwu_pending()			try_to_wake_up()</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_rq = 1			  LOAD p-&gt;state</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (switch to task &#x27;p&#x27;)</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock			  smp_rmb();</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock();</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * [task p]</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;state = UNINTERRUPTIBLE	  LOAD p-&gt;on_rq</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the LOCK+smp_mb__after_spinlock() on rq-&gt;lock in</span></span><br><span class="line"><span class="comment">	 * __schedule().  See the comment for smp_mb__after_spinlock().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;on_rq &amp;&amp; ttwu_remote(p, wake_flags))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure we load p-&gt;on_cpu _after_ p-&gt;on_rq, otherwise it would be</span></span><br><span class="line"><span class="comment">	 * possible to, falsely, observe p-&gt;on_cpu == 0.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * One must be running (-&gt;on_cpu == 1) in order to remove oneself</span></span><br><span class="line"><span class="comment">	 * from the runqueue.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (switch to task &#x27;p&#x27;)	try_to_wake_up()</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_cpu = 1		  LOAD p-&gt;on_rq</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (put &#x27;p&#x27; to sleep)</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock			  smp_rmb();</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock();</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_rq = 0			  LOAD p-&gt;on_cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the LOCK+smp_mb__after_spinlock() on rq-&gt;lock in</span></span><br><span class="line"><span class="comment">	 * __schedule().  See the comment for smp_mb__after_spinlock().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_rmb();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the owning (remote) CPU is still in the middle of schedule() with</span></span><br><span class="line"><span class="comment">	 * this task as prev, wait until its done referencing the task.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the smp_store_release() in finish_task().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This ensures that tasks getting woken will be fully ordered against</span></span><br><span class="line"><span class="comment">	 * their previous state and preserve Program Order.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_cond_load_acquire(&amp;p-&gt;on_cpu, !VAL);</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_contributes_to_load = !!task_contributes_to_load(p);</span><br><span class="line">	p-&gt;state = TASK_WAKING;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;in_iowait) &#123;</span><br><span class="line">		delayacct_blkio_end(p);</span><br><span class="line">		<span class="type">atomic_dec</span>(&amp;task_rq(p)-&gt;nr_iowait);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cpu = select_task_rq(p, p-&gt;wake_cpu, SD_BALANCE_WAKE, wake_flags);</span><br><span class="line">	<span class="keyword">if</span> (task_cpu(p) != cpu) &#123;</span><br><span class="line">		wake_flags |= WF_MIGRATED;</span><br><span class="line">		psi_ttwu_dequeue(p);</span><br><span class="line">		set_task_cpu(p, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;in_iowait) &#123;</span><br><span class="line">		delayacct_blkio_end(p);</span><br><span class="line">		<span class="type">atomic_dec</span>(&amp;task_rq(p)-&gt;nr_iowait);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line">	ttwu_queue(p, cpu, wake_flags);</span><br><span class="line">unlock:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (success)</span><br><span class="line">		ttwu_stat(p, cpu, wake_flags);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pts_thread</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_func</span><span class="params">(<span class="type">void</span>* argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> iData = <span class="number">-1</span>;</span><br><span class="line">	printk(<span class="string">&quot;test_func pid ==&gt; %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line">	</span><br><span class="line">	iData = wake_up_process(pts_thread);</span><br><span class="line">	printk(<span class="string">&quot;the state of pts_thread after wake_up_process ==&gt; %ld\n&quot;</span>, pts_thread-&gt;state);</span><br><span class="line">	printk(<span class="string">&quot;the res of the wake_up_process ==&gt; %d&quot;</span>, iData);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result_data = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> cName[] = <span class="string">&quot;kthread_test.c%s&quot;</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pResult</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">long</span> time_out;</span><br><span class="line">	</span><br><span class="line">	<span class="type">wait_queue_head_t</span> head;</span><br><span class="line">	<span class="type">wait_queue_entry_t</span> data;</span><br><span class="line">	</span><br><span class="line">	pResult = kthread_create_on_node(test_func, <span class="literal">NULL</span>, <span class="number">-1</span>, cName);</span><br><span class="line">	printk(<span class="string">&quot;new kthread pid ==&gt; %d\n&quot;</span>, pResult-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;init pid ==&gt; %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line">	</span><br><span class="line">	init_waitqueue_head(&amp;head);</span><br><span class="line">	init_waitqueue_entry(&amp;data, current);</span><br><span class="line">	add_wait_queue(&amp;head, &amp;data);</span><br><span class="line">	pts_thread = current;</span><br><span class="line">	</span><br><span class="line">	result_data = wake_up_process(pResult);</span><br><span class="line">	printk(<span class="string">&quot;after wake_up pResult, result_data ==&gt; %d&quot;</span>, result_data);</span><br><span class="line">	time_out = schedule_timeout_uninterruptible(<span class="number">2000</span>*<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	result_data = wake_up_process(current);</span><br><span class="line">	printk(<span class="string">&quot;after wake up current, result_data ==&gt; %d&quot;</span>, result_data);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;time_out ==&gt; %ld&quot;</span>, time_out);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;mod-kthread_test exit normal...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(test_init);</span><br><span class="line">module_exit(test_exit);</span><br></pre></td></tr></table></figure></div>

<h2 id="task-nice"><a href="#task-nice" class="headerlink" title="task_nice()"></a>task_nice()</h2><p>获取进程对应nice值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回进程的nice值</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">task_nice</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> PRIO_TO_NICE((p)-&gt;static_prio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>复习</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NICE	19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_NICE	-20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NICE_WIDTH	(MAX_NICE - MIN_NICE + 1)</span></span><br></pre></td></tr></table></figure></div>

<p>nice &#x3D; static_prio-120，其范围是 -20~19，nice 值越小，优先级越高。</p>
</blockquote>
<h2 id="set-user-nice"><a href="#set-user-nice" class="headerlink" title="set_user_nice()"></a>set_user_nice()</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_user_nice</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">long</span> nice)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> queued, running;</span><br><span class="line">	<span class="type">int</span> old_prio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_nice(p) == nice || nice &lt; MIN_NICE || nice &gt; MAX_NICE)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have to be careful, if called from sys_setpriority(),</span></span><br><span class="line"><span class="comment">	 * the task might be in the middle of scheduling on another CPU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The RT priorities are set via sched_setscheduler(), but we still</span></span><br><span class="line"><span class="comment">	 * allow the &#x27;normal&#x27; nice value to be set - but as expected</span></span><br><span class="line"><span class="comment">	 * it wont have any effect on scheduling until the task is</span></span><br><span class="line"><span class="comment">	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p) || task_has_rt_policy(p)) &#123;</span><br><span class="line">		p-&gt;static_prio = NICE_TO_PRIO(nice);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	p-&gt;static_prio = NICE_TO_PRIO(nice);</span><br><span class="line">	set_load_weight(p, <span class="literal">true</span>);</span><br><span class="line">	old_prio = p-&gt;prio;</span><br><span class="line">	p-&gt;prio = effective_prio(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the task increased its priority or is running and</span></span><br><span class="line"><span class="comment">	 * lowered its priority, then reschedule its CPU:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;sched_class-&gt;prio_changed(rq, p, old_prio);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(set_user_nice);</span><br></pre></td></tr></table></figure></div>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_func</span><span class="params">(<span class="type">void</span>* argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;init test_func\n&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot;current static_prio ==&gt; %d\n&quot;</span>, current-&gt;static_prio);</span><br><span class="line">	printk(<span class="string">&quot;task_nice(current) ==&gt; %d\n&quot;</span>, task_nice(current));</span><br><span class="line">	printk(<span class="string">&quot;current_pid ==&gt; %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;exit test_func\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;init func\n&quot;</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pts</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> iNice;</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;current-&gt;pid ==&gt; %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line">	</span><br><span class="line">	pts = kthread_create_on_node(test_func,<span class="literal">NULL</span>,<span class="number">-1</span>,<span class="string">&quot;kthread_test&quot;</span>);</span><br><span class="line">	wake_up_process(pts);</span><br><span class="line">	iNice = task_nice(pts);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;pts-&gt;pid ==&gt; %d\n&quot;</span>, pts-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;pts-&gt;static_prio ==&gt; %d\n&quot;</span>, pts-&gt;static_prio);</span><br><span class="line">	printk(<span class="string">&quot;task_nice(pts) ==&gt; %d\n&quot;</span>, iNice);</span><br><span class="line">	printk(<span class="string">&quot;pts-&gt;prio ==&gt; %d\n&quot;</span>, pts-&gt;prio);</span><br><span class="line">	</span><br><span class="line">	set_user_nice(pts, <span class="number">-20</span>);</span><br><span class="line">	printk(<span class="string">&quot;pts-&gt;pid ==&gt; %d\n&quot;</span>, pts-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;pts-&gt;static_prio ==&gt; %d\n&quot;</span>, pts-&gt;static_prio);</span><br><span class="line">	printk(<span class="string">&quot;task_nice(pts) ==&gt; %d\n&quot;</span>, iNice);</span><br><span class="line">	printk(<span class="string">&quot;pts-&gt;prio ==&gt; %d\n&quot;</span>, pts-&gt;prio);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;exit func\n&quot;</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;mod-kthread_test exit...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(test_init);</span><br><span class="line">module_exit(test_exit);</span><br></pre></td></tr></table></figure></div>

<h2 id="complete-all"><a href="#complete-all" class="headerlink" title="complete_all()"></a>complete_all()</h2><p>主要用于唤醒等待队列中所有睡眠进程。唤醒进程不是同步操作。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * complete_all: - signals all threads waiting on this completion</span></span><br><span class="line"><span class="comment"> * @x:  holds the state of this particular completion</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This will wake up all threads waiting on this particular completion event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this function wakes up a task, it executes a full memory barrier before</span></span><br><span class="line"><span class="comment"> * accessing the task state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since complete_all() sets the completion of @x permanently to done</span></span><br><span class="line"><span class="comment"> * to allow multiple waiters to finish, a call to reinit_completion()</span></span><br><span class="line"><span class="comment"> * must be used on @x if @x is to be used again. The code must make</span></span><br><span class="line"><span class="comment"> * sure that all waiters have woken and finished before reinitializing</span></span><br><span class="line"><span class="comment"> * @x. Also note that the function completion_done() can not be used</span></span><br><span class="line"><span class="comment"> * to know if there are still waiters after complete_all() has been called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> done;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">complete_all</span><span class="params">(<span class="keyword">struct</span> completion *x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;x-&gt;wait.lock, flags);</span><br><span class="line">	x-&gt;done = UINT_MAX;</span><br><span class="line">	__wake_up_locked(&amp;x-&gt;wait, TASK_NORMAL, <span class="number">0</span>);</span><br><span class="line">	spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(complete_all);</span><br></pre></td></tr></table></figure></div>

<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pthread</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">cp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_func</span><span class="params">(<span class="type">void</span>* argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;parent thread state ==&gt; %ld\n&quot;</span>, pthread-&gt;state);</span><br><span class="line">	printk(<span class="string">&quot;parent thread pid ==&gt; %d\n&quot;</span>, pthread-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;kthread pid ==&gt; %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;kthread done ==&gt; %d\n&quot;</span>,cp.done);</span><br><span class="line">	</span><br><span class="line">	complete_all(&amp;cp);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;parent thread pid ==&gt; %d\n&quot;</span>, pthread-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;kthread done ==&gt; %d\n&quot;</span>,cp.done);	</span><br><span class="line">	printk(<span class="string">&quot;parent thread state ==&gt; %ld\n&quot;</span>, pthread-&gt;state);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pts</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">wait_queue_entry_t</span> data;</span><br><span class="line">	<span class="type">long</span> lefttime;</span><br><span class="line">	</span><br><span class="line">	pthread = current;</span><br><span class="line">	pts = kthread_create_on_node(test_func, <span class="literal">NULL</span>, <span class="number">-1</span>, <span class="string">&quot;kthread_test&quot;</span>);</span><br><span class="line">	wake_up_process(pts); <span class="comment">// wake the new kthread up</span></span><br><span class="line">	</span><br><span class="line">	init_completion(&amp;cp);</span><br><span class="line">	init_wait_entry(&amp;data, current);</span><br><span class="line">	add_wait_queue(&amp;(cp.wait), &amp;data);</span><br><span class="line">	</span><br><span class="line">	lefttime = schedule_timeout_uninterruptible(<span class="number">10000</span>);</span><br><span class="line">	printk(<span class="string">&quot;timeout ==&gt; %ld\n&quot;</span>, lefttime);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;mod-kthread_test exit...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(test_init);</span><br><span class="line">module_exit(test_exit);</span><br></pre></td></tr></table></figure></div>

<h2 id="wake-up-sync-key"><a href="#wake-up-sync-key" class="headerlink" title="__wake_up_sync_key()"></a>__wake_up_sync_key()</h2><p>此函数用于唤醒等待队列中处于特定状态的进程，此特定状态是此函数的第二个参数mode定义的。当进程的状态满足此特定状态时就有可能被唤醒，获得CPU资源，从而被调度执行。此函数唤醒的进程不会改变进程之前所在的CPU，不会引起额外的CPU的抢占，并且可以同步唤醒进程。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __wake_up_sync_key - wake up threads blocked on a waitqueue.</span></span><br><span class="line"><span class="comment"> * @wq_head: the waitqueue</span></span><br><span class="line"><span class="comment"> * @mode: which threads</span></span><br><span class="line"><span class="comment"> * @key: opaque value to be passed to wakeup targets</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The sync wakeup differs that the waker knows that it will schedule</span></span><br><span class="line"><span class="comment"> * away soon, so while the target thread will be woken up, it will not</span></span><br><span class="line"><span class="comment"> * be migrated to another CPU - ie. the two threads are &#x27;synchronized&#x27;</span></span><br><span class="line"><span class="comment"> * with each other. This can prevent needless bouncing between CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On UP it can prevent extra preemption.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this function wakes up a task, it executes a full memory barrier before</span></span><br><span class="line"><span class="comment"> * accessing the task state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __wake_up_sync_key(<span class="keyword">struct</span> wait_queue_head *wq_head, <span class="type">unsigned</span> <span class="type">int</span> mode,</span><br><span class="line">			<span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!wq_head))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__wake_up_common_lock(wq_head, mode, <span class="number">1</span>, WF_SYNC, key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__wake_up_sync_key);</span><br></pre></td></tr></table></figure></div>

<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*头文件引用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*全局变量定义*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">wait_queue_head_t</span> head;  <span class="comment">//等待队列头元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">old_thread</span>;</span> <span class="comment">//保存进程描述符信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_function</span><span class="params">(<span class="type">void</span> * argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;in the kernel thread function! \n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;the current pid is:%d\n&quot;</span>, current-&gt;pid);    <span class="comment">//显示当前进程的PID值</span></span><br><span class="line">    <span class="comment">/*显示父进程的状态*/</span></span><br><span class="line">    printk(<span class="string">&quot;the state of the init funcation is :%ld\n&quot;</span>, old_thread-&gt;state);</span><br><span class="line">    __wake_up_sync(&amp;head, TASK_NEW,<span class="number">0</span>);                     <span class="comment">//调用函数唤醒等待队列中的进程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示函数调用之后的父进程的状态</span></span><br><span class="line">    printk(<span class="string">&quot;the state of the init function after __wake_up_sync is :%ld\n&quot;</span>, old_thread-&gt;state);</span><br><span class="line">    printk(<span class="string">&quot;out the kernel thread function\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init __wake_up_sync_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> namefrm[]=<span class="string">&quot;__wake_up_sync.c%s&quot;</span>;            <span class="comment">//线程的输出类型名，在此程序中无影响</span></span><br><span class="line">    <span class="type">long</span> time_out; <span class="comment">//保存schedule_timeout_uninterruptible( )的返回结果</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">result</span>;</span>                   <span class="comment">//保存新进程的信息</span></span><br><span class="line">    <span class="type">wait_queue_t</span> data;                              <span class="comment">//等待队列元素</span></span><br><span class="line">    printk(<span class="string">&quot;into __wake_up_sync_init.\n&quot;</span>);</span><br><span class="line">    result=kthread_create_on_node(my_function, <span class="literal">NULL</span>, <span class="number">-1</span>, namefrm); <span class="comment">// 创建新进程</span></span><br><span class="line">    printk(<span class="string">&quot;the pid of the new thread is:%d\n&quot;</span>, result-&gt;pid);    <span class="comment">//显示新线程的PID值</span></span><br><span class="line">    printk(<span class="string">&quot;the current pid is:%d\n&quot;</span>, current-&gt;pid);     <span class="comment">//显示当前进程的PID值</span></span><br><span class="line"></span><br><span class="line">    init_waitqueue_head(&amp;head);                     <span class="comment">//初始化等待队列头元素</span></span><br><span class="line">    init_waitqueue_entry(&amp;data, current);           <span class="comment">//用当前进程初始化等待队列中的一个元素</span></span><br><span class="line">    add_wait_queue(&amp;head, &amp;data);                   <span class="comment">//将等待队列元素加入等待队列中</span></span><br><span class="line">    old_thread=current;                             <span class="comment">//记录当前进程的信息</span></span><br><span class="line">    wake_up_process(result);                        <span class="comment">//唤醒新创建的线程</span></span><br><span class="line">    time_out=schedule_timeout_uninterruptible(<span class="number">1000</span>*<span class="number">10</span>); <span class="comment">//让当前进程进入睡眠状态，可以改小一点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出schedule_timeout_uninterruptible( )返回结果</span></span><br><span class="line">    printk(<span class="string">&quot;the schedule timeout is:%ld\n&quot;</span>, time_out);</span><br><span class="line">    printk(<span class="string">&quot;out __wake_up_sync_init.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit __wake_up_sync_exit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye __wake_up_sync\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(__wake_up_sync_init);</span><br><span class="line">module_exit(__wake_up_sync_exit);</span><br></pre></td></tr></table></figure></div>


        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Linux内核分析之进程</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2024-01-29 22:11:49</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-03-03 11:43:05
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2024/01/29/Linux内核分析之进程/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/Linux-kernel%E8%BF%9B%E7%A8%8B/">#Linux_kernel进程</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2024/02/01/%E6%B5%85%E6%9E%90Linux%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">浅析Linux内核之进程</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2024/01/25/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">Linux内核分析之内存管理</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">Linux内核分析之进程</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%8E%9F%E7%90%86%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">进程原理及系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9B%E8%A6%81%E7%B4%A0"><span class="nav-text">进程四要素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-text">内核线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%86%85%E6%A0%B8%E6%8F%90%E4%BE%9B%E7%9A%84%E8%BF%9B%E7%A8%8BAPI"><span class="nav-text">Linux内核提供的进程API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-struct-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90"><span class="nav-text">task_struct 结构体分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">进程优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">查看进程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%AD%96%E7%95%A5"><span class="nav-text">进程优先级策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">一些进程相关系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E8%BF%9B%E7%A8%8B"><span class="nav-text">退出进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%AE%80%E8%BF%B0"><span class="nav-text">调度器简述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-text">调度器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">调度类结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-text">调度器分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">就绪队列结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-text">内核调度策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BD%93"><span class="nav-text">调度实体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CFS%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BD%93-sched-entity"><span class="nav-text">CFS调度实体 sched_entity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RT%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BD%93-sched-rt-entity"><span class="nav-text">RT调度实体 sched_rt_entity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DL%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BD%93-sched-dl-entity"><span class="nav-text">DL调度实体 sched_dl_entity</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CFS%E8%B0%83%E5%BA%A6%E7%B1%BBfair-sched-class"><span class="nav-text">CFS调度类fair_sched_class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CFS%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97cfs-rq"><span class="nav-text">CFS就绪队列cfs_rq</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RT%E8%B0%83%E5%BA%A6%E7%B1%BBrt-sched-class"><span class="nav-text">RT调度类rt_sched_class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RT%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97struct-rt-rq"><span class="nav-text">RT就绪队列struct rt_rq</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DL%E8%B0%83%E5%BA%A6%E7%B1%BBdl-sched-class"><span class="nav-text">DL调度类dl_sched_class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DL%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97dl-rq"><span class="nav-text">DL就绪队列dl_rq</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UMA%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-text">UMA系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NUMA%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-text">NUMA系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MPP%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-text">MPP系统架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RCU-%E6%9C%BA%E5%88%B6"><span class="nav-text">RCU 机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RCU%E6%9C%BA%E5%88%B6%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-text">RCU机制解决了什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RCU-%E5%8E%9F%E7%90%86"><span class="nav-text">RCU 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RCU-%E6%A0%B8%E5%BF%83-API"><span class="nav-text">RCU 核心 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E9%93%BE%E8%A1%A8%E9%A1%B9"><span class="nav-text">增加链表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E9%93%BE%E8%A1%A8%E9%A1%B9"><span class="nav-text">访问链表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%A1%B9"><span class="nav-text">删除链表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E9%93%BE%E8%A1%A8%E9%A1%B9"><span class="nav-text">更新链表项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E4%B8%8E%E4%BC%98%E5%8C%96%E5%B1%8F%E9%9A%9C"><span class="nav-text">内存屏障与优化屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%B1%8F%E9%9A%9C"><span class="nav-text">优化屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-text">内存屏障</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">内核内存布局</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B8%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-text">多核调度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B8%E8%B0%83%E5%BA%A6"><span class="nav-text">多核调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%9F%9F%E5%92%8C%E8%B0%83%E5%BA%A6%E7%BB%84"><span class="nav-text">调度域和调度组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%8B%93%E6%89%91"><span class="nav-text">处理器拓扑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">内核数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">Linux内核链表实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">红黑树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8API"><span class="nav-text">进程管理常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-pid"><span class="nav-text">struct pid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#find-get-pid"><span class="nav-text">find_get_pid()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#find-vpid"><span class="nav-text">find_vpid()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-pid"><span class="nav-text">get_pid()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pid-task"><span class="nav-text">pid_task()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pid-nr"><span class="nav-text">pid_nr()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-pid-nr-ns"><span class="nav-text">__task_pid_nr_ns()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%B8%B8%E7%94%A8API"><span class="nav-text">进程调度常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kthread-create-on-node"><span class="nav-text">kthread_create_on_node()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wake-up-process"><span class="nav-text">wake_up_process()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-nice"><span class="nav-text">task_nice()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-user-nice"><span class="nav-text">set_user_nice()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complete-all"><span class="nav-text">complete_all()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wake-up-sync-key"><span class="nav-text">__wake_up_sync_key()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="nav-text">示例</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        31 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <!-- <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span>
        </div> -->
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/Swup.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupSlideTheme.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupScriptsPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupProgressPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupScrollPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupPreloadPlugin.min.js"></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>






<script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/imageViewer.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/utils.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/main.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/layouts/navbarShrink.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/scrollTopBottom.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/lightDarkSwitch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/layouts/categoryList.js"></script>


    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/localSearch.js"></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/codeBlock.js"></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/layouts/lazyload.js"></script>



    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/runtime.js"></script>
    <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/odometer.min.js"></script>
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/assets/odometer-theme-minimal.css">



  <script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/Typed.min.js"></script>
  <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/plugins/typed.js"></script>








<div class="post-scripts" data-swup-reload-script>
    
        <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/tocToggle.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/layouts/toc.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/plugins/tabs.js"></script>
    
</div>


</body>
</html>
